<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.3">
<meta name="description" content="GPars is a multi-paradigm concurrency framework offering several mutually cooperating high-level concurrency abstractions.">
<meta name="author" content="The Whole GPars Team &lt;gpars-developers@googlegroups.com&gt;">
<title>User Guide To Data Parallelism</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
</head>
<body class="book toc2 toc-right">
<div id="header">
<h1>User Guide To Data Parallelism</h1>
<div class="details">
<span id="author" class="author">The Whole GPars Team &lt;gpars-developers@googlegroups.com&gt;</span><br>
<span id="revnumber">version 1.0,</span>
<span id="revdate">2015-11-01</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_parallel_collections">Parallel Collections</a>
<ul class="sectlevel2">
<li><a href="#_meet_parallel_arrays">Meet Parallel Arrays</a></li>
<li><a href="#_gparspool">GParsPool</a></li>
<li><a href="#_avoid_side_effects_in_functions">Avoid Side-Effects in Functions</a></li>
<li><a href="#_gparsexecutorspool">GParsExecutorsPool</a></li>
<li><a href="#_usage_of_gparsexecutorspool">Usage of GParsExecutorsPool</a></li>
<li><a href="#_avoid_side_effects_in_functions_2">Avoid Side-effects in Functions</a></li>
<li><a href="#_memoize">Memoize</a></li>
<li><a href="#_examples_of_use_3">Examples Of Use</a></li>
<li><a href="#_fibonacci_example">Fibonacci Example</a></li>
<li><a href="#_available_variants">Available Variants</a></li>
</ul>
</li>
<li><a href="#_map_reduce">Map-Reduce</a>
<ul class="sectlevel2">
<li><a href="#_avoid_side_effects_in_functions_3">Avoid Side-effects in Functions</a></li>
<li><a href="#_combine">Combine</a></li>
</ul>
</li>
<li><a href="#_parallel_arrays">Parallel Arrays</a></li>
<li><a href="#_asynchronous_invocations">Asynchronous Invocations</a>
<ul class="sectlevel2">
<li><a href="#_usage_of_strong_gparspool_strong_and_strong_gparsexecutorspool_strong_asynchronous_processing_facilities">Usage of <strong>GParsPool</strong> and <strong>GParsExecutorsPool</strong> Asynchronous Processing Facilities</a></li>
</ul>
</li>
<li><a href="#_composable_asynchronous_functions">Composable Asynchronous Functions</a>
<ul class="sectlevel2">
<li><a href="#_functions_in_strong_groovy_strong">Functions in <strong>Groovy</strong></a></li>
<li><a href="#_are_we_concurrent_yet">Are We Concurrent Yet?</a></li>
</ul>
</li>
<li><a href="#_fork_join">Fork-Join</a>
<ul class="sectlevel2">
<li><a href="#_the_abstraction">The Abstraction</a></li>
</ul>
</li>
<li><a href="#_parallel_speculations">Parallel Speculations</a>
<ul class="sectlevel2">
<li><a href="#_parallel_speculations_2">Parallel Speculations</a></li>
<li><a href="#_alternatives_using_strong_dataflow_variables_strong_and_strong_streams_strong">Alternatives Using <strong>Dataflow Variables</strong> and <strong>Streams</strong></a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Focusing on data instead of processes helps us create robust concurrent programs. As a programmer, you define
your data together with functions that should be applied to it and then let the underlying machinery process
the data.  Typically, a set of concurrent tasks will be created and submitted to a thread pool for
processing.</p>
</div>
<div class="paragraph">
<p>In <strong>GPars</strong>, the <strong>GParsPool</strong> and <strong>GParsExecutorsPool</strong> classes give you access to low-level data parallelism
techniques.  The <strong>GParsPool</strong> class relies on the <strong>Fork/Join</strong> implementation introduced in <strong>JDK 7</strong> and offers
excellent functionality and performance. The <strong>GParsExecutorsPool</strong> is provided for those who still need to
use the older Java executors.</p>
</div>
<div class="paragraph">
<p>There are three fundamental domains covered by the <strong>GPars</strong> low-level data parallelism:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Processing collections concurrently</p>
</li>
<li>
<p>Running functions (closures) asynchronously</p>
</li>
<li>
<p>Performing <strong>Fork/Join</strong> (Divide/Conquer) algorithms</p>
</li>
</ul>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The API described here is based on using <strong>GPars</strong> with <strong>JDK7</strong>. It can be used with later JDKs, but <strong>JDK8</strong>
introduced the <strong>Streams</strong> framework which can be used directly from <strong>Groovy</strong> and, in essence, replaces the <strong>GPars</strong>
features covered here. Work is underway to provide the API described here based on the <strong>JDK8 Streams</strong>
framework for use with <strong>JDK8</strong> and later to provide a simple upgrade path.
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_parallel_collections">Parallel Collections</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Dealing with data frequently involves manipulating collections. Lists, arrays, sets, maps, iterators,
strings. A lot of other data types can be viewed as collections of items.  The common pattern to process
such collections is to take elements sequentially, one-by-one, and make an action for each of the items
in the series.</p>
</div>
<div class="paragraph">
<p>Take, for example, the <em>min</em> function, which is supposed to return the smallest element of a collection.
When you call the <em>min</em> method on a collection of numbers, a variable (<em>minVal</em> say) is created
to store the smallest value seen so far, initialized to some reasonable value for the given type, so for example
for integers and floating points, this may well be zero. The elements of the collection are then iterated
through as each is compared to the stored value. Should a value be less than the one currently held in
<em>minVal</em> then <em>minVal</em> is changed to store the newly seen smaller value.</p>
</div>
<div class="paragraph">
<p>Once all elements have been processed, the minimum value in the collection is stored in the <em>minVal</em>.</p>
</div>
<div class="paragraph">
<p>However simple, this solution is <strong class="red">totally wrong</strong> on multi-core and multi-processor hardware. Running the
<em>min</em> function on a dual-core chip can leverage <strong>at most 50%</strong> of the computing power of the chip.  On a
quad-core it would be only 25%. So in this latter case, this algorithm effectively wastes 75% of the computing
power of the chip.</p>
</div>
<div class="paragraph">
<p>Tree-like structures prove to be more appropriate for parallel processing.</p>
</div>
<div class="paragraph">
<p>The <em>min</em> function in our example doesn&#8217;t need to iterate through all the elements in row and compare their values with the
<em>minVal</em> variable.  What it can do, instead, is rely on the multi-core/multi-processor nature of our hardware.</p>
</div>
<div class="paragraph">
<p>A <em>parallel_min</em> function can, for example, compare pairs (or tuples of certain size) of neighboring values in the collection and promote the smallest value from the tuple into a next round of comparisons. Searching for <code>the minimum</code> in different tuples can safely happen in parallel, so tuples in the same round can be processed by different cores at the same time without races or contention among threads.</p>
</div>
<hr>
<div class="sect2">
<h3 id="_meet_parallel_arrays">Meet Parallel Arrays</h3>
<div class="paragraph">
<p>Although not part of <strong>JDK7</strong>, the <strong>extra166y</strong> library brings a very convenient abstraction called
 <a href="http://groovy.dzone.com/articles/parallelize-your-arrays-with-j">Parallel Arrays</a>, and <strong>GPars</strong> has harnessed this mechanism to provide a very Groovy API.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">What is <code>extra166y</code> ?</div>
<div class="paragraph">
<p><strong>extra166y</strong> Is an implementation of Java collections supporting parallel operations using
Fork-Join concurrent framework provided by JSR-166. It was never made part of the JDK&#8201;&#8212;&#8201;unlike the <strong>jsr166y</strong> library. In fact, <strong>extra166y</strong> was made redundant from <strong>JDK8</strong> onwards by the <strong>Streams</strong> framework. Therefore, to continue to support <strong>JDK7, *GPars</strong> includes a copy of <strong>extra166y</strong> in it so there is no external dependency.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>As noted earlier, work is underway to rewrite the <strong>GPars</strong> API in terms of <strong>Streams</strong> for users of <strong>JDK8</strong> onwards. Of course people using <strong>JDK8</strong> onwards can simply use <strong>Streams</strong> directly from <strong>Groovy</strong>.</p>
</div>
<div class="sect3">
<h4 id="_how">How ?</h4>
<div class="paragraph">
<p><strong>GPars</strong> leverages the <code>Parallel Arrays</code> implementation in several ways. The <strong>*GPars*Pool</strong> and <strong>GParsExecutorsPool</strong> classes provide
parallel variants of the common <strong>Groovy</strong> iteration methods like <em>each</em> , <em>collect</em> , <em>findAll</em>, etc.</p>
</div>
<div class="listingblock">
<div class="title">A Parallel Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre> <span class="keyword">def</span> selfPortraits = images.findAllParallel{<span class="local-variable">it</span>.contains me}.collectParallel{<span class="local-variable">it</span>.resize()}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>It also allows for a more functional style <strong>map/reduce</strong> style of collections processing.</p>
</div>
<div class="listingblock">
<div class="title">A Map/Reduce Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre> <span class="keyword">def</span> smallestSelfPortrait = images.parallel.filter{<span class="local-variable">it</span>.contains me}.map{<span class="local-variable">it</span>.resize()}.min{<span class="local-variable">it</span>.sizeInMB}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_gparspool">GParsPool</h3>
<div class="paragraph">
<p>Use of <strong>GParsPool</strong>&#8201;&#8212;&#8201;the <strong>JSR-166y</strong>-based concurrent collection processor</p>
</div>
<div class="sect3">
<h4 id="_usage_of_gparspool">Usage of GParsPool</h4>
<div class="paragraph">
<p>The <strong>GParsPool</strong> class enables (from <strong>JSR-166y</strong>), a <strong>ParallelArray</strong>-based concurrency DSL for collections and objects.</p>
</div>
</div>
<div class="sect3">
<h4 id="_examples_of_use">Examples of use:</h4>
<div class="listingblock">
<div class="title">Some Parallel Samples</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td>
  <td class="code"><pre><span class="comment">// Summarize numbers concurrently.</span>
GParsPool.withPool {
    <span class="directive">final</span> <span class="predefined-type">AtomicInteger</span> result = <span class="keyword">new</span> <span class="predefined-type">AtomicInteger</span>(<span class="integer">0</span>)
    [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].eachParallel{result.addAndGet(<span class="local-variable">it</span>)}

    <span class="keyword">assert</span> <span class="integer">15</span> == result
}

<span class="comment">// Multiply numbers asynchronously.</span>
GParsPool.withPool {
    <span class="directive">final</span> <span class="predefined-type">List</span> result = [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].collectParallel{<span class="local-variable">it</span> * <span class="integer">2</span>}

    <span class="keyword">assert</span> ([<span class="integer">2</span>, <span class="integer">4</span>, <span class="integer">6</span>, <span class="integer">8</span>, <span class="integer">10</span>].equals(result))
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The passed-in closure takes an instance of a <strong>ForkJoinPool</strong> as a parameter, which can then be freely used inside the closure.</p>
</div>
<div class="listingblock">
<div class="title">A <strong>ForkJoinPool</strong> Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre><span class="comment">// Check whether all elements within a collection meet certain criteria.</span>
GParsPool.withPool(<span class="integer">5</span>){ForkJoinPool pool -&gt;
    <span class="keyword">assert</span> [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].everyParallel{<span class="local-variable">it</span> &gt; <span class="integer">0</span>}

    <span class="keyword">assert</span> ![<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].everyParallel{<span class="local-variable">it</span> &gt; <span class="integer">1</span>}
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>GParsPool.withPool</em> method takes optional parameters for number of threads in the created pool plus an <code>unhandled exceptions</code> handler.</p>
</div>
<div class="listingblock">
<div class="title">An Exception Handler Sample With Threads Required</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre>withPool(<span class="integer">10</span>){...}
withPool(<span class="integer">20</span>, exceptionHandler){...}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pool_reuse">Pool Reuse</h4>
<div class="paragraph">
<p>The <em>GParsPool.withExistingPool</em> takes an already existing <strong>ForkJoinPool</strong> instance to reuse. The DSL is valid only within the associated block of code and only for the thread that has called the <em>withPool</em> or <em>withExistingPool</em> methods. The <em>withPool</em> method returns only after all the worker threads have finished their tasks and the pool has been destroyed, returning the resulting value of the associated block of
code. The <em>withExistingPool</em> method doesn&#8217;t wait for the pool threads to finish.</p>
</div>
<div class="paragraph">
<p>Alternatively, the <strong>GParsPool</strong> class can be statically imported as <em>import static groovyx.gpars.GParsPool</em>, which will allow omitting the <strong>GParsPool</strong> class name.</p>
</div>
<div class="listingblock">
<div class="title">A Pool Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>withPool {
    <span class="keyword">assert</span> [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].everyParallel{<span class="local-variable">it</span> &gt; <span class="integer">0</span>}
    <span class="keyword">assert</span> ![<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].everyParallel{<span class="local-variable">it</span> &gt; <span class="integer">1</span>}
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The following methods are currently supported on all objects in <strong>Groovy</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>eachParallel</em></p>
</li>
<li>
<p><em>eachWithIndexParallel</em></p>
</li>
<li>
<p><em>collectParallel</em></p>
</li>
<li>
<p><em>collectManyParallel</em></p>
</li>
<li>
<p><em>findAllParallel</em></p>
</li>
<li>
<p><em>findAnyParallel</em></p>
</li>
<li>
<p><em>findParallel</em></p>
</li>
<li>
<p><em>everyParallel</em></p>
</li>
<li>
<p><em>anyParallel</em></p>
</li>
<li>
<p><em>grepParallel</em></p>
</li>
<li>
<p><em>groupByParallel</em></p>
</li>
<li>
<p><em>foldParallel</em></p>
</li>
<li>
<p><em>minParallel</em></p>
</li>
<li>
<p><em>maxParallel</em></p>
</li>
<li>
<p><em>sumParallel</em></p>
</li>
<li>
<p><em>splitParallel</em></p>
</li>
<li>
<p><em>countParallel</em></p>
</li>
<li>
<p><em>foldParallel</em></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_meta_class_enhancer">Meta-class Enhancer</h4>
<div class="paragraph">
<p>As an alternative, you can use the <strong>ParallelEnhancer</strong> class to enhance meta-classes of any classes or individual instances with the parallel methods.</p>
</div>
<div class="listingblock">
<div class="title">An Enhanced Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.ParallelEnhancer</span>

<span class="keyword">def</span> list = [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>, <span class="integer">6</span>, <span class="integer">7</span>, <span class="integer">8</span>, <span class="integer">9</span>]
ParallelEnhancer.enhanceInstance(list)
println list.collectParallel {<span class="local-variable">it</span> * <span class="integer">2</span> }

<span class="keyword">def</span> animals = [<span class="string"><span class="delimiter">'</span><span class="content">dog</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">ant</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">cat</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">whale</span><span class="delimiter">'</span></span>]
ParallelEnhancer.enhanceInstance animals
println (animals.anyParallel {<span class="local-variable">it</span> ==~ <span class="regexp"><span class="delimiter">/</span><span class="content">ant</span><span class="delimiter">/</span></span>} ? <span class="string"><span class="delimiter">'</span><span class="content">Found an ant</span><span class="delimiter">'</span></span> : <span class="string"><span class="delimiter">'</span><span class="content">No ants found</span><span class="delimiter">'</span></span>)
println (animals.everyParallel {<span class="local-variable">it</span>.contains(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>)} ? <span class="string"><span class="delimiter">'</span><span class="content">All animals contain a</span><span class="delimiter">'</span></span> : <span class="string"><span class="delimiter">'</span><span class="content">Some animals can live without an a</span><span class="delimiter">'</span></span>)</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>When using the <strong>ParallelEnhancer</strong> class, you&#8217;re not restricted to a <em>withPool</em> block when using the <strong>GParsPool</strong> DSLs. The enhanced classed or instances remain enhanced till they are garbage collected.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exception_handling">Exception Handling</h4>
<div class="paragraph">
<p>If an exception is thrown while processing any of the passed-in closures, the first exception is re-thrown from the xxxParallel methods and the algorithm stops as soon as possible.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Exception Handling</div>
<div class="paragraph">
<p>The exception handling mechanism of <strong>GParsPool</strong> builds on the one built into the <strong>Fork/Join</strong> framework. Since <strong>Fork/Join</strong> algorithms are by nature hierarchical, once any part of the algorithm fails, there&#8217;s usually little benefit continuing the computation, since some branches of the algorithm will never return a result.</p>
</div>
<div class="paragraph">
<p>Bear in mind that the <strong>GParsPool</strong> implementation doesn&#8217;t give any guarantees about its behavior after a first unhandled exception occurs, beyond stopping the algorithm and re-throwing the first detected exception to the caller. This behavior, after all, is consistent with what the traditional sequential iteration methods do.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_transparently_parallel_collections">Transparently Parallel Collections</h4>
<div class="paragraph">
<p>On top of adding new <em>xxxParallel</em> methods, <strong>GPars</strong> can also let you change the semantics of original iteration methods. For example, you may be passing a collection into a library method, which will process your collection in a sequential way, let&#8217;s say, by using the <em>collect</em> method. Then by changing the semantics of the <em>collect</em> method on your collection, you can effectively parallelize the library sequential code.</p>
</div>
<div class="listingblock">
<div class="title">A makeConcurrent() Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td>
  <td class="code"><pre>GParsPool.withPool {

    <span class="comment">//The selectImportantNames() will process the name collections concurrently</span>
    <span class="keyword">assert</span> [<span class="string"><span class="delimiter">'</span><span class="content">ALICE</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">JASON</span><span class="delimiter">'</span></span>] == selectImportantNames([<span class="string"><span class="delimiter">'</span><span class="content">Joe</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">Alice</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">Dave</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">Jason</span><span class="delimiter">'</span></span>].makeConcurrent())
}

<span class="comment">/**
 * A function implemented using standard sequential collect() and findAll() methods.
 */</span>
<span class="keyword">def</span> <span class="function">selectImportantNames</span>(names) {
    names.collect {<span class="local-variable">it</span>.toUpperCase()}.findAll{<span class="local-variable">it</span>.size() &gt; <span class="integer">4</span>}
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>makeSequential</em> method will reset the collection back to the original sequential semantics.</p>
</div>
<div class="listingblock">
<div class="title">A Sequential Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.withPool</span>

<span class="keyword">def</span> list = [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>, <span class="integer">6</span>, <span class="integer">7</span>, <span class="integer">8</span>, <span class="integer">9</span>]

println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span> list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> } println()

withPool {

    println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span>
    list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
    println()

    list.makeConcurrent()

    println <span class="string"><span class="delimiter">'</span><span class="content">Concurrent: </span><span class="delimiter">'</span></span>
    list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
    println()

    list.makeSequential()

    println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span>
    list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
    println()
}

println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span>
list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
println()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>asConcurrent()</em> convenience method allows us to specify code blocks, where the collection maintains concurrent semantics.</p>
</div>
<div class="listingblock">
<div class="title">An <em>asConcurrent()</em> Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.withPool</span>

<span class="keyword">def</span> list = [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>, <span class="integer">6</span>, <span class="integer">7</span>, <span class="integer">8</span>, <span class="integer">9</span>]

println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span>
list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
println()

withPool {

    println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span>
    list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
    println()

    list.asConcurrent {
        println <span class="string"><span class="delimiter">'</span><span class="content">Concurrent: </span><span class="delimiter">'</span></span>
        list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
        println()
    }

    println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span>
    list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
    println()
}

println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span>
list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
println()</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_code_samples">Code Samples</h4>
<div class="paragraph">
<p>Transparent parallelism, including the <em>makeConcurrent()</em> , <em>makeSequential()</em> and <em>asConcurrent()</em> methods, is also available in combination with our <em>ParallelEnhancer</em> .</p>
</div>
<div class="listingblock">
<div class="title">A ParallelEnhancer Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td>
  <td class="code"><pre><span class="comment">/**
 * A function implemented using standard sequential collect() and findAll() methods.
 */</span>
<span class="keyword">def</span> <span class="function">selectImportantNames</span>(names) {
    names.collect {<span class="local-variable">it</span>.toUpperCase()}.findAll{<span class="local-variable">it</span>.size() &gt; <span class="integer">4</span>}
}

<span class="keyword">def</span> names = [<span class="string"><span class="delimiter">'</span><span class="content">Joe</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">Alice</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">Dave</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">Jason</span><span class="delimiter">'</span></span>]
ParallelEnhancer.enhanceInstance(names)

<span class="comment">//The selectImportantNames() will process the name collections concurrently</span>
<span class="keyword">assert</span> [<span class="string"><span class="delimiter">'</span><span class="content">ALICE</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">JASON</span><span class="delimiter">'</span></span>] == selectImportantNames(names.makeConcurrent())
</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Another ParallelEnhancer Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.ParallelEnhancer</span>

<span class="keyword">def</span> list = [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>, <span class="integer">6</span>, <span class="integer">7</span>, <span class="integer">8</span>, <span class="integer">9</span>]

println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span>
list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
println()

ParallelEnhancer.enhanceInstance(list)

println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span>
list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
println()

list.asConcurrent {
    println <span class="string"><span class="delimiter">'</span><span class="content">Concurrent: </span><span class="delimiter">'</span></span>
    list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
    println()

}
list.makeSequential()

println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span>
list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
println()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_avoid_side_effects_in_functions">Avoid Side-Effects in Functions</h3>
<div class="paragraph">
<p>We have to warn you. Since the closures that are provided to the parallel methods like <em>eachParallel</em> or <em>collectParallel()</em> may be run in parallel, you have to make sure that each of the closures is written in a thread-safe manner. The closures must hold no internal state, share data nor have side-effects beyond the boundaries of the single element that they&#8217;ve been invoked on.  Violations of these rules will open the door for race conditions and deadlocks, the most severe enemies of a modern multi-core programmer.</p>
</div>
<hr>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<strong>Don&#8217;t do this !</strong>
</td>
</tr>
</table>
</div>
<hr>
<div class="listingblock">
<div class="title">Concurrently Accessing a non-Thread-Safe Collection</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> thumbnails = <span class="type">[]</span>
images.eachParallel {thumbnails &lt;&lt; <span class="local-variable">it</span>.thumbnail}  <span class="comment">//Concurrently accessing a not-thread-safe collection of thumbnails? Don't do this!</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>At least, you&#8217;ve been warned.</p>
</div>
<hr>
<div class="sidebarblock">
<div class="content">
<div class="title">It May Not Execute The Way You Expect</div>
<div class="paragraph">
<p>Because <strong>GParsPool</strong> uses a <strong>Fork/Join</strong> pool (with work stealing), threads may not be applied to a waiting processing task even though they may appear idle.</p>
</div>
<div class="paragraph">
<p>With a work-stealing algorithm, worker threads that run out of things to do can steal tasks from other threads that are still busy.</p>
</div>
<div class="paragraph">
<p>If you use <strong>GParsExecutorsPool</strong> (which doesn&#8217;t use <strong>Fork/Join</strong>), you&#8217;ll get the thread allocation behavior that you would naively expect.</p>
</div>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_gparsexecutorspool">GParsExecutorsPool</h3>
<div class="paragraph">
<p>Use of <strong>GParsExecutorsPool</strong> - the <code>Java Executors</code>-based concurrent collection processor -</p>
</div>
</div>
<div class="sect2">
<h3 id="_usage_of_gparsexecutorspool">Usage of GParsExecutorsPool</h3>
<div class="paragraph">
<p>The <strong>GParsPool</strong> classes enable a <code>Java Executors</code>-based concurrency DSL for collections and objects.</p>
</div>
<div class="paragraph">
<p>The <strong>GParsExecutorsPool</strong> class can be used as a pure-JDK-based <code>collections parallel processor</code>. Unlike the <strong>GParsPool</strong> class, <strong>GParsExecutorsPool</strong> doesn&#8217;t require <strong>fork/join</strong> thread pools but, instead, leverages the standard JDK executor services to parallelize closures to process a collection or an object iteratively.</p>
</div>
<div class="paragraph">
<p>It needs to be stated, however, that <strong>GParsPool</strong> typically performs much better than <strong>GParsExecutorsPool</strong> does.</p>
</div>
<hr>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<strong>GParsPool</strong> typically performs much better than <strong>GParsExecutorsPool</strong>
</td>
</tr>
</table>
</div>
<hr>
<div class="sect3">
<h4 id="_examples_of_use_2">Examples of Use</h4>
<div class="listingblock">
<div class="title">A <strong>GParsExecutorsPool</strong> Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td>
  <td class="code"><pre><span class="comment">//multiply numbers asynchronously</span>
 GParsExecutorsPool.withPool {
     <span class="predefined-type">Collection</span>&lt;<span class="predefined-type">Future</span>&gt; result = [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].collectParallel{<span class="local-variable">it</span> * <span class="integer">10</span>}

     <span class="keyword">assert</span> <span class="keyword">new</span> <span class="predefined-type">HashSet</span>([<span class="integer">10</span>, <span class="integer">20</span>, <span class="integer">30</span>, <span class="integer">40</span>, <span class="integer">50</span>]) == <span class="keyword">new</span> <span class="predefined-type">HashSet</span>((<span class="predefined-type">Collection</span>)result*.get())
 }

 <span class="comment">//multiply numbers asynchronously using an asynchronous closure</span>
 GParsExecutorsPool.withPool {
     <span class="keyword">def</span> closure={<span class="local-variable">it</span> * <span class="integer">10</span>}
     <span class="keyword">def</span> asyncClosure=closure.async()

     <span class="predefined-type">Collection</span>&lt;<span class="predefined-type">Future</span>&gt; result = [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].collect(asyncClosure)

     <span class="keyword">assert</span> <span class="keyword">new</span> <span class="predefined-type">HashSet</span>([<span class="integer">10</span>, <span class="integer">20</span>, <span class="integer">30</span>, <span class="integer">40</span>, <span class="integer">50</span>]) == <span class="keyword">new</span> <span class="predefined-type">HashSet</span>((<span class="predefined-type">Collection</span>)result*.get())
 }</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The passed-in closure takes an instance of an <strong>ExecutorService</strong> as a parameter, which can be then used freely inside the closure.</p>
</div>
<div class="listingblock">
<div class="title">Another <strong>GParsExecutorsPool</strong> Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="comment">//find an element meeting specified criteria</span>
 GParsExecutorsPool.withPool(<span class="integer">5</span>) {<span class="predefined-type">ExecutorService</span> service -&gt;
     service.submit({performLongCalculation()} <span class="keyword">as</span> <span class="predefined-type">Runnable</span>)
 }</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>GParsExecutorsPool.withPool()</em> method takes an optional parameter declaring the number of threads in the created pool and a thread factory.</p>
</div>
<div class="listingblock">
<div class="title">An Example Declaring Required Thread Count</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre>withPool(<span class="integer">10</span>) {...}
withPool(<span class="integer">20</span>, threadFactory) {...}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>GParsExecutorsPool.withExistingPool()</em> takes an already existing <code>executor service instance</code> to reuse. The DSL is only valid within the associated block of code and only for the thread that has called the <em>withPool()</em> or <em>withExistingPool()</em> method.</p>
</div>
<div class="paragraph">
<p>The <em>withPool()</em> method returns control only after all the worker threads have finished their tasks and the executor service has been destroyed, returning the resulting value of the associated block of code.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Did you know the <em>withExistingPool()</em> method doesn&#8217;t wait for <code>executor service threads</code> to finish ?
</td>
</tr>
</table>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Statically import the <strong>GParsExecutorsPool</strong> class as <em>import static groovyx.gpars.GParsExecutorsPool.`<strong>`</em> to omit the *GParsExecutorsPool</strong> class name.
</td>
</tr>
</table>
</div>
<hr>
<div class="listingblock">
<div class="title">A FindParallel Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>withPool {
     <span class="keyword">def</span> result = [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].findParallel{<span class="predefined-type">Number</span> number -&gt; number &gt; <span class="integer">2</span>}
     <span class="keyword">assert</span> result <span class="keyword">in</span> [<span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>]
 }</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The following methods are currently supported on all objects that support iterations in <strong>Groovy</strong> :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>eachParallel()</p>
</li>
<li>
<p>eachWithIndexParallel()</p>
</li>
<li>
<p>collectParallel()</p>
</li>
<li>
<p>findAllParallel()</p>
</li>
<li>
<p>findParallel()</p>
</li>
<li>
<p>allParallel()</p>
</li>
<li>
<p>anyParallel()</p>
</li>
<li>
<p>grepParallel()</p>
</li>
<li>
<p>groupByParallel()</p>
</li>
</ul>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_meta_class_enhancer_2">Meta-class Enhancer</h4>
<div class="paragraph">
<p>As an alternative, you can use the <em>GParsExecutorsPoolEnhancer</em> class to enhance meta-classes for any classes or individual instances having asynchronous methods.</p>
</div>
<div class="listingblock">
<div class="title">Enhancing Your Code</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.GParsExecutorsPoolEnhancer</span>

<span class="keyword">def</span> list = [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>, <span class="integer">6</span>, <span class="integer">7</span>, <span class="integer">8</span>, <span class="integer">9</span>]
GParsExecutorsPoolEnhancer.enhanceInstance(list)
println list.collectParallel {<span class="local-variable">it</span> * <span class="integer">2</span> }

<span class="keyword">def</span> animals = [<span class="string"><span class="delimiter">'</span><span class="content">dog</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">ant</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">cat</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">whale</span><span class="delimiter">'</span></span>]
GParsExecutorsPoolEnhancer.enhanceInstance animals

println (animals.anyParallel {<span class="local-variable">it</span> ==~ <span class="regexp"><span class="delimiter">/</span><span class="content">ant</span><span class="delimiter">/</span></span>} ? <span class="string"><span class="delimiter">'</span><span class="content">Found an ant</span><span class="delimiter">'</span></span> : <span class="string"><span class="delimiter">'</span><span class="content">No ants found</span><span class="delimiter">'</span></span>)
println (animals.allParallel {<span class="local-variable">it</span>.contains(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>)} ? <span class="string"><span class="delimiter">'</span><span class="content">All animals contain a</span><span class="delimiter">'</span></span> : <span class="string"><span class="delimiter">'</span><span class="content">Some animals can live without an a</span><span class="delimiter">'</span></span>)</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>When using the <em>GParsExecutorsPoolEnhancer</em> class, you&#8217;re not restricted to a <em>withPool()</em> block with the
use of the <code>GParsExecutorsPool DSLs</code>. The enhanced classes or instances remain enhanced until they are garbage collected.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exception_handling_2">Exception Handling</h4>
<div class="paragraph">
<p>Exceptions can be thrown while processing any of the passed-in closures. An instance of the <em>AsyncException</em> method will wrap any/all of the original exceptions re-thrown from the xxxParallel methods.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_avoid_side_effects_in_functions_2">Avoid Side-effects in Functions</h3>
<div class="paragraph">
<p>Once again we need to warn you about using closures with side-effects. Please avoid logic that affects objects beyond the scope of the single, currently processed element. Please avoid logic or closures that keep state. Don&#8217;t do that! It&#8217;s dangerous to pass them to any of the <em>xxxParallel()</em> methods.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_memoize">Memoize</h3>
<div class="paragraph">
<p>The <em>memoize</em> function enables caching of a function&#8217;s return values. Repeated calls to the memoized function with the same argument values will, instead of invoking the calculation encoded in the original function, retrieve the resulting value from an internal, transparent cache.</p>
</div>
<div class="paragraph">
<p>Provided the calculation is considerably slower than retrieving a cached value from the cache, developers can trade-off memory for performance.</p>
</div>
<div class="paragraph">
<p>Checkout out the example, where we attempt to scan multiple websites for particular content:</p>
</div>
<div class="paragraph">
<p>The <strong>memoize</strong> functionality of <strong>GPars</strong> was donated to <strong>Groovy</strong> for version 1.8 and if you run on <strong>Groovy</strong> 1.8 or later, we recommend you use the <strong>Groovy</strong> functionality.</p>
</div>
<div class="paragraph">
<p><strong>Memoize</strong>, in <strong>GPars</strong>, is almost identical, except that it searches the memoized caches concurrently using the surrounding thread pool. This may give performance benefits in some scenarios.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Memoize Me Up, Scotty</div>
<div class="paragraph">
<p>The <strong>GPars memoize</strong> functionality has been renamed to avoid future conflicts with the <strong>memoize</strong> functionality in <strong>Groovy</strong>.</p>
</div>
<div class="paragraph">
<p><strong>GPars</strong> now calls these methods with a preceding letter <em>g</em> , such as <em>gmemoize()</em>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_examples_of_use_3">Examples Of Use</h3>
<div class="listingblock">
<div class="title">A <strong>GParsPool</strong> Example With gmemoize()</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td>
  <td class="code"><pre>GParsPool.withPool {
    <span class="keyword">def</span> urls = [<span class="string"><span class="delimiter">'</span><span class="content">http://www.dzone.com</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">http://www.theserverside.com</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">http://www.infoq.com</span><span class="delimiter">'</span></span>]

    Closure download = {url -&gt;
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Downloading </span><span class="inline"><span class="inline-delimiter">$</span>url</span><span class="delimiter">&quot;</span></span>
        url.toURL().text.toUpperCase()
    }

    Closure cachingDownload = download.gmemoize()

    println <span class="string"><span class="delimiter">'</span><span class="content">Groovy sites today: </span><span class="delimiter">'</span></span> + urls.findAllParallel {url -&gt; cachingDownload(url).contains(<span class="string"><span class="delimiter">'</span><span class="content">GROOVY</span><span class="delimiter">'</span></span>)}
    println <span class="string"><span class="delimiter">'</span><span class="content">Grails sites today: </span><span class="delimiter">'</span></span> + urls.findAllParallel {url -&gt; cachingDownload(url).contains(<span class="string"><span class="delimiter">'</span><span class="content">GRAILS</span><span class="delimiter">'</span></span>)}
    println <span class="string"><span class="delimiter">'</span><span class="content">Griffon sites today: </span><span class="delimiter">'</span></span> + urls.findAllParallel {url -&gt; cachingDownload(url).contains(<span class="string"><span class="delimiter">'</span><span class="content">GRIFFON</span><span class="delimiter">'</span></span>)}
    println <span class="string"><span class="delimiter">'</span><span class="content">Gradle sites today: </span><span class="delimiter">'</span></span> + urls.findAllParallel {url -&gt; cachingDownload(url).contains(<span class="string"><span class="delimiter">'</span><span class="content">GRADLE</span><span class="delimiter">'</span></span>)}
    println <span class="string"><span class="delimiter">'</span><span class="content">Concurrency sites today: </span><span class="delimiter">'</span></span> + urls.findAllParallel {url -&gt; cachingDownload(url).contains(<span class="string"><span class="delimiter">'</span><span class="content">CONCURRENCY</span><span class="delimiter">'</span></span>)}
    println <span class="string"><span class="delimiter">'</span><span class="content">GPars sites today: </span><span class="delimiter">'</span></span> + urls.findAllParallel {url -&gt; cachingDownload(url).contains(<span class="string"><span class="delimiter">'</span><span class="content">GPARS</span><span class="delimiter">'</span></span>)}
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how closures are enhanced inside the <em>GParsPool.withPool()</em> blocks with a <em>memoize()</em> function. This returns a new closure wrapping the original closure as a cache entry.</p>
</div>
<div class="paragraph">
<p>In the previous example, we&#8217;re calling the <em>cachingDownload</em> function in several places in the code, however, each unique url is downloaded only once - the first time it&#8217;s needed. The values are then cached and available for subsequent calls. Additionally, these values are also available to all threads, no matter which thread originally came first with a download request  for that particular url and had to handle the actual calculation/download.</p>
</div>
<div class="paragraph">
<p>So, to wrap up, a <strong>memoize</strong> call shields a function by using a cache of past return values.</p>
</div>
<div class="paragraph">
<p>However, <em>memoize</em> can do even more! In some algorithms, adding a little memory may have a dramatic impact on the computational complexity of the calculation. Let&#8217;s look at a classical example of <code>Fibonacci</code> numbers.</p>
</div>
</div>
<div class="sect2">
<h3 id="_fibonacci_example">Fibonacci Example</h3>
<div class="paragraph">
<p>A purely functional, recursive implementation that follows the definition of Fibonacci numbers is exponentially complex:</p>
</div>
<div class="listingblock">
<div class="title">A Fibonacci Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>Closure fib = {n -&gt; n &gt; <span class="integer">1</span> ? call(n - <span class="integer">1</span>) + call(n - <span class="integer">2</span>) : n}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Try calling the <em>fib</em> function with numbers around 30 and you&#8217;ll see how slow it is.</p>
</div>
<div class="paragraph">
<p>Now with a little twist and an added <strong>memoize</strong> cache, the algorithm magically turns into a linearly complex one:</p>
</div>
<div class="listingblock">
<div class="title">A Better Version of the Fibonacci Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre>Closure fib
fib = {n -&gt; n &gt; <span class="integer">1</span> ? fib(n - <span class="integer">1</span>) + fib(n - <span class="integer">2</span>) : n}.gmemoize()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The extra memory we added has now cut off all but one recursive branch of the calculation. And all subsequent calls to the same <em>fib</em> function will also benefit from the cached values.</p>
</div>
<div class="paragraph">
<p>Look below to see how the <em>memoizeAtMost</em> variant can reduce memory consumption in our example, yet preserve the linear complexity of the algorithm.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_available_variants">Available Variants</h3>
<div class="sect3">
<h4 id="_memoize_2">Memoize</h4>
<div class="paragraph">
<p>The basic variant keeps values in the internal cache for the whole lifetime of the memoized function. It provides the best performance characteristics of all the variants.</p>
</div>
</div>
<div class="sect3">
<h4 id="_memoizeatmost">memoizeAtMost</h4>
<div class="paragraph">
<p>Allows us to set a hard limit on number of items cached. Once the limit has been reached, all subsequently added values will eliminate the oldest value from the cache using the <strong>LRU</strong> (<code>Last Recently Used</code>) strategy.</p>
</div>
<div class="paragraph">
<p>So for our Fibonacci number example, we could safely reduce the cache size to two items:</p>
</div>
<div class="listingblock">
<div class="title">A Cached Fibonacci Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre>Closure fib
fib = {n -&gt; n &gt; <span class="integer">1</span> ? fib(n - <span class="integer">1</span>) + fib(n - <span class="integer">2</span>) : n}.memoizeAtMost(<span class="integer">2</span>)</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Setting an upper limit on the cache size serves two purposes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Keeps the memory footprint of the cache within defined boundaries</p>
</li>
<li>
<p>Preserves desired performance characteristics of the function. Too large a cache increases the time to retrieve a cached value, compared to the time it would have taken to calculate the result directly.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_memoizeatleast">memoizeAtLeast</h4>
<div class="paragraph">
<p>Allows unlimited growth of the internal cache until the JVM&#8217;s garbage collector decides to step in and evict a <code>SoftReferences</code> entry (used by our implementation) from the memory.</p>
</div>
<div class="paragraph">
<p>The single parameter to the <em>memoizeAtLeast()</em> method indicates the minimum number of cached items that should be protected from gc eviction. The cache will never shrink below the specified number of entries.  The cache ensures it only protects the most recently used items from eviction using the LRU (<code>Last Recently Used</code>) strategy.</p>
</div>
</div>
<div class="sect3">
<h4 id="_memoizebetween">memoizeBetween</h4>
<div class="paragraph">
<p>Combines the <strong>memoizeAtLeast</strong> and <strong>memoizeAtMost</strong> methods to allow the cache to grow and shrink in the range between the two parameter values depending on available memory and the gc activity.</p>
</div>
<div class="paragraph">
<p>The cache size will never exceed the upper size limit to preserve desired performance characteristics of the cache.</p>
</div>
<hr>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_map_reduce">Map-Reduce</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>Parallel Collection Map/Reduce</code> DSL gives <strong>GPars</strong> a more functional flavor. In general, the <code>Map/Reduce DSL</code> may be used for the same purpose as the <em>xxxParallel()</em> family of methods and has very similar semantics.  On the other hand, <strong>Map/Reduce</strong> can perform considerably faster, if you need to chain multiple methods together to process a single collection in multiple steps:</p>
</div>
<div class="listingblock">
<div class="title">A <strong>Map-Reduce</strong> Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>    println <span class="string"><span class="delimiter">'</span><span class="content">Number of occurrences of the word GROOVY today: </span><span class="delimiter">'</span></span> + urls.parallel
            .map {<span class="local-variable">it</span>.toURL().text.toUpperCase()}
            .filter {<span class="local-variable">it</span>.contains(<span class="string"><span class="delimiter">'</span><span class="content">GROOVY</span><span class="delimiter">'</span></span>)}
            .map{<span class="local-variable">it</span>.split()}
            .map{<span class="local-variable">it</span>.findAll{word -&gt; word.contains <span class="string"><span class="delimiter">'</span><span class="content">GROOVY</span><span class="delimiter">'</span></span>}.size()}
            .sum()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>xxxParallel()</em> methods must follow the same contract as their non-parallel peers. So a <em>collectParallel()</em> method must return a legal collection of items, which you can treat as a <strong>Groovy</strong> collection.</p>
</div>
<div class="paragraph">
<p>Internally, the <em>parallel collect method</em> builds an efficient parallel structure, called a <code>parallel array</code>. It then performs the required operation concurrently. Before returning, it destroys the <em>Parallel Array</em> as it builds a collection of results to return to you.
A potential call to, for example, <em>findAllParallel()</em> on the resulting collection would repeat the whole process of construction and destruction of a <code>Parallel Array</code> instance under the covers.</p>
</div>
<div class="paragraph">
<p>With <strong>Map/Reduce</strong>, you turn your collection into a <code>Parallel Array</code> and back again only a single time. The <strong>Map/Reduce</strong> family of methods do not return <strong>Groovy</strong> collections, but can freely pass along the internal <code>Parallel Arrays</code> directly.</p>
</div>
<div class="paragraph">
<p>Invoking the <em>parallel</em> property of a collection will build a <code>Parallel Array</code> for the collection and then return a thin wrapper around the <code>Parallel Array</code> instance.  Then you can chain any of these methods together to get an answer :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>map()</p>
</li>
<li>
<p>reduce()</p>
</li>
<li>
<p>filter()</p>
</li>
<li>
<p>size()</p>
</li>
<li>
<p>sum()</p>
</li>
<li>
<p>min()</p>
</li>
<li>
<p>max()</p>
</li>
<li>
<p>sort()</p>
</li>
<li>
<p>groupBy()</p>
</li>
<li>
<p>combine()</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Returning a plain <strong>Groovy</strong> collection instance is always just a matter of retrieving the <em>collection</em> property.</p>
</div>
<div class="listingblock">
<div class="title">A <strong>Map-Reduce</strong> Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> myNumbers = (<span class="integer">1</span>..<span class="integer">1000</span>).parallel.filter{<span class="local-variable">it</span> % <span class="integer">2</span> == <span class="integer">0</span>}.map{<span class="predefined-type">Math</span>.sqrt <span class="local-variable">it</span>}.collection</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_avoid_side_effects_in_functions_3">Avoid Side-effects in Functions</h3>
<div class="paragraph">
<p>Once again we need to warn you. To avoid nasty surprises, please, keep any closures you pass to the <strong>Map/Reduce</strong> functions, stateless and clean from side-effects.</p>
</div>
<hr>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
To avoid nasty surprises keep your closures stateless
</td>
</tr>
</table>
</div>
<hr>
<div class="sect3">
<h4 id="_availability">Availability</h4>
<div class="paragraph">
<p>This feature is only available when using in the <strong>Fork/Join</strong>-based <strong>GParsPool</strong> , not in the <strong>GParsExecutorsPool</strong> method.</p>
</div>
</div>
<div class="sect3">
<h4 id="_classical_example">Classical Example</h4>
<div class="paragraph">
<p>A classical example, inspired by <a href="http://github.com/thevery">thevery</a>, counts occurrences of words in a string:</p>
</div>
<div class="listingblock">
<div class="title">A Telling Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.withPool</span>

<span class="keyword">def</span> words = <span class="string"><span class="delimiter">&quot;</span><span class="content">This is just plain text to count words in</span><span class="delimiter">&quot;</span></span>
print count(words)

<span class="keyword">def</span> <span class="function">count</span>(arg) {

  withPool {

    <span class="keyword">return</span> arg.parallel
      .map{[<span class="local-variable">it</span>, <span class="integer">1</span>]}
      .groupBy{<span class="local-variable">it</span>[<span class="integer">0</span>]}.getParallel()
      .map {<span class="local-variable">it</span>.value=<span class="local-variable">it</span>.value.size();<span class="local-variable">it</span>}
      .sort{-<span class="local-variable">it</span>.value}.collection
  }

}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The same example can be implemented with the more general <em>combine</em> operation:</p>
</div>
<div class="listingblock">
<div class="title">A <em>Combine</em> Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> words = <span class="string"><span class="delimiter">&quot;</span><span class="content">This is just plain text to count words in</span><span class="delimiter">&quot;</span></span>
print count(words)

<span class="keyword">def</span> <span class="function">count</span>(arg) {

  withPool {
    <span class="keyword">return</span> arg.parallel
      .map{[<span class="local-variable">it</span>, <span class="integer">1</span>]}
      .combine(<span class="integer">0</span>) {sum, value -&gt; sum + value}.getParallel()
      .sort{-<span class="local-variable">it</span>.value}.collection
  }

}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_combine">Combine</h3>
<div class="paragraph">
<p>The <em>combine</em> operation expects an input list of tuples (two-element lists), often considered to be key-value pairs (such as [ [key1, value1], [key2, value2], [key1, value3], [key3, value4] &#8230;&#8203; ] ). These might have potentially repeating keys.</p>
</div>
<div class="paragraph">
<p>When invoked, the <em>combine</em> method merges the values of identical keys using the provided accumulator function. This produces a map of the original (unique) keys and their (now) accumulated values.</p>
</div>
<div class="paragraph">
<p>E.g. <a id="a"></a> will be combined into [a : b+e, c : d+f]. Some logic like the '+' operation for the values will need to be provided as the accumulation closure logic.</p>
</div>
<div class="paragraph">
<p>The <em>accumulation function</em> argument needs to specify a function to use when combining (accumulating) values belonging to the same key.  An <em>initial accumulator value</em> needs to be provided as well.</p>
</div>
<div class="paragraph">
<p>Since the <em>combine</em> method processes items in parallel, the <em>initial accumulator value</em> will be reused multiple times. Thus the provided value must allow for reuse.</p>
</div>
<div class="paragraph">
<p>It should either be a <strong>cloneable</strong> (or <strong>immutable</strong>) value or a <strong>closure</strong> returning a fresh initial accumulator each time it&#8217;s requested.  Good combinations of accumulator functions and reusable initial values include:</p>
</div>
<div class="listingblock">
<div class="title">Some Examples of a Combining-Accumulator Function and Reusable Initial Value</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>accumulator = {<span class="predefined-type">List</span> acc, value -&gt; acc &lt;&lt; value} initialValue = <span class="type">[]</span>
accumulator = {<span class="predefined-type">List</span> acc, value -&gt; acc &lt;&lt; value} initialValue = {-&gt; <span class="type">[]</span>}
accumulator = {<span class="type">int</span> sum, <span class="type">int</span> value -&gt; acc + value} initialValue = <span class="integer">0</span>
accumulator = {<span class="type">int</span> sum, <span class="type">int</span> value -&gt; sum + value} initialValue = {-&gt; <span class="integer">0</span>}
accumulator = {ShoppingCart cart, Item value -&gt; cart.addItem(value)} initialValue = {-&gt; <span class="keyword">new</span> ShoppingCart()}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The return type is a map.
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p>E.g. [['he', 1], ['she', 2], ['he', 2], ['me', 1], ['she', 5], ['he', 1]] with an initial value of zero will combine into ['he' : 4, 'she' : 7, 'me' : 1]</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Comparion Logic</div>
<div class="paragraph">
<p>The keys will be mutually compared using their <strong>equals</strong> and <strong>hashCode</strong> methods. Consider using <em>\@Canonical</em> or <em>\@EqualsAndHashCode</em> annotations to annotate objects you use as keys.</p>
</div>
<div class="paragraph">
<p>As with all hash maps in <strong>Groovy</strong>, be sure you&#8217;re using a <strong>String</strong> not a <strong>GString</strong> as a key!</p>
</div>
</div>
</div>
<div class="paragraph">
<p>For more involved scenarios when you <em>combine()</em> complex objects, a good strategy here is to have a complete class to use as a key for common use cases and to apply different keys for uncommon cases.</p>
</div>
<div class="listingblock">
<div class="title">A Complex Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovy.transform.ToString</span>
<span class="keyword">import</span> <span class="include">groovy.transform.TupleConstructor</span>

<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.withPool</span>

<span class="comment">// declare a complete class to use in combination processing</span>
<span class="annotation">@TupleConstructor</span> <span class="annotation">@ToString</span>
<span class="type">class</span> <span class="class">PricedCar</span> <span class="directive">implements</span> <span class="predefined-type">Cloneable</span> {        <span class="comment">// either Clonable or Immutable</span>
    <span class="predefined-type">String</span> model
    <span class="predefined-type">String</span> color
    <span class="predefined-type">Double</span> price

        <span class="comment">// declare a way to resolve comparison logic</span>
    <span class="type">boolean</span> equals(<span class="directive">final</span> o) {
        <span class="keyword">if</span> (<span class="local-variable">this</span>.is(o)) <span class="keyword">return</span> <span class="predefined-constant">true</span>
        <span class="keyword">if</span> (getClass() != o.class) <span class="keyword">return</span> <span class="predefined-constant">false</span>

        <span class="directive">final</span> PricedCar pricedCar = (PricedCar) o

        <span class="keyword">if</span> (color != pricedCar.color) <span class="keyword">return</span> <span class="predefined-constant">false</span>
        <span class="keyword">if</span> (model != pricedCar.model) <span class="keyword">return</span> <span class="predefined-constant">false</span>

        <span class="keyword">return</span> <span class="predefined-constant">true</span>
    }

    <span class="type">int</span> hashCode() {
        <span class="type">int</span> result
        result = (model != <span class="predefined-constant">null</span> ? model.hashCode() : <span class="integer">0</span>)
        result = <span class="integer">31</span> * result + (color != <span class="predefined-constant">null</span> ? color.hashCode() : <span class="integer">0</span>)
        <span class="keyword">return</span> result
    }

    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="predefined-type">Object</span> clone() {
        <span class="keyword">return</span> <span class="local-variable">super</span>.clone()
    }
}

<span class="comment">// some data</span>
<span class="keyword">def</span> cars = [<span class="keyword">new</span> PricedCar(<span class="string"><span class="delimiter">'</span><span class="content">F550</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">blue</span><span class="delimiter">'</span></span>, <span class="float">2342.223</span>),
        <span class="keyword">new</span> PricedCar(<span class="string"><span class="delimiter">'</span><span class="content">F550</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">red</span><span class="delimiter">'</span></span>, <span class="float">234.234</span>),
        <span class="keyword">new</span> PricedCar(<span class="string"><span class="delimiter">'</span><span class="content">Da</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">white</span><span class="delimiter">'</span></span>, <span class="float">2222.2</span>),
        <span class="keyword">new</span> PricedCar(<span class="string"><span class="delimiter">'</span><span class="content">Da</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">white</span><span class="delimiter">'</span></span>, <span class="float">1111.1</span>)]


withPool {
    <span class="comment">//Combine by model</span>
    <span class="keyword">def</span> result =
        cars.parallel.map {
            [<span class="local-variable">it</span>.model, <span class="local-variable">it</span>]
        }.combine(<span class="keyword">new</span> PricedCar(<span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">N/A</span><span class="delimiter">'</span></span>, <span class="float">0.0</span>)) {sum, value -&gt;
            sum.model = value.model
            sum.price += value.price
            sum
        }.values()

    println result


    <span class="comment">//Combine by model and color (using the PricedCar's equals and hashCode))</span>
    result =
        cars.parallel.map {
            [<span class="local-variable">it</span>, <span class="local-variable">it</span>]
        }.combine(<span class="keyword">new</span> PricedCar(<span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">N/A</span><span class="delimiter">'</span></span>, <span class="float">0.0</span>)) {sum, value -&gt;
            sum.model = value.model
            sum.color = value.color
            sum.price += value.price
            sum
        }.values()

    println result
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_parallel_arrays">Parallel Arrays</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As an alternative, the efficient tree-based data structures defined in <a href="https://en.wikipedia.org/wiki/Java_concurrency"><strong>JSR-166y</strong> - Java Concurrency</a> can be used directly. The <em>parallelArray</em> property on any collection or object will return a <em>ParallelArray</em> instance holding the elements of the original collection. These then can be manipulated through the <a href="https://en.wikipedia.org/wiki/Java_concurrency"><strong>jsr166y</strong></a> API.</p>
</div>
<div class="paragraph">
<p>Please refer to <a href="https://en.wikipedia.org/wiki/Java_concurrency"><strong>jsr166y</strong></a> documentation for API details.</p>
</div>
<div class="listingblock">
<div class="title">A Parallel Array Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.extra166y.Ops</span>

groovyx.gpars.GParsPool.withPool {

    <span class="keyword">assert</span> <span class="integer">15</span> == [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].parallelArray.reduce({a, b -&gt; a + b} <span class="keyword">as</span> Ops.Reducer, <span class="integer">0</span>)                                        <span class="comment">//summarize</span>

    <span class="keyword">assert</span> <span class="integer">55</span> == [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].parallelArray.withMapping({<span class="local-variable">it</span> ** <span class="integer">2</span>} <span class="keyword">as</span> Ops.Op).reduce({a, b -&gt; a + b} <span class="keyword">as</span> Ops.Reducer, <span class="integer">0</span>)       <span class="comment">//summarize squares</span>

    <span class="keyword">assert</span> <span class="integer">20</span> == [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].parallelArray.withFilter({<span class="local-variable">it</span> % <span class="integer">2</span> == <span class="integer">0</span>} <span class="keyword">as</span> Ops.Predicate)                                       <span class="comment">//summarize squares of even numbers</span>
            .withMapping({<span class="local-variable">it</span> ** <span class="integer">2</span>} <span class="keyword">as</span> Ops.Op)
            .reduce({a, b -&gt; a + b} <span class="keyword">as</span> Ops.Reducer, <span class="integer">0</span>)

    <span class="keyword">assert</span> <span class="string"><span class="delimiter">'</span><span class="content">aa:bb:cc:dd:ee</span><span class="delimiter">'</span></span> == <span class="string"><span class="delimiter">'</span><span class="content">abcde</span><span class="delimiter">'</span></span>.parallelArray                                                                            <span class="comment">//concatenate duplicated characters with separator</span>
            .withMapping({<span class="local-variable">it</span> * <span class="integer">2</span>} <span class="keyword">as</span> Ops.Op)
            .reduce({a, b -&gt; <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>a</span><span class="content">:</span><span class="inline"><span class="inline-delimiter">$</span>b</span><span class="delimiter">&quot;</span></span>} <span class="keyword">as</span> Ops.Reducer, <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_asynchronous_invocations">Asynchronous Invocations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Long running background tasks happen a lot in most systems.</p>
</div>
<div class="paragraph">
<p>Typically, a main thread of execution wants to initialize a few calculations, start downloads, do searches, etc. even when the results may not be needed immediately.</p>
</div>
<div class="paragraph">
<p><strong>GPars</strong> gives the developers the tools to schedule asynchronous activities for background processing and collect the results later, when they&#8217;re needed.</p>
</div>
<div class="sect2">
<h3 id="_usage_of_strong_gparspool_strong_and_strong_gparsexecutorspool_strong_asynchronous_processing_facilities">Usage of <strong>GParsPool</strong> and <strong>GParsExecutorsPool</strong> Asynchronous Processing Facilities</h3>
<div class="paragraph">
<p>Both <strong>GParsPool</strong> and <strong>GParsExecutorsPool</strong> methods provide nearly identical services while leveraging different underlying machinery.</p>
</div>
<div class="sect3">
<h4 id="_closures_enhancements">Closures Enhancements</h4>
<div class="paragraph">
<p>The following methods are added to closures inside the <em>GPars(Executors)Pool.withPool()</em> blocks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>async() - To create an asynchronous variant of the supplied closure which, when invoked, returns a <strong>future</strong> object for the potential return value</p>
</li>
<li>
<p>callAsync() - Calls a closure in a separate thread while supplying the given arguments, returning a <strong>future</strong> object for the potential return value,</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">An <strong>async()</strong> Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre>GParsPool.withPool() {
    Closure longLastingCalculation = {calculate()}
    Closure fastCalculation = longLastingCalculation.async()  <span class="comment">//create a new closure, which starts the original closure on a thread pool</span>

    <span class="predefined-type">Future</span> result=fastCalculation()                           <span class="comment">//returns almost immediately</span>

    <span class="comment">//do stuff while calculation performs ...</span>
    println result.get()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">A <strong>callAsync()</strong> Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre>GParsPool.withPool() {
    <span class="comment">/**
     * The callAsync() method is an asynchronous variant of the default call() method to invoke a closure.
     * It will return a Future for the result value.
     */</span>
    <span class="keyword">assert</span> <span class="integer">6</span> == {<span class="local-variable">it</span> * <span class="integer">2</span>}.call(<span class="integer">3</span>)
    <span class="keyword">assert</span> <span class="integer">6</span> == {<span class="local-variable">it</span> * <span class="integer">2</span>}.callAsync(<span class="integer">3</span>).get()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_timeouts">Timeouts</h4>
<div class="paragraph">
<p>The <em>callTimeoutAsync()</em> methods, taking either a long value or a <strong>Duration</strong> instance, provides a timer mechanism.</p>
</div>
<div class="listingblock">
<div class="title">A Timed Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>{-&gt;
    <span class="keyword">while</span>(<span class="predefined-constant">true</span>) {
        <span class="predefined-type">Thread</span>.sleep <span class="integer">1000</span>  <span class="comment">//Simulate a bit of interesting calculation</span>
        <span class="keyword">if</span> (<span class="predefined-type">Thread</span>.currentThread().isInterrupted()) <span class="keyword">break</span>;  <span class="comment">//We've been cancelled</span>
    }
}.callTimeoutAsync(<span class="integer">2000</span>)</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>To allow cancellation, our asynchronously running code must keep checking the <em>interrupted</em> flag of it&#8217;s own thread and stop calculating when/if the flag is set to true.</p>
</div>
</div>
<div class="sect3">
<h4 id="_executor_service_enhancements">Executor Service Enhancements</h4>
<div class="paragraph">
<p>The <strong>ExecutorService</strong> and <strong>ForkJoinPool</strong> classes are enhanced with the <strong class="red">'&lt;&lt;'</strong> (leftShift) operator to submit tasks to the pool and return a <em>Future</em> for the result.</p>
</div>
<div class="listingblock">
<div class="title">A Convenient Example Using [red]'&lt;&lt;'</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>GParsExecutorsPool.withPool {<span class="predefined-type">ExecutorService</span> executorService -&gt;
    executorService &lt;&lt; {println <span class="string"><span class="delimiter">'</span><span class="content">Inside parallel task</span><span class="delimiter">'</span></span>}
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_running_functions_closures_in_parallel">Running Functions (closures) in Parallel</h4>
<div class="paragraph">
<p>The <strong>GParsPool</strong> and <strong>GParsExecutorsPool</strong> classes also provide handy methods <em>executeAsync()</em> and
<em>executeAsyncAndWait()</em> to easily run multiple closures asynchronously.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="title">An Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>GParsPool.withPool {
    <span class="keyword">assert</span> [<span class="integer">10</span>, <span class="integer">20</span>] == GParsPool.executeAsyncAndWait({calculateA()}, {calculateB()}         <span class="comment">//waits for results</span>
    <span class="keyword">assert</span> [<span class="integer">10</span>, <span class="integer">20</span>] == GParsPool.executeAsync({calculateA()}, {calculateB()})*.get()  <span class="comment">//returns Futures instead and doesn't wait for results to be calculated</span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_composable_asynchronous_functions">Composable Asynchronous Functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Functions are to be composed. In fact, composing side-effect-free functions is very easy. Much easier and more reliable than composing objects, for example.</p>
</div>
<div class="paragraph">
<p>Given the same input, functions always return the same result, they never change their behavior unexpectedly nor they break when multiple threads call them at the same time.</p>
</div>
<div class="sect2">
<h3 id="_functions_in_strong_groovy_strong">Functions in <strong>Groovy</strong></h3>
<div class="paragraph">
<p>We can treat <strong>Groovy</strong> closures as functions. They take arguments, do their calculation and return a value. Provided you don&#8217;t let your closures touch anything outside their scope,
your closures are well-behaved, just like pure functions. Functions that you can combine for a higher good.</p>
</div>
<div class="listingblock">
<div class="title">A Higher Good Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> sum = (<span class="integer">0</span>..<span class="integer">100000</span>).inject(<span class="integer">0</span>, {a, b -&gt; a + b})</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>For this example, by combining a function adding two numbers <code>{a,b}</code> with the <em>inject</em> function, which iterates through the whole collection, you can quickly summarize all items.
Then, replacing the <em>adding</em> function with a <em>comparison</em> function immediately gives you a combined function to calculate maximums.</p>
</div>
<div class="listingblock">
<div class="title">Find The Maximums</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> max = myNumbers.inject(<span class="integer">0</span>, {a, b -&gt; a&gt;b?a:b})</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>You see, functional programming is popular for a reason.</p>
</div>
</div>
<div class="sect2">
<h3 id="_are_we_concurrent_yet">Are We Concurrent Yet?</h3>
<div class="paragraph">
<p>This all works just fine until you realize you&#8217;re not using the full power of your expensive hardware. These functions are just plain sequential! No parallelism is used!
All but one processor core is doing nothing, they&#8217;re idle, totally wasted!</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">A Generic Way to Use Asynchronous Functions</div>
<div class="paragraph">
<p>Those paying attention might decide to use the <em>Parallel Collection</em> techniques described earlier and they would certainly be correct.</p>
</div>
<div class="paragraph">
<p>For our scenario described here, where we process a collection, using those <em>parallel</em> methods would be the best choice. However, we&#8217;re now looking for a generic way to create and combine asynchronous functions.
This would help us, not only for collections processing, but mostly in other, more generic, cases like the one right below.</p>
</div>
</div>
</div>
<hr>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
All but one processor core is doing nothing! They&#8217;re idle! Totally wasted!
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p>To make things more obvious, here&#8217;s an example of combining four functions, which are supposed to check
whether a particular web page matches the contents of a local file.  We need to download the page, load the
file, calculate hashes of both and finally compare the resulting numbers.</p>
</div>
<div class="listingblock">
<div class="title">An Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td>
  <td class="code"><pre>Closure download = {<span class="predefined-type">String</span> url -&gt;
    url.toURL().text
}

Closure loadFile = {<span class="predefined-type">String</span> fileName -&gt;
    ...  <span class="comment">//load the file here</span>
}

Closure hash = {s -&gt; s.hashCode()}

Closure compare = {<span class="type">int</span> first, <span class="type">int</span> second -&gt;
    first == second
}

<span class="keyword">def</span> result = compare(hash(download(<span class="string"><span class="delimiter">'</span><span class="content">http://www.gpars.org</span><span class="delimiter">'</span></span>)), hash(loadFile(<span class="string"><span class="delimiter">'</span><span class="content">/coolStuff/gpars/website/index.html</span><span class="delimiter">'</span></span>)))
println <span class="string"><span class="delimiter">&quot;</span><span class="content">The result of comparison: </span><span class="delimiter">&quot;</span></span> + result</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>We need to download the page, load up the file, calculate hashes of both and finally compare the resulting
numbers.  Each of the functions is responsible for one particular job. One function downloads the content, a second
loads the file, and a third calculates the hashes and finally the fourth one will do the comparison.</p>
</div>
<div class="paragraph">
<p>Combining the functions is as simple as nesting their calls.</p>
</div>
<hr>
<div class="sect3">
<h4 id="_making_it_all_asynchronous">Making It All Asynchronous</h4>
<div class="paragraph">
<p>The downside of our code is that we haven&#8217;t leveraged the independence of the <em>download()</em> and the <em>loadFile()</em> functions.  Neither have we allowed the two hashes to be run concurrently.
They could well run in parallel, but our approach to combine functions restricts parallelism.</p>
</div>
<div class="paragraph">
<p>Obviously not all of the functions <strong>can</strong> run concurrently. Some functions depend on results of others. They cannot start before the other function finishes.
We need to block them until their parameters are available. The <em>hash()</em> functions needs a string to work on. The <em>compare()</em> function needs two numbers to compare.</p>
</div>
<div class="paragraph">
<p>So we can only take parallelism so far, while blocking parallelism of others. Seems like a challenging task.</p>
</div>
</div>
<div class="sect3">
<h4 id="_things_are_bright_in_the_functional_world">Things Are Bright in the Functional World</h4>
<div class="paragraph">
<p>Luckily, the dependencies between functions are already expressed implicitly in the code. There&#8217;s no need to duplicate that dependency information.
If one functions takes parameters and the parameters need to be calculated first by another function, we implicitly have a dependency here.</p>
</div>
<div class="paragraph">
<p>The <em>hash()</em> function depends on <em>loadFile()</em> as well as on the <em>download()</em> functions in our example.  The <em>inject</em> function in our earlier example depended on the results of the <em>addition</em> functions gradually invoked  on all elements of the collection.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>However difficult it may seem at first, our task is, in fact, very simple. We only need to teach our functions to return a <em>promise</em> of their future results.
And we need to teach the other functions to accept those <em>promises</em> as parameters so that they will wait for the real values before they start their work.</p>
</div>
<div class="paragraph">
<p>And if we convince the functions to release the threads they hold, while waiting for the values, we get directly to where the magic can happen.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>In the best traditions of <em>*GPars*</em>, we&#8217;ve made it very straightforward for you to convince any function to believe in the <strong>promises</strong> of other functions.  Call the <em>asyncFun()</em> function on a closure and you&#8217;re asynchronous !</p>
</div>
<div class="listingblock">
<div class="title">Promises, Promises</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>withPool {
    <span class="keyword">def</span> maxPromise = numbers.inject(<span class="integer">0</span>, {a, b -&gt; a&gt;b?a:b}.asyncFun())

    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Look Ma, I can talk to the user while the math is being done for me!</span><span class="delimiter">&quot;</span></span>
    println maxPromise.get()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>inject</em> function doesn&#8217;t really care what objects are returned from the <em>addition</em> function,
maybe it&#8217;s a little surprised each call to the <em>addition</em> function returns so fast, but doesn&#8217;t moan much, keeps iterating and finally returns the overall result we expect.</p>
</div>
<div class="paragraph">
<p>Now is the time you should stand behind what you say and do what you want others to do. Don&#8217;t frown at the result and just accept that you got back just a <strong>promise</strong>.  A <strong>promise</strong> to get the answer delivered as soon as the calculation is complete.
The extra heat from your laptop is an indication that the calculation exploits natural parallelism in your functions and makes its best effort to deliver the result to you quickly.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">A Promise Is A Promise</div>
<div class="paragraph">
<p>The <em>promise</em> is a good old <em>DataflowVariable</em>, so you can query its status, register some notification hooks or even make it an input to a <strong>Dataflow</strong> algorithm !</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">An Promising Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre>withPool {
    <span class="keyword">def</span> sumPromise = (<span class="integer">0</span>..<span class="integer">100000</span>).inject(<span class="integer">0</span>, {a, b -&gt; a + b}.asyncFun())

    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Are we done yet? </span><span class="delimiter">&quot;</span></span> + sumPromise.bound

    sumPromise.whenBound {sum -&gt; println sum}
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Do You Need A Timeout ?</div>
<div class="paragraph">
<p>The <em>get()</em> method has also a variant with a timeout parameter, if you want to avoid the risk of waiting indefinitely.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_can_things_go_wrong">Can Things Go Wrong?</h4>
<div class="paragraph">
<p>Sure. But you&#8217;ll get an exception thrown from the <strong>promise</strong> <em>get()</em> method.</p>
</div>
<div class="listingblock">
<div class="title">An Exceptional Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre><span class="keyword">try</span> {
    sumPromise.get()

} <span class="keyword">catch</span> (MyCalculationException e) {
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Guess, things are not ideal today.</span><span class="delimiter">&quot;</span></span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_this_is_all_fine_but_what_functions_can_really_be_combined">This Is All Fine, But What Functions Can Really Be Combined?</h4>
<div class="paragraph">
<p>There are no limits to your ambitions. Take any sequential functions you need to combine and you should be able to combine their asynchronous variants as well.</p>
</div>
<div class="paragraph">
<p>Review our initial example comparing the content of a file with a web page. We simply make all the functions asynchronous by calling the <em>asyncFun()</em> method on them and we are ready to set off.</p>
</div>
<div class="listingblock">
<div class="title">Using  The <em>asyncFun()</em> Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td>
  <td class="code"><pre>    Closure download = {<span class="predefined-type">String</span> url -&gt;
        url.toURL().text
    }.asyncFun()

    Closure loadFile = {<span class="predefined-type">String</span> fileName -&gt;
        ...  <span class="comment">//load the file here</span>
    }.asyncFun()

    Closure hash = {s -&gt; s.hashCode()}.asyncFun()

    Closure compare = {<span class="type">int</span> first, <span class="type">int</span> second -&gt;
        first == second
    }.asyncFun()

    <span class="keyword">def</span> result = compare(hash(download(<span class="string"><span class="delimiter">'</span><span class="content">http://www.gpars.org</span><span class="delimiter">'</span></span>)), hash(loadFile(<span class="string"><span class="delimiter">'</span><span class="content">/coolStuff/gpars/website/index.html</span><span class="delimiter">'</span></span>)))

    println <span class="string"><span class="delimiter">'</span><span class="content">Allowed to do something else now</span><span class="delimiter">'</span></span>
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">The result of comparison: </span><span class="delimiter">&quot;</span></span> + result.get()</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_calling_asynchronous_functions_from_within_asynchronous_functions">Calling Asynchronous Functions from Within Asynchronous Functions</h4>
<div class="paragraph">
<p>Another very valuable attribute of asynchronous functions is that <code>promises</code> can be combined.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Promises can be combined !
</td>
</tr>
</table>
</div>
<hr>
<div class="listingblock">
<div class="title">An Asynchronous Function Within Another</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.withPool</span>

  withPool {
      Closure plus = {<span class="predefined-type">Integer</span> a, <span class="predefined-type">Integer</span> b -&gt;
          sleep <span class="integer">3000</span>
          println <span class="string"><span class="delimiter">'</span><span class="content">Adding numbers</span><span class="delimiter">'</span></span>
          a + b
      }.asyncFun();        <span class="comment">// ok, here's one func</span>

      Closure multiply = {<span class="predefined-type">Integer</span> a, <span class="predefined-type">Integer</span> b -&gt;
          sleep <span class="integer">2000</span>
          a * b
      }.asyncFun()        <span class="comment">// and second one</span>

      Closure measureTime = {-&gt;
          sleep <span class="integer">3000</span>
          <span class="integer">4</span>
      }.asyncFun();        <span class="comment">// and another</span>

          <span class="comment">// declare a function within a function</span>
      Closure distance = {<span class="predefined-type">Integer</span> initialDistance, <span class="predefined-type">Integer</span> velocity, <span class="predefined-type">Integer</span> time -&gt;
          plus(initialDistance, multiply(velocity, time))
      }.asyncFun();        <span class="comment">// and another</span>


      Closure chattyDistance = {<span class="predefined-type">Integer</span> initialDistance, <span class="predefined-type">Integer</span> velocity, <span class="predefined-type">Integer</span> time -&gt;
          println <span class="string"><span class="delimiter">'</span><span class="content">All parameters are now ready - starting</span><span class="delimiter">'</span></span>
          println <span class="string"><span class="delimiter">'</span><span class="content">About to call another asynchronous function</span><span class="delimiter">'</span></span>
          <span class="keyword">def</span> innerResultPromise = plus(initialDistance, multiply(velocity, time))
          println <span class="string"><span class="delimiter">'</span><span class="content">Returning the promise for the inner calculation as my own result</span><span class="delimiter">'</span></span>
          <span class="keyword">return</span> innerResultPromise
      }.asyncFun();        <span class="comment">// and declare (but not run) a final asynch.function</span>

          <span class="comment">// fine, now let's execute those previous asynch. functions</span>
      println <span class="string"><span class="delimiter">&quot;</span><span class="content">Distance = </span><span class="delimiter">&quot;</span></span> + distance(<span class="integer">100</span>, <span class="integer">20</span>, measureTime()).get() + <span class="string"><span class="delimiter">'</span><span class="content"> m</span><span class="delimiter">'</span></span>
      println <span class="string"><span class="delimiter">&quot;</span><span class="content">ChattyDistance = </span><span class="delimiter">&quot;</span></span> + chattyDistance(<span class="integer">100</span>, <span class="integer">20</span>, measureTime()).get() + <span class="string"><span class="delimiter">'</span><span class="content"> m</span><span class="delimiter">'</span></span>
  }</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>If an asynchronous function (e.g. like the <em>distance</em> function in this example) in its body calls another
asynchronous function (e.g. <em>plus</em> ) and returns the the promise of the invoked function, the inner
function&#8217;s ( <em>plus</em> ) resulting promise will combine with the outer function&#8217;s ( <em>distance</em> ) results promise.</p>
</div>
<div class="paragraph">
<p>The inner function ( <em>plus</em> ) will now bind its result to the outer function&#8217;s ( <em>distance</em> ) promise, once the inner function (plus) finishes its calculation.
This ability of promises to combine logic allows functions to cease their calculation without blocking a thread. This happens not only when waiting for parameters,
but also whenever they call another asynchronous function anywhere in their code body.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_methods_as_asynchronous_functions">Methods as Asynchronous Functions</h4>
<div class="paragraph">
<p>Methods can be referred to as closures using the <em>.&amp;</em> operator. These closures can then be transformed using the
<em>asyncFun</em> method into composable asynchronous functions just like ordinary closures.</p>
</div>
<div class="listingblock">
<div class="title">An Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td>
  <td class="code"><pre><span class="type">class</span> <span class="class">DownloadHelper</span> {

    <span class="predefined-type">String</span> download(<span class="predefined-type">String</span> url) {
        url.toURL().text
    }

    <span class="type">int</span> scanFor(<span class="predefined-type">String</span> word, <span class="predefined-type">String</span> text) {
        text.findAll(word).size()
    }

    <span class="predefined-type">String</span> lower(s) {
        s.toLowerCase()
    }
}

<span class="comment">//now we'll make the methods asynchronous</span>
withPool {
    <span class="directive">final</span> DownloadHelper d = <span class="keyword">new</span> DownloadHelper()
    Closure download = d.&amp;download.asyncFun()   <span class="comment">// notice the .&amp; syntax</span>
    Closure scanFor = d.&amp;scanFor.asyncFun()                <span class="comment">// and here</span>
    Closure lower = d.&amp;lower.asyncFun()                        <span class="comment">// and here</span>

    <span class="comment">//asynchronous processing</span>
    <span class="keyword">def</span> result = scanFor(<span class="string"><span class="delimiter">'</span><span class="content">groovy</span><span class="delimiter">'</span></span>, lower(download(<span class="string"><span class="delimiter">'</span><span class="content">http://www.infoq.com</span><span class="delimiter">'</span></span>)))
    println <span class="string"><span class="delimiter">'</span><span class="content">Doing something else for now</span><span class="delimiter">'</span></span>
    println result.get()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_annotations_to_create_asynchronous_functions">Using Annotations to Create Asynchronous Functions</h4>
<div class="paragraph">
<p>Instead of calling the <em>asyncFun()</em> function, the <em>@AsyncFun</em> annotation can be used to annotate Closure-typed fields.
The fields have to be initialized in-place and the containing class needs to be instantiated within a <em>withPool</em> block.</p>
</div>
<div class="listingblock">
<div class="title">An Annotation Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.withPool</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.AsyncFun</span>

<span class="type">class</span> <span class="class">DownloadingSearch</span> {
    <span class="annotation">@AsyncFun</span> Closure download = {<span class="predefined-type">String</span> url -&gt;
        url.toURL().text
    }

    <span class="annotation">@AsyncFun</span> Closure scanFor = {<span class="predefined-type">String</span> word, <span class="predefined-type">String</span> text -&gt;
        text.findAll(word).size()
    }

    <span class="annotation">@AsyncFun</span> Closure lower = {s -&gt; s.toLowerCase()}

    <span class="type">void</span> scan() {
        <span class="keyword">def</span> result = scanFor(<span class="string"><span class="delimiter">'</span><span class="content">groovy</span><span class="delimiter">'</span></span>, lower(download(<span class="string"><span class="delimiter">'</span><span class="content">http://www.infoq.com</span><span class="delimiter">'</span></span>)))  <span class="comment">//synchronous processing</span>

        println <span class="string"><span class="delimiter">'</span><span class="content">Allowed to do something else now</span><span class="delimiter">'</span></span>
        println result.get()
    }
}

withPool {
    <span class="keyword">new</span> DownloadingSearch().scan()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_alternative_pools">Alternative Pools</h5>
<div class="paragraph">
<p>The <em>AsyncFun</em> annotation, by default, uses an instance of <strong>GParsPool</strong> from the wrapping <code>withPool</code> block. You may, however, specify the type of pool explicitly:</p>
</div>
<div class="listingblock">
<div class="title">A Explicit Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="annotation">@AsyncFun</span>(GParsExecutorsPoolUtil) <span class="keyword">def</span> sum6 = {a, b -&gt; a + b }</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_blocking_functions_through_annotations">Blocking Functions Through Annotations</h5>
<div class="paragraph">
<p>The <em>AsyncFun</em> method also allows us to specify, whether the resulting function should allow blocking (true)
or non-blocking (false - default) semantics.</p>
</div>
<div class="listingblock">
<div class="title">An Example of Blocking Semantics</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="annotation">@AsyncFun</span>(blocking = <span class="predefined-constant">true</span>)
<span class="keyword">def</span> sum = {a, b -&gt; a + b }</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="_explicit_and_delayed_pool_assignment">Explicit and Delayed Pool Assignment</h5>
<div class="paragraph">
<p>When using the <em>GPars(Executors)PoolUtil.asyncFun()</em> function directly to create an asynchronous function,
you have two additional ways to assign a thread pool to the function.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The thread pool to be used by the function can be specified explicitly as an additional argument at creation time</p>
</li>
<li>
<p>The implicit thread pool can be obtained from the surrounding scope at invocation-time rather at creation time</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When specifying the thread pool explicitly, the call doesn&#8217;t need to be wrapped in a <em>withPool()</em> block:</p>
</div>
<div class="listingblock">
<div class="title">To Specify Thread Pools Explicitly</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td>
  <td class="code"><pre>Closure sPlus = {<span class="predefined-type">Integer</span> a, <span class="predefined-type">Integer</span> b -&gt;
    a + b
}

Closure sMultiply = {<span class="predefined-type">Integer</span> a, <span class="predefined-type">Integer</span> b -&gt;
    sleep <span class="integer">2000</span>
    a * b
}

println <span class="string"><span class="delimiter">&quot;</span><span class="content">Synchronous result: </span><span class="delimiter">&quot;</span></span> + sMultiply(sPlus(<span class="integer">10</span>, <span class="integer">30</span>), <span class="integer">100</span>)

<span class="directive">final</span> pool = <span class="keyword">new</span> FJPool();

Closure aPlus = GParsPoolUtil.asyncFun(sPlus, pool)
Closure aMultiply = GParsPoolUtil.asyncFun(sMultiply, pool)

<span class="keyword">def</span> result = aMultiply(aPlus(<span class="integer">10</span>, <span class="integer">30</span>), <span class="integer">100</span>)

println <span class="string"><span class="delimiter">&quot;</span><span class="content">Time to do something else while the calculation is running</span><span class="delimiter">&quot;</span></span>
println <span class="string"><span class="delimiter">&quot;</span><span class="content">Asynchronous result: </span><span class="delimiter">&quot;</span></span> + result.get()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>With a delayed pool assignment, only the function invocation must be surrounded with a <em>withPool()</em> block:</p>
</div>
<div class="listingblock">
<div class="title">A Delayed Pool Assignment Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre>Closure aPlus = GParsPoolUtil.asyncFun(sPlus)
Closure aMultiply = GParsPoolUtil.asyncFun(sMultiply)

withPool {
    <span class="keyword">def</span> result = aMultiply(aPlus(<span class="integer">10</span>, <span class="integer">30</span>), <span class="integer">100</span>)

    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Time to do something else while the calculation is running</span><span class="delimiter">&quot;</span></span>
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Asynchronous result: </span><span class="delimiter">&quot;</span></span> + result.get()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>For us, this is a very interesting domain to explore. So any comments, questions or suggestions are welcome on combining asynchronous functions or hints about its limits.</p>
</div>
<hr>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fork_join">Fork-Join</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Fork/Join</strong> or <em>Divide-and-Conquer</em>, is a very powerful abstraction to solve hierarchical problems.</p>
</div>
<div class="sect2">
<h3 id="_the_abstraction">The Abstraction</h3>
<div class="paragraph">
<p>When talking about hierarchical problems, think about quick sort, merge sort, file system or general tree navigation problems.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Fork/Join</strong> algorithms essentially split a problem into several smaller sub-problems and then recursively applies the same algorithm to each of the sub-problems.</p>
</li>
<li>
<p>Once the sub-problem is small enough, it is solved directly.</p>
</li>
<li>
<p>The solutions of all sub-problems are combined to solve their parent problem, which in turn helps solve its' own grand-parent problem.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">A Picture Is Worth A Thousand Words</div>
<div class="paragraph">
<p>Check out the fancy <a href="http://blog.krecan.net/2011/03/27/visualizing-forkjoin/">Interactive <strong>Fork/Join</strong>
visualization demo</a>. It shows you how threads co-operate to solve a common divide-and-conquer algorithm.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The mighty <strong>JSR-166y</strong> library co-ordinates <strong>Fork/Join</strong> orchestration rather nicely, but leaves a few rough edges, which can hurt you, if you don&#8217;t pay enough attention. You must still deal with threads, pools and/or
synchronization barriers.</p>
</div>
<div class="sect3">
<h4 id="_the_strong_gpars_strong_abstraction_convenience_layer">The <strong>GPars</strong> Abstraction Convenience Layer</h4>
<div class="paragraph">
<p><strong>GPars</strong> can hide the complexities of dealing with threads, pools and recursive tasks from you, yet let you
leverage the powerful <strong>Fork/Join</strong> implementation in <strong>jsr166y</strong>.</p>
</div>
<div class="listingblock">
<div class="title">A Complex Example to Walk A File Directory</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.runForkJoin</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.withPool</span>

withPool() {
    println <span class="string"><span class="delimiter">&quot;&quot;&quot;</span><span class="content">Number of files: </span><span class="inline"><span class="inline-delimiter">${</span>

        runForkJoin(<span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">./src</span><span class="delimiter">&quot;</span></span>)) {file -&gt;
            <span class="type">long</span> count = <span class="integer">0</span>
            file.eachFile {
                <span class="keyword">if</span> (<span class="local-variable">it</span>.isDirectory()) {
                    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Forking a child task for </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>
                    forkOffChild(<span class="local-variable">it</span>)           <span class="comment">//fork a child task</span>

                } <span class="keyword">else</span> {
                    count++
                }
            }
            <span class="keyword">return</span> count + (childrenResults.sum(<span class="integer">0</span>))
            <span class="comment">//use results of children tasks to calculate and store own result</span>
        }

    <span class="inline-delimiter">}</span></span><span class="delimiter">&quot;&quot;&quot;</span></span>.toString();
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>runForkJoin()</em> factory method uses the supplied recursive code together with the provided values
to build a hierarchical <strong>Fork/Join</strong> calculation. The number of values passed to the <em>runForkJoin()</em> method
must match the number of expected parameters of the closure. This must equal the same number of arguments passed to the <em>forkOffChild()</em> or <em>runChildDirectly()</em> methods.</p>
</div>
<div class="listingblock">
<div class="title">An Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> <span class="function">quicksort</span>(numbers) {

    withPool {

        runForkJoin(<span class="integer">0</span>, numbers) {index, list -&gt;

            <span class="keyword">def</span> groups = list.groupBy {<span class="local-variable">it</span> &lt;=&gt; list[list.size().intdiv(<span class="integer">2</span>)]}

            <span class="keyword">if</span> ((list.size() &lt; <span class="integer">2</span>) || (groups.size() == <span class="integer">1</span>)) {
                <span class="keyword">return</span> [<span class="key">index</span>: index, <span class="key">list</span>: list.clone()]
            }

            (-<span class="integer">1</span>..<span class="integer">1</span>).each {forkOffChild(<span class="local-variable">it</span>, groups[<span class="local-variable">it</span>] ?: <span class="type">[]</span>)}

            <span class="keyword">return</span> [<span class="key">index</span>: index, <span class="key">list</span>: childrenResults.sort {<span class="local-variable">it</span>.index}.sum {<span class="local-variable">it</span>.list}]

        }.list
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">It&#8217;s Asynchronous, Mate !</div>
<div class="paragraph">
<p>The important piece of the puzzle to note here is that <em>forkOffChild()</em> doesn&#8217;t wait for the child to run.
It merely schedules it for execution at a future time. If a child task throws an exception, don&#8217;t expect the exception to be fired from the <em>forkOffChild()</em> method itself.
The exception will have happened long after the parent has called <em>forkOffChild()</em>.</p>
</div>
<div class="paragraph">
<p>It&#8217;s the <em>getChildrenResults()</em> method that will re-throw any child sub-task exceptions back to the parent.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_alternative_approach">Alternative Approach</h5>
<div class="paragraph">
<p>Alternatively, the underlying mechanism of nested <strong>Fork/Join</strong> worker tasks can be used directly.
Custom-tailored workers can eliminate the performance overhead associated with parameter spreading
imposed when using the generic workers.</p>
</div>
<div class="paragraph">
<p>Also, custom workers can be implemented in <strong>Java</strong> for further increases in performance.</p>
</div>
<div class="listingblock">
<div class="title">A Custom Worker</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">FileCounter</span> <span class="directive">extends</span> AbstractForkJoinWorker&lt;<span class="predefined-type">Long</span>&gt; {
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">File</span> file;

    <span class="keyword">def</span> <span class="function">FileCounter</span>(<span class="directive">final</span> <span class="predefined-type">File</span> file) {
        <span class="local-variable">this</span>.file = file
    }

    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="predefined-type">Long</span> computeTask() {
        <span class="type">long</span> count = <span class="integer">0</span>;

        file.eachFile {
            <span class="keyword">if</span> (<span class="local-variable">it</span>.isDirectory()) {
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">Forking a thread for </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>
                forkOffChild(<span class="keyword">new</span> FileCounter(<span class="local-variable">it</span>))           <span class="comment">//fork a child task</span>

            } <span class="keyword">else</span> {
                count++
            }
        }
        <span class="keyword">return</span> count + ((childrenResults)?.sum() ?: <span class="integer">0</span>)  <span class="comment">//use results of children tasks to calculate and store own result</span>
    }
}

withPool(<span class="integer">1</span>) {pool -&gt;  <span class="comment">//feel free to experiment with the number of fork/join threads in the pool</span>
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Number of files: </span><span class="inline"><span class="inline-delimiter">${</span>runForkJoin(<span class="keyword">new</span> FileCounter(<span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">..</span><span class="delimiter">&quot;</span></span>)))<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <strong>AbstractForkJoinWorker</strong> subclasses can be written in both <strong>Java</strong> and <strong>Groovy</strong>. Either choicr lets you optimize for execution speed, if low performance of the worker becomes a bottleneck.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_fork_join_saves_your_resources">Fork / Join Saves Your Resources</h4>
<div class="paragraph">
<p><strong>Fork/Join</strong> operations can safely br run with small numbers of threads thanks to internal use of the
<strong>TaskBarrier</strong> class to synchronize the threads.</p>
</div>
<div class="paragraph">
<p>While a thread is blocked inside an algorithm waiting for its sub-problems to be calculated, the thread is silently returned to it&#8217;s pool to take on any other available sub-problems from the task queue and process them.
Although the algorithm creates as many tasks as there are sub-directories and tasks wait for the sub-directory tasks to complete, often as few as a single thread is enough to keep the computation going and eventually calculate a valid result.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mergesort_example">Mergesort Example</h4>
<div class="listingblock">
<div class="title">Come on Punk, Merge my day !</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.runForkJoin</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.withPool</span>

<span class="comment">/**
 * Splits a list of numbers in half
 */</span>
<span class="keyword">def</span> <span class="function">split</span>(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; list) {
    <span class="type">int</span> listSize = list.size()
    <span class="type">int</span> middleIndex = listSize / <span class="integer">2</span>
    <span class="keyword">def</span> list1 = list[<span class="integer">0</span>..&lt;middleIndex]
    <span class="keyword">def</span> list2 = list[middleIndex..listSize - <span class="integer">1</span>]
    <span class="keyword">return</span> [list1, list2]
}

<span class="comment">/**
 * Merges two sorted lists into one
 */</span>
<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; merge(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; a, <span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; b) {
    <span class="type">int</span> i = <span class="integer">0</span>, j = <span class="integer">0</span>
    <span class="directive">final</span> <span class="type">int</span> newSize = a.size() + b.size()
    <span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; result = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Integer</span>&gt;(newSize)

    <span class="keyword">while</span> ((i &lt; a.size()) &amp;&amp; (j &lt; b.size())) {
        <span class="keyword">if</span> (a[i] &lt;= b[j]) result &lt;&lt; a[i++]
        <span class="keyword">else</span> result &lt;&lt; b[j++]
    }

    <span class="keyword">if</span> (i &lt; a.size()) result.addAll(a[i..-<span class="integer">1</span>])
    <span class="keyword">else</span> result.addAll(b[j..-<span class="integer">1</span>])
    <span class="keyword">return</span> result
}

<span class="directive">final</span> <span class="keyword">def</span> numbers = [<span class="integer">1</span>, <span class="integer">5</span>, <span class="integer">2</span>, <span class="integer">4</span>, <span class="integer">3</span>, <span class="integer">8</span>, <span class="integer">6</span>, <span class="integer">7</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>, <span class="integer">2</span>, <span class="integer">2</span>, <span class="integer">9</span>, <span class="integer">8</span>, <span class="integer">7</span>, <span class="integer">6</span>, <span class="integer">7</span>, <span class="integer">8</span>, <span class="integer">1</span>, <span class="integer">4</span>, <span class="integer">1</span>, <span class="integer">7</span>, <span class="integer">5</span>, <span class="integer">8</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">9</span>, <span class="integer">5</span>, <span class="integer">7</span>, <span class="integer">4</span>, <span class="integer">3</span>]

withPool(<span class="integer">3</span>) {  <span class="comment">//feel free to experiment with the number of fork/join threads in the pool</span>
    println <span class="string"><span class="delimiter">&quot;&quot;&quot;</span><span class="content">Sorted numbers: </span><span class="inline"><span class="inline-delimiter">${</span>
        runForkJoin(numbers) {nums -&gt;
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">Thread </span><span class="inline"><span class="inline-delimiter">${</span><span class="predefined-type">Thread</span>.currentThread().name[-<span class="integer">1</span>]<span class="inline-delimiter">}</span></span><span class="content">: Sorting </span><span class="inline"><span class="inline-delimiter">$</span>nums</span><span class="delimiter">&quot;</span></span>
            <span class="keyword">switch</span> (nums.size()) {
                <span class="keyword">case</span> <span class="integer">0</span>..<span class="integer">1</span>:
                    <span class="keyword">return</span> nums                                   <span class="comment">//store own result</span>
                <span class="keyword">case</span> <span class="integer">2</span>:
                    <span class="keyword">if</span> (nums[<span class="integer">0</span>] &lt;= nums[<span class="integer">1</span>]) <span class="keyword">return</span> nums     <span class="comment">//store own result</span>
                    <span class="keyword">else</span> <span class="keyword">return</span> nums[-<span class="integer">1</span>..<span class="integer">0</span>]                       <span class="comment">//store own result</span>
                <span class="keyword">default</span>:
                    <span class="keyword">def</span> splitList = split(nums)
                    [splitList[<span class="integer">0</span>], splitList[<span class="integer">1</span>]].each {forkOffChild <span class="local-variable">it</span>}  <span class="comment">//fork a child task</span>
                    <span class="keyword">return</span> merge(* childrenResults)      <span class="comment">//use results of children tasks to calculate and store own result</span>
            }
        }
    <span class="inline-delimiter">}</span></span><span class="delimiter">&quot;&quot;&quot;</span></span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_mergesort_example_using_a_custom_tailored_worker_class">Mergesort Example Using A Custom-tailored Worker Class</h4>
<div class="listingblock">
<div class="title">An Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">SortWorker</span> <span class="directive">extends</span> AbstractForkJoinWorker&lt;<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt;&gt; {
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">List</span> numbers

    <span class="keyword">def</span> <span class="function">SortWorker</span>(<span class="directive">final</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; numbers) {
        <span class="local-variable">this</span>.numbers = numbers.asImmutable()
    }

    <span class="comment">/**
     * Splits a list of numbers in half
     */</span>
    <span class="keyword">def</span> <span class="function">split</span>(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; list) {
        <span class="type">int</span> listSize = list.size()
        <span class="type">int</span> middleIndex = listSize / <span class="integer">2</span>
        <span class="keyword">def</span> list1 = list[<span class="integer">0</span>..&lt;middleIndex]
        <span class="keyword">def</span> list2 = list[middleIndex..listSize - <span class="integer">1</span>]
        <span class="keyword">return</span> [list1, list2]
    }

    <span class="comment">/**
     * Merges two sorted lists into one
     */</span>
    <span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; merge(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; a, <span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; b) {
        <span class="type">int</span> i = <span class="integer">0</span>, j = <span class="integer">0</span>
        <span class="directive">final</span> <span class="type">int</span> newSize = a.size() + b.size()

        <span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; result = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Integer</span>&gt;(newSize)

        <span class="keyword">while</span> ((i &lt; a.size()) &amp;&amp; (j &lt; b.size())) {
            <span class="keyword">if</span> (a[i] &lt;= b[j]) result &lt;&lt; a[i++]
            <span class="keyword">else</span> result &lt;&lt; b[j++]
        }

        <span class="keyword">if</span> (i &lt; a.size()) result.addAll(a[i..-<span class="integer">1</span>])
        <span class="keyword">else</span> result.addAll(b[j..-<span class="integer">1</span>])
        <span class="keyword">return</span> result
    }

    <span class="comment">/**
     * Sorts a small list or delegates to two children, if the list contains more than two elements.
     */</span>
    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; computeTask() {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Thread </span><span class="inline"><span class="inline-delimiter">${</span><span class="predefined-type">Thread</span>.currentThread().name[-<span class="integer">1</span>]<span class="inline-delimiter">}</span></span><span class="content">: Sorting </span><span class="inline"><span class="inline-delimiter">$</span>numbers</span><span class="delimiter">&quot;</span></span>

        <span class="keyword">switch</span> (numbers.size()) {
            <span class="keyword">case</span> <span class="integer">0</span>..<span class="integer">1</span>:
                <span class="keyword">return</span> numbers                                   <span class="comment">//store own result</span>

            <span class="keyword">case</span> <span class="integer">2</span>:
                <span class="keyword">if</span> (numbers[<span class="integer">0</span>] &lt;= numbers[<span class="integer">1</span>]) <span class="keyword">return</span> numbers     <span class="comment">//store own result</span>
                <span class="keyword">else</span> <span class="keyword">return</span> numbers[-<span class="integer">1</span>..<span class="integer">0</span>]                       <span class="comment">//store own result</span>

            <span class="keyword">default</span>:
                <span class="keyword">def</span> splitList = split(numbers)
                [<span class="keyword">new</span> SortWorker(splitList[<span class="integer">0</span>]), <span class="keyword">new</span> SortWorker(splitList[<span class="integer">1</span>])].each{forkOffChild <span class="local-variable">it</span>}  <span class="comment">//fork a child task</span>
                <span class="keyword">return</span> merge(* childrenResults)      <span class="comment">//use results of children tasks to calculate and store own result</span>
        }
    }
}

<span class="directive">final</span> <span class="keyword">def</span> numbers = [<span class="integer">1</span>, <span class="integer">5</span>, <span class="integer">2</span>, <span class="integer">4</span>, <span class="integer">3</span>, <span class="integer">8</span>, <span class="integer">6</span>, <span class="integer">7</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>, <span class="integer">2</span>, <span class="integer">2</span>, <span class="integer">9</span>, <span class="integer">8</span>, <span class="integer">7</span>, <span class="integer">6</span>, <span class="integer">7</span>, <span class="integer">8</span>, <span class="integer">1</span>, <span class="integer">4</span>, <span class="integer">1</span>, <span class="integer">7</span>, <span class="integer">5</span>, <span class="integer">8</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">9</span>, <span class="integer">5</span>, <span class="integer">7</span>, <span class="integer">4</span>, <span class="integer">3</span>]

withPool(<span class="integer">1</span>) {  <span class="comment">//feel free to experiment with the number of fork/join threads in the pool</span>
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Sorted numbers: </span><span class="inline"><span class="inline-delimiter">${</span>runForkJoin(<span class="keyword">new</span> SortWorker(numbers))<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_running_child_tasks_directly">Running Child Tasks Directly</h4>
<div class="paragraph">
<p>The <em>forkOffChild</em> method has a sibling&#8201;&#8212;&#8201;called the <em>runChildDirectly</em> method. This method will run the child task
directly and immediately within the current thread instead of scheduling the child task for asynchronous processing on the thread pool.
Typically you&#8217;d call <em>forkOffChild</em> on every sub-task but the last, which you invoke directly without the scheduling overhead.</p>
</div>
<div class="listingblock">
<div class="title">A Fork-In-Time-Saves-Nine</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td>
  <td class="code"><pre>Closure fib = {number -&gt;
    <span class="keyword">if</span> (number &lt;= <span class="integer">2</span>) {
        <span class="keyword">return</span> <span class="integer">1</span>
    }

    forkOffChild(number - <span class="integer">1</span>)                            <span class="comment">//  This task will run asynchronously, probably in a different thread</span>
    <span class="directive">final</span> <span class="keyword">def</span> result = runChildDirectly(number - <span class="integer">2</span>)     <span class="comment">//  This task is run directly within the current thread</span>
    <span class="keyword">return</span> (<span class="predefined-type">Integer</span>) getChildrenResults().sum() + result
}

withPool {
    <span class="keyword">assert</span> <span class="integer">55</span> == runForkJoin(<span class="integer">10</span>, fib)
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_availability_2">Availability</h4>
<div class="paragraph">
<p>This feature is only available when using in the <strong>Fork/Join</strong>-based <strong>GParsPool</strong> , but not <strong>GParsExecutorsPool</strong> .</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_parallel_speculations">Parallel Speculations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With processor cores having become plentiful, some algorithms might benefit from brutal-force parallel
duplication.  Instead of deciding up-front about how to solve a problem, what algorithm to use or which
location to connect to, you run all potential solutions in parallel.</p>
</div>
<div class="sect2">
<h3 id="_parallel_speculations_2">Parallel Speculations</h3>
<div class="paragraph">
<p>Imagine you need to perform a task like e.g. calculate an expensive function or read data from a file,
database or internet. Luckily, you know several good ways (e.g. functions or urls) to reach your
goal. However, all are not equal.</p>
</div>
<div class="paragraph">
<p>Although they return the same (as far as your needs are concerned) result, the elapsed time of each will differ and some may even fail (e.g. network issues).
What&#8217;s worse, no-one&#8217;s going to tell you which choice gives you the single best solution nor which paths might lead to no solution at all.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Shall I run <em>quick sort</em> or <em>merge sort</em> on my list?</p>
</li>
<li>
<p>Which url will work best?</p>
</li>
<li>
<p>Is this service available at its primary location or should I use the backup one?</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>GPars Speculations</strong> give you the option to try all the available alternatives in parallel and receive the result from the fastest functional path, silently ignoring the slow or broken ones.</p>
</div>
<div class="paragraph">
<p>This is what the <em>speculate</em> methods on <strong>GParsPool</strong> and <strong>GParsExecutorsPool</strong> can do for you.</p>
</div>
<div class="listingblock">
<div class="title">A Sort Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> numbers = ...
def quickSort = ...
def mergeSort = ...
def sortedNumbers = speculate(quickSort, mergeSort)</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>So we&#8217;re performing both a <em>quick sort</em> and a <em>merge sort</em> at the same time (concurrently), while getting the result of the
faster one.</p>
</div>
<div class="paragraph">
<p>Given the parallel resources available these days on mainstream hardware, running the two functions in parallel will not have a dramatic impact on speed of calculation of either one,
and thus we get the results of both in about the same time as if we ran only ran the faster of the two calculations.
And also, the result arrives sooner than when running the slower one. Yet we didn&#8217;t have to know up-front, which of the two sorting
algorithms would perform better on our data. Thus we speculated (guessed).</p>
</div>
<div class="paragraph">
<p>Similarly, downloading a document from several sources with different speeds and/or reliability might look like this:</p>
</div>
<div class="listingblock">
<div class="title">A Dpcument DownLoad Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.speculate</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.withPool</span>

<span class="keyword">def</span> alternative1 = {
    <span class="string"><span class="delimiter">'</span><span class="content">http://www.dzone.com/links/index.html</span><span class="delimiter">'</span></span>.toURL().text
}

<span class="keyword">def</span> alternative2 = {
    <span class="string"><span class="delimiter">'</span><span class="content">http://www.dzone.com/</span><span class="delimiter">'</span></span>.toURL().text
}

<span class="keyword">def</span> alternative3 = {
    <span class="string"><span class="delimiter">'</span><span class="content">http://www.dzzzzzone.com/</span><span class="delimiter">'</span></span>.toURL().text  <span class="comment">//wrong url</span>
}

<span class="keyword">def</span> alternative4 = {
    <span class="string"><span class="delimiter">'</span><span class="content">http://dzone.com/</span><span class="delimiter">'</span></span>.toURL().text
}

withPool(<span class="integer">4</span>){
    println speculate([alternative1, alternative2, alternative3, alternative4]).contains(<span class="string"><span class="delimiter">'</span><span class="content">groovy</span><span class="delimiter">'</span></span>)
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Thread Starvation</div>
<div class="paragraph">
<p>Make sure the surrounding thread pool has enough threads to process all alternatives in parallel. The size of the pool should match
the number of closures supplied.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_alternatives_using_strong_dataflow_variables_strong_and_strong_streams_strong">Alternatives Using <strong>Dataflow Variables</strong> and <strong>Streams</strong></h3>
<div class="paragraph">
<p>In some use cases, we can ignore failing alternatives, so <strong>Dataflow</strong> variables or <strong>Streams</strong> may be used to obtain the results of the winning speculation.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">See the <strong>User Guide&#8217;s</strong> topic on <strong>Dataflow Concurrency</strong></div>
<div class="paragraph">
<p>Please refer to the <strong>Dataflow Concurrency</strong> section of the <strong>User Guide</strong> for details on <strong>Dataflow Variables</strong> and streams.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">An Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

<span class="keyword">def</span> alternative1 = {
    <span class="string"><span class="delimiter">'</span><span class="content">http://www.dzone.com/links/index.html</span><span class="delimiter">'</span></span>.toURL().text
}

<span class="keyword">def</span> alternative2 = {
    <span class="string"><span class="delimiter">'</span><span class="content">http://www.dzone.com/</span><span class="delimiter">'</span></span>.toURL().text
}

<span class="keyword">def</span> alternative3 = {
    <span class="string"><span class="delimiter">'</span><span class="content">http://www.dzzzzzone.com/</span><span class="delimiter">'</span></span>.toURL().text  <span class="comment">//will fail due to wrong url</span>
}

<span class="keyword">def</span> alternative4 = {
    <span class="string"><span class="delimiter">'</span><span class="content">http://dzone.com/</span><span class="delimiter">'</span></span>.toURL().text
}

<span class="comment">//Pick either one of the following, both will work:</span>
<span class="directive">final</span> <span class="keyword">def</span> result = <span class="keyword">new</span> DataflowQueue()
<span class="comment">//  final def result = new DataflowVariable()</span>

[alternative1, alternative2, alternative3, alternative4].each{code -&gt;
    task{
        <span class="keyword">try</span> {
            result &lt;&lt; code()
        }
        <span class="keyword">catch</span> (ignore) { }  <span class="comment">// We deliberately ignore unsuccessful urls.</span>
    }
}

println result.val.contains(<span class="string"><span class="delimiter">'</span><span class="content">groovy</span><span class="delimiter">'</span></span>)</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.0<br>
Last updated 2015-11-13 15:46:33 +01:00
</div>
</div>
</body>
</html>