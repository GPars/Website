<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0) on Fri May 09 07:22:33 CEST 2014 -->
<title>GParsPoolUtil (gpars 1.2.1)</title>
<meta name="date" content="2014-05-09">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="GParsPoolUtil (gpars 1.2.1)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/GParsPoolUtil.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../groovyx/gpars/GParsConfig.html" title="class in groovyx.gpars"><span class="strong">Prev Class</span></a></li>
<li><a href="../../groovyx/gpars/MessagingRunnable.html" title="class in groovyx.gpars"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?groovyx/gpars/GParsPoolUtil.html" target="_top">Frames</a></li>
<li><a href="GParsPoolUtil.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">groovyx.gpars</div>
<h2 title="Class GParsPoolUtil" class="title">Class GParsPoolUtil</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>groovyx.gpars.GParsPoolUtil</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="strong">GParsPoolUtil</span>
extends java.lang.Object</pre>
<div class="block">This class forms the core of the DSL initialized by <code>GParsPool</code>. The static methods of <code>GParsPoolUtil</code>
 get attached to their first arguments (the Groovy Category mechanism) and can be then invoked as if they were part of
 the argument classes.</div>
<dl><dt><span class="strong">Author:</span></dt>
  <dd>Vaclav Pech, Robert Fischer
         Date: Mar 10, 2010</dd>
<dt><span class="strong">See Also:</span></dt><dd><code>GParsPool</code></dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private static <a href="../../groovyx/gpars/util/GeneralTimer.html" title="interface in groovyx.gpars.util">GeneralTimer</a></code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#timer">timer</a></strong></code>
<div class="block">Allows timeouts for async operations</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#GParsPoolUtil()">GParsPoolUtil</a></strong>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#anyParallel(java.util.Collection, groovy.lang.Closure)">anyParallel</a></strong>(java.util.Collection&nbsp;collection,
           groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 closure as the filter predicate.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#anyParallel(java.util.Map, groovy.lang.Closure)">anyParallel</a></strong>(java.util.Map&nbsp;collection,
           groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied map and invokes the withFilter() method using the supplied
 closure as the filter predicate.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#anyParallel(java.lang.Object, groovy.lang.Closure)">anyParallel</a></strong>(java.lang.Object&nbsp;collection,
           groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 closure as the filter predicate.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#asConcurrent(java.lang.Object, groovy.lang.Closure)">asConcurrent</a></strong>(java.lang.Object&nbsp;collection,
            groovy.lang.Closure&nbsp;code)</code>
<div class="block">Makes the collection concurrent for the passed-in block of code.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static groovy.lang.Closure</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#async(groovy.lang.Closure)">async</a></strong>(groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates an asynchronous variant of the supplied closure, which, when invoked returns a future for the potential return value</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static groovy.lang.Closure</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#asyncFun(groovy.lang.Closure)">asyncFun</a></strong>(groovy.lang.Closure&nbsp;original)</code>
<div class="block">Creates an asynchronous and composable variant of the supplied closure, which, when invoked returns a DataflowVariable for the potential return value</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static groovy.lang.Closure</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#asyncFun(groovy.lang.Closure, boolean)">asyncFun</a></strong>(groovy.lang.Closure&nbsp;original,
        boolean&nbsp;blocking)</code>
<div class="block">Creates an asynchronous and composable variant of the supplied closure, which, when invoked returns a DataflowVariable for the potential return value</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static groovy.lang.Closure</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#asyncFun(groovy.lang.Closure, groovyx.gpars.scheduler.FJPool)">asyncFun</a></strong>(groovy.lang.Closure&nbsp;original,
        <a href="../../groovyx/gpars/scheduler/FJPool.html" title="class in groovyx.gpars.scheduler">FJPool</a>&nbsp;pool)</code>
<div class="block">Creates an asynchronous and composable variant of the supplied closure, which, when invoked returns a DataflowVariable for the potential return value</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static groovy.lang.Closure</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#asyncFun(groovy.lang.Closure, groovyx.gpars.scheduler.FJPool, boolean)">asyncFun</a></strong>(groovy.lang.Closure&nbsp;original,
        <a href="../../groovyx/gpars/scheduler/FJPool.html" title="class in groovyx.gpars.scheduler">FJPool</a>&nbsp;pool,
        boolean&nbsp;blocking)</code>
<div class="block">Creates an asynchronous and composable variant of the supplied closure, which, when invoked returns a DataflowVariable for the potential return value</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.concurrent.Future&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#callAsync(groovy.lang.Closure, java.lang.Object...)">callAsync</a></strong>(groovy.lang.Closure&lt;T&gt;&nbsp;cl,
         java.lang.Object...&nbsp;args)</code>
<div class="block">Calls a closure in a separate thread supplying the given arguments, returning a future for the potential return value.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.concurrent.Future&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#callParallel(groovy.lang.Closure)">callParallel</a></strong>(groovy.lang.Closure&lt;T&gt;&nbsp;task)</code>
<div class="block">schedules the supplied closure for processing in the underlying thread pool.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.concurrent.Future&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#callTimeoutAsync(groovy.lang.Closure, groovy.time.Duration, java.lang.Object...)">callTimeoutAsync</a></strong>(groovy.lang.Closure&lt;T&gt;&nbsp;cl,
                groovy.time.Duration&nbsp;timeout,
                java.lang.Object...&nbsp;args)</code>
<div class="block">Calls a closure in a separate thread supplying the given arguments, returning a future for the potential return value.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.concurrent.Future&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#callTimeoutAsync(groovy.lang.Closure, long, java.lang.Object...)">callTimeoutAsync</a></strong>(groovy.lang.Closure&lt;T&gt;&nbsp;cl,
                long&nbsp;timeout,
                java.lang.Object...&nbsp;args)</code>
<div class="block">Calls a closure in a separate thread supplying the given arguments, returning a future for the potential return value.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.List&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#collectManyParallel(java.util.Collection, groovy.lang.Closure)">collectManyParallel</a></strong>(java.util.Collection&nbsp;collection,
                   groovy.lang.Closure&lt;java.util.Collection&lt;? extends T&gt;&gt;&nbsp;projection)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 <code>projection</code> closure as the transformation operation.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.List&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#collectManyParallel(java.util.Map, groovy.lang.Closure)">collectManyParallel</a></strong>(java.util.Map&nbsp;collection,
                   groovy.lang.Closure&lt;java.util.Collection&lt;? extends T&gt;&gt;&nbsp;projection)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 <code>projection</code> closure as the transformation operation.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.List&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#collectManyParallel(java.lang.Object, groovy.lang.Closure)">collectManyParallel</a></strong>(java.lang.Object&nbsp;collection,
                   groovy.lang.Closure&lt;java.util.Collection&lt;? extends T&gt;&gt;&nbsp;projection)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 <code>projection</code> closure as the transformation operation.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.Collection&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#collectParallel(java.util.Collection, groovy.lang.Closure)">collectParallel</a></strong>(java.util.Collection&nbsp;collection,
               groovy.lang.Closure&lt;? extends T&gt;&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 closure as the transformation operation.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.Collection&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#collectParallel(java.util.Map, groovy.lang.Closure)">collectParallel</a></strong>(java.util.Map&nbsp;collection,
               groovy.lang.Closure&lt;? extends T&gt;&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied map and invokes the withMapping() method using the supplied
 closure as the transformation operation.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.Collection&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#collectParallel(java.lang.Object, groovy.lang.Closure)">collectParallel</a></strong>(java.lang.Object&nbsp;collection,
               groovy.lang.Closure&lt;? extends T&gt;&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 closure as the transformation operation.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#countParallel(java.util.Collection, groovy.lang.Closure)">countParallel</a></strong>(java.util.Collection&nbsp;collection,
             groovy.lang.Closure&nbsp;filter)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 rule as the filter predicate.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#countParallel(java.util.Collection, java.lang.Object)">countParallel</a></strong>(java.util.Collection&nbsp;collection,
             java.lang.Object&nbsp;filter)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 rule as the filter predicate.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#countParallel(java.lang.Object, groovy.lang.Closure)">countParallel</a></strong>(java.lang.Object&nbsp;collection,
             groovy.lang.Closure&nbsp;filter)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 rule as the filter predicate.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#countParallel(java.lang.Object, java.lang.Object)">countParallel</a></strong>(java.lang.Object&nbsp;collection,
             java.lang.Object&nbsp;filter)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 rule as the filter predicate.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private static &lt;K,V&gt;&nbsp;<a href="../../groovyx/gpars/extra166y/ParallelArray.html" title="class in groovyx.gpars.extra166y">ParallelArray</a>&lt;java.util.Map.Entry&lt;K,V&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#createPA(java.util.Map, jsr166y.ForkJoinPool)">createPA</a></strong>(java.util.Map&lt;K,V&gt;&nbsp;collection,
        jsr166y.ForkJoinPool&nbsp;pool)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.Collection&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#eachParallel(java.util.Collection, groovy.lang.Closure)">eachParallel</a></strong>(java.util.Collection&lt;T&gt;&nbsp;collection,
            groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 closure as the transformation operation.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;K,V&gt;&nbsp;java.util.Map&lt;K,V&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#eachParallel(java.util.Map, groovy.lang.Closure)">eachParallel</a></strong>(java.util.Map&lt;K,V&gt;&nbsp;collection,
            groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied map and invokes the withMapping() method using the supplied
 closure as the transformation operation.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#eachParallel(T, groovy.lang.Closure)">eachParallel</a></strong>(T&nbsp;collection,
            groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 closure as the transformation operation.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.Collection&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#eachWithIndexParallel(java.util.Collection, groovy.lang.Closure)">eachWithIndexParallel</a></strong>(java.util.Collection&lt;T&gt;&nbsp;collection,
                     groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 closure as the transformation operation.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;K,V&gt;&nbsp;java.util.Map&lt;K,V&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#eachWithIndexParallel(java.util.Map, groovy.lang.Closure)">eachWithIndexParallel</a></strong>(java.util.Map&lt;K,V&gt;&nbsp;collection,
                     groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Does parallel eachWithIndex on maps</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#eachWithIndexParallel(T, groovy.lang.Closure)">eachWithIndexParallel</a></strong>(T&nbsp;collection,
                     groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 closure as the transformation operation.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#everyParallel(java.util.Collection, groovy.lang.Closure)">everyParallel</a></strong>(java.util.Collection&nbsp;collection,
             groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 closure as the filter predicate.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#everyParallel(java.util.Map, groovy.lang.Closure)">everyParallel</a></strong>(java.util.Map&nbsp;collection,
             groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied map and invokes the withFilter() method using the supplied
 closure as the filter predicate.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#everyParallel(java.lang.Object, groovy.lang.Closure)">everyParallel</a></strong>(java.lang.Object&nbsp;collection,
             groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 closure as the filter predicate.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.Collection&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#findAllParallel(java.util.Collection, groovy.lang.Closure)">findAllParallel</a></strong>(java.util.Collection&lt;T&gt;&nbsp;collection,
               groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 closure as the filter predicate.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;K,V&gt;&nbsp;java.util.Map&lt;K,V&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#findAllParallel(java.util.Map, groovy.lang.Closure)">findAllParallel</a></strong>(java.util.Map&lt;K,V&gt;&nbsp;collection,
               groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied map and invokes the withFilter() method using the supplied
 closure as the filter predicate.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.util.Collection&lt;java.lang.Object&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#findAllParallel(java.lang.Object, groovy.lang.Closure)">findAllParallel</a></strong>(java.lang.Object&nbsp;collection,
               groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 closure as the filter predicate.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#findAnyParallel(java.util.Collection, groovy.lang.Closure)">findAnyParallel</a></strong>(java.util.Collection&lt;T&gt;&nbsp;collection,
               groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 closure as the filter predicate.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;K,V&gt;&nbsp;java.util.Map.Entry&lt;K,V&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#findAnyParallel(java.util.Map, groovy.lang.Closure)">findAnyParallel</a></strong>(java.util.Map&lt;K,V&gt;&nbsp;collection,
               groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied map and invokes the withFilter() method using the supplied
 closure as the filter predicate.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#findAnyParallel(java.lang.Object, groovy.lang.Closure)">findAnyParallel</a></strong>(java.lang.Object&nbsp;collection,
               groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 closure as the filter predicate.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#findParallel(java.util.Collection, groovy.lang.Closure)">findParallel</a></strong>(java.util.Collection&lt;T&gt;&nbsp;collection,
            groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 closure as the filter predicate.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;K,V&gt;&nbsp;java.util.Map.Entry&lt;K,V&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#findParallel(java.util.Map, groovy.lang.Closure)">findParallel</a></strong>(java.util.Map&lt;K,V&gt;&nbsp;collection,
            groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied map and invokes the withFilter() method using the supplied
 closure as the filter predicate.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#findParallel(java.lang.Object, groovy.lang.Closure)">findParallel</a></strong>(java.lang.Object&nbsp;collection,
            groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 closure as the filter predicate.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#foldParallel(java.util.Collection, groovy.lang.Closure)">foldParallel</a></strong>(java.util.Collection&lt;T&gt;&nbsp;collection,
            groovy.lang.Closure&nbsp;cl)</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#foldParallel(java.util.Collection, T, groovy.lang.Closure)">foldParallel</a></strong>(java.util.Collection&lt;T&gt;&nbsp;collection,
            T&nbsp;seed,
            groovy.lang.Closure&nbsp;cl)</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#foldParallel(java.lang.Object, groovy.lang.Closure)">foldParallel</a></strong>(java.lang.Object&nbsp;collection,
            groovy.lang.Closure&nbsp;cl)</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#foldParallel(java.lang.Object, java.lang.Object, groovy.lang.Closure)">foldParallel</a></strong>(java.lang.Object&nbsp;collection,
            java.lang.Object&nbsp;seed,
            groovy.lang.Closure&nbsp;cl)</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;groovyx.gpars.pa.PAWrapper&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#getParallel(java.util.Collection)">getParallel</a></strong>(java.util.Collection&lt;T&gt;&nbsp;collection)</code>
<div class="block">Creates a PAWrapper around a ParallelArray wrapping the elements of the original collection.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static groovyx.gpars.pa.PAWrapper</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#getParallel(java.lang.Object)">getParallel</a></strong>(java.lang.Object&nbsp;collection)</code>
<div class="block">Creates a PAWrapper around a ParallelArray wrapping the elements of the original collection.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../groovyx/gpars/extra166y/ParallelArray.html" title="class in groovyx.gpars.extra166y">ParallelArray</a>&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#getParallelArray(java.util.Collection)">getParallelArray</a></strong>(java.util.Collection&lt;T&gt;&nbsp;collection)</code>
<div class="block">Creates a ParallelArray wrapping the elements of the original collection.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../groovyx/gpars/extra166y/ParallelArray.html" title="class in groovyx.gpars.extra166y">ParallelArray</a></code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#getParallelArray(java.lang.Object)">getParallelArray</a></strong>(java.lang.Object&nbsp;collection)</code>
<div class="block">Creates a ParallelArray wrapping the elements of the original collection.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;groovy.lang.Closure&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#gmemoize(groovy.lang.Closure)">gmemoize</a></strong>(groovy.lang.Closure&lt;T&gt;&nbsp;cl)</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;groovy.lang.Closure&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#gmemoizeAtLeast(groovy.lang.Closure, int)">gmemoizeAtLeast</a></strong>(groovy.lang.Closure&lt;T&gt;&nbsp;cl,
               int&nbsp;protectedCacheSize)</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;groovy.lang.Closure&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#gmemoizeAtMost(groovy.lang.Closure, int)">gmemoizeAtMost</a></strong>(groovy.lang.Closure&lt;T&gt;&nbsp;cl,
              int&nbsp;maxCacheSize)</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;groovy.lang.Closure&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#gmemoizeBetween(groovy.lang.Closure, int, int)">gmemoizeBetween</a></strong>(groovy.lang.Closure&lt;T&gt;&nbsp;cl,
               int&nbsp;protectedCacheSize,
               int&nbsp;maxCacheSize)</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.Collection&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#grepParallel(java.util.Collection, java.lang.Object)">grepParallel</a></strong>(java.util.Collection&lt;T&gt;&nbsp;collection,
            java.lang.Object&nbsp;filter)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 rule as the filter predicate.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;K,V&gt;&nbsp;java.util.Map&lt;K,V&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#grepParallel(java.util.Map, java.lang.Object)">grepParallel</a></strong>(java.util.Map&lt;K,V&gt;&nbsp;collection,
            java.lang.Object&nbsp;filter)</code>
<div class="block">Creates a Parallel Array out of the supplied map and invokes the withFilter() method using the supplied
 rule as the filter predicate.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#grepParallel(java.lang.Object, java.lang.Object)">grepParallel</a></strong>(java.lang.Object&nbsp;collection,
            java.lang.Object&nbsp;filter)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 rule as the filter predicate.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;K,T&gt;&nbsp;java.util.Map&lt;K,java.util.List&lt;T&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#groupByParallel(java.util.Collection, groovy.lang.Closure)">groupByParallel</a></strong>(java.util.Collection&lt;T&gt;&nbsp;collection,
               groovy.lang.Closure&lt;K&gt;&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 closure as the mapping predicate.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;K&gt;&nbsp;java.util.Map&lt;K,java.util.List&lt;java.lang.Object&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#groupByParallel(java.lang.Object, groovy.lang.Closure)">groupByParallel</a></strong>(java.lang.Object&nbsp;collection,
               groovy.lang.Closure&lt;K&gt;&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 closure as the mapping predicate.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private static &lt;K,T&gt;&nbsp;java.util.Map&lt;K,java.util.List&lt;T&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#groupByParallelPA(groovyx.gpars.extra166y.ParallelArray, groovy.lang.Closure)">groupByParallelPA</a></strong>(<a href="../../groovyx/gpars/extra166y/ParallelArray.html" title="class in groovyx.gpars.extra166y">ParallelArray</a>&lt;T&gt;&nbsp;pa,
                 groovy.lang.Closure&lt;K&gt;&nbsp;cl)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#injectParallel(java.util.Collection, groovy.lang.Closure)">injectParallel</a></strong>(java.util.Collection&lt;T&gt;&nbsp;collection,
              groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its reduce() method using the supplied
 closure as the reduction operation.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#injectParallel(java.util.Collection, T, groovy.lang.Closure)">injectParallel</a></strong>(java.util.Collection&lt;T&gt;&nbsp;collection,
              T&nbsp;seed,
              groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its reduce() method using the supplied
 closure as the reduction operation.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#injectParallel(java.lang.Object, groovy.lang.Closure)">injectParallel</a></strong>(java.lang.Object&nbsp;collection,
              groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its reduce() method using the supplied
 closure as the reduction operation.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#injectParallel(java.lang.Object, java.lang.Object, groovy.lang.Closure)">injectParallel</a></strong>(java.lang.Object&nbsp;collection,
              java.lang.Object&nbsp;seed,
              groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its reduce() method using the supplied
 closure as the reduction operation.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#isConcurrent(java.lang.Object)">isConcurrent</a></strong>(java.lang.Object&nbsp;collection)</code>
<div class="block">Indicates whether the iterative methods like each() or collect() work have been altered to work concurrently.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.concurrent.Future&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#leftShift(jsr166y.ForkJoinPool, groovy.lang.Closure)">leftShift</a></strong>(jsr166y.ForkJoinPool&nbsp;pool,
         groovy.lang.Closure&lt;T&gt;&nbsp;task)</code>
<div class="block">Submits the task for asynchronous processing returning the Future received from the executor service.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#makeConcurrent(java.lang.Object)">makeConcurrent</a></strong>(java.lang.Object&nbsp;collection)</code>
<div class="block">Overrides the iterative methods like each(), collect() and such, so that they call their parallel variants from the GParsPoolUtil class
 like eachParallel(), collectParallel() and such.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#makeSequential(java.lang.Object)">makeSequential</a></strong>(java.lang.Object&nbsp;collection)</code>
<div class="block">Gives the iterative methods like each() or find() the original sequential semantics.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#maxParallel(java.util.Collection)">maxParallel</a></strong>(java.util.Collection&lt;T&gt;&nbsp;collection)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its max() method using the default comparator.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#maxParallel(java.util.Collection, groovy.lang.Closure)">maxParallel</a></strong>(java.util.Collection&lt;T&gt;&nbsp;collection,
           groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its max() method using the supplied
 closure as the comparator.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#maxParallel(java.lang.Object)">maxParallel</a></strong>(java.lang.Object&nbsp;collection)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its max() method using the default comparator.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#maxParallel(java.lang.Object, groovy.lang.Closure)">maxParallel</a></strong>(java.lang.Object&nbsp;collection,
           groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its max() method using the supplied
 closure as the comparator.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#minParallel(java.util.Collection)">minParallel</a></strong>(java.util.Collection&lt;T&gt;&nbsp;collection)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its min() method using the default comparator.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#minParallel(java.util.Collection, groovy.lang.Closure)">minParallel</a></strong>(java.util.Collection&lt;T&gt;&nbsp;collection,
           groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its min() method using the supplied
 closure as the comparator.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#minParallel(java.lang.Object)">minParallel</a></strong>(java.lang.Object&nbsp;collection)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its min() method using the default comparator.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#minParallel(java.lang.Object, groovy.lang.Closure)">minParallel</a></strong>(java.lang.Object&nbsp;collection,
           groovy.lang.Closure&nbsp;cl)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its min() method using the supplied
 closure as the comparator.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private static jsr166y.ForkJoinPool</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#retrievePool()">retrievePool</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.Collection&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#splitParallel(java.util.Collection, java.lang.Object)">splitParallel</a></strong>(java.util.Collection&lt;T&gt;&nbsp;collection,
             java.lang.Object&nbsp;filter)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 rule as the filter predicate.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#splitParallel(java.lang.Object, java.lang.Object)">splitParallel</a></strong>(java.lang.Object&nbsp;collection,
             java.lang.Object&nbsp;filter)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 rule as the filter predicate.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#sumParallel(java.util.Collection)">sumParallel</a></strong>(java.util.Collection&lt;T&gt;&nbsp;collection)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and summarizes its elements using the foldParallel()
 method with the + operator and the reduction operation.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../groovyx/gpars/GParsPoolUtil.html#sumParallel(java.lang.Object)">sumParallel</a></strong>(java.lang.Object&nbsp;collection)</code>
<div class="block">Creates a Parallel Array out of the supplied collection/object and summarizes its elements using the foldParallel()
 method with the + operator and the reduction operation.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="timer">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>timer</h4>
<pre>private static final&nbsp;<a href="../../groovyx/gpars/util/GeneralTimer.html" title="interface in groovyx.gpars.util">GeneralTimer</a> timer</pre>
<div class="block">Allows timeouts for async operations</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="GParsPoolUtil()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>GParsPoolUtil</h4>
<pre>public&nbsp;GParsPoolUtil()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="retrievePool()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>retrievePool</h4>
<pre>private static&nbsp;jsr166y.ForkJoinPool&nbsp;retrievePool()</pre>
</li>
</ul>
<a name="callParallel(groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>callParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;java.util.concurrent.Future&lt;T&gt;&nbsp;callParallel(groovy.lang.Closure&lt;T&gt;&nbsp;task)</pre>
<div class="block">schedules the supplied closure for processing in the underlying thread pool.</div>
</li>
</ul>
<a name="callAsync(groovy.lang.Closure, java.lang.Object...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>callAsync</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;java.util.concurrent.Future&lt;T&gt;&nbsp;callAsync(groovy.lang.Closure&lt;T&gt;&nbsp;cl,
                                           java.lang.Object...&nbsp;args)</pre>
<div class="block">Calls a closure in a separate thread supplying the given arguments, returning a future for the potential return value.</div>
</li>
</ul>
<a name="callTimeoutAsync(groovy.lang.Closure, long, java.lang.Object...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>callTimeoutAsync</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;java.util.concurrent.Future&lt;T&gt;&nbsp;callTimeoutAsync(groovy.lang.Closure&lt;T&gt;&nbsp;cl,
                                                  long&nbsp;timeout,
                                                  java.lang.Object...&nbsp;args)</pre>
<div class="block">Calls a closure in a separate thread supplying the given arguments, returning a future for the potential return value.
 Also allows the asynchronous calculation to be cancelled after a given timeout.
 In order to allow cancellation, the asynchronously running code must keep checking the _interrupted_ flag of its
 own thread and cease the calculation once the flag is set to true.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>timeout</code> - The timeout in milliseconds to wait before the calculation gets cancelled.</dd></dl>
</li>
</ul>
<a name="callTimeoutAsync(groovy.lang.Closure, groovy.time.Duration, java.lang.Object...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>callTimeoutAsync</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;java.util.concurrent.Future&lt;T&gt;&nbsp;callTimeoutAsync(groovy.lang.Closure&lt;T&gt;&nbsp;cl,
                                                  groovy.time.Duration&nbsp;timeout,
                                                  java.lang.Object...&nbsp;args)</pre>
<div class="block">Calls a closure in a separate thread supplying the given arguments, returning a future for the potential return value.
 Also allows the asynchronous calculation to be cancelled after a given timeout.
 In order to allow cancellation, the asynchronously running code must keep checking the _interrupted_ flag of its
 own thread and cease the calculation once the flag is set to true.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>timeout</code> - The timeout to wait before the calculation gets cancelled.</dd></dl>
</li>
</ul>
<a name="leftShift(jsr166y.ForkJoinPool, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>leftShift</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;java.util.concurrent.Future&lt;T&gt;&nbsp;leftShift(jsr166y.ForkJoinPool&nbsp;pool,
                                           groovy.lang.Closure&lt;T&gt;&nbsp;task)</pre>
<div class="block">Submits the task for asynchronous processing returning the Future received from the executor service.
 Allows for the following syntax:
 <pre>
 executorService &lt;&lt; {println 'Inside parallel task'}
 </pre></div>
</li>
</ul>
<a name="async(groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>async</h4>
<pre>public static&nbsp;groovy.lang.Closure&nbsp;async(groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates an asynchronous variant of the supplied closure, which, when invoked returns a future for the potential return value</div>
</li>
</ul>
<a name="asyncFun(groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asyncFun</h4>
<pre>public static&nbsp;groovy.lang.Closure&nbsp;asyncFun(groovy.lang.Closure&nbsp;original)</pre>
<div class="block">Creates an asynchronous and composable variant of the supplied closure, which, when invoked returns a DataflowVariable for the potential return value</div>
</li>
</ul>
<a name="asyncFun(groovy.lang.Closure, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asyncFun</h4>
<pre>public static&nbsp;groovy.lang.Closure&nbsp;asyncFun(groovy.lang.Closure&nbsp;original,
                           boolean&nbsp;blocking)</pre>
<div class="block">Creates an asynchronous and composable variant of the supplied closure, which, when invoked returns a DataflowVariable for the potential return value</div>
</li>
</ul>
<a name="asyncFun(groovy.lang.Closure, groovyx.gpars.scheduler.FJPool)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asyncFun</h4>
<pre>public static&nbsp;groovy.lang.Closure&nbsp;asyncFun(groovy.lang.Closure&nbsp;original,
                           <a href="../../groovyx/gpars/scheduler/FJPool.html" title="class in groovyx.gpars.scheduler">FJPool</a>&nbsp;pool)</pre>
<div class="block">Creates an asynchronous and composable variant of the supplied closure, which, when invoked returns a DataflowVariable for the potential return value</div>
</li>
</ul>
<a name="asyncFun(groovy.lang.Closure, groovyx.gpars.scheduler.FJPool, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asyncFun</h4>
<pre>public static&nbsp;groovy.lang.Closure&nbsp;asyncFun(groovy.lang.Closure&nbsp;original,
                           <a href="../../groovyx/gpars/scheduler/FJPool.html" title="class in groovyx.gpars.scheduler">FJPool</a>&nbsp;pool,
                           boolean&nbsp;blocking)</pre>
<div class="block">Creates an asynchronous and composable variant of the supplied closure, which, when invoked returns a DataflowVariable for the potential return value</div>
</li>
</ul>
<a name="gmemoize(groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>gmemoize</h4>
<pre>@Deprecated
public static&nbsp;&lt;T&gt;&nbsp;groovy.lang.Closure&lt;T&gt;&nbsp;gmemoize(groovy.lang.Closure&lt;T&gt;&nbsp;cl)</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;</div>
<div class="block">Creates a caching variant of the supplied closure.
 Whenever the closure is called, the mapping between the parameters and the return value is preserved in cache
 making subsequent calls with the same arguments fast.
 This variant will keep all values forever, i.e. till the closure gets garbage-collected.
 The returned function can be safely used concurrently from multiple threads, however, the implementation
 values high average-scenario performance and so concurrent calls on the memoized function with identical argument values
 may not necessarily be able to benefit from each other's cached return value. With this having been mentioned,
 the performance trade-off still makes concurrent use of memoized functions safe and highly recommended.
 <p>
 The cache gets garbage-collected together with the memoized closure.
 </p></div>
<dl><dt><span class="strong">Returns:</span></dt><dd>A new function forwarding to the original one while caching the results</dd></dl>
</li>
</ul>
<a name="gmemoizeAtMost(groovy.lang.Closure, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>gmemoizeAtMost</h4>
<pre>@Deprecated
public static&nbsp;&lt;T&gt;&nbsp;groovy.lang.Closure&lt;T&gt;&nbsp;gmemoizeAtMost(groovy.lang.Closure&lt;T&gt;&nbsp;cl,
                                                   int&nbsp;maxCacheSize)</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;</div>
<div class="block">Creates a caching variant of the supplied closure with upper limit on the cache size.
 Whenever the closure is called, the mapping between the parameters and the return value is preserved in cache
 making subsequent calls with the same arguments fast.
 This variant will keep all values until the upper size limit is reached. Then the values in the cache start rotating
 using the LRU (Last Recently Used) strategy.
 The returned function can be safely used concurrently from multiple threads, however, the implementation
 values high average-scenario performance and so concurrent calls on the memoized function with identical argument values
 may not necessarily be able to benefit from each other's cached return value. With this having been mentioned,
 the performance trade-off still makes concurrent use of memoized functions safe and highly recommended.
 <p>
 The cache gets garbage-collected together with the memoized closure.
 </p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>maxCacheSize</code> - The maximum size the cache can grow to</dd>
<dt><span class="strong">Returns:</span></dt><dd>A new function forwarding to the original one while caching the results</dd></dl>
</li>
</ul>
<a name="gmemoizeAtLeast(groovy.lang.Closure, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>gmemoizeAtLeast</h4>
<pre>@Deprecated
public static&nbsp;&lt;T&gt;&nbsp;groovy.lang.Closure&lt;T&gt;&nbsp;gmemoizeAtLeast(groovy.lang.Closure&lt;T&gt;&nbsp;cl,
                                                    int&nbsp;protectedCacheSize)</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;</div>
<div class="block">Creates a caching variant of the supplied closure with automatic cache size adjustment and lower limit
 on the cache size.
 Whenever the closure is called, the mapping between the parameters and the return value is preserved in cache
 making subsequent calls with the same arguments fast.
 This variant allows the garbage collector to release entries from the cache and at the same time allows
 the user to specify how many entries should be protected from the eventual gc-initiated eviction.
 Cached entries exceeding the specified preservation threshold are made available for eviction based on
 the LRU (Last Recently Used) strategy.
 Given the non-deterministic nature of garbage collector, the actual cache size may grow well beyond the limits
 set by the user if memory is plentiful.
 The returned function can be safely used concurrently from multiple threads, however, the implementation
 values high average-scenario performance and so concurrent calls on the memoized function with identical argument values
 may not necessarily be able to benefit from each other's cached return value. Also the protectedCacheSize parameter
 might not be respected accurately in such scenarios for some periods of time. With this having been mentioned,
 the performance trade-off still makes concurrent use of memoized functions safe and highly recommended.
 <p>
 The cache gets garbage-collected together with the memoized closure.
 </p></div>
</li>
</ul>
<a name="gmemoizeBetween(groovy.lang.Closure, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>gmemoizeBetween</h4>
<pre>@Deprecated
public static&nbsp;&lt;T&gt;&nbsp;groovy.lang.Closure&lt;T&gt;&nbsp;gmemoizeBetween(groovy.lang.Closure&lt;T&gt;&nbsp;cl,
                                                    int&nbsp;protectedCacheSize,
                                                    int&nbsp;maxCacheSize)</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;</div>
<div class="block">Creates a caching variant of the supplied closure with automatic cache size adjustment and lower and upper limits
 on the cache size.
 Whenever the closure is called, the mapping between the parameters and the return value is preserved in cache
 making subsequent calls with the same arguments fast.
 This variant allows the garbage collector to release entries from the cache and at the same time allows
 the user to specify how many entries should be protected from the eventual gc-initiated eviction.
 Cached entries exceeding the specified preservation threshold are made available for eviction based on
 the LRU (Last Recently Used) strategy.
 Given the non-deterministic nature of garbage collector, the actual cache size may grow well beyond the protected
 size limits set by the user, if memory is plentiful.
 Also, this variant will never exceed in size the upper size limit. Once the upper size limit has been reached,
 the values in the cache start rotating using the LRU (Last Recently Used) strategy.
 The returned function can be safely used concurrently from multiple threads, however, the implementation
 values high average-scenario performance and so concurrent calls on the memoized function with identical argument values
 may not necessarily be able to benefit from each other's cached return value. Also the protectedCacheSize parameter
 might not be respected accurately in such scenarios for some periods of time. With this having been mentioned,
 the performance trade-off still makes concurrent use of memoized functions safe and highly recommended.
 <p>
 The cache gets garbage-collected together with the memoized closure.
 </p></div>
</li>
</ul>
<a name="createPA(java.util.Map, jsr166y.ForkJoinPool)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createPA</h4>
<pre>private static&nbsp;&lt;K,V&gt;&nbsp;<a href="../../groovyx/gpars/extra166y/ParallelArray.html" title="class in groovyx.gpars.extra166y">ParallelArray</a>&lt;java.util.Map.Entry&lt;K,V&gt;&gt;&nbsp;createPA(java.util.Map&lt;K,V&gt;&nbsp;collection,
                                                     jsr166y.ForkJoinPool&nbsp;pool)</pre>
</li>
</ul>
<a name="makeConcurrent(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeConcurrent</h4>
<pre>public static&nbsp;java.lang.Object&nbsp;makeConcurrent(java.lang.Object&nbsp;collection)</pre>
<div class="block">Overrides the iterative methods like each(), collect() and such, so that they call their parallel variants from the GParsPoolUtil class
 like eachParallel(), collectParallel() and such.
 The first time it is invoked on a collection the method creates a TransparentParallel class instance and mixes it
 in the object it is invoked on. After mixing-in, the isConcurrent() method will return true.
 Delegates to GParsPoolUtil.makeConcurrent().</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>collection</code> - The object to make transparent</dd>
<dt><span class="strong">Returns:</span></dt><dd>The instance of the TransparentParallel class wrapping the original object and overriding the iterative methods with new parallel behavior</dd></dl>
</li>
</ul>
<a name="makeSequential(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeSequential</h4>
<pre>public static&nbsp;java.lang.Object&nbsp;makeSequential(java.lang.Object&nbsp;collection)</pre>
<div class="block">Gives the iterative methods like each() or find() the original sequential semantics.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>collection</code> - The collection to apply the change to</dd>
<dt><span class="strong">Returns:</span></dt><dd>The collection itself</dd></dl>
</li>
</ul>
<a name="asConcurrent(java.lang.Object, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asConcurrent</h4>
<pre>public static&nbsp;void&nbsp;asConcurrent(java.lang.Object&nbsp;collection,
                groovy.lang.Closure&nbsp;code)</pre>
<div class="block">Makes the collection concurrent for the passed-in block of code.
 The iterative methods like each or collect are given concurrent semantics inside the passed-in closure.
 Once the closure finishes, the original sequential semantics of the methods is restored.
 Must be invoked inside a withPool block.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>collection</code> - The collection to enhance</dd><dd><code>code</code> - The closure to run with the collection enhanced.</dd></dl>
</li>
</ul>
<a name="isConcurrent(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isConcurrent</h4>
<pre>public static&nbsp;boolean&nbsp;isConcurrent(java.lang.Object&nbsp;collection)</pre>
<div class="block">Indicates whether the iterative methods like each() or collect() work have been altered to work concurrently.</div>
</li>
</ul>
<a name="eachParallel(java.util.Collection, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>eachParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;java.util.Collection&lt;T&gt;&nbsp;eachParallel(java.util.Collection&lt;T&gt;&nbsp;collection,
                                       groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 closure as the transformation operation.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>eachParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = new ConcurrentSkipListSet()
     [1, 2, 3, 4, 5].eachParallel {Number number -&gt; result.add(number * 10)}
     assertEquals(new HashSet([10, 20, 30, 40, 50]), result)
 }
 </pre>
 <p>
 Note that the <code>result</code> variable is synchronized to prevent race conditions between multiple threads.
 </p></div>
</li>
</ul>
<a name="eachParallel(java.lang.Object,groovy.lang.Closure)">
<!--   -->
</a><a name="eachParallel(T, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>eachParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;eachParallel(T&nbsp;collection,
                 groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 closure as the transformation operation.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>eachParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = new ConcurrentSkipListSet()
     [1, 2, 3, 4, 5].eachParallel {Number number -&gt; result.add(number * 10)}
     assertEquals(new HashSet([10, 20, 30, 40, 50]), result)
 }
 </pre>
 <p>
 Note that the <code>result</code> variable is synchronized to prevent race conditions between multiple threads.
 </p></div>
</li>
</ul>
<a name="eachParallel(java.util.Map, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>eachParallel</h4>
<pre>public static&nbsp;&lt;K,V&gt;&nbsp;java.util.Map&lt;K,V&gt;&nbsp;eachParallel(java.util.Map&lt;K,V&gt;&nbsp;collection,
                                    groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied map and invokes the withMapping() method using the supplied
 closure as the transformation operation.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>eachParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = new ConcurrentSkipListSet()
     [1, 2, 3, 4, 5].eachParallel {Number number -&gt; result.add(number * 10)}
     assertEquals(new HashSet([10, 20, 30, 40, 50]), result)
 }
 </pre>
 <p>
 Note that the <code>result</code> variable is synchronized to prevent race conditions between multiple threads.
 </p></div>
</li>
</ul>
<a name="eachWithIndexParallel(java.util.Collection, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>eachWithIndexParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;java.util.Collection&lt;T&gt;&nbsp;eachWithIndexParallel(java.util.Collection&lt;T&gt;&nbsp;collection,
                                                groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 closure as the transformation operation.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>eachWithIndexParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = new ConcurrentSkipListSet()
     [1, 2, 3, 4, 5].eachWithIndexParallel {Number number, int index -&gt; result.add(number * 10)}
     assertEquals(new HashSet([10, 20, 30, 40, 50]), result)
 }
 </pre>
 <p>
 Note that the <code>result</code> variable is synchronized to prevent race conditions between multiple threads.
 </p></div>
</li>
</ul>
<a name="eachWithIndexParallel(java.lang.Object,groovy.lang.Closure)">
<!--   -->
</a><a name="eachWithIndexParallel(T, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>eachWithIndexParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;eachWithIndexParallel(T&nbsp;collection,
                          groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 closure as the transformation operation.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>eachWithIndexParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = new ConcurrentSkipListSet()
     [1, 2, 3, 4, 5].eachWithIndexParallel {Number number, int index -&gt; result.add(number * 10)}
     assertEquals(new HashSet([10, 20, 30, 40, 50]), result)
 }
 </pre>
 <p>
 Note that the <code>result</code> variable is synchronized to prevent race conditions between multiple threads.
 </p></div>
</li>
</ul>
<a name="eachWithIndexParallel(java.util.Map, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>eachWithIndexParallel</h4>
<pre>public static&nbsp;&lt;K,V&gt;&nbsp;java.util.Map&lt;K,V&gt;&nbsp;eachWithIndexParallel(java.util.Map&lt;K,V&gt;&nbsp;collection,
                                             groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Does parallel eachWithIndex on maps</div>
</li>
</ul>
<a name="collectParallel(java.util.Collection, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;java.util.Collection&lt;T&gt;&nbsp;collectParallel(java.util.Collection&nbsp;collection,
                                          groovy.lang.Closure&lt;? extends T&gt;&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 closure as the transformation operation.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a collection of values from the resulting Parallel Array.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>collectParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = [1, 2, 3, 4, 5].collectParallel {Number number -&gt; number * 10}
     assertEquals(new HashSet([10, 20, 30, 40, 50]), result)
 }
 </pre></div>
</li>
</ul>
<a name="collectParallel(java.lang.Object, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;java.util.Collection&lt;T&gt;&nbsp;collectParallel(java.lang.Object&nbsp;collection,
                                          groovy.lang.Closure&lt;? extends T&gt;&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 closure as the transformation operation.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a collection of values from the resulting Parallel Array.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>collectParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = [1, 2, 3, 4, 5].collectParallel {Number number -&gt; number * 10}
     assertEquals(new HashSet([10, 20, 30, 40, 50]), result)
 }
 </pre></div>
</li>
</ul>
<a name="collectParallel(java.util.Map, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;java.util.Collection&lt;T&gt;&nbsp;collectParallel(java.util.Map&nbsp;collection,
                                          groovy.lang.Closure&lt;? extends T&gt;&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied map and invokes the withMapping() method using the supplied
 closure as the transformation operation.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a collection of values from the resulting Parallel Array.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>collectParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = [1, 2, 3, 4, 5].collectParallel {Number number -&gt; number * 10}
     assertEquals(new HashSet([10, 20, 30, 40, 50]), result)
 }
 </pre></div>
</li>
</ul>
<a name="collectManyParallel(java.util.Collection, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectManyParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;java.util.List&lt;T&gt;&nbsp;collectManyParallel(java.util.Collection&nbsp;collection,
                                        groovy.lang.Closure&lt;java.util.Collection&lt;? extends T&gt;&gt;&nbsp;projection)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 <code>projection</code> closure as the transformation operation. The <code>projection</code> closure should return a
 (possibly empty) collection of items which are subsequently flattened to produce a new collection.
 The <code>projection</code> closure will be effectively invoked concurrently on the elements of the original collection.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>collectManyParallel(Closure projection)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def squaresAndCubesOfOdds = [1, 2, 3, 4, 5].collectManyParallel { Number number -&gt;
         number % 2 ? [number ** 2, number ** 3] : []
     }
     assert squaresAndCubesOfOdds == [1, 1, 9, 27, 25, 125]
 }
 </pre></div>
</li>
</ul>
<a name="collectManyParallel(java.lang.Object, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectManyParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;java.util.List&lt;T&gt;&nbsp;collectManyParallel(java.lang.Object&nbsp;collection,
                                        groovy.lang.Closure&lt;java.util.Collection&lt;? extends T&gt;&gt;&nbsp;projection)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 <code>projection</code> closure as the transformation operation. The <code>projection</code> closure should return a
 (possibly empty) collection of items which are subsequently flattened to produce a new collection.
 The <code>projection</code> closure will be effectively invoked concurrently on the elements of the original collection.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>collectManyParallel(Closure projection)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def squaresAndCubesOfOdds = [1, 2, 3, 4, 5].collectManyParallel { Number number -&gt;
         number % 2 ? [number ** 2, number ** 3] : []
     }
     assert squaresAndCubesOfOdds == [1, 1, 9, 27, 25, 125]
 }
 </pre></div>
</li>
</ul>
<a name="collectManyParallel(java.util.Map, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectManyParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;java.util.List&lt;T&gt;&nbsp;collectManyParallel(java.util.Map&nbsp;collection,
                                        groovy.lang.Closure&lt;java.util.Collection&lt;? extends T&gt;&gt;&nbsp;projection)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 <code>projection</code> closure as the transformation operation. The <code>projection</code> closure should return a
 (possibly empty) collection of items which are subsequently flattened to produce a new collection.
 The <code>projection</code> closure will be effectively invoked concurrently on the elements of the original collection.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>collectManyParallel(Closure projection)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def squaresAndCubesOfOdds = [1, 2, 3, 4, 5].collectManyParallel { Number number -&gt;
         number % 2 ? [number ** 2, number ** 3] : []
     }
     assert squaresAndCubesOfOdds == [1, 1, 9, 27, 25, 125]
 }
 </pre></div>
</li>
</ul>
<a name="findAllParallel(java.util.Collection, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findAllParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;java.util.Collection&lt;T&gt;&nbsp;findAllParallel(java.util.Collection&lt;T&gt;&nbsp;collection,
                                          groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 closure as the filter predicate.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a collection of values from the resulting Parallel Array.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>findAllParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = [1, 2, 3, 4, 5].findAllParallel {Number number -&gt; number &gt; 3}
     assertEquals(new HashSet([4, 5]), result)
 }
 </pre></div>
</li>
</ul>
<a name="findAllParallel(java.lang.Object, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findAllParallel</h4>
<pre>public static&nbsp;java.util.Collection&lt;java.lang.Object&gt;&nbsp;findAllParallel(java.lang.Object&nbsp;collection,
                                                     groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 closure as the filter predicate.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a collection of values from the resulting Parallel Array.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>findAllParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = [1, 2, 3, 4, 5].findAllParallel {Number number -&gt; number &gt; 3}
     assertEquals(new HashSet([4, 5]), result)
 }
 </pre></div>
</li>
</ul>
<a name="findAllParallel(java.util.Map, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findAllParallel</h4>
<pre>public static&nbsp;&lt;K,V&gt;&nbsp;java.util.Map&lt;K,V&gt;&nbsp;findAllParallel(java.util.Map&lt;K,V&gt;&nbsp;collection,
                                       groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied map and invokes the withFilter() method using the supplied
 closure as the filter predicate.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a collection of values from the resulting Parallel Array.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>findAllParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <code>
 GParsPool.withPool {
 def result = [1, 2, 3, 4, 5].findAllParallel {Number number -&gt; number &gt; 3}
 assertEquals(new HashSet([4, 5]), result)
 }
 </code></div>
</li>
</ul>
<a name="findParallel(java.util.Collection, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;findParallel(java.util.Collection&lt;T&gt;&nbsp;collection,
                 groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 closure as the filter predicate.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a value from the resulting Parallel Array with the minimum index.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>findParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = [1, 2, 3, 4, 5].findParallel {Number number -&gt; number &gt; 3}
     assert (result in [4, 5])
 }
 </pre></div>
</li>
</ul>
<a name="findParallel(java.lang.Object, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findParallel</h4>
<pre>public static&nbsp;java.lang.Object&nbsp;findParallel(java.lang.Object&nbsp;collection,
                            groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 closure as the filter predicate.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a value from the resulting Parallel Array with the minimum index.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>findParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = [1, 2, 3, 4, 5].findParallel {Number number -&gt; number &gt; 3}
     assert (result in [4, 5])
 }
 </pre></div>
</li>
</ul>
<a name="findParallel(java.util.Map, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findParallel</h4>
<pre>public static&nbsp;&lt;K,V&gt;&nbsp;java.util.Map.Entry&lt;K,V&gt;&nbsp;findParallel(java.util.Map&lt;K,V&gt;&nbsp;collection,
                                          groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied map and invokes the withFilter() method using the supplied
 closure as the filter predicate.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a value from the resulting Parallel Array with the minimum index.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>findParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = [1, 2, 3, 4, 5].findParallel {Number number -&gt; number &gt; 3}
     assert (result in [4, 5])
 }
 </pre></div>
</li>
</ul>
<a name="findAnyParallel(java.util.Collection, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findAnyParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;findAnyParallel(java.util.Collection&lt;T&gt;&nbsp;collection,
                    groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 closure as the filter predicate.
 Unlike with the <code>find</code> method, findAnyParallel() does not guarantee
 that the a matching element with the lowest index is returned.
 The findAnyParallel() method evaluates elements lazily and stops processing further elements of the collection once a match has been found.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a random value from the resulting Parallel Array.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>findParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = [1, 2, 3, 4, 5].findParallel {Number number -&gt; number &gt; 3}
     assert (result in [4, 5])
 }
 </pre></div>
</li>
</ul>
<a name="findAnyParallel(java.lang.Object, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findAnyParallel</h4>
<pre>public static&nbsp;java.lang.Object&nbsp;findAnyParallel(java.lang.Object&nbsp;collection,
                               groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 closure as the filter predicate.
 Unlike with the <code>find</code> method, findAnyParallel() does not guarantee
 that the a matching element with the lowest index is returned.
 The findAnyParallel() method evaluates elements lazily and stops processing further elements of the collection once a match has been found.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a random value from the resulting Parallel Array.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>findParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = [1, 2, 3, 4, 5].findAnyParallel {Number number -&gt; number &gt; 3}
     assert (result in [4, 5])
 }
 </pre></div>
</li>
</ul>
<a name="findAnyParallel(java.util.Map, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findAnyParallel</h4>
<pre>public static&nbsp;&lt;K,V&gt;&nbsp;java.util.Map.Entry&lt;K,V&gt;&nbsp;findAnyParallel(java.util.Map&lt;K,V&gt;&nbsp;collection,
                                             groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied map and invokes the withFilter() method using the supplied
 closure as the filter predicate.
 Unlike with the <code>find</code> method, findAnyParallel() does not guarantee
 that the matching element with the lowest index is returned.
 The findAnyParallel() method evaluates elements lazily and stops processing further elements of the collection once a match has been found.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a random value from the resulting Parallel Array.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>findParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = [1, 2, 3, 4, 5].findAnyParallel {Number number -&gt; number &gt; 3}
     assert (result in [4, 5])
 }
 </pre></div>
</li>
</ul>
<a name="grepParallel(java.util.Collection, java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>grepParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;java.util.Collection&lt;T&gt;&nbsp;grepParallel(java.util.Collection&lt;T&gt;&nbsp;collection,
                                       java.lang.Object&nbsp;filter)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 rule as the filter predicate.
 The filter will be effectively used concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a collection of values from the resulting Parallel Array.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>grepParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = [1, 2, 3, 4, 5].grepParallel(4..6)
     assertEquals(new HashSet([4, 5]), result)
 }
 </pre></div>
</li>
</ul>
<a name="grepParallel(java.lang.Object, java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>grepParallel</h4>
<pre>public static&nbsp;java.lang.Object&nbsp;grepParallel(java.lang.Object&nbsp;collection,
                            java.lang.Object&nbsp;filter)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 rule as the filter predicate.
 The filter will be effectively used concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a collection of values from the resulting Parallel Array.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>grepParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = [1, 2, 3, 4, 5].grepParallel(4..6)
     assertEquals(new HashSet([4, 5]), result)
 }
 </pre></div>
</li>
</ul>
<a name="grepParallel(java.util.Map, java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>grepParallel</h4>
<pre>public static&nbsp;&lt;K,V&gt;&nbsp;java.util.Map&lt;K,V&gt;&nbsp;grepParallel(java.util.Map&lt;K,V&gt;&nbsp;collection,
                                    java.lang.Object&nbsp;filter)</pre>
<div class="block">Creates a Parallel Array out of the supplied map and invokes the withFilter() method using the supplied
 rule as the filter predicate.
 The filter will be effectively used concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a collection of values from the resulting Parallel Array.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>grepParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = [1, 2, 3, 4, 5].grepParallel(4..6)
     assertEquals(new HashSet([4, 5]), result)
 }
 </pre></div>
</li>
</ul>
<a name="splitParallel(java.util.Collection, java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>splitParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;java.util.Collection&lt;T&gt;&nbsp;splitParallel(java.util.Collection&lt;T&gt;&nbsp;collection,
                                        java.lang.Object&nbsp;filter)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 rule as the filter predicate.
 The filter will be effectively used concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a collection of values from the resulting Parallel Array.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>grepParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.</div>
</li>
</ul>
<a name="splitParallel(java.lang.Object, java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>splitParallel</h4>
<pre>public static&nbsp;java.lang.Object&nbsp;splitParallel(java.lang.Object&nbsp;collection,
                             java.lang.Object&nbsp;filter)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 rule as the filter predicate.
 The filter will be effectively used concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a collection of values from the resulting Parallel Array.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>grepParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = [1, 2, 3, 4, 5].splitParallel(4..6)
     assert [3, 4, 5] as Set == result[0] as Set
     assert [1, 2] as Set == result[1] as Set
 }
 </pre></div>
</li>
</ul>
<a name="countParallel(java.util.Collection, java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countParallel</h4>
<pre>public static&nbsp;int&nbsp;countParallel(java.util.Collection&nbsp;collection,
                java.lang.Object&nbsp;filter)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 rule as the filter predicate.
 The filter will be effectively used concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a collection of values from the resulting Parallel Array.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>grepParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = [1, 2, 3, 4, 5].countParallel(4)
     assertEquals(1, result)
 }
 </pre></div>
</li>
</ul>
<a name="countParallel(java.lang.Object, java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countParallel</h4>
<pre>public static&nbsp;int&nbsp;countParallel(java.lang.Object&nbsp;collection,
                java.lang.Object&nbsp;filter)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 rule as the filter predicate.
 The filter will be effectively used concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a collection of values from the resulting Parallel Array.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>grepParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def result = [1, 2, 3, 4, 5].countParallel(4)
     assertEquals(1, result)
 }
 </pre></div>
</li>
</ul>
<a name="countParallel(java.util.Collection, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countParallel</h4>
<pre>public static&nbsp;int&nbsp;countParallel(java.util.Collection&nbsp;collection,
                groovy.lang.Closure&nbsp;filter)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 rule as the filter predicate.
 The filter will be effectively used concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a collection of values from the resulting Parallel Array.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>grepParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def isOdd = { it % 2 }
     def result = [1, 2, 3, 4, 5].countParallel(isOdd)
     assert result == 3
 }
 </pre></div>
</li>
</ul>
<a name="countParallel(java.lang.Object, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countParallel</h4>
<pre>public static&nbsp;int&nbsp;countParallel(java.lang.Object&nbsp;collection,
                groovy.lang.Closure&nbsp;filter)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 rule as the filter predicate.
 The filter will be effectively used concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a collection of values from the resulting Parallel Array.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>grepParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     def isEven = { it % 2 == 0 }
     def result = [1, 2, 3, 4, 5].countParallel(isEven)
     assert result == 2
 }
 </pre></div>
</li>
</ul>
<a name="anyParallel(java.util.Collection, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>anyParallel</h4>
<pre>public static&nbsp;boolean&nbsp;anyParallel(java.util.Collection&nbsp;collection,
                  groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 closure as the filter predicate.
 The closure will be effectively invoked concurrently on the elements of the collection.
 The anyParallel() method is lazy and once a positive answer has been given by at least one element, it avoids running
 the supplied closure on subsequent elements.
 After all the elements have been processed, the method returns a boolean value indicating, whether at least
 one element of the collection meets the predicate.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>anyParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     assert [1, 2, 3, 4, 5].anyParallel {Number number -&gt; number &gt; 3}
     assert ![1, 2, 3].anyParallel {Number number -&gt; number &gt; 3}
 }
 </pre></div>
</li>
</ul>
<a name="anyParallel(java.lang.Object, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>anyParallel</h4>
<pre>public static&nbsp;boolean&nbsp;anyParallel(java.lang.Object&nbsp;collection,
                  groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 closure as the filter predicate.
 The closure will be effectively invoked concurrently on the elements of the collection.
 The anyParallel() method is lazy and once a positive answer has been given by at least one element, it avoids running
 the supplied closure on subsequent elements.
 After all the elements have been processed, the method returns a boolean value indicating, whether at least
 one element of the collection meets the predicate.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>anyParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     assert [1, 2, 3, 4, 5].anyParallel {Number number -&gt; number &gt; 3}
     assert ![1, 2, 3].anyParallel {Number number -&gt; number &gt; 3}
 }
 </pre></div>
</li>
</ul>
<a name="anyParallel(java.util.Map, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>anyParallel</h4>
<pre>public static&nbsp;boolean&nbsp;anyParallel(java.util.Map&nbsp;collection,
                  groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied map and invokes the withFilter() method using the supplied
 closure as the filter predicate.
 The closure will be effectively invoked concurrently on the elements of the collection.
 The anyParallel() method is lazy and once a positive answer has been given by at least one element, it avoids running
 the supplied closure on subsequent elements.
 After all the elements have been processed, the method returns a boolean value indicating, whether at least
 one element of the collection meets the predicate.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>anyParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     assert [1, 2, 3, 4, 5].anyParallel {Number number -&gt; number &gt; 3}
     assert ![1, 2, 3].anyParallel {Number number -&gt; number &gt; 3}
 }
 </pre></div>
</li>
</ul>
<a name="everyParallel(java.util.Collection, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>everyParallel</h4>
<pre>public static&nbsp;boolean&nbsp;everyParallel(java.util.Collection&nbsp;collection,
                    groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 closure as the filter predicate.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a boolean value indicating, whether all the elements
 of the collection meet the predicate.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>everyParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool(5) {
     assert ![1, 2, 3, 4, 5].everyParallel {Number number -&gt; number &gt; 3}
     assert [1, 2, 3].everyParallel() {Number number -&gt; number &lt;= 3}
 }
 </pre></div>
</li>
</ul>
<a name="everyParallel(java.lang.Object, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>everyParallel</h4>
<pre>public static&nbsp;boolean&nbsp;everyParallel(java.lang.Object&nbsp;collection,
                    groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withFilter() method using the supplied
 closure as the filter predicate.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a boolean value indicating, whether all the elements
 of the collection meet the predicate.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>everyParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool(5) {
     assert ![1, 2, 3, 4, 5].everyParallel {Number number -&gt; number &gt; 3}
     assert [1, 2, 3].everyParallel() {Number number -&gt; number &lt;= 3}
 }
 </pre></div>
</li>
</ul>
<a name="everyParallel(java.util.Map, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>everyParallel</h4>
<pre>public static&nbsp;boolean&nbsp;everyParallel(java.util.Map&nbsp;collection,
                    groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied map and invokes the withFilter() method using the supplied
 closure as the filter predicate.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a boolean value indicating, whether all the elements
 of the collection meet the predicate.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>everyParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool(5) {
     assert ![1, 2, 3, 4, 5].everyParallel {Number number -&gt; number &gt; 3}
     assert [1, 2, 3].everyParallel() {Number number -&gt; number &lt;= 3}
 }
 </pre></div>
</li>
</ul>
<a name="groupByParallel(java.util.Collection, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupByParallel</h4>
<pre>public static&nbsp;&lt;K,T&gt;&nbsp;java.util.Map&lt;K,java.util.List&lt;T&gt;&gt;&nbsp;groupByParallel(java.util.Collection&lt;T&gt;&nbsp;collection,
                                                       groovy.lang.Closure&lt;K&gt;&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 closure as the mapping predicate.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a map of groups of the original elements.
 Elements in the same group gave identical results when the supplied closure was invoked on them.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>groupByParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     assert ([1, 2, 3, 4, 5].groupByParallel {Number number -&gt; number % 2}).size() == 2
 }
 </pre></div>
</li>
</ul>
<a name="groupByParallel(java.lang.Object, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupByParallel</h4>
<pre>public static&nbsp;&lt;K&gt;&nbsp;java.util.Map&lt;K,java.util.List&lt;java.lang.Object&gt;&gt;&nbsp;groupByParallel(java.lang.Object&nbsp;collection,
                                                                    groovy.lang.Closure&lt;K&gt;&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes the withMapping() method using the supplied
 closure as the mapping predicate.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns a map of groups of the original elements.
 Elements in the same group gave identical results when the supplied closure was invoked on them.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>groupByParallel(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 Example:
 <pre>
 GParsPool.withPool {
     assert ([1, 2, 3, 4, 5].groupByParallel {Number number -&gt; number % 2}).size() == 2
 }
 </pre></div>
</li>
</ul>
<a name="groupByParallelPA(groovyx.gpars.extra166y.ParallelArray, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupByParallelPA</h4>
<pre>private static&nbsp;&lt;K,T&gt;&nbsp;java.util.Map&lt;K,java.util.List&lt;T&gt;&gt;&nbsp;groupByParallelPA(<a href="../../groovyx/gpars/extra166y/ParallelArray.html" title="class in groovyx.gpars.extra166y">ParallelArray</a>&lt;T&gt;&nbsp;pa,
                                                         groovy.lang.Closure&lt;K&gt;&nbsp;cl)</pre>
</li>
</ul>
<a name="minParallel(java.util.Collection, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>minParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;minParallel(java.util.Collection&lt;T&gt;&nbsp;collection,
                groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its min() method using the supplied
 closure as the comparator.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns the minimum of the elements in the collection.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>min(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 If the supplied closure takes two arguments it is used directly as a comparator.
 If the supplied closure takes one argument, the values returned by the supplied closure for individual elements are used for comparison by the implicit comparator.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>cl</code> - A one or two-argument closure</dd></dl>
</li>
</ul>
<a name="minParallel(java.lang.Object, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>minParallel</h4>
<pre>public static&nbsp;java.lang.Object&nbsp;minParallel(java.lang.Object&nbsp;collection,
                           groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its min() method using the supplied
 closure as the comparator.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns the minimum of the elements in the collection.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>min(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 If the supplied closure takes two arguments it is used directly as a comparator.
 If the supplied closure takes one argument, the values returned by the supplied closure for individual elements are used for comparison by the implicit comparator.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>cl</code> - A one or two-argument closure</dd></dl>
</li>
</ul>
<a name="minParallel(java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>minParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;minParallel(java.util.Collection&lt;T&gt;&nbsp;collection)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its min() method using the default comparator.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns the minimum of the elements in the collection.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>min(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.</div>
</li>
</ul>
<a name="minParallel(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>minParallel</h4>
<pre>public static&nbsp;java.lang.Object&nbsp;minParallel(java.lang.Object&nbsp;collection)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its min() method using the default comparator.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns the minimum of the elements in the collection.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>min(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.</div>
</li>
</ul>
<a name="maxParallel(java.util.Collection, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>maxParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;maxParallel(java.util.Collection&lt;T&gt;&nbsp;collection,
                groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its max() method using the supplied
 closure as the comparator.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns the maximum of the elements in the collection.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>max(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 If the supplied closure takes two arguments it is used directly as a comparator.
 If the supplied closure takes one argument, the values returned by the supplied closure for individual elements are used for comparison by the implicit comparator.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>cl</code> - A one or two-argument closure</dd></dl>
</li>
</ul>
<a name="maxParallel(java.lang.Object, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>maxParallel</h4>
<pre>public static&nbsp;java.lang.Object&nbsp;maxParallel(java.lang.Object&nbsp;collection,
                           groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its max() method using the supplied
 closure as the comparator.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns the maximum of the elements in the collection.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>max(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.
 If the supplied closure takes two arguments it is used directly as a comparator.
 If the supplied closure takes one argument, the values returned by the supplied closure for individual elements are used for comparison by the implicit comparator.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>cl</code> - A one or two-argument closure</dd></dl>
</li>
</ul>
<a name="maxParallel(java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>maxParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;maxParallel(java.util.Collection&lt;T&gt;&nbsp;collection)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its max() method using the default comparator.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns the maximum of the elements in the collection.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>max(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.</div>
</li>
</ul>
<a name="maxParallel(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>maxParallel</h4>
<pre>public static&nbsp;java.lang.Object&nbsp;maxParallel(java.lang.Object&nbsp;collection)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its max() method using the default comparator.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns the maximum of the elements in the collection.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>max(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.</div>
</li>
</ul>
<a name="sumParallel(java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sumParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;sumParallel(java.util.Collection&lt;T&gt;&nbsp;collection)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and summarizes its elements using the foldParallel()
 method with the + operator and the reduction operation.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns the sum of the elements in the collection.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>sun(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.</div>
</li>
</ul>
<a name="sumParallel(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sumParallel</h4>
<pre>public static&nbsp;java.lang.Object&nbsp;sumParallel(java.lang.Object&nbsp;collection)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and summarizes its elements using the foldParallel()
 method with the + operator and the reduction operation.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns the sum of the elements in the collection.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>sum(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.</div>
</li>
</ul>
<a name="foldParallel(java.util.Collection, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>foldParallel</h4>
<pre>@Deprecated
public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;foldParallel(java.util.Collection&lt;T&gt;&nbsp;collection,
                            groovy.lang.Closure&nbsp;cl)</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;</div>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its reduce() method using the supplied
 closure as the reduction operation.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns the reduction result of the elements in the collection.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>reduce(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.</div>
</li>
</ul>
<a name="foldParallel(java.lang.Object, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>foldParallel</h4>
<pre>@Deprecated
public static&nbsp;java.lang.Object&nbsp;foldParallel(java.lang.Object&nbsp;collection,
                                       groovy.lang.Closure&nbsp;cl)</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;</div>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its reduce() method using the supplied
 closure as the reduction operation.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns the reduction result of the elements in the collection.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>reduce(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.</div>
</li>
</ul>
<a name="foldParallel(java.util.Collection,java.lang.Object,groovy.lang.Closure)">
<!--   -->
</a><a name="foldParallel(java.util.Collection, T, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>foldParallel</h4>
<pre>@Deprecated
public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;foldParallel(java.util.Collection&lt;T&gt;&nbsp;collection,
                            T&nbsp;seed,
                            groovy.lang.Closure&nbsp;cl)</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;</div>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its reduce() method using the supplied
 closure as the reduction operation.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns the reduction result of the elements in the collection.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>reduce(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>seed</code> - A seed value to initialize the operation</dd></dl>
</li>
</ul>
<a name="foldParallel(java.lang.Object, java.lang.Object, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>foldParallel</h4>
<pre>@Deprecated
public static&nbsp;java.lang.Object&nbsp;foldParallel(java.lang.Object&nbsp;collection,
                                       java.lang.Object&nbsp;seed,
                                       groovy.lang.Closure&nbsp;cl)</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;</div>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its reduce() method using the supplied
 closure as the reduction operation.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns the reduction result of the elements in the collection.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>reduce(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>seed</code> - A seed value to initialize the operation</dd></dl>
</li>
</ul>
<a name="injectParallel(java.util.Collection, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>injectParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;injectParallel(java.util.Collection&lt;T&gt;&nbsp;collection,
                   groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its reduce() method using the supplied
 closure as the reduction operation.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns the reduction result of the elements in the collection.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>reduce(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.</div>
</li>
</ul>
<a name="injectParallel(java.lang.Object, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>injectParallel</h4>
<pre>public static&nbsp;java.lang.Object&nbsp;injectParallel(java.lang.Object&nbsp;collection,
                              groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its reduce() method using the supplied
 closure as the reduction operation.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns the reduction result of the elements in the collection.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>reduce(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.</div>
</li>
</ul>
<a name="injectParallel(java.util.Collection,java.lang.Object,groovy.lang.Closure)">
<!--   -->
</a><a name="injectParallel(java.util.Collection, T, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>injectParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;injectParallel(java.util.Collection&lt;T&gt;&nbsp;collection,
                   T&nbsp;seed,
                   groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its reduce() method using the supplied
 closure as the reduction operation.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns the reduction result of the elements in the collection.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>reduce(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>seed</code> - A seed value to initialize the operation</dd></dl>
</li>
</ul>
<a name="injectParallel(java.lang.Object, java.lang.Object, groovy.lang.Closure)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>injectParallel</h4>
<pre>public static&nbsp;java.lang.Object&nbsp;injectParallel(java.lang.Object&nbsp;collection,
                              java.lang.Object&nbsp;seed,
                              groovy.lang.Closure&nbsp;cl)</pre>
<div class="block">Creates a Parallel Array out of the supplied collection/object and invokes its reduce() method using the supplied
 closure as the reduction operation.
 The closure will be effectively invoked concurrently on the elements of the collection.
 After all the elements have been processed, the method returns the reduction result of the elements in the collection.
 It's important to protect any shared resources used by the supplied closure from race conditions caused by multi-threaded access.
 Alternatively a DSL can be used to simplify the code. All collections/objects within the <code>withPool</code> block
 have a new <code>reduce(Closure cl)</code> method, which delegates to the <code>GParsPoolUtil</code> class.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>seed</code> - A seed value to initialize the operation</dd></dl>
</li>
</ul>
<a name="getParallel(java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getParallel</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;groovyx.gpars.pa.PAWrapper&lt;T&gt;&nbsp;getParallel(java.util.Collection&lt;T&gt;&nbsp;collection)</pre>
<div class="block">Creates a PAWrapper around a ParallelArray wrapping the elements of the original collection.
 This allows further parallel processing operations on the collection to chain and so effectively leverage the underlying
 ParallelArray implementation.</div>
</li>
</ul>
<a name="getParallel(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getParallel</h4>
<pre>public static&nbsp;groovyx.gpars.pa.PAWrapper&nbsp;getParallel(java.lang.Object&nbsp;collection)</pre>
<div class="block">Creates a PAWrapper around a ParallelArray wrapping the elements of the original collection.
 This allows further parallel processing operations on the collection to chain and so effectively leverage the underlying
 ParallelArray implementation.</div>
</li>
</ul>
<a name="getParallelArray(java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getParallelArray</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../groovyx/gpars/extra166y/ParallelArray.html" title="class in groovyx.gpars.extra166y">ParallelArray</a>&lt;T&gt;&nbsp;getParallelArray(java.util.Collection&lt;T&gt;&nbsp;collection)</pre>
<div class="block">Creates a ParallelArray wrapping the elements of the original collection.</div>
</li>
</ul>
<a name="getParallelArray(java.lang.Object)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>getParallelArray</h4>
<pre>public static&nbsp;<a href="../../groovyx/gpars/extra166y/ParallelArray.html" title="class in groovyx.gpars.extra166y">ParallelArray</a>&nbsp;getParallelArray(java.lang.Object&nbsp;collection)</pre>
<div class="block">Creates a ParallelArray wrapping the elements of the original collection.</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/GParsPoolUtil.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><em>Copyright &#169; 2008&#8211;2013  V&#225;clav Pech.  All Rights Reserved.</em></div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../groovyx/gpars/GParsConfig.html" title="class in groovyx.gpars"><span class="strong">Prev Class</span></a></li>
<li><a href="../../groovyx/gpars/MessagingRunnable.html" title="class in groovyx.gpars"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?groovyx/gpars/GParsPoolUtil.html" target="_top">Frames</a></li>
<li><a href="GParsPoolUtil.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
