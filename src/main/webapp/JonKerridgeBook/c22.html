<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.3">
<meta name="description" content="GPars is a multi-paradigm concurrency framework offering several mutually cooperating high-level concurrency abstractions.">
<meta name="author" content="Jon Kerridge">
<title>GPars - Groovy Parallel Systems</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
</head>
<body class="book toc2 toc-right">
<div id="header">
<h1>GPars - Groovy Parallel Systems</h1>
<div class="details">
<span id="author" class="author">Jon Kerridge</span><br>
<span id="email" class="email"><a href="mailto:j.kerridge@napier.ac.uk">j.kerridge@napier.ac.uk</a></span><br>
<span id="revnumber">version 1.2.1,</span>
<span id="revdate">2015-12-02</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_conclusion_why_use_em_groovy_parallel_em_and_strong_jcsp_strong">Conclusion - Why Use <em>Groovy Parallel</em> and <strong>JCSP</strong> ?</a>
<ul class="sectlevel2">
<li><a href="#_csp">CSP</a></li>
<li><a href="#_purpose">Purpose</a></li>
<li><a href="#_more_cores_please">More Cores, Please</a></li>
<li><a href="#_review">Review</a></li>
<li><a href="#_implementations">Implementations</a></li>
<li><a href="#_the_programmer_s_job">The Programmer&#8217;s Job</a></li>
<li><a href="#_usage">Usage</a></li>
</ul>
</li>
<li><a href="#_conclusion">Conclusion</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_conclusion_why_use_em_groovy_parallel_em_and_strong_jcsp_strong">Conclusion - Why Use <em>Groovy Parallel</em> and <strong>JCSP</strong> ?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>At the end of this journey, we are able to reflect on the capabilities that have been described and considered.</p>
</div>
<div class="paragraph">
<p>We started with four very simple concepts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>process</p>
</li>
<li>
<p>channel</p>
</li>
<li>
<p>alternative</p>
</li>
<li>
<p>timer</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>and from these we have been able to construct a wide variety of systems with very different operational requirements and functionality.</p>
</div>
<div class="sect2">
<h3 id="_csp">CSP</h3>
<div class="paragraph">
<p>In general, this has been achieved with one fundamental design pattern, the <code>client-server</code>, together with a small number of programming idioms that facilitate its use; such as the prompted buffer.
The intellectual challenge is realised by understanding how to use this pattern and idioms in an effective manner.</p>
</div>
</div>
<div class="sect2">
<h3 id="_purpose">Purpose</h3>
<div class="paragraph">
<p>In this book, I have purposely avoided the use of any formal representation of the process and how networks of such processes can be analysed using formal tools. I believe that the engineering approach based upon the reuse of a single design pattern, which has its basis in the underlying formalism,
is the best way to make software engineers appreciate what can be achieved, provided the capability we are using has a formal basis.</p>
</div>
<div class="paragraph">
<p>The real world is not populated with sufficient software engineers who have the mathematical skill to be able to undertake the formal analysis of their systems, even with the tools currently available.</p>
</div>
</div>
<div class="sect2">
<h3 id="_more_cores_please">More Cores, Please</h3>
<div class="paragraph">
<p>The increasing availability of multi-core processor based systems is inevitable and the desire to make more effective use of this technology will be an increasing challenge.
If the engineers use currently available models and methods then this technology will be increasingly difficult to use.
Software engineers, therefore, require a better model with which they can program such systems. But why leave it to just multi-core systems? Why not better and more effective use of network based workstation systems?
We might then be able to move to processing systems that makes more effective use of grid-computing because we have a viable model that allows us to interact over any size network.</p>
</div>
</div>
<div class="sect2">
<h3 id="_review">Review</h3>
<div class="paragraph">
<p>The content of this book started at a basic undergraduate level and ended with examples of mobile systems that are still the subject of intense research activity (<strong>occam-pi, mobile</strong>).</p>
</div>
<div class="paragraph">
<p>All the examples presented are demonstrable and where necessary operate over a network and employ aspects of mobility.
Yet this is achieved in manner that does not require a detailed understanding of the operation of networked systems and in which the definition of a process is not reliant upon whether it is to execute as one among many on a single processor or over a network.</p>
</div>
</div>
<div class="sect2">
<h3 id="_implementations">Implementations</h3>
<div class="paragraph">
<p>The underlying support is provided by <strong>JCSP</strong> and it has been made easier to assimilate by use of <strong>Groovy</strong> because it helps to reduce the amount of code that needs writing.</p>
</div>
<div class="paragraph">
<p>These are of relatively little importance of themselves but it is important that they both utilise the underlying <strong>JVM</strong>.</p>
</div>
<div class="paragraph">
<p>What is really crucial is that <strong>JCSP</strong> provides an implementation of <strong>CSP</strong>. <strong>CSP</strong> provides the formal framework upon which <strong>JCSP</strong> is implemented and thereby the engineering support for programmers.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A programmer is no longer concerned with a poorly implemented underlying thread model
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_the_programmer_s_job">The Programmer&#8217;s Job</h3>
<div class="paragraph">
<p>The programmers are not concerned with the inner workings of the underlying <strong>JCSP</strong> package because they can reason about their systems at a much higher level.</p>
</div>
<div class="paragraph">
<p>The programmer is no longer concerned with the detailed workings of a poorly implemented underlying thread model, in effect, writing machine code.</p>
</div>
<div class="paragraph">
<p>They can now concentrate on high-level design of the processes at the application layer; confident that, if they use the building blocks correctly and apply one pattern effectively then, the resulting system will operate as expected.</p>
</div>
<div class="paragraph">
<p>This does not remove the need for testing, which exposes the frailties of a system when exposed to a real operating environment. In this book, we have shown how systems can be tested, albeit in a cumbersome manner but which, with further research and the development of support tools, will make it easier to achieve.</p>
</div>
</div>
<div class="sect2">
<h3 id="_usage">Usage</h3>
<div class="paragraph">
<p>The final chapters have shown how we can exploit the <code>process</code> concept in a more up-to-date setting and how it may address the problems that the software industry is starting to deal with in terms of how to exploit mobility, network connectivity and parallelism effectively.</p>
</div>
<div class="paragraph">
<p>Previously, parallelism has been thought of as providing a solution to the needs of high performance computing, where ultimate speed was the only driving force.</p>
</div>
<div class="paragraph">
<p>Hopefully, with some of the later examples, in particular, the reader will have been convinced that approaching a solution to a problem from the parallel point of view actually makes it easier to achieve a working and effective solution.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The book ends at the point where the examples have to become real problems and which, of course, tend to be too large to explain within the confines of such a book. Hopefully, however, the book contains sufficient ideas, concepts and capabilities that the solution to larger problems can be broken down into sufficiently small processes that it becomes manageable.</p>
</div>
<div class="paragraph">
<p>As a final design consideration, I offer the advice that if you are having problems with a design and cannot get the design right then the solution is usually to add one or more processes. If a designer tries to restrict the number of processes then that is usually followed by problems.</p>
</div>
<div class="paragraph">
<p>In the future perhaps, we will get to the situation where team leaders will ask why a serial solution has been adopted rather than one that relies on parallel design methods!</p>
</div>
<div class="paragraph">
<p><strong class="right">- Jon Kerridge</strong></p>
</div>
<hr>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.2.1<br>
Last updated 2016-01-14 13:37:37 +01:00
</div>
</div>
</body>
</html>