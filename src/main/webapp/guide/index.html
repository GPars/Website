<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.3">
<meta name="description" content="GPars is a multi-paradigm concurrency framework offering several mutually cooperating high-level concurrency abstractions.">
<meta name="author" content="The Whole GPars Team &lt;gpars-developers@googlegroups.com&gt;">
<title>The GPars User Guide</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
</head>
<body class="book toc2 toc-right">
<div id="header">
<h1>The GPars User Guide</h1>
<div class="details">
<span id="author" class="author">The Whole GPars Team &lt;gpars-developers@googlegroups.com&gt;</span><br>
<span id="revnumber">version 2.0,</span>
<span id="revdate">2017-02-01</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introducing_our_user_guide">Introducing Our User Guide</a>
<ul class="sectlevel2">
<li><a href="#_enter_strong_gpars_strong">Enter <strong>GPars</strong></a></li>
<li><a href="#_credits">Credits</a></li>
</ul>
</li>
<li><a href="#_user_guide_to_strong_getting_started_strong">User Guide To <strong>Getting Started</strong></a>
<ul class="sectlevel2">
<li><a href="#_a_few_assumptions">A Few Assumptions</a></li>
<li><a href="#_ready">Ready ?</a></li>
<li><a href="#_download_and_install">Download and Install</a></li>
<li><a href="#_the_strong_gpars_strong_artifact">The <strong>GPars</strong> Artifact</a></li>
<li><a href="#_transitive_dependencies">Transitive Dependencies</a></li>
</ul>
</li>
<li><a href="#_a_hello_world_example">A Hello World Example</a>
<ul class="sectlevel2">
<li><a href="#_code_conventions">Code Conventions</a></li>
<li><a href="#_usage">Usage</a></li>
<li><a href="#_getting_set_up_in_an_ide">Getting Set Up In An IDE</a></li>
<li><a href="#_applicability_of_concepts">Applicability of Concepts</a></li>
<li><a href="#_what_s_new">What&#8217;s New</a></li>
<li><a href="#__strong_java_strong_api_using_strong_gpars_strong_from_strong_java_strong"><strong>Java</strong> API – Using <strong>GPars</strong> from <strong>Java</strong></a></li>
<li><a href="#_actors_2">Actors</a></li>
<li><a href="#_convenience_factory_methods">Convenience Factory Methods</a></li>
<li><a href="#_agents">Agents</a></li>
<li><a href="#_dataflow_concurrency">Dataflow Concurrency</a></li>
<li><a href="#_dataflow_operators">Dataflow Operators</a></li>
<li><a href="#_performance">Performance</a></li>
<li><a href="#_prerequisites">Prerequisites</a></li>
</ul>
</li>
<li><a href="#_user_guide_to_strong_data_parallelism_strong">User Guide To <strong>Data Parallelism</strong></a>
<ul class="sectlevel2">
<li><a href="#_parallel_collections_2">Parallel Collections</a></li>
<li><a href="#_meet_parallel_arrays">Meet Parallel Arrays</a></li>
<li><a href="#_gparspool">GParsPool</a></li>
<li><a href="#_avoid_side_effects_in_functions">Avoid Side-Effects in Functions</a></li>
<li><a href="#_gparsexecutorspool">GParsExecutorsPool</a></li>
<li><a href="#_usage_of_gparsexecutorspool">Usage of GParsExecutorsPool</a></li>
<li><a href="#_avoid_side_effects_in_functions_2">Avoid Side-effects in Functions</a></li>
<li><a href="#_memoize">Memoize</a></li>
<li><a href="#_examples_of_use_3">Examples Of Use</a></li>
<li><a href="#_fibonacci_example">Fibonacci Example</a></li>
<li><a href="#_available_variants">Available Variants</a></li>
<li><a href="#_map_reduce">Map-Reduce</a></li>
<li><a href="#_avoid_side_effects_in_functions_3">Avoid Side-effects in Functions</a></li>
<li><a href="#_combine">Combine</a></li>
<li><a href="#_parallel_arrays">Parallel Arrays</a></li>
<li><a href="#_asynchronous_invocations">Asynchronous Invocations</a></li>
<li><a href="#_composable_asynchronous_functions">Composable Asynchronous Functions</a></li>
<li><a href="#_are_we_concurrent_yet">Are We Concurrent Yet?</a></li>
<li><a href="#_fork_join_2">Fork-Join</a></li>
<li><a href="#_parallel_speculations">Parallel Speculations</a></li>
<li><a href="#_parallel_speculations_2">Parallel Speculations</a></li>
<li><a href="#_alternatives_using_strong_dataflow_variables_strong_and_strong_streams_strong">Alternatives Using <strong>Dataflow Variables</strong> and <strong>Streams</strong></a></li>
</ul>
</li>
<li><a href="#_user_guide_to_strong_csp_strong">User Guide To <strong>CSP</strong></a>
<ul class="sectlevel2">
<li><a href="#_communicating_sequential_processes">Communicating Sequential Processes</a></li>
<li><a href="#_the_strong_csp_strong_model_principles">The <strong>CSP</strong> Model Principles</a></li>
<li><a href="#__strong_csp_strong_with_strong_gpars_strong_dataflow"><strong>CSP</strong> with <strong>GPars</strong> Dataflow</a></li>
<li><a href="#_processes">Processes</a></li>
<li><a href="#_channels">Channels</a></li>
<li><a href="#_composition">Composition</a></li>
<li><a href="#_alternatives">Alternatives</a></li>
<li><a href="#_components">Components</a></li>
</ul>
</li>
<li><a href="#_user_guide_to_strong_actors_strong">User Guide To <strong>Actors</strong></a>
<ul class="sectlevel2">
<li><a href="#_types_of_actors">Types of Actors</a></li>
<li><a href="#_actor_threading_model">Actor Threading Model</a></li>
<li><a href="#_usage_of_actors">Usage of Actors</a></li>
<li><a href="#_actors_principles">Actors Principles</a></li>
<li><a href="#_stateless_actors">Stateless Actors</a></li>
<li><a href="#_tips_and_tricks">Tips and Tricks</a></li>
<li><a href="#_active_objects">Active Objects</a></li>
<li><a href="#_classic_examples">Classic Examples</a></li>
</ul>
</li>
<li><a href="#_user_guide_to_strong_agents_strong">User Guide To <strong>Agents</strong></a>
<ul class="sectlevel2">
<li><a href="#_introduction">Introduction</a></li>
<li><a href="#_concepts">Concepts</a></li>
<li><a href="#_examples">Examples</a></li>
<li><a href="#_factory_methods">Factory Methods</a></li>
<li><a href="#_listeners_and_validators">Listeners and Validators</a></li>
<li><a href="#_validator_gotchas">Validator Gotchas</a></li>
<li><a href="#_grouping">Grouping</a></li>
<li><a href="#_reading_the_value">Reading The Value</a></li>
<li><a href="#_state_copy_strategy">State Copy Strategy</a></li>
<li><a href="#_error_handling">Error Handling</a></li>
<li><a href="#_fair_and_non_fair_strong_agents_strong">Fair and Non-fair <strong>Agents</strong></a></li>
</ul>
</li>
<li><a href="#_user_guide_to_strong_dataflow_strong">User Guide to <strong>Dataflow</strong></a>
<ul class="sectlevel2">
<li><a href="#_introduction_2">Introduction</a></li>
<li><a href="#_implementation_detail">Implementation Detail</a></li>
<li><a href="#_benefits">Benefits</a></li>
<li><a href="#_concepts_2">Concepts</a></li>
<li><a href="#_principles">Principles</a></li>
<li><a href="#_dataflow_queues_and_broadcasts">Dataflow Queues and Broadcasts</a></li>
<li><a href="#_dataflowstream">DataflowStream</a></li>
<li><a href="#_bind_handlers">Bind Handlers</a></li>
<li><a href="#_bind_handlers_grouping">Bind Handlers Grouping</a></li>
<li><a href="#_bind_handler_chaining">Bind Handler Chaining</a></li>
<li><a href="#_lazy_strong_dataflow_strong_tasks_and_variables">Lazy <strong>Dataflow</strong> Tasks and Variables</a></li>
<li><a href="#_dataflow_expressions">Dataflow Expressions</a></li>
<li><a href="#_bind_error_notification">Bind Error Notification</a></li>
<li><a href="#_further_reading">Further Reading</a></li>
<li><a href="#_tasks">Tasks</a></li>
<li><a href="#_deterministic_deadlocks">Deterministic Deadlocks</a></li>
<li><a href="#__strong_dataflows_strong_map"><strong>Dataflows</strong> Map</a></li>
<li><a href="#_returning_values_from_a_task">Returning Values From A Task</a></li>
<li><a href="#_joining_tasks">Joining Tasks</a></li>
<li><a href="#_selects">Selects</a></li>
<li><a href="#_guards">Guards</a></li>
<li><a href="#_priority_select">Priority Select</a></li>
<li><a href="#_collecting_results_of_asynchronous_computations">Collecting Results of Asynchronous Computations</a></li>
<li><a href="#_timeouts_2">Timeouts</a></li>
<li><a href="#_cancellations">Cancellations</a></li>
<li><a href="#_operators">Operators</a></li>
<li><a href="#_concepts_3">Concepts</a></li>
<li><a href="#_constructing_operators">Constructing Operators</a></li>
<li><a href="#_holding_state_in_operators">Holding State in Operators</a></li>
<li><a href="#_parallelize_operators">Parallelize Operators</a></li>
<li><a href="#_selectors">Selectors</a></li>
<li><a href="#_shutting_down_dataflow_networks">Shutting Down Dataflow Networks</a></li>
<li><a href="#_emergency_shutdown">Emergency Shutdown</a></li>
<li><a href="#_poisonpill">PoisonPill</a></li>
<li><a href="#_immediate_poison_pill">Immediate Poison Pill</a></li>
<li><a href="#_poison_with_counting">Poison With Counting</a></li>
<li><a href="#_poison_strategies">Poison Strategies</a></li>
<li><a href="#_termination_tips_and_tricks">Termination Tips and Tricks</a></li>
<li><a href="#_keeping_poisonpill_inside_a_given_network">Keeping PoisonPill Inside a Given Network</a></li>
<li><a href="#_graceful_shutdown">Graceful Shutdown</a></li>
<li><a href="#_application_frameworks">Application Frameworks</a></li>
<li><a href="#_pipeline_dsl">Pipeline DSL</a></li>
<li><a href="#_overriding_the_default_strong_pgroup_strong">Overriding the Default <strong>PGroup</strong></a></li>
<li><a href="#_the_pipeline_builder">The Pipeline Builder</a></li>
<li><a href="#_passing_construction_parameters_through_the_pipeline_dsl">Passing Construction Parameters Through the Pipeline DSL</a></li>
<li><a href="#_implementation">Implementation</a></li>
<li><a href="#_using_plain_strong_java_strong_threads">Using Plain <strong>Java</strong> Threads</a></li>
<li><a href="#_synchronous_variables_and_channels">Synchronous Variables and Channels</a></li>
<li><a href="#_synchronous_dataflow_broadcast">Synchronous Dataflow Broadcast</a></li>
<li><a href="#_synchronous_dataflow_variable">Synchronous Dataflow Variable</a></li>
<li><a href="#_kanban_flow">Kanban Flow</a></li>
<li><a href="#_kanbanflow_description">KanbanFlow Description</a></li>
<li><a href="#_classic_examples_2">Classic Examples</a></li>
</ul>
</li>
<li><a href="#_user_guide_to_strong_stm_strong">User Guide To <strong>STM</strong></a>
<ul class="sectlevel2">
<li><a href="#__em_software_transactional_memory_em"><em>Software Transactional Memory</em></a></li>
<li><a href="#_running_a_piece_of_code_atomically">Running A Piece of Code Atomically</a></li>
<li><a href="#_customizing_the_transactional_properties">Customizing the Transactional Properties</a></li>
<li><a href="#_using_the_em_transaction_em_object">Using the <em>Transaction</em> Object</a></li>
<li><a href="#_data_structures">Data Structures</a></li>
<li><a href="#_more_information">More Information</a></li>
</ul>
</li>
<li><a href="#_user_guide_to_strong_gae_strong">User Guide To <strong>GAE</strong></a>
<ul class="sectlevel2">
<li><a href="#_google_app_engine_integration">Google App Engine Integration</a></li>
</ul>
</li>
<li><a href="#_user_guide_to_strong_remoting_strong">User Guide To <strong>Remoting</strong></a>
<ul class="sectlevel2">
<li><a href="#_introduction_3">Introduction</a></li>
<li><a href="#_remote_serialization">Remote Serialization</a></li>
<li><a href="#_dataflows">Dataflows</a></li>
<li><a href="#_dataflowvariable">DataflowVariable</a></li>
<li><a href="#_dataflowbroadcast">DataflowBroadcast</a></li>
<li><a href="#_dataflowqueue">DataflowQueue</a></li>
<li><a href="#_actors_3">Actors</a></li>
<li><a href="#_remote_actor_names">Remote Actor Names</a></li>
<li><a href="#_agents_2">Agents</a></li>
</ul>
</li>
<li><a href="#_general_strong_gpars_strong_tips">General <strong>GPars</strong> Tips</a>
<ul class="sectlevel2">
<li><a href="#_grouping_2">Grouping</a></li>
<li><a href="#_java_api">Java API</a></li>
<li><a href="#_performance_2">Performance</a></li>
<li><a href="#_parallel_collections_3">Parallel Collections</a></li>
<li><a href="#_actors_4">Actors</a></li>
<li><a href="#__strong_agents_strong"><strong>Agents</strong></a></li>
<li><a href="#_hosted_environments">Hosted Environments</a></li>
<li><a href="#_compatibility">Compatibility</a></li>
</ul>
</li>
<li><a href="#_user_guide_to_strong_the_conclusion_strong">User Guide To <strong>The Conclusion</strong></a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="imageblock" style="text-align: center">
<div class="content">
<a class="image" href="http://gpars.org/"><img src="../../images/gpars-rgb.svg" alt="GPars Logo" width="320"></a>
</div>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To download this guide as a PDF - <a href="../guide/index.pdf">click here</a>
</td>
</tr>
</table>
</div>
<hr>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_introducing_our_user_guide">Introducing Our User Guide</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The world of mainstream computing is changing rapidly these days. If you open the case and look under the
covers of your computer, you&#8217;ll most likely see a dual-core processor there, or a quad-core one, if you have
a high-end computer.  We all now run our software on multi-processor systems.</p>
</div>
<div class="paragraph">
<div class="title">Why do people still create single-threaded code ?</div>
<p>The code we write today and tomorrow will probably never run on a single processor system: parallel hardware has become standard.  Not
so with the software though, at least not yet. People still create single-threaded code, even though it will
not be able to leverage the full power of current and future hardware.</p>
</div>
<hr>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The code we write today will probably never run on a single processor system !
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p>Some developers experiment with low-level concurrency primitives, like threads, and locks or synchronized blocks.
However, it has become obvious that the shared-memory multi-threading approach used at the application level causes more trouble
than it solves. Low-level concurrency handling is usually hard to get right, and it&#8217;s not much fun either.</p>
</div>
<div class="paragraph">
<p>With such a radical change in hardware, software inevitably has to change dramatically too. Higher-levelS OF
concurrency and parallelism concepts like <em>map/reduce</em>, <em>fork/join</em>, <em>actors</em> and <em>dataflow</em> provide natural
abstractions for different types of problem domains while leveraging the multi-core hardware.</p>
</div>
<div class="sect2">
<h3 id="_enter_strong_gpars_strong">Enter <strong>GPars</strong></h3>
<div class="paragraph">
<p>Meet <a href="http://gpars.org"><strong>GPars</strong></a>, an open-source concurrency and parallelism library for <strong>Java</strong> and <strong>Groovy</strong> that gives you a number of high-level abstractions for writing concurrent and parallel code in <strong>Groovy</strong>
(<em>map/reduce, fork/join, asynchronous closures, actors, agents, dataflow concurrency</em> and other concepts),
which can make your <strong>Java</strong> and <strong>Groovy</strong> code concurrent and/or parallel with little effort.</p>
</div>
<div class="paragraph">
<p>With <strong>GPars</strong>, your <strong>Java</strong> and/or <strong>Groovy</strong> code can easily utilize all the available processors on the target system. You can run
multiple calculations at the same time, request network resources in parallel, safely solve hierarchical
divide-and-conquer problems, perform functional style map/reduce or data parallel collection processing or
build your applications around the actor or dataflow model.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Apache</div>
<div class="paragraph">
<p>The <strong>GPars</strong> project is open sourced under the <a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache 2 License</a>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>If you&#8217;re working on a commercial, open-source, educational or any other type of software project in <strong>Groovy</strong>, download the binaries or integrate them from the <strong>Maven</strong> repository and get going. The door to writing highly concurrent and/or parallel <strong>Java</strong> and <strong>Groovy</strong> code is wide open. <span class="blue">Enjoy!</span></p>
</div>
</div>
<div class="sect2">
<h3 id="_credits">Credits</h3>
<div class="paragraph">
<p>This project could not have reached the point where it stands currently without all the great help and
contributionS from many individuals, who have devoted their time, energy and expertise to make <strong>GPars</strong> a solid
product. First, it&#8217;s the people in the core team who should be mentioned:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Václav Pech</p>
</li>
<li>
<p>Dierk Koenig</p>
</li>
<li>
<p>Alex Tkachman</p>
</li>
<li>
<p>Russel Winder</p>
</li>
<li>
<p>Paul King</p>
</li>
<li>
<p>Jon Kerridge</p>
</li>
<li>
<p>Rafał Sławik</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Over time, many other people have contributed their ideas, provided useful feedback or helped <strong>GPars</strong> in one way or
another.  There are many people in this group, too many to name them all, but let&#8217;s list at least the most
active:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hamlet d&#8217;Arcy</p>
</li>
<li>
<p>Hans Dockter</p>
</li>
<li>
<p>Guillaume Laforge</p>
</li>
<li>
<p>Robert Fischer</p>
</li>
<li>
<p>Johannes Link</p>
</li>
<li>
<p>Graeme Rocher</p>
</li>
<li>
<p>Alex Miller</p>
</li>
<li>
<p>Jeff Gortatowsky</p>
</li>
<li>
<p>Jiří Kropáček</p>
</li>
<li>
<p>Jim Northrop</p>
</li>
</ul>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Many thanks to everyone!
</td>
</tr>
</table>
</div>
<hr>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../images/divider.png" alt="divider" width="436">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_user_guide_to_strong_getting_started_strong">User Guide To <strong>Getting Started</strong></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_few_assumptions">A Few Assumptions</h3>
<div class="paragraph">
<p>Let&#8217;s set out a few assumptions before we start :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You know and use <strong>Groovy</strong> and/or <strong>Java</strong> : otherwise you&#8217;d not be investing your valuable time studying a concurrency and parallelism library for <strong>Groovy</strong> and/or <strong>Java</strong>.</p>
</li>
<li>
<p>You definitely want to write code employing concurrency and parallelism concepts.</p>
</li>
<li>
<p>If you are not using <strong>Groovy</strong>, you are prepared to pay the inevitable verbosity tax of using <strong>Java</strong>.</p>
</li>
<li>
<p>You target multi-core hardware with your code.</p>
</li>
<li>
<p>You appreciate that in concurrent and parallel code things can happen at any time, in any order, and, more likely, with more than one thing happening at once.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_ready">Ready ?</h3>
<div class="paragraph">
<p>With those assumptions in place, we can get started.</p>
</div>
<div class="paragraph">
<p>It&#8217;s becoming more and more obvious that dealing with concurrency and parallelism at the
thread/synchronized/lock level, as provided by the JVM, is far too low a level to be safe and comfortable.</p>
</div>
<div class="paragraph">
<p>Many high-level concepts, such as <strong>actors</strong> and <strong>dataflow</strong> have been around for quite some time. Parallel-chipped
 computers have been in use, at least in data centres if not on the desktop, long before multi-core chips hit
the hardware mainstream.</p>
</div>
<div class="paragraph">
<p>So now is the time to adopt these higher-level abstractions into the mainstream software industry.</p>
</div>
<div class="paragraph">
<p>This is what <strong>GPars</strong> enables for the <strong>Groovy</strong> and <strong>Java</strong> languages, allowing them to use higher-level abstractions and, therefore,
 make development of concurrent and parallel software easier and less error prone.</p>
</div>
<div class="paragraph">
<p>The concepts available in <strong>GPars</strong> can be categorized into three groups:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Code-level helpers</em> - Constructs that can be applied to small parts of your code-base, such as an individual algorithms or data structure, without any major changes in the overall project architecture</p>
<div class="ulist">
<ul>
<li>
<p>Parallel Collections</p>
</li>
<li>
<p>Asynchronous Processing</p>
</li>
<li>
<p>Fork/Join (Divide/Conquer)</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>Architecture-level concepts</em> - Constructs that need to be taken into account when designing the project structure</p>
<div class="ulist">
<ul>
<li>
<p>Actors</p>
</li>
<li>
<p>Communicating Sequential Processes (CSP)</p>
</li>
<li>
<p>Dataflow</p>
</li>
<li>
<p>Data Parallelism</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>Shared Mutable State Protection</em> - More than 95% of the current use of shared mutable states can be avoided using proper abstractions.
Good abstractions are still necessary for the remaining 5% of those use cases, i.e. when shared mutable state cannot be avoided.</p>
<div class="ulist">
<ul>
<li>
<p>Agents</p>
</li>
<li>
<p>Software Transactional Memory (not fully implemented in <strong>GPars</strong> as yet)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_download_and_install">Download and Install</h3>
<div class="paragraph">
<p><strong>GPars</strong> is now distributed as part of <strong>Groovy</strong>.  So if you have a <strong>Groovy</strong> installation, you should already have
<strong>GPars</strong>.  Your exact version of <strong>GPars</strong> will, of course, depend on which version of <strong>Groovy</strong> you use.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t already have <strong>GPars</strong>, and you do have <strong>Groovy</strong>, then perhaps you should upgrade your <strong>Groovy</strong> !</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you need it, you can <a href="http://groovy-lang.org/download.html">download <strong>Groovy</strong> from here,</a> and <a href="../Download.html"><strong>GPars</strong> from here.</a>
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p>If you don&#8217;t have a <strong>Groovy</strong> installation, but use <strong>Groovy</strong> by using dependencies or perhaps, just having the <strong>groovy-all</strong>
artifact, then you will need to get <strong>GPars</strong>.  Also if you want to use a different version of <strong>GPars</strong> to the one bundled with <strong>Groovy</strong>,
or have an old <strong>GPars</strong>-free <strong>Groovy</strong> that you cannot upgrade, you will need to get <strong>GPars</strong>.  The ways to download <strong>GPars</strong> are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Download the artifact from a repository and add it and all the transitive dependencies manually.</p>
</li>
<li>
<p>Specify a dependency in Gradle, Maven, or Ivy (or Gant, or Ant) build files.</p>
</li>
<li>
<p>Use Grapes (especially useful for <strong>Groovy</strong> scripts).</p>
</li>
<li>
<p>Download and install it <a href="../Download.html">from here.</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you&#8217;re building a <strong>Grails</strong> or a <strong>Griffon</strong> application, you can use the appropriate plugins to fetch our jar files for you.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_the_strong_gpars_strong_artifact">The <strong>GPars</strong> Artifact</h3>
<div class="paragraph">
<p>As noted above, <strong>GPars</strong> is now distributed as standard with <strong>Groovy</strong>.  If however, you have to manage this
dependency manually, the <strong>GPars</strong> artifact is in the main <strong>Maven</strong> repository and was in the Codehaus main and snapshots repositories before they closed.</p>
</div>
<div class="paragraph">
<p>Release versions can be found in the <strong>Maven</strong> main repositories but, for now, the current development version (SNAPSHOT) was in the Codehaus snapshots repository.
We&#8217;re moving it to another location.</p>
</div>
<div class="paragraph">
<p>To use <strong>GPars</strong> from <strong>Gradle</strong> or Grapes, use the specification:</p>
</div>
<div class="listingblock">
<div class="title">A <strong>Gradle</strong> Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="gradle"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>&quot;org.codehaus.gpars:gpars:2.0&quot;</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>You may need to add our snapshot repository manually to the search list in this latter case.  Using <strong>Maven</strong> the dependency is:</p>
</div>
<div class="listingblock">
<div class="title">A Sample <strong>Maven</strong> Declaration</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="maven"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>&lt;dependency&gt;
    &lt;groupId&gt;org.codehaus.gpars&lt;/groupId&gt;
    &lt;artifactId&gt;gpars&lt;/artifactId&gt;
    &lt;version&gt;2.0&lt;/version&gt;
&lt;/dependency&gt;</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_transitive_dependencies">Transitive Dependencies</h3>
<div class="paragraph">
<p><strong>GPars</strong> as a library depends on <strong>Groovy</strong> versions later than 2.2.1. Also, the <strong>Fork/Join</strong> concurrency library must be available.
This comes as standard with <strong>Java 7</strong>.</p>
</div>
<div class="paragraph">
<p><strong>GPars 2.0</strong> will depend on <strong>Java 8</strong> and will only be usable with <strong>Groovy 2.4.7</strong> and later.</p>
</div>
<div class="paragraph">
<p>Please visit the <a href="../Integration.html">Integration</a> page on our <strong>GPars</strong> website for more details.</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_hello_world_example">A Hello World Example</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Once you&#8217;re setup, try the following <strong>Groovy</strong> script to confirm your setup is functioning properly.</p>
</div>
<div class="listingblock">
<div class="title">A <strong>Groovy</strong> Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.actor.Actors.actor</span>

<span class="comment">/**
 * A demo showing two cooperating actors. The decryptor decrypts received messages
 * and replies them back.  The console actor sends a message to decrypt, prints out
 * the reply and terminates both actors.  The main thread waits on both actors to
 * finish using the join() method to prevent premature exit, since both actors use
 * the default actor group, which uses a daemon thread pool.
 * @author Dierk Koenig, Vaclav Pech
 */</span>

<span class="keyword">def</span> decryptor = actor {
    loop {
        react { message -&gt;
            <span class="keyword">if</span> (message <span class="keyword">instanceof</span> <span class="predefined-type">String</span>) reply message.reverse()
            <span class="keyword">else</span> stop()
        }
    }
}

<span class="keyword">def</span> console = actor {
    decryptor.send <span class="string"><span class="delimiter">'</span><span class="content">lellarap si yvoorG</span><span class="delimiter">'</span></span>
    react {
        println <span class="string"><span class="delimiter">'</span><span class="content">Decrypted message: </span><span class="delimiter">'</span></span> + <span class="local-variable">it</span>
        decryptor.send <span class="predefined-constant">false</span>
    }
}

[decryptor, console]*.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>You should receive a message "Decrypted message: <strong>Groovy</strong> is parallel" on the console.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title"><strong>Java API</strong></div>
<div class="paragraph">
<p><strong>GPars</strong> has been designed primarily for use with the <strong>Groovy</strong> programming language.  Of course all <strong>Java</strong> and
<strong>Groovy</strong> programs are just bytecodes running on the JVM, so <strong>GPars</strong> can be used with <strong>Java</strong> source.</p>
</div>
<div class="paragraph">
<p>Despite being aimed at <strong>Groovy</strong>, the solid technical foundation, plus the good performance characteristics of
<strong>GPars</strong> makes it an excellent library for <strong>Java</strong> programs too. In fact much of <strong>GPars</strong> is written in <strong>Java</strong>, so there&#8217;s
no performance penalty for <strong>Java</strong> applications using <strong>GPars</strong>.</p>
</div>
<div class="paragraph">
<p>For details please refer to the <strong>Java API</strong> section.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>To quick-test <strong>GPars</strong> with the <strong>Java API</strong>, compile and run the following <strong>Java</strong> code:</p>
</div>
<div class="listingblock">
<div class="title">Another <strong>Java</strong> Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.MessagingRunnable</span>;
<span class="keyword">import</span> <span class="include">groovyx.gpars.actor.DynamicDispatchActor</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">StatelessActorDemo</span> {

    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) <span class="directive">throws</span> <span class="exception">InterruptedException</span> {
        <span class="directive">final</span> MyStatelessActor actor = <span class="keyword">new</span> MyStatelessActor();
        actor.start();
        actor.send(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello</span><span class="delimiter">&quot;</span></span>);
        actor.sendAndWait(<span class="integer">10</span>);

        actor.sendAndContinue(<span class="float">10.0</span>, <span class="keyword">new</span> MessagingRunnable&lt;<span class="predefined-type">String</span>&gt;() {
            <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="type">void</span> doRun(<span class="directive">final</span> <span class="predefined-type">String</span> s) {
                <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Received a reply </span><span class="delimiter">&quot;</span></span> + s);
            }
        });
    }
}

<span class="type">class</span> <span class="class">MyStatelessActor</span> <span class="directive">extends</span> DynamicDispatchActor {
    <span class="directive">public</span> <span class="type">void</span> onMessage(<span class="directive">final</span> <span class="predefined-type">String</span> msg) {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Received </span><span class="delimiter">&quot;</span></span> + msg);
        replyIfExists(<span class="string"><span class="delimiter">&quot;</span><span class="content">Thank you</span><span class="delimiter">&quot;</span></span>);
    }

    <span class="directive">public</span> <span class="type">void</span> onMessage(<span class="directive">final</span> <span class="predefined-type">Integer</span> msg) {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Received a number </span><span class="delimiter">&quot;</span></span> + msg);
        replyIfExists(<span class="string"><span class="delimiter">&quot;</span><span class="content">Thank you</span><span class="delimiter">&quot;</span></span>);
    }

    <span class="directive">public</span> <span class="type">void</span> onMessage(<span class="directive">final</span> <span class="predefined-type">Object</span> msg) {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Received an object </span><span class="delimiter">&quot;</span></span> + msg);
        replyIfExists(<span class="string"><span class="delimiter">&quot;</span><span class="content">Thank you</span><span class="delimiter">&quot;</span></span>);
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Artifacts maybe needed</div>
<p>Remember though that you will almost certainly have to add the <strong>Groovy</strong> artifact to the build as well as the
<strong>GPars</strong> artifact.  <strong>GPars</strong> may well work at <strong>Java</strong> speeds with <strong>Java</strong> applications, but it still has some compilation dependencies on <strong>Groovy</strong>.</p>
</div>
<hr>
<div class="sect2">
<h3 id="_code_conventions">Code Conventions</h3>
<div class="paragraph">
<p>We follow certain conventions in our code samples. Understanding these conventions may help you read and comprehend <strong>GPars</strong> code samples better.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <em>leftShift</em> operator <strong class="red">'&lt;&lt;'</strong> has been overloaded on <strong>actors</strong>, <strong>agents</strong> and <strong>dataflow</strong> expressions (both variables and streams) to mean <em>send</em> a message or <em>assign</em> a value.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Using The <em>leftShift</em> Operator</div>
<div class="content">
<pre>myActor &lt;&lt; 'message'

myAgent &lt;&lt; {account -&gt; account.add('5 USD')}

myDataflowVariable &lt;&lt; 120332</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>On <strong>actors</strong> and <strong>agents</strong>, the default <em>call()</em> method has been also overloaded to mean <em>send</em> . So sending a message to an actor or agent may look like a regular method call.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>myActor "message"

myAgent {house -&gt; house.repair()}</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The <em>rightShift</em> operator <strong class="red">'&gt;&gt;'</strong> in <strong>GPars</strong> has the <em>when bound</em> meaning. So</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre> myDataflowVariable &gt;&gt; {value -&gt; doSomethingWith(value)}</pre>
</div>
</div>
<div class="paragraph">
<p>will schedule the closure to run only after <em>myDataflowVariable</em> is bound to a value, with the value as a parameter.</p>
</div>
</div>
<div class="sect2">
<h3 id="_usage">Usage</h3>
<div class="paragraph">
<p>In samples, we tend to statically import frequently used factory methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>GParsPool.withPool()</p>
</li>
<li>
<p>GParsPool.withExistingPool()</p>
</li>
<li>
<p>GParsExecutorsPool.withPool()</p>
</li>
<li>
<p>GParsExecutorsPool.withExistingPool()</p>
</li>
<li>
<p>Actors.actor()</p>
</li>
<li>
<p>Actors.reactor()</p>
</li>
<li>
<p>Actors.fairReactor()</p>
</li>
<li>
<p>Actors.messageHandler()</p>
</li>
<li>
<p>Actors.fairMessageHandler()</p>
</li>
<li>
<p>Agent.agent()</p>
</li>
<li>
<p>Agent.fairAgent()</p>
</li>
<li>
<p>Dataflow.task()</p>
</li>
<li>
<p>Dataflow.operator()</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It&#8217;s more a matter of style preferences and personal taste, but we think static imports make the code more compact and readable.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_getting_set_up_in_an_ide">Getting Set Up In An IDE</h3>
<div class="paragraph">
<p>Adding the <strong>GPars</strong> jar files to your project or defining the appropriate dependencies in pom.xml should be
enough to get you started with <strong>GPars</strong> in your IDE.</p>
</div>
<div class="sect3">
<h4 id="__strong_gpars_strong_dsl_recognition"><strong>GPars</strong> DSL recognition</h4>
<div class="paragraph">
<p><strong>IntelliJ IDEA</strong> in both the free <em>Community Edition</em> and the commercial <em>Ultimate Edition</em> will recognize
the <strong>GPars</strong> domain specific languages, complete methods like <em>eachParallel()</em> , <em>reduce()</em> or <em>callAsync()</em>
and validate them. <strong>GPars</strong> uses the
<a href="http://www.jetbrains.net/confluence/display/GRVY/Scripting+IDE+for+DSL+awareness"><strong>Groovy</strong> DSL</a> mechanism,
which teaches IntelliJ IDEA the DSLs as soon as the <strong>GPars</strong> jar file is added to the project.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_applicability_of_concepts">Applicability of Concepts</h3>
<div class="paragraph">
<p><strong>GPars</strong> provides a lot of concepts to pick from. We&#8217;re continuously building and updating our documents to
help users choose the right level of abstraction for their tasks at hands.  Please, refer to <a href="../Concepts_Compared.html">Concepts Compared</a> for details.</p>
</div>
<div class="paragraph">
<p>To briefly summarize the suggestions, here are some basic guide-lines:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You&#8217;re looking at a collection, which needs to be <strong>iterated</strong> or processed using one of the many beautiful
<strong>Groovy</strong> collection methods, like <em>each()</em> , <em>collect()</em> , <em>find()</em> etc.. Suppose that processing each
element of the collection is independent of the other items, then using <strong>GPars</strong> <strong>parallel collections</strong> can be
appropriate.</p>
</li>
<li>
<p>If you have a <strong>long-lasting calculation</strong> , which may safely run in the background, use the <strong>asynchronous
invocation support</strong> in <strong>GPars</strong>. Since <strong>GPars</strong> asynchronous functions can be composed, you can quickly
parallelize tyhese complex functional calculations without having to mark independent calculations explicitly.</p>
</li>
<li>
<p>Say you need to <strong>parallelize</strong> an algorithm. You can identify a set of <strong>tasks</strong> with their mutual
dependencies. The tasks typically do not need to share data, but instead some tasks may need to wait for
other tasks to finish before starting. Now you&#8217;re ready to express these dependencies explicitly in code. With
<strong>GPars</strong> <strong>dataflow tasks</strong>, you create internally sequential tasks, each of which can run concurrently with the
others. <strong>Dataflow</strong> variables and channels provide the tasks with the capability to declare their dependencies and to exchange data safely.</p>
</li>
<li>
<p>Perhaps you can&#8217;t avoid using <strong>shared mutable state</strong> in your logic. Multiple threads will be accessing shared
data and (some of them) modifying it. A traditional locking and synchronized approach feels too risky or
unfamiliar? Then go for <strong>agents</strong> to wrap your data and serialize all access to it.</p>
</li>
<li>
<p>You&#8217;re building a system with high concurrency demands. Tweaking a data structure here or task there won&#8217;t
cut it. You need to build the architecture from the ground up with concurrency in mind. <strong>Message-passing</strong>
might be the way to go. Your choices could include :</p>
<div class="ulist">
<ul>
<li>
<p><strong>Groovy CSP</strong> to give you highly deterministic and composable models for concurrent processes. A model
is organized around the concept of <strong>calculations</strong> or <strong>processes</strong>, which run concurrently and communicate
through synchronous channels.</p>
</li>
<li>
<p>If you&#8217;re trying to solve a complex data-processing problem, consider <strong>GPars</strong> <strong>dataflow operators</strong> to build
a data flow network. The concept is organized around event-driven transformations wired into pipelines
using asynchronous channels.</p>
</li>
<li>
<p><strong>Actors</strong> and <strong>Active Objects</strong> will shine if you need to build a general-purpose, highly concurrent and scalable architecture following the object-oriented paradigm.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Now you may have a better idea of what concepts to use on your current project. Go check out more details on them in our <strong>User Guide</strong>.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_what_s_new">What&#8217;s New</h3>
<div class="paragraph">
<p>The next <strong>GPars</strong> release introduces several enhancements and improvements on top of the previous release, mainly in the dataflow area.</p>
</div>
<div class="paragraph">
<p>Check out the JIRA release notes.</p>
</div>
<hr>
<div class="sect3">
<h4 id="_project_changes">Project Changes</h4>
<div class="sidebarblock">
<div class="content">
<div class="title">Breaking Changes</div>
<div class="paragraph">
<p>See <a href="../Breaking_Changes.html">the Breaking Changes listing</a> for the lists of bug fixes and improvements.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_asynchronous_functions">Asynchronous Functions</h4>
<div class="paragraph">
<p><strong>TBD</strong></p>
</div>
</div>
<div class="sect3">
<h4 id="_parallel_collections">Parallel Collections</h4>
<div class="paragraph">
<p><strong>TBD</strong></p>
</div>
</div>
<div class="sect3">
<h4 id="_fork_join">Fork / Join</h4>
<div class="paragraph">
<p><strong>TBD</strong></p>
</div>
</div>
<div class="sect3">
<h4 id="_actors">Actors</h4>
<div class="ulist">
<ul>
<li>
<p>Remote actors</p>
</li>
<li>
<p>Exception propagation from active objects</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_dataflow">Dataflow</h4>
<div class="ulist">
<ul>
<li>
<p>Remote dataflow variables and channels</p>
</li>
<li>
<p>Dataflow operators accepting variable number arguments</p>
</li>
<li>
<p>Select made @CompileStatic compatible</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_agent">Agent</h4>
<div class="ulist">
<ul>
<li>
<p>Remote agents</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_stm">STM</h4>
<div class="paragraph">
<p><strong>TBD</strong></p>
</div>
</div>
<div class="sect3">
<h4 id="_other">Other</h4>
<div class="ulist">
<ul>
<li>
<p>Raised the JDK dependency to version 1.7</p>
</li>
<li>
<p>Raised the <strong>Groovy</strong> dependency to version 2.2</p>
</li>
<li>
<p>Replaced the <strong>jsr-177y fork-join</strong> pool implementation with the one from JDK 1.7</p>
</li>
<li>
<p>Removed the dependency on <strong>jsr-166y</strong></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="__strong_java_strong_api_using_strong_gpars_strong_from_strong_java_strong"><strong>Java</strong> API – Using <strong>GPars</strong> from <strong>Java</strong></h3>
<div class="paragraph">
<p>Using <strong>GPars</strong> is very addictive, I guarantee. Once you get hooked, you won&#8217;t be able to code without it.  If
the world forces you to write code in <strong>Java</strong>, you&#8217;ll still be able to benefit from many of the <strong>GPars</strong> features.</p>
</div>
<div class="sect3">
<h4 id="__strong_java_strong_api_specifics"><strong>Java</strong> API specifics</h4>
<div class="paragraph">
<p>Some parts of <strong>GPars</strong> are irrelevant in <strong>Java</strong> and it&#8217;s better to use the underlying <strong>Java</strong> libraries directly:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Parallel Collection – use <em>jsr-166y</em> library&#8217;s <strong>Parallel Array</strong> directly until <strong>GPars 2.0</strong> becomes available</p>
</li>
<li>
<p>Fork/Join – use <em>jsr-166y</em> library&#8217;s <strong>Fork/Join</strong> support directly until <strong>GPars 2.0</strong> becomes available</p>
</li>
<li>
<p>Asynchronous functions – use <strong>Java</strong> executor services directly</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The other parts of <strong>GPars</strong> can be used from <strong>Java</strong> just as from <strong>Groovy</strong>, although most will miss the <strong>Groovy</strong> DSL capabilities.</p>
</div>
</div>
<div class="sect3">
<h4 id="__strong_gpars_strong_closures_in_strong_java_strong_api"><strong>GPars</strong> Closures in <strong>Java</strong> API</h4>
<div class="paragraph">
<p>To overcome the lack of closures as a language element in <strong>Java</strong> and to avoid forcing users to use <strong>Groovy</strong> closures directly
through the <strong>Java</strong> API, a few handy wrapper classes have been provided to help you define callbacks, <strong>actor</strong> body or <strong>dataflow</strong> tasks.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>groovyx.gpars.MessagingRunnable - used for single-argument callbacks or <strong>actor</strong> body</p>
</li>
<li>
<p>groovyx.gpars.ReactorMessagingRunnable - used for <strong>ReactiveActor</strong> body</p>
</li>
<li>
<p>groovyx.gpars.DataflowMessagingRunnable - used for <strong>dataflow</strong> operators' body</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These classes can be used in places where the <strong>GPars API</strong> expects a <strong>Groovy</strong> closure.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_actors_2">Actors</h3>
<div class="paragraph">
<p>The <em>DynamicDispatchActor</em> as well as the <em>ReactiveActor</em> classes can be used just like in <strong>Groovy</strong>:</p>
</div>
<div class="listingblock">
<div class="title">A <strong>DynamicDispatchActor</strong> Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td>
  <td class="code"><pre> <span class="keyword">import</span> <span class="include">groovyx.gpars.MessagingRunnable</span>;
 <span class="keyword">import</span> <span class="include">groovyx.gpars.actor.DynamicDispatchActor</span>;

 <span class="directive">public</span> <span class="type">class</span> <span class="class">StatelessActorDemo</span> {
     <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) <span class="directive">throws</span> <span class="exception">InterruptedException</span> {
         <span class="directive">final</span> MyStatelessActor actor = <span class="keyword">new</span> MyStatelessActor();
         actor.start();
         actor.send(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello</span><span class="delimiter">&quot;</span></span>);
         actor.sendAndWait(<span class="integer">10</span>);
         actor.sendAndContinue(<span class="float">10.0</span>, <span class="keyword">new</span> MessagingRunnable&lt;<span class="predefined-type">String</span>&gt;() {
             <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="type">void</span> doRun(<span class="directive">final</span> <span class="predefined-type">String</span> s) {
                 <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Received a reply </span><span class="delimiter">&quot;</span></span> + s);
             }
         });
     }
 }

 <span class="type">class</span> <span class="class">MyStatelessActor</span> <span class="directive">extends</span> DynamicDispatchActor {
     <span class="directive">public</span> <span class="type">void</span> onMessage(<span class="directive">final</span> <span class="predefined-type">String</span> msg) {
         <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Received </span><span class="delimiter">&quot;</span></span> + msg);
         replyIfExists(<span class="string"><span class="delimiter">&quot;</span><span class="content">Thank you</span><span class="delimiter">&quot;</span></span>);
     }

     <span class="directive">public</span> <span class="type">void</span> onMessage(<span class="directive">final</span> <span class="predefined-type">Integer</span> msg) {
         <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Received a number </span><span class="delimiter">&quot;</span></span> + msg);
         replyIfExists(<span class="string"><span class="delimiter">&quot;</span><span class="content">Thank you</span><span class="delimiter">&quot;</span></span>);
     }

     <span class="directive">public</span> <span class="type">void</span> onMessage(<span class="directive">final</span> <span class="predefined-type">Object</span> msg) {
         <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Received an object </span><span class="delimiter">&quot;</span></span> + msg);
         replyIfExists(<span class="string"><span class="delimiter">&quot;</span><span class="content">Thank you</span><span class="delimiter">&quot;</span></span>);
     }
 }</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are few differences between <strong>Groovy</strong> and <strong>Java</strong> for <strong>GPars</strong> use, but notice the callbacks
instantiating the <em>MessagingRunnable</em> class in place of a <strong>Groovy</strong> closure.</p>
</div>
<div class="listingblock">
<div class="title">A <strong>MessagingRunnable</strong> Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovy.lang.Closure</span>;
<span class="keyword">import</span> <span class="include">groovyx.gpars.ReactorMessagingRunnable</span>;
<span class="keyword">import</span> <span class="include">groovyx.gpars.actor.Actor</span>;
<span class="keyword">import</span> <span class="include">groovyx.gpars.actor.ReactiveActor</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">ReactorDemo</span> {
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> args) <span class="directive">throws</span> <span class="exception">InterruptedException</span> {

        <span class="directive">final</span> Closure handler = <span class="keyword">new</span> ReactorMessagingRunnable&lt;<span class="predefined-type">Integer</span>, <span class="predefined-type">Integer</span>&gt;() {
            <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="predefined-type">Integer</span> doRun(<span class="directive">final</span> <span class="predefined-type">Integer</span> integer) {
                <span class="keyword">return</span> integer * <span class="integer">2</span>;
            }
        };
        <span class="directive">final</span> Actor actor = <span class="keyword">new</span> ReactiveActor(handler);
        actor.start();

        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="delimiter">&quot;</span></span> +  actor.sendAndWait(<span class="integer">1</span>));
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="delimiter">&quot;</span></span> +  actor.sendAndWait(<span class="integer">2</span>));
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="delimiter">&quot;</span></span> +  actor.sendAndWait(<span class="integer">3</span>));
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_convenience_factory_methods">Convenience Factory Methods</h3>
<div class="paragraph">
<p>Obviously, all the essential factory methods to build actors quickly are available where you&#8217;d expect them.</p>
</div>
<div class="listingblock">
<div class="title">Factory Samples</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovy.lang.Closure</span>;
<span class="keyword">import</span> <span class="include">groovyx.gpars.ReactorMessagingRunnable</span>;
<span class="keyword">import</span> <span class="include">groovyx.gpars.actor.Actor</span>;
<span class="keyword">import</span> <span class="include">groovyx.gpars.actor.Actors</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">ReactorDemo</span> {
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> args) <span class="directive">throws</span> <span class="exception">InterruptedException</span> {
        <span class="directive">final</span> Closure handler = <span class="keyword">new</span> ReactorMessagingRunnable&lt;<span class="predefined-type">Integer</span>, <span class="predefined-type">Integer</span>&gt;() {
            <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="predefined-type">Integer</span> doRun(<span class="directive">final</span> <span class="predefined-type">Integer</span> integer) {
                <span class="keyword">return</span> integer * <span class="integer">2</span>;
            }
        };
        <span class="directive">final</span> Actor actor = Actors.reactor(handler);

        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="delimiter">&quot;</span></span> +  actor.sendAndWait(<span class="integer">1</span>));
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="delimiter">&quot;</span></span> +  actor.sendAndWait(<span class="integer">2</span>));
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="delimiter">&quot;</span></span> +  actor.sendAndWait(<span class="integer">3</span>));
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_agents">Agents</h3>
<div class="listingblock">
<div class="title">Agent Samples</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td>
  <td class="code"><pre> <span class="keyword">import</span> <span class="include">groovyx.gpars.MessagingRunnable</span>;
 <span class="keyword">import</span> <span class="include">groovyx.gpars.agent.Agent</span>;

 <span class="directive">public</span> <span class="type">class</span> <span class="class">AgentDemo</span> {

     <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> args) <span class="directive">throws</span> <span class="exception">InterruptedException</span> {

         <span class="directive">final</span> Agent counter = <span class="keyword">new</span> Agent&lt;<span class="predefined-type">Integer</span>&gt;(<span class="integer">0</span>);
         counter.send(<span class="integer">10</span>);
         <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Current value: </span><span class="delimiter">&quot;</span></span> + counter.getVal());
         counter.send(<span class="keyword">new</span> MessagingRunnable&lt;<span class="predefined-type">Integer</span>&gt;() {
             <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="type">void</span> doRun(<span class="directive">final</span> <span class="predefined-type">Integer</span> integer) {
                 counter.updateValue(integer + <span class="integer">1</span>);
             }
         });

         <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Current value: </span><span class="delimiter">&quot;</span></span> + counter.getVal());
     }
 }</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_dataflow_concurrency">Dataflow Concurrency</h3>
<div class="paragraph">
<p>Both <em>DataflowVariables</em> and <em>DataflowQueues</em> can be used from <strong>Java</strong> without any hiccups. Just avoid the
handy overloaded operators and go straight to the methods, like <em>bind</em> , <em>whenBound</em>, <em>getVal</em> and other.</p>
</div>
<div class="paragraph">
<p>You may also continue to use <strong>dataflow</strong> tasks passing them instances of <em>Runnable</em> or <em>Callable</em> just like
groovy closures.</p>
</div>
<div class="listingblock">
<div class="title">Dataflow Samples</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.MessagingRunnable</span>;
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowVariable</span>;
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>;

<span class="keyword">import</span> <span class="include">java.util.concurrent.Callable</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">DataflowTaskDemo</span> {

    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> args) <span class="directive">throws</span> <span class="exception">InterruptedException</span> {
        <span class="directive">final</span> DefaultPGroup group = <span class="keyword">new</span> DefaultPGroup(<span class="integer">10</span>);

        <span class="directive">final</span> DataflowVariable a = <span class="keyword">new</span> DataflowVariable();

        group.task(<span class="keyword">new</span> <span class="predefined-type">Runnable</span>() {
            <span class="directive">public</span> <span class="type">void</span> run() {
                a.bind(<span class="integer">10</span>);
            }
        });

        <span class="directive">final</span> Promise result = group.task(<span class="keyword">new</span> <span class="predefined-type">Callable</span>() {
            <span class="directive">public</span> <span class="predefined-type">Object</span> call() <span class="directive">throws</span> <span class="exception">Exception</span> {
                <span class="keyword">return</span> (<span class="predefined-type">Integer</span>)a.getVal() + <span class="integer">10</span>;
            }
        });

        result.whenBound(<span class="keyword">new</span> MessagingRunnable&lt;<span class="predefined-type">Integer</span>&gt;() {
            <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="type">void</span> doRun(<span class="directive">final</span> <span class="predefined-type">Integer</span> integer) {
                <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">arguments = </span><span class="delimiter">&quot;</span></span> + integer);
            }
        });

        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">result = </span><span class="delimiter">&quot;</span></span> + result.getVal());
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_dataflow_operators">Dataflow Operators</h3>
<div class="paragraph">
<p>The sample below should illustrate the main differences between <strong>Groovy</strong> and <strong>Java</strong> APIs for dataflow operators.</p>
</div>
<div class="ulist">
<div class="title">Ideas</div>
<ul>
<li>
<p>Use the convenience factory methods when accepting lists of channels to create operators or selectors</p>
</li>
<li>
<p>Use <em>DataflowMessagingRunnable</em> to specify the operator body</p>
</li>
<li>
<p>Call <em>getOwningProcessor()</em> to get hold of the operator from within the body in order to e.g. bind output values</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">More Dataflow Samples</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.DataflowMessagingRunnable</span>;
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.Dataflow</span>;
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>;
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.operator.DataflowProcessor</span>;

<span class="keyword">import</span> <span class="include">java.util.Arrays</span>;
<span class="keyword">import</span> <span class="include">java.util.List</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">DataflowOperatorDemo</span> {

    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> args) <span class="directive">throws</span> <span class="exception">InterruptedException</span> {
        <span class="directive">final</span> DataflowQueue stream1 = <span class="keyword">new</span> DataflowQueue();
        <span class="directive">final</span> DataflowQueue stream2 = <span class="keyword">new</span> DataflowQueue();
        <span class="directive">final</span> DataflowQueue stream3 = <span class="keyword">new</span> DataflowQueue();
        <span class="directive">final</span> DataflowQueue stream4 = <span class="keyword">new</span> DataflowQueue();

        <span class="directive">final</span> DataflowProcessor op1 = Dataflow.selector(<span class="predefined-type">Arrays</span>.asList(stream1), <span class="predefined-type">Arrays</span>.asList(stream2), <span class="keyword">new</span> DataflowMessagingRunnable(<span class="integer">1</span>) {
            <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="type">void</span> doRun(<span class="directive">final</span> <span class="predefined-type">Object</span>... objects) {
                getOwningProcessor().bindOutput(<span class="integer">2</span>*(<span class="predefined-type">Integer</span>)objects[<span class="integer">0</span>]);
            }
        });

        <span class="directive">final</span> <span class="predefined-type">List</span> secondOperatorInput = <span class="predefined-type">Arrays</span>.asList(stream2, stream3);

        <span class="directive">final</span> DataflowProcessor op2 = Dataflow.operator(secondOperatorInput, <span class="predefined-type">Arrays</span>.asList(stream4), <span class="keyword">new</span> DataflowMessagingRunnable(<span class="integer">2</span>) {
            <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="type">void</span> doRun(<span class="directive">final</span> <span class="predefined-type">Object</span>... objects) {
                getOwningProcessor().bindOutput((<span class="predefined-type">Integer</span>) objects[<span class="integer">0</span>] + (<span class="predefined-type">Integer</span>) objects[<span class="integer">1</span>]);
            }
        });

        stream1.bind(<span class="integer">1</span>);
        stream1.bind(<span class="integer">2</span>);
        stream1.bind(<span class="integer">3</span>);
        stream3.bind(<span class="integer">100</span>);
        stream3.bind(<span class="integer">100</span>);
        stream3.bind(<span class="integer">100</span>);
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="delimiter">&quot;</span></span> + stream4.getVal());
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="delimiter">&quot;</span></span> + stream4.getVal());
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="delimiter">&quot;</span></span> + stream4.getVal());
        op1.stop();
        op2.stop();
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_performance">Performance</h3>
<div class="paragraph">
<p>In general, <strong>GPars</strong> overhead is identical irrespective of whether you use it from <strong>Groovy</strong> or <strong>Java</strong> and it tends to
be very low anyway.  <strong>GPars actors</strong>, for example, can compete head-to-head with other JVM <strong>actor</strong> options, like <strong>Scala
actors</strong>.</p>
</div>
<div class="paragraph">
<p>Since <strong>Groovy</strong> code, in general, runs a little slower than <strong>Java</strong> code, due to dynamic method invocations, you might
consider writing your code in <strong>Java</strong> to improve performance.</p>
</div>
<div class="paragraph">
<p>Typically numeric operations or frequent fine-grained method calls within a task or <strong>actor</strong> body may benefit from a rewrite into <strong>Java</strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_prerequisites">Prerequisites</h3>
<div class="paragraph">
<p>All the <strong>GPars</strong> integration rules apply equally to <strong>Java</strong> projects and <strong>Groovy</strong> projects. You only need
to include the <strong>Groovy</strong> distribution jar file in your project and your are good-to-go.</p>
</div>
<div class="paragraph">
<p>You may also want to check out our sample <strong>Java-Maven</strong> project for tips on how to integrate <strong>GPars</strong> into a <strong>Maven</strong>-based
pure <strong>Java</strong> application – <a href="../Demos.html"><strong>Java</strong> Sample <strong>Maven</strong> Project</a></p>
</div>
<hr>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../images/divider.png" alt="divider" width="436">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_user_guide_to_strong_data_parallelism_strong">User Guide To <strong>Data Parallelism</strong></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Focusing on data instead of processes helps us create robust concurrent programs. As a programmer, you define
your data together with functions that should be applied to it and then let the underlying machinery process
the data.  Typically, a set of concurrent tasks will be created and submitted to a thread pool for
processing.</p>
</div>
<div class="paragraph">
<p>In <strong>GPars</strong>, the <strong>GParsPool</strong> and <strong>GParsExecutorsPool</strong> classes give you access to low-level data parallelism
techniques.  The <strong>GParsPool</strong> class relies on the <strong>Fork/Join</strong> implementation introduced in <strong>JDK 7</strong> and offers
excellent functionality and performance. The <strong>GParsExecutorsPool</strong> is provided for those who still need to
use the older Java executors.</p>
</div>
<div class="paragraph">
<p>There are three fundamental domains covered by the <strong>GPars</strong> low-level data parallelism:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Processing collections concurrently</p>
</li>
<li>
<p>Running functions (closures) asynchronously</p>
</li>
<li>
<p>Performing <strong>Fork/Join</strong> (Divide/Conquer) algorithms</p>
</li>
</ul>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The API described here is based on using <strong>GPars</strong> with <strong>JDK7</strong>. It can be used with later JDKs, but <strong>JDK8</strong>
introduced the <strong>Streams</strong> framework which can be used directly from <strong>Groovy</strong> and, in essence, replaces the <strong>GPars</strong>
features covered here. Work is underway to provide the API described here based on the <strong>JDK8 Streams</strong>
framework for use with <strong>JDK8</strong> and later to provide a simple upgrade path.
</td>
</tr>
</table>
</div>
<hr>
<div class="sect2">
<h3 id="_parallel_collections_2">Parallel Collections</h3>
<div class="paragraph">
<p>Dealing with data frequently involves manipulating collections. Lists, arrays, sets, maps, iterators,
strings. A lot of other data types can be viewed as collections of items.  The common pattern to process
such collections is to take elements sequentially, one-by-one, and make an action for each of the items
in the series.</p>
</div>
<div class="paragraph">
<p>Take, for example, the <em>min</em> function, which is supposed to return the smallest element of a collection.
When you call the <em>min</em> method on a collection of numbers, a variable (<em>minVal</em> say) is created
to store the smallest value seen so far, initialized to some reasonable value for the given type, so for example
for integers and floating points, this may well be zero. The elements of the collection are then iterated
through as each is compared to the stored value. Should a value be less than the one currently held in
<em>minVal</em> then <em>minVal</em> is changed to store the newly seen smaller value.</p>
</div>
<div class="paragraph">
<p>Once all elements have been processed, the minimum value in the collection is stored in the <em>minVal</em>.</p>
</div>
<div class="paragraph">
<p>However simple, this solution is <strong class="red">totally wrong</strong> on multi-core and multi-processor hardware. Running the
<em>min</em> function on a dual-core chip can leverage <strong>at most 50%</strong> of the computing power of the chip.  On a
quad-core, it would be only 25%. So in this latter case, this algorithm effectively wastes 75% of the computing
power of the chip.</p>
</div>
<div class="paragraph">
<p>Tree-like structures prove to be more appropriate for parallel processing.</p>
</div>
<div class="paragraph">
<p>The <em>min</em> function in our example doesn&#8217;t need to iterate through all the elements in row and compare their values with the
<em>minVal</em> variable.  What it can do, instead, is rely on the multi-core/multi-processor nature of our hardware.</p>
</div>
<div class="paragraph">
<p>A <em>parallel_min</em> function can, for example, compare pairs (or tuples of certain size) of neighboring values in the collection and promote the smallest value from the tuple into a next round of comparisons.
Searching for <code>the minimum</code> in different tuples can safely happen in parallel, so tuples in the same round can be processed by different cores at the same time without races or contention among threads.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_meet_parallel_arrays">Meet Parallel Arrays</h3>
<div class="paragraph">
<p>Although not part of <strong>JDK7</strong>, the <strong>extra166y</strong> library brings a very convenient abstraction called <a href="http://groovy.dzone.com/articles/parallelize-your-arrays-with-j">Parallel Arrays</a>, and <strong>GPars</strong> has harnessed this mechanism to provide a very <strong>Groovy API</strong>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">What is <code>extra166y</code> ?</div>
<div class="paragraph">
<p><strong>extra166y</strong> is an implementation of <strong>Java</strong> collections supporting parallel operations using
<strong>Fork-Join</strong> concurrent framework provided by <strong>JSR-166</strong>. It was never made part of the JDK&#8201;&#8212;&#8201;unlike the <strong>jsr166y</strong> library. In fact, <strong>extra166y</strong> was made redundant from <strong>JDK8</strong> onwards by the <strong>Streams</strong> framework.
Therefore, to continue to support <strong>JDK7</strong>, <strong>GPars</strong> includes a copy of <strong>extra166y</strong> in it so there is no external dependency.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>As noted earlier, work is underway to rewrite the <strong>GPars</strong> API in terms of <strong>Streams</strong> for users of <strong>JDK8</strong> onwards. Of course people using <strong>JDK8</strong> onwards can simply use <strong>Streams</strong> directly from <strong>Groovy</strong>.</p>
</div>
<div class="sect3">
<h4 id="_how">How ?</h4>
<div class="paragraph">
<p><strong>GPars</strong> leverages the <code>Parallel Arrays</code> implementation in several ways. The <strong>GParsPool</strong> and <strong>GParsExecutorsPool</strong> classes provide
parallel variants of the common <strong>Groovy</strong> iteration methods like <em>each</em> , <em>collect</em> , <em>findAll</em>, etc.</p>
</div>
<div class="listingblock">
<div class="title">A Parallel Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre> <span class="keyword">def</span> selfPortraits = images.findAllParallel{<span class="local-variable">it</span>.contains me}.collectParallel{<span class="local-variable">it</span>.resize()}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>It also allows for a more functional style <strong>map/reduce</strong> style of collections processing.</p>
</div>
<div class="listingblock">
<div class="title">A Map/Reduce Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre> <span class="keyword">def</span> smallestSelfPortrait = images.parallel.filter{<span class="local-variable">it</span>.contains me}.map{<span class="local-variable">it</span>.resize()}.min{<span class="local-variable">it</span>.sizeInMB}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_gparspool">GParsPool</h3>
<div class="paragraph">
<p>Use of <strong>GParsPool</strong>&#8201;&#8212;&#8201;the <strong>JSR-166y</strong>-based concurrent collection processor</p>
</div>
<div class="sect3">
<h4 id="_usage_2">Usage</h4>
<div class="paragraph">
<p>The <strong>GParsPool</strong> class provides (from <strong>JSR-166y</strong>), a <strong>ParallelArray</strong>-based concurrency DSL for collections and objects.</p>
</div>
</div>
<div class="sect3">
<h4 id="_examples_of_use">Examples of use:</h4>
<div class="listingblock">
<div class="title">Some Parallel Samples</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td>
  <td class="code"><pre><span class="comment">// Summarize numbers concurrently.</span>
GParsPool.withPool {
    <span class="directive">final</span> <span class="predefined-type">AtomicInteger</span> result = <span class="keyword">new</span> <span class="predefined-type">AtomicInteger</span>(<span class="integer">0</span>)
    [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].eachParallel{result.addAndGet(<span class="local-variable">it</span>)}

    <span class="keyword">assert</span> <span class="integer">15</span> == result
}

<span class="comment">// Multiply numbers asynchronously.</span>
GParsPool.withPool {
    <span class="directive">final</span> <span class="predefined-type">List</span> result = [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].collectParallel{<span class="local-variable">it</span> * <span class="integer">2</span>}

    <span class="keyword">assert</span> ([<span class="integer">2</span>, <span class="integer">4</span>, <span class="integer">6</span>, <span class="integer">8</span>, <span class="integer">10</span>].equals(result))
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The passed-in closure takes an instance of a <strong>ForkJoinPool</strong> as a parameter, which can then be freely used inside the closure.</p>
</div>
<div class="listingblock">
<div class="title">A <strong>ForkJoinPool</strong> Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre><span class="comment">// Check whether all elements within a collection meet certain criteria.</span>
GParsPool.withPool(<span class="integer">5</span>){ForkJoinPool pool -&gt;
    <span class="keyword">assert</span> [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].everyParallel{<span class="local-variable">it</span> &gt; <span class="integer">0</span>}

    <span class="keyword">assert</span> ![<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].everyParallel{<span class="local-variable">it</span> &gt; <span class="integer">1</span>}
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>GParsPool.withPool</em> method takes optional parameters for number of threads in the created pool plus an <code>unhandled exceptions</code> handler.</p>
</div>
<div class="listingblock">
<div class="title">An Exception Handler Sample With Number of Threads Required</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre>withPool(<span class="integer">10</span>){...}
withPool(<span class="integer">20</span>, exceptionHandler){...}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pool_reuse">Pool Reuse</h4>
<div class="paragraph">
<p>The <em>GParsPool.withExistingPool</em> takes an already existing <strong>ForkJoinPool</strong> instance to reuse. The DSL is valid only within the associated block of code and only for the thread that has called the <em>withPool</em> or <em>withExistingPool</em> methods. The <em>withPool</em> method returns only after all the worker threads have finished their tasks and the pool has been destroyed, returning the resulting value of the associated block of
code. The <em>withExistingPool</em> method doesn&#8217;t wait for the pool threads to finish.</p>
</div>
<div class="paragraph">
<p>Alternatively, the <strong>GParsPool</strong> class can be statically imported as <em>import static groovyx.gpars.GParsPool</em>, so we can omit the <strong>GParsPool</strong> class name.</p>
</div>
<div class="listingblock">
<div class="title">A Pool Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>withPool {
    <span class="keyword">assert</span> [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].everyParallel{<span class="local-variable">it</span> &gt; <span class="integer">0</span>}
    <span class="keyword">assert</span> ![<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].everyParallel{<span class="local-variable">it</span> &gt; <span class="integer">1</span>}
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The following methods are currently supported on all objects in <strong>Groovy</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>eachParallel</em></p>
</li>
<li>
<p><em>eachWithIndexParallel</em></p>
</li>
<li>
<p><em>collectParallel</em></p>
</li>
<li>
<p><em>collectManyParallel</em></p>
</li>
<li>
<p><em>findAllParallel</em></p>
</li>
<li>
<p><em>findAnyParallel</em></p>
</li>
<li>
<p><em>findParallel</em></p>
</li>
<li>
<p><em>everyParallel</em></p>
</li>
<li>
<p><em>anyParallel</em></p>
</li>
<li>
<p><em>grepParallel</em></p>
</li>
<li>
<p><em>groupByParallel</em></p>
</li>
<li>
<p><em>foldParallel</em></p>
</li>
<li>
<p><em>minParallel</em></p>
</li>
<li>
<p><em>maxParallel</em></p>
</li>
<li>
<p><em>sumParallel</em></p>
</li>
<li>
<p><em>splitParallel</em></p>
</li>
<li>
<p><em>countParallel</em></p>
</li>
<li>
<p><em>foldParallel</em></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_meta_class_enhancer">Meta-class Enhancer</h4>
<div class="paragraph">
<p>As an alternative, you can use the <strong>ParallelEnhancer</strong> class to enhance meta-classes of any classes or individual instances with the parallel methods.</p>
</div>
<div class="listingblock">
<div class="title">An Enhanced Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.ParallelEnhancer</span>

<span class="keyword">def</span> list = [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>, <span class="integer">6</span>, <span class="integer">7</span>, <span class="integer">8</span>, <span class="integer">9</span>]
ParallelEnhancer.enhanceInstance(list)
println list.collectParallel {<span class="local-variable">it</span> * <span class="integer">2</span> }

<span class="keyword">def</span> animals = [<span class="string"><span class="delimiter">'</span><span class="content">dog</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">ant</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">cat</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">whale</span><span class="delimiter">'</span></span>]
ParallelEnhancer.enhanceInstance animals
println (animals.anyParallel {<span class="local-variable">it</span> ==~ <span class="regexp"><span class="delimiter">/</span><span class="content">ant</span><span class="delimiter">/</span></span>} ? <span class="string"><span class="delimiter">'</span><span class="content">Found an ant</span><span class="delimiter">'</span></span> : <span class="string"><span class="delimiter">'</span><span class="content">No ants found</span><span class="delimiter">'</span></span>)
println (animals.everyParallel {<span class="local-variable">it</span>.contains(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>)} ? <span class="string"><span class="delimiter">'</span><span class="content">All animals contain a</span><span class="delimiter">'</span></span> : <span class="string"><span class="delimiter">'</span><span class="content">Some animals can live without an a</span><span class="delimiter">'</span></span>)</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>When using the <strong>ParallelEnhancer</strong> class, you&#8217;re not restricted to a <em>withPool</em> block when using the <strong>GParsPool</strong> DSLs. The enhanced classes or instances remain enhanced till they are garbage collected.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exception_handling">Exception Handling</h4>
<div class="paragraph">
<p>If an exception is thrown while processing any of the passed-in closures, the first exception is re-thrown from the <em>xxxParallel</em> methods and the algorithm stops as soon as possible.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Exception Handling</div>
<div class="paragraph">
<p>The exception handling mechanism of <strong>GParsPool</strong> builds on the one provided in the <strong>Fork/Join</strong> framework.
Since <strong>Fork/Join</strong> algorithms are by nature hierarchical, once any part of the algorithm fails, there&#8217;s usually little benefit continuing the computation, since some branches of the algorithm will never return a result.</p>
</div>
<div class="paragraph">
<p>Bear in mind that the <strong>GParsPool</strong> implementation doesn&#8217;t give any guarantees about its behavior after a first unhandled exception occurs, beyond stopping the algorithm and re-throwing the first detected exception to the caller.
This behavior, after all, is consistent with what the traditional sequential iteration methods do.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_transparently_parallel_collections">Transparently Parallel Collections</h4>
<div class="paragraph">
<p>On top of adding new <em>xxxParallel</em> methods, <strong>GPars</strong> can also let you change the semantics of original iteration methods.</p>
</div>
<div class="paragraph">
<p>For example, you may be passing a collection into a library method, which will process your collection in a sequential way, let&#8217;s say, by using the <em>collect</em> method. Then by changing the semantics of the <em>collect</em> method on your collection, you can effectively parallelize this library sequential code.</p>
</div>
<div class="listingblock">
<div class="title">A makeConcurrent() Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td>
  <td class="code"><pre>GParsPool.withPool {

    <span class="comment">//The selectImportantNames() will process the name collections concurrently</span>
    <span class="keyword">assert</span> [<span class="string"><span class="delimiter">'</span><span class="content">ALICE</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">JASON</span><span class="delimiter">'</span></span>] == selectImportantNames([<span class="string"><span class="delimiter">'</span><span class="content">Joe</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">Alice</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">Dave</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">Jason</span><span class="delimiter">'</span></span>].makeConcurrent())
}

<span class="comment">/**
 * A function implemented using standard sequential collect() and findAll() methods.
 */</span>
<span class="keyword">def</span> <span class="function">selectImportantNames</span>(names) {
    names.collect {<span class="local-variable">it</span>.toUpperCase()}.findAll{<span class="local-variable">it</span>.size() &gt; <span class="integer">4</span>}
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>makeSequential</em> method will reset the collection back to the original sequential semantics.</p>
</div>
<div class="listingblock">
<div class="title">A Sequential Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.withPool</span>

<span class="keyword">def</span> list = [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>, <span class="integer">6</span>, <span class="integer">7</span>, <span class="integer">8</span>, <span class="integer">9</span>]

println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span> list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> } println()

withPool {

    println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span>
    list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
    println()

    list.makeConcurrent()

    println <span class="string"><span class="delimiter">'</span><span class="content">Concurrent: </span><span class="delimiter">'</span></span>
    list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
    println()

    list.makeSequential()

    println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span>
    list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
    println()
}

println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span>
list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
println()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>asConcurrent()</em> convenience method allows us to specify code blocks, where the collection maintains concurrent semantics.</p>
</div>
<div class="listingblock">
<div class="title">An <em>asConcurrent()</em> Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.withPool</span>

<span class="keyword">def</span> list = [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>, <span class="integer">6</span>, <span class="integer">7</span>, <span class="integer">8</span>, <span class="integer">9</span>]

println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span>
list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
println()

withPool {

    println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span>
    list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
    println()

    list.asConcurrent {
        println <span class="string"><span class="delimiter">'</span><span class="content">Concurrent: </span><span class="delimiter">'</span></span>
        list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
        println()
    }

    println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span>
    list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
    println()
}

println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span>
list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
println()</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_code_samples">Code Samples</h4>
<div class="paragraph">
<p>Transparent parallelism, including the <em>makeConcurrent()</em> , <em>makeSequential()</em> and <em>asConcurrent()</em> methods, is also available in combination with our <em>ParallelEnhancer</em> .</p>
</div>
<div class="listingblock">
<div class="title">A ParallelEnhancer Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td>
  <td class="code"><pre><span class="comment">/**
 * A function implemented using standard sequential collect() and findAll() methods.
 */</span>
<span class="keyword">def</span> <span class="function">selectImportantNames</span>(names) {
    names.collect {<span class="local-variable">it</span>.toUpperCase()}.findAll{<span class="local-variable">it</span>.size() &gt; <span class="integer">4</span>}
}

<span class="keyword">def</span> names = [<span class="string"><span class="delimiter">'</span><span class="content">Joe</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">Alice</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">Dave</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">Jason</span><span class="delimiter">'</span></span>]
ParallelEnhancer.enhanceInstance(names)

<span class="comment">//The selectImportantNames() will process the name collections concurrently</span>
<span class="keyword">assert</span> [<span class="string"><span class="delimiter">'</span><span class="content">ALICE</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">JASON</span><span class="delimiter">'</span></span>] == selectImportantNames(names.makeConcurrent())
</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Another ParallelEnhancer Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.ParallelEnhancer</span>

<span class="keyword">def</span> list = [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>, <span class="integer">6</span>, <span class="integer">7</span>, <span class="integer">8</span>, <span class="integer">9</span>]

println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span>
list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
println()

ParallelEnhancer.enhanceInstance(list)

println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span>
list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
println()

list.asConcurrent {
    println <span class="string"><span class="delimiter">'</span><span class="content">Concurrent: </span><span class="delimiter">'</span></span>
    list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
    println()

}
list.makeSequential()

println <span class="string"><span class="delimiter">'</span><span class="content">Sequential: </span><span class="delimiter">'</span></span>
list.each { print <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> }
println()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_avoid_side_effects_in_functions">Avoid Side-Effects in Functions</h3>
<div class="paragraph">
<p>We have to warn you. Since the closures that are provided to the parallel methods like <em>eachParallel</em> or <em>collectParallel()</em> may be run in parallel, you have to make sure that each of the closures is written in a thread-safe manner. The closures must hold no internal state, share data nor have side-effects beyond the boundaries of the single element that they&#8217;ve been invoked on.  Violations of these rules will open the door for race conditions and deadlocks, the most severe enemies of a modern multi-core programmer.</p>
</div>
<hr>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<strong>Don&#8217;t do this !</strong>
</td>
</tr>
</table>
</div>
<hr>
<div class="listingblock">
<div class="title">Concurrently Accessing a non-Thread-Safe Collection</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> thumbnails = <span class="type">[]</span>
images.eachParallel {thumbnails &lt;&lt; <span class="local-variable">it</span>.thumbnail}  <span class="comment">//Concurrently accessing a not-thread-safe collection of thumbnails? Don't do this!</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>At least, you&#8217;ve been warned.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">It May Not Execute The Way You Expect</div>
<div class="paragraph">
<p>Because <strong>GParsPool</strong> uses a <strong>Fork/Join</strong> pool (with work stealing), threads may not be applied to a waiting processing task even though they may appear idle.</p>
</div>
<div class="paragraph">
<p>With a work-stealing algorithm, worker threads that run out of things to do can steal tasks from other threads that are still busy.</p>
</div>
<div class="paragraph">
<p>If you use <strong>GParsExecutorsPool</strong> (which doesn&#8217;t use <strong>Fork/Join</strong>), you&#8217;ll get the thread allocation behavior that you would naively expect.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gparsexecutorspool">GParsExecutorsPool</h3>
<div class="paragraph">
<p>Use of <strong>GParsExecutorsPool</strong> - the <code>Java Executors</code>-based concurrent collection processor -</p>
</div>
</div>
<div class="sect2">
<h3 id="_usage_of_gparsexecutorspool">Usage of GParsExecutorsPool</h3>
<div class="paragraph">
<p>The <strong>GParsPool</strong> classes enable a <code>Java Executors</code>-based concurrency DSL for collections and objects.</p>
</div>
<div class="paragraph">
<p>The <strong>GParsExecutorsPool</strong> class can be used as a pure-JDK-based <code>collections parallel processor</code>. Unlike the <strong>GParsPool</strong> class, <strong>GParsExecutorsPool</strong> doesn&#8217;t require <strong>fork/join</strong> thread pools but, instead, leverages the standard JDK executor services to parallelize closures to process a collection or an object iteratively.</p>
</div>
<div class="paragraph">
<p>It needs to be stated, however, that <strong>GParsPool</strong> typically performs much better than <strong>GParsExecutorsPool</strong> does.</p>
</div>
<hr>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<strong>GParsPool</strong> typically performs much better than <strong>GParsExecutorsPool</strong>
</td>
</tr>
</table>
</div>
<hr>
<div class="sect3">
<h4 id="_examples_of_use_2">Examples of Use</h4>
<div class="listingblock">
<div class="title">A <strong>GParsExecutorsPool</strong> Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td>
  <td class="code"><pre><span class="comment">//multiply numbers asynchronously</span>
 GParsExecutorsPool.withPool {
     <span class="predefined-type">Collection</span>&lt;<span class="predefined-type">Future</span>&gt; result = [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].collectParallel{<span class="local-variable">it</span> * <span class="integer">10</span>}

     <span class="keyword">assert</span> <span class="keyword">new</span> <span class="predefined-type">HashSet</span>([<span class="integer">10</span>, <span class="integer">20</span>, <span class="integer">30</span>, <span class="integer">40</span>, <span class="integer">50</span>]) == <span class="keyword">new</span> <span class="predefined-type">HashSet</span>((<span class="predefined-type">Collection</span>)result*.get())
 }

 <span class="comment">//multiply numbers asynchronously using an asynchronous closure</span>
 GParsExecutorsPool.withPool {
     <span class="keyword">def</span> closure={<span class="local-variable">it</span> * <span class="integer">10</span>}
     <span class="keyword">def</span> asyncClosure=closure.async()

     <span class="predefined-type">Collection</span>&lt;<span class="predefined-type">Future</span>&gt; result = [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].collect(asyncClosure)

     <span class="keyword">assert</span> <span class="keyword">new</span> <span class="predefined-type">HashSet</span>([<span class="integer">10</span>, <span class="integer">20</span>, <span class="integer">30</span>, <span class="integer">40</span>, <span class="integer">50</span>]) == <span class="keyword">new</span> <span class="predefined-type">HashSet</span>((<span class="predefined-type">Collection</span>)result*.get())
 }</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The passed-in closure takes an instance of an <strong>ExecutorService</strong> as a parameter, which can be then used freely inside the closure.</p>
</div>
<div class="listingblock">
<div class="title">Another <strong>GParsExecutorsPool</strong> Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="comment">//find an element meeting specified criteria</span>
 GParsExecutorsPool.withPool(<span class="integer">5</span>) {<span class="predefined-type">ExecutorService</span> service -&gt;
     service.submit({performLongCalculation()} <span class="keyword">as</span> <span class="predefined-type">Runnable</span>)
 }</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>GParsExecutorsPool.withPool()</em> method takes an optional parameter declaring the number of threads in the created pool and a thread factory.</p>
</div>
<div class="listingblock">
<div class="title">An Example Declaring Required Thread Count</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre>withPool(<span class="integer">10</span>) {...}
withPool(<span class="integer">20</span>, threadFactory) {...}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>GParsExecutorsPool.withExistingPool()</em> takes an already existing <code>executor service instance</code> to reuse. The DSL is only valid within the associated block of code and only for the thread that has called the <em>withPool()</em> or <em>withExistingPool()</em> method.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Did you know the <em>withExistingPool()</em> method doesn&#8217;t wait for <code>executor service threads</code> to finish ?
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p>The <em>withPool()</em> method returns control only after all the worker threads have finished their tasks and the executor service has been destroyed, returning the resulting value of the associated block of code.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Statically import the <strong>GParsExecutorsPool</strong> class as import static groovyx.gpars.GParsExecutorsPool.* to omit the <strong>GParsExecutorsPool</strong> class name.
</td>
</tr>
</table>
</div>
<hr>
<div class="listingblock">
<div class="title">A FindParallel Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>withPool {
     <span class="keyword">def</span> result = [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].findParallel{<span class="predefined-type">Number</span> number -&gt; number &gt; <span class="integer">2</span>}
     <span class="keyword">assert</span> result <span class="keyword">in</span> [<span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>]
 }</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The following methods are currently supported on all objects that support iterations in <strong>Groovy</strong> :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>eachParallel()</p>
</li>
<li>
<p>eachWithIndexParallel()</p>
</li>
<li>
<p>collectParallel()</p>
</li>
<li>
<p>findAllParallel()</p>
</li>
<li>
<p>findParallel()</p>
</li>
<li>
<p>allParallel()</p>
</li>
<li>
<p>anyParallel()</p>
</li>
<li>
<p>grepParallel()</p>
</li>
<li>
<p>groupByParallel()</p>
</li>
</ul>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_meta_class_enhancer_2">Meta-class Enhancer</h4>
<div class="paragraph">
<p>As an alternative, you can use the <em>GParsExecutorsPoolEnhancer</em> class to enhance meta-classes for any classes or individual instances having asynchronous methods.</p>
</div>
<div class="listingblock">
<div class="title">Enhancing Your Code</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.GParsExecutorsPoolEnhancer</span>

<span class="keyword">def</span> list = [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>, <span class="integer">6</span>, <span class="integer">7</span>, <span class="integer">8</span>, <span class="integer">9</span>]
GParsExecutorsPoolEnhancer.enhanceInstance(list)
println list.collectParallel {<span class="local-variable">it</span> * <span class="integer">2</span> }

<span class="keyword">def</span> animals = [<span class="string"><span class="delimiter">'</span><span class="content">dog</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">ant</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">cat</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">whale</span><span class="delimiter">'</span></span>]
GParsExecutorsPoolEnhancer.enhanceInstance animals

println (animals.anyParallel {<span class="local-variable">it</span> ==~ <span class="regexp"><span class="delimiter">/</span><span class="content">ant</span><span class="delimiter">/</span></span>} ? <span class="string"><span class="delimiter">'</span><span class="content">Found an ant</span><span class="delimiter">'</span></span> : <span class="string"><span class="delimiter">'</span><span class="content">No ants found</span><span class="delimiter">'</span></span>)
println (animals.allParallel {<span class="local-variable">it</span>.contains(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>)} ? <span class="string"><span class="delimiter">'</span><span class="content">All animals contain a</span><span class="delimiter">'</span></span> : <span class="string"><span class="delimiter">'</span><span class="content">Some animals can live without an a</span><span class="delimiter">'</span></span>)</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>When using the <em>GParsExecutorsPoolEnhancer</em> class, you&#8217;re not restricted to a <em>withPool()</em> block with the
use of the <code>GParsExecutorsPool DSLs</code>. The enhanced classes or instances remain enhanced until they are garbage collected.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exception_handling_2">Exception Handling</h4>
<div class="paragraph">
<p>Exceptions can be thrown while processing any of the passed-in closures. An instance of the <em>AsyncException</em> method will wrap any/all of the original exceptions re-thrown from the xxxParallel methods.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_avoid_side_effects_in_functions_2">Avoid Side-effects in Functions</h3>
<div class="paragraph">
<p>Once again we need to warn you about using closures with side-effects. Please avoid logic that affects objects beyond the scope of the single, currently processed element. Please avoid logic or closures that keep state. Don&#8217;t do that! It&#8217;s dangerous to pass them to any of the <em>xxxParallel()</em> methods.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_memoize">Memoize</h3>
<div class="paragraph">
<p>The <em>memoize</em> function enables caching of a function&#8217;s return values. Repeated calls to the memoized function with the same argument values will, instead of invoking the calculation encoded in the original function, retrieve the resulting value from an internal, transparent cache.</p>
</div>
<div class="paragraph">
<p>Provided the calculation is considerably slower than retrieving a cached value from the cache, developers can trade-off memory for performance.</p>
</div>
<div class="paragraph">
<p>Checkout out the example, where we attempt to scan multiple websites for particular content:</p>
</div>
<div class="paragraph">
<p>The <strong>memoize</strong> functionality of <strong>GPars</strong> was donated to <strong>Groovy</strong> for version 1.8 and if you run on <strong>Groovy</strong> 1.8 or later, we recommend you use the <strong>Groovy</strong> functionality.</p>
</div>
<div class="paragraph">
<p><strong>Memoize</strong>, in <strong>GPars</strong>, is almost identical, except that it searches the memoized caches concurrently using the surrounding thread pool. This may give performance benefits in some scenarios.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Memoize Me Up, Scotty</div>
<div class="paragraph">
<p>The <strong>GPars memoize</strong> functionality has been renamed to avoid future conflicts with the <strong>memoize</strong> functionality in <strong>Groovy</strong>.</p>
</div>
<div class="paragraph">
<p><strong>GPars</strong> now calls these methods with a preceding letter <em>g</em> , such as <em>gmemoize()</em>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_examples_of_use_3">Examples Of Use</h3>
<div class="listingblock">
<div class="title">A <strong>GParsPool</strong> Example With gmemoize()</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td>
  <td class="code"><pre>GParsPool.withPool {
    <span class="keyword">def</span> urls = [<span class="string"><span class="delimiter">'</span><span class="content">http://www.dzone.com</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">http://www.theserverside.com</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">http://www.infoq.com</span><span class="delimiter">'</span></span>]

    Closure download = {url -&gt;
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Downloading </span><span class="inline"><span class="inline-delimiter">$</span>url</span><span class="delimiter">&quot;</span></span>
        url.toURL().text.toUpperCase()
    }

    Closure cachingDownload = download.gmemoize()

    println <span class="string"><span class="delimiter">'</span><span class="content">Groovy sites today: </span><span class="delimiter">'</span></span> + urls.findAllParallel {url -&gt; cachingDownload(url).contains(<span class="string"><span class="delimiter">'</span><span class="content">GROOVY</span><span class="delimiter">'</span></span>)}
    println <span class="string"><span class="delimiter">'</span><span class="content">Grails sites today: </span><span class="delimiter">'</span></span> + urls.findAllParallel {url -&gt; cachingDownload(url).contains(<span class="string"><span class="delimiter">'</span><span class="content">GRAILS</span><span class="delimiter">'</span></span>)}
    println <span class="string"><span class="delimiter">'</span><span class="content">Griffon sites today: </span><span class="delimiter">'</span></span> + urls.findAllParallel {url -&gt; cachingDownload(url).contains(<span class="string"><span class="delimiter">'</span><span class="content">GRIFFON</span><span class="delimiter">'</span></span>)}
    println <span class="string"><span class="delimiter">'</span><span class="content">Gradle sites today: </span><span class="delimiter">'</span></span> + urls.findAllParallel {url -&gt; cachingDownload(url).contains(<span class="string"><span class="delimiter">'</span><span class="content">GRADLE</span><span class="delimiter">'</span></span>)}
    println <span class="string"><span class="delimiter">'</span><span class="content">Concurrency sites today: </span><span class="delimiter">'</span></span> + urls.findAllParallel {url -&gt; cachingDownload(url).contains(<span class="string"><span class="delimiter">'</span><span class="content">CONCURRENCY</span><span class="delimiter">'</span></span>)}
    println <span class="string"><span class="delimiter">'</span><span class="content">GPars sites today: </span><span class="delimiter">'</span></span> + urls.findAllParallel {url -&gt; cachingDownload(url).contains(<span class="string"><span class="delimiter">'</span><span class="content">GPARS</span><span class="delimiter">'</span></span>)}
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how closures are enhanced inside the <em>GParsPool.withPool()</em> blocks with a <em>memoize()</em> function. This returns a new closure wrapping the original closure as a cache entry.</p>
</div>
<div class="paragraph">
<p>In the previous example, we&#8217;re calling the <em>cachingDownload</em> function in several places in the code, however, each unique url is downloaded only once - the first time it&#8217;s needed. The values are then cached and available for subsequent calls. Additionally, these values are also available to all threads, no matter which thread originally came first with a download request  for that particular url and had to handle the actual calculation/download.</p>
</div>
<div class="paragraph">
<p>So, to wrap up, a <strong>memoize</strong> call shields a function by using a cache of past return values.</p>
</div>
<div class="paragraph">
<p>However, <em>memoize</em> can do even more! In some algorithms, adding a little memory may have a dramatic impact on the computational complexity of the calculation. Let&#8217;s look at a classical example of <code>Fibonacci</code> numbers.</p>
</div>
</div>
<div class="sect2">
<h3 id="_fibonacci_example">Fibonacci Example</h3>
<div class="paragraph">
<p>A purely functional, recursive implementation that follows the definition of Fibonacci numbers is exponentially complex:</p>
</div>
<div class="listingblock">
<div class="title">A Fibonacci Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>Closure fib = {n -&gt; n &gt; <span class="integer">1</span> ? call(n - <span class="integer">1</span>) + call(n - <span class="integer">2</span>) : n}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Try calling the <em>fib</em> function with numbers around 30 and you&#8217;ll see how slow it is.</p>
</div>
<div class="paragraph">
<p>Now with a little twist and an added <strong>memoize</strong> cache, the algorithm magically turns into a linearly complex one:</p>
</div>
<div class="listingblock">
<div class="title">A Better Version of the Fibonacci Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre>Closure fib
fib = {n -&gt; n &gt; <span class="integer">1</span> ? fib(n - <span class="integer">1</span>) + fib(n - <span class="integer">2</span>) : n}.gmemoize()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The extra memory we added has now cut off all but one recursive branch of the calculation. And all subsequent calls to the same <em>fib</em> function will also benefit from the cached values.</p>
</div>
<div class="paragraph">
<p>Look below to see how the <em>memoizeAtMost</em> variant can reduce memory consumption in our example, yet preserve the linear complexity of the algorithm.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_available_variants">Available Variants</h3>
<div class="sect3">
<h4 id="_memoize_2">Memoize</h4>
<div class="paragraph">
<p>The basic variant keeps values in the internal cache for the whole lifetime of the memoized function. It provides the best performance characteristics of all the variants.</p>
</div>
</div>
<div class="sect3">
<h4 id="_memoizeatmost">memoizeAtMost</h4>
<div class="paragraph">
<p>Allows us to set a hard limit on number of items cached. Once the limit has been reached, all subsequently added values will eliminate the oldest value from the cache using the <strong>LRU</strong> (<code>Last Recently Used</code>) strategy.</p>
</div>
<div class="paragraph">
<p>So for our Fibonacci number example, we could safely reduce the cache size to two items:</p>
</div>
<div class="listingblock">
<div class="title">A Cached Fibonacci Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre>Closure fib
fib = {n -&gt; n &gt; <span class="integer">1</span> ? fib(n - <span class="integer">1</span>) + fib(n - <span class="integer">2</span>) : n}.memoizeAtMost(<span class="integer">2</span>)</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Setting an upper limit on the cache size serves two purposes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Keeps the memory footprint of the cache within defined boundaries</p>
</li>
<li>
<p>Preserves desired performance characteristics of the function. Too large a cache increases the time to retrieve a cached value, compared to the time it would have taken to calculate the result directly.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_memoizeatleast">memoizeAtLeast</h4>
<div class="paragraph">
<p>Allows unlimited growth of the internal cache until the JVM&#8217;s garbage collector decides to step in and evict a <code>SoftReferences</code> entry (used by our implementation) from the memory.</p>
</div>
<div class="paragraph">
<p>The single parameter to the <em>memoizeAtLeast()</em> method indicates the minimum number of cached items that should be protected from gc eviction. The cache will never shrink below the specified number of entries.  The cache ensures it only protects the most recently used items from eviction using the LRU (<code>Last Recently Used</code>) strategy.</p>
</div>
</div>
<div class="sect3">
<h4 id="_memoizebetween">memoizeBetween</h4>
<div class="paragraph">
<p>Combines the <strong>memoizeAtLeast</strong> and <strong>memoizeAtMost</strong> methods to allow the cache to grow and shrink in the range between the two parameter values depending on available memory and the gc activity.</p>
</div>
<div class="paragraph">
<p>The cache size will never exceed the upper size limit to preserve desired performance characteristics of the cache.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_map_reduce">Map-Reduce</h3>
<div class="paragraph">
<p>The <code>Parallel Collection Map/Reduce</code> DSL gives <strong>GPars</strong> a more functional flavor. In general, the <code>Map/Reduce DSL</code> may be used for the same purpose as the <em>xxxParallel()</em> family of methods and has very similar semantics.  On the other hand, <strong>Map/Reduce</strong> can perform considerably faster, if you need to chain multiple methods together to process a single collection in multiple steps:</p>
</div>
<div class="listingblock">
<div class="title">A <strong>Map-Reduce</strong> Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>    println <span class="string"><span class="delimiter">'</span><span class="content">Number of occurrences of the word GROOVY today: </span><span class="delimiter">'</span></span> + urls.parallel
            .map {<span class="local-variable">it</span>.toURL().text.toUpperCase()}
            .filter {<span class="local-variable">it</span>.contains(<span class="string"><span class="delimiter">'</span><span class="content">GROOVY</span><span class="delimiter">'</span></span>)}
            .map{<span class="local-variable">it</span>.split()}
            .map{<span class="local-variable">it</span>.findAll{word -&gt; word.contains <span class="string"><span class="delimiter">'</span><span class="content">GROOVY</span><span class="delimiter">'</span></span>}.size()}
            .sum()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>xxxParallel()</em> methods must follow the same contract as their non-parallel peers. So a <em>collectParallel()</em> method must return a legal collection of items, which you can treat as a <strong>Groovy</strong> collection.</p>
</div>
<div class="paragraph">
<p>Internally, the <em>parallel collect method</em> builds an efficient parallel structure, called a <code>parallel array</code>. It then performs the required operation concurrently. Before returning, it destroys the <em>Parallel Array</em> as it builds a collection of results to return to you.
A potential call to, for example, <em>findAllParallel()</em> on the resulting collection would repeat the whole process of construction and destruction of a <code>Parallel Array</code> instance under the covers.</p>
</div>
<div class="paragraph">
<p>With <strong>Map/Reduce</strong>, you turn your collection into a <code>Parallel Array</code> and back again only a single time. The <strong>Map/Reduce</strong> family of methods do not return <strong>Groovy</strong> collections, but can freely pass along the internal <code>Parallel Arrays</code> directly.</p>
</div>
<div class="paragraph">
<p>Invoking the <em>parallel</em> property of a collection will build a <code>Parallel Array</code> for the collection and then return a thin wrapper around the <code>Parallel Array</code> instance.  Then you can chain any of these methods together to get an answer :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>map()</p>
</li>
<li>
<p>reduce()</p>
</li>
<li>
<p>filter()</p>
</li>
<li>
<p>size()</p>
</li>
<li>
<p>sum()</p>
</li>
<li>
<p>min()</p>
</li>
<li>
<p>max()</p>
</li>
<li>
<p>sort()</p>
</li>
<li>
<p>groupBy()</p>
</li>
<li>
<p>combine()</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Returning a plain <strong>Groovy</strong> collection instance is always just a matter of retrieving the <em>collection</em> property.</p>
</div>
<div class="listingblock">
<div class="title">A <strong>Map-Reduce</strong> Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> myNumbers = (<span class="integer">1</span>..<span class="integer">1000</span>).parallel.filter{<span class="local-variable">it</span> % <span class="integer">2</span> == <span class="integer">0</span>}.map{<span class="predefined-type">Math</span>.sqrt <span class="local-variable">it</span>}.collection</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_avoid_side_effects_in_functions_3">Avoid Side-effects in Functions</h3>
<div class="paragraph">
<p>Once again we need to warn you. To avoid nasty surprises, please, keep any closures you pass to the <strong>Map/Reduce</strong> functions, stateless and clean from side-effects.</p>
</div>
<hr>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
To avoid nasty surprises keep your closures stateless
</td>
</tr>
</table>
</div>
<hr>
<div class="sect3">
<h4 id="_availability">Availability</h4>
<div class="paragraph">
<p>This feature is only available when using in the <strong>Fork/Join</strong>-based <strong>GParsPool</strong> , not in the <strong>GParsExecutorsPool</strong> method.</p>
</div>
</div>
<div class="sect3">
<h4 id="_classical_example">Classical Example</h4>
<div class="paragraph">
<p>A classical example, inspired by <a href="http://github.com/thevery">thevery</a>, counts occurrences of words in a string:</p>
</div>
<div class="listingblock">
<div class="title">A Telling Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.withPool</span>

<span class="keyword">def</span> words = <span class="string"><span class="delimiter">&quot;</span><span class="content">This is just plain text to count words in</span><span class="delimiter">&quot;</span></span>
print count(words)

<span class="keyword">def</span> <span class="function">count</span>(arg) {

  withPool {

    <span class="keyword">return</span> arg.parallel
      .map{[<span class="local-variable">it</span>, <span class="integer">1</span>]}
      .groupBy{<span class="local-variable">it</span>[<span class="integer">0</span>]}.getParallel()
      .map {<span class="local-variable">it</span>.value=<span class="local-variable">it</span>.value.size();<span class="local-variable">it</span>}
      .sort{-<span class="local-variable">it</span>.value}.collection
  }

}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The same example can be implemented with the more general <em>combine</em> operation:</p>
</div>
<div class="listingblock">
<div class="title">A <em>Combine</em> Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> words = <span class="string"><span class="delimiter">&quot;</span><span class="content">This is just plain text to count words in</span><span class="delimiter">&quot;</span></span>
print count(words)

<span class="keyword">def</span> <span class="function">count</span>(arg) {

  withPool {
    <span class="keyword">return</span> arg.parallel
      .map{[<span class="local-variable">it</span>, <span class="integer">1</span>]}
      .combine(<span class="integer">0</span>) {sum, value -&gt; sum + value}.getParallel()
      .sort{-<span class="local-variable">it</span>.value}.collection
  }

}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_combine">Combine</h3>
<div class="paragraph">
<p>The <em>combine</em> operation expects an input list of tuples (two-element lists), often considered to be key-value pairs (such as [ [key1, value1], [key2, value2], [key1, value3], [key3, value4] &#8230;&#8203; ] ). These might have potentially repeating keys.</p>
</div>
<div class="paragraph">
<p>When invoked, the <em>combine</em> method merges the values of identical keys using the provided accumulator function. This produces a map of the original (unique) keys and their (now) accumulated values.</p>
</div>
<div class="paragraph">
<p>E.g. <a id="a"></a> will be combined into [a : b+e, c : d+f]. Some logic like the '+' operation for the values will need to be provided as the accumulation closure logic.</p>
</div>
<div class="paragraph">
<p>The <em>accumulation function</em> argument needs to specify a function to use when combining (accumulating) values belonging to the same key.  An <em>initial accumulator value</em> needs to be provided as well.</p>
</div>
<div class="paragraph">
<p>Since the <em>combine</em> method processes items in parallel, the <em>initial accumulator value</em> will be reused multiple times. Thus the provided value must allow for reuse.</p>
</div>
<div class="paragraph">
<p>It should either be a <strong>cloneable</strong> (or <strong>immutable</strong>) value or a <strong>closure</strong> returning a fresh initial accumulator each time it&#8217;s requested.  Good combinations of accumulator functions and reusable initial values include:</p>
</div>
<div class="listingblock">
<div class="title">Some Examples of a Combining-Accumulator Function and Reusable Initial Value</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>accumulator = {<span class="predefined-type">List</span> acc, value -&gt; acc &lt;&lt; value} initialValue = <span class="type">[]</span>
accumulator = {<span class="predefined-type">List</span> acc, value -&gt; acc &lt;&lt; value} initialValue = {-&gt; <span class="type">[]</span>}
accumulator = {<span class="type">int</span> sum, <span class="type">int</span> value -&gt; acc + value} initialValue = <span class="integer">0</span>
accumulator = {<span class="type">int</span> sum, <span class="type">int</span> value -&gt; sum + value} initialValue = {-&gt; <span class="integer">0</span>}
accumulator = {ShoppingCart cart, Item value -&gt; cart.addItem(value)} initialValue = {-&gt; <span class="keyword">new</span> ShoppingCart()}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The return type is a map.
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p>E.g. [['he', 1], ['she', 2], ['he', 2], ['me', 1], ['she', 5], ['he', 1]] with an initial value of zero will combine into ['he' : 4, 'she' : 7, 'me' : 1]</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Comparion Logic</div>
<div class="paragraph">
<p>The keys will be mutually compared using their <strong>equals</strong> and <strong>hashCode</strong> methods. Consider using <em>@Canonical</em> or <em>@EqualsAndHashCode</em> annotations to annotate objects you use as keys.</p>
</div>
<div class="paragraph">
<p>As with all hash maps in <strong>Groovy</strong>, be sure you&#8217;re using a <strong>String</strong> not a <strong>GString</strong> as a key!</p>
</div>
</div>
</div>
<div class="paragraph">
<p>For more involved scenarios when you <em>combine()</em> complex objects, a good strategy here is to have a complete class to use as a key for common use cases and to apply different keys for uncommon cases.</p>
</div>
<div class="listingblock">
<div class="title">A Complex Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovy.transform.ToString</span>
<span class="keyword">import</span> <span class="include">groovy.transform.TupleConstructor</span>

<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.withPool</span>

<span class="comment">// declare a complete class to use in combination processing</span>
<span class="annotation">@TupleConstructor</span> <span class="annotation">@ToString</span>
<span class="type">class</span> <span class="class">PricedCar</span> <span class="directive">implements</span> <span class="predefined-type">Cloneable</span> {        <span class="comment">// either Clonable or Immutable</span>
    <span class="predefined-type">String</span> model
    <span class="predefined-type">String</span> color
    <span class="predefined-type">Double</span> price

        <span class="comment">// declare a way to resolve comparison logic</span>
    <span class="type">boolean</span> equals(<span class="directive">final</span> o) {
        <span class="keyword">if</span> (<span class="local-variable">this</span>.is(o)) <span class="keyword">return</span> <span class="predefined-constant">true</span>
        <span class="keyword">if</span> (getClass() != o.class) <span class="keyword">return</span> <span class="predefined-constant">false</span>

        <span class="directive">final</span> PricedCar pricedCar = (PricedCar) o

        <span class="keyword">if</span> (color != pricedCar.color) <span class="keyword">return</span> <span class="predefined-constant">false</span>
        <span class="keyword">if</span> (model != pricedCar.model) <span class="keyword">return</span> <span class="predefined-constant">false</span>

        <span class="keyword">return</span> <span class="predefined-constant">true</span>
    }

    <span class="type">int</span> hashCode() {
        <span class="type">int</span> result
        result = (model != <span class="predefined-constant">null</span> ? model.hashCode() : <span class="integer">0</span>)
        result = <span class="integer">31</span> * result + (color != <span class="predefined-constant">null</span> ? color.hashCode() : <span class="integer">0</span>)
        <span class="keyword">return</span> result
    }

    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="predefined-type">Object</span> clone() {
        <span class="keyword">return</span> <span class="local-variable">super</span>.clone()
    }
}

<span class="comment">// some data</span>
<span class="keyword">def</span> cars = [<span class="keyword">new</span> PricedCar(<span class="string"><span class="delimiter">'</span><span class="content">F550</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">blue</span><span class="delimiter">'</span></span>, <span class="float">2342.223</span>),
        <span class="keyword">new</span> PricedCar(<span class="string"><span class="delimiter">'</span><span class="content">F550</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">red</span><span class="delimiter">'</span></span>, <span class="float">234.234</span>),
        <span class="keyword">new</span> PricedCar(<span class="string"><span class="delimiter">'</span><span class="content">Da</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">white</span><span class="delimiter">'</span></span>, <span class="float">2222.2</span>),
        <span class="keyword">new</span> PricedCar(<span class="string"><span class="delimiter">'</span><span class="content">Da</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">white</span><span class="delimiter">'</span></span>, <span class="float">1111.1</span>)]


withPool {
    <span class="comment">//Combine by model</span>
    <span class="keyword">def</span> result =
        cars.parallel.map {
            [<span class="local-variable">it</span>.model, <span class="local-variable">it</span>]
        }.combine(<span class="keyword">new</span> PricedCar(<span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">N/A</span><span class="delimiter">'</span></span>, <span class="float">0.0</span>)) {sum, value -&gt;
            sum.model = value.model
            sum.price += value.price
            sum
        }.values()

    println result


    <span class="comment">//Combine by model and color (using the PricedCar's equals and hashCode))</span>
    result =
        cars.parallel.map {
            [<span class="local-variable">it</span>, <span class="local-variable">it</span>]
        }.combine(<span class="keyword">new</span> PricedCar(<span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">N/A</span><span class="delimiter">'</span></span>, <span class="float">0.0</span>)) {sum, value -&gt;
            sum.model = value.model
            sum.color = value.color
            sum.price += value.price
            sum
        }.values()

    println result
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_parallel_arrays">Parallel Arrays</h3>
<div class="paragraph">
<p>As an alternative, the efficient tree-based data structures defined in <a href="https://en.wikipedia.org/wiki/Java_concurrency"><strong>JSR-166y</strong> - Java Concurrency</a> can be used directly. The <em>parallelArray</em> property on any collection or object will return a <em>ParallelArray</em> instance holding the elements of the original collection. These then can be manipulated through the <a href="https://en.wikipedia.org/wiki/Java_concurrency"><strong>jsr166y</strong></a> API.</p>
</div>
<div class="paragraph">
<p>Please refer to <a href="https://en.wikipedia.org/wiki/Java_concurrency"><strong>jsr166y</strong></a> documentation for API details.</p>
</div>
<div class="listingblock">
<div class="title">A Parallel Array Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.extra166y.Ops</span>

groovyx.gpars.GParsPool.withPool {

    <span class="keyword">assert</span> <span class="integer">15</span> == [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].parallelArray.reduce({a, b -&gt; a + b} <span class="keyword">as</span> Ops.Reducer, <span class="integer">0</span>)                                        <span class="comment">//summarize</span>

    <span class="keyword">assert</span> <span class="integer">55</span> == [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].parallelArray.withMapping({<span class="local-variable">it</span> ** <span class="integer">2</span>} <span class="keyword">as</span> Ops.Op).reduce({a, b -&gt; a + b} <span class="keyword">as</span> Ops.Reducer, <span class="integer">0</span>)       <span class="comment">//summarize squares</span>

    <span class="keyword">assert</span> <span class="integer">20</span> == [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>].parallelArray.withFilter({<span class="local-variable">it</span> % <span class="integer">2</span> == <span class="integer">0</span>} <span class="keyword">as</span> Ops.Predicate)                                       <span class="comment">//summarize squares of even numbers</span>
            .withMapping({<span class="local-variable">it</span> ** <span class="integer">2</span>} <span class="keyword">as</span> Ops.Op)
            .reduce({a, b -&gt; a + b} <span class="keyword">as</span> Ops.Reducer, <span class="integer">0</span>)

    <span class="keyword">assert</span> <span class="string"><span class="delimiter">'</span><span class="content">aa:bb:cc:dd:ee</span><span class="delimiter">'</span></span> == <span class="string"><span class="delimiter">'</span><span class="content">abcde</span><span class="delimiter">'</span></span>.parallelArray                                                                            <span class="comment">//concatenate duplicated characters with separator</span>
            .withMapping({<span class="local-variable">it</span> * <span class="integer">2</span>} <span class="keyword">as</span> Ops.Op)
            .reduce({a, b -&gt; <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>a</span><span class="content">:</span><span class="inline"><span class="inline-delimiter">$</span>b</span><span class="delimiter">&quot;</span></span>} <span class="keyword">as</span> Ops.Reducer, <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_asynchronous_invocations">Asynchronous Invocations</h3>
<div class="paragraph">
<p>Long running background tasks happen a lot in most systems.</p>
</div>
<div class="paragraph">
<p>Typically, a main thread of execution wants to initialize a few calculations, start downloads, do searches, etc. even when the results may not be needed immediately.</p>
</div>
<div class="paragraph">
<p><strong>GPars</strong> gives the developers the tools to schedule asynchronous activities for background processing and collect the results later, when they&#8217;re needed.</p>
</div>
<div class="sect3">
<h4 id="_usage_of_strong_gparspool_strong_and_strong_gparsexecutorspool_strong_asynchronous_processing_facilities">Usage of <strong>GParsPool</strong> and <strong>GParsExecutorsPool</strong> Asynchronous Processing Facilities</h4>
<div class="paragraph">
<p>Both <strong>GParsPool</strong> and <strong>GParsExecutorsPool</strong> methods provide nearly identical services while leveraging different underlying machinery.</p>
</div>
</div>
<div class="sect3">
<h4 id="_closures_enhancements">Closures Enhancements</h4>
<div class="paragraph">
<p>The following methods are added to closures inside the <em>GPars(Executors)Pool.withPool()</em> blocks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>async() - To create an asynchronous variant of the supplied closure which, when invoked, returns a <strong>future</strong> object for the potential return value</p>
</li>
<li>
<p>callAsync() - Calls a closure in a separate thread while supplying the given arguments, returning a <strong>future</strong> object for the potential return value,</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">An <strong>async()</strong> Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre>GParsPool.withPool() {
    Closure longLastingCalculation = {calculate()}
    Closure fastCalculation = longLastingCalculation.async()  <span class="comment">//create a new closure, which starts the original closure on a thread pool</span>

    <span class="predefined-type">Future</span> result=fastCalculation()                           <span class="comment">//returns almost immediately</span>

    <span class="comment">//do stuff while calculation performs ...</span>
    println result.get()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">A <strong>callAsync()</strong> Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre>GParsPool.withPool() {
    <span class="comment">/**
     * The callAsync() method is an asynchronous variant of the default call() method to invoke a closure.
     * It will return a Future for the result value.
     */</span>
    <span class="keyword">assert</span> <span class="integer">6</span> == {<span class="local-variable">it</span> * <span class="integer">2</span>}.call(<span class="integer">3</span>)
    <span class="keyword">assert</span> <span class="integer">6</span> == {<span class="local-variable">it</span> * <span class="integer">2</span>}.callAsync(<span class="integer">3</span>).get()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_timeouts">Timeouts</h4>
<div class="paragraph">
<p>The <em>callTimeoutAsync()</em> methods, taking either a long value or a <strong>Duration</strong> instance, provides a timer mechanism.</p>
</div>
<div class="listingblock">
<div class="title">A Timed Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>{-&gt;
    <span class="keyword">while</span>(<span class="predefined-constant">true</span>) {
        <span class="predefined-type">Thread</span>.sleep <span class="integer">1000</span>  <span class="comment">//Simulate a bit of interesting calculation</span>
        <span class="keyword">if</span> (<span class="predefined-type">Thread</span>.currentThread().isInterrupted()) <span class="keyword">break</span>;  <span class="comment">//We've been cancelled</span>
    }
}.callTimeoutAsync(<span class="integer">2000</span>)</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>To allow cancellation, our asynchronously running code must keep checking the <em>interrupted</em> flag of it&#8217;s own thread and stop calculating when/if the flag is set to true.</p>
</div>
</div>
<div class="sect3">
<h4 id="_executor_service_enhancements">Executor Service Enhancements</h4>
<div class="paragraph">
<p>The <strong>ExecutorService</strong> and <strong>ForkJoinPool</strong> classes are enhanced with the <strong class="red">'&lt;&lt;'</strong> (leftShift) operator to submit tasks to the pool and return a <em>Future</em> for the result.</p>
</div>
<div class="listingblock">
<div class="title">A Convenient Example Using [red]'&lt;&lt;'</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>GParsExecutorsPool.withPool {<span class="predefined-type">ExecutorService</span> executorService -&gt;
    executorService &lt;&lt; {println <span class="string"><span class="delimiter">'</span><span class="content">Inside parallel task</span><span class="delimiter">'</span></span>}
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_running_functions_closures_in_parallel">Running Functions (closures) in Parallel</h4>
<div class="paragraph">
<p>The <strong>GParsPool</strong> and <strong>GParsExecutorsPool</strong> classes also provide handy methods <em>executeAsync()</em> and
<em>executeAsyncAndWait()</em> to easily run multiple closures asynchronously.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="title">An Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>GParsPool.withPool {
    <span class="keyword">assert</span> [<span class="integer">10</span>, <span class="integer">20</span>] == GParsPool.executeAsyncAndWait({calculateA()}, {calculateB()}         <span class="comment">//waits for results</span>
    <span class="keyword">assert</span> [<span class="integer">10</span>, <span class="integer">20</span>] == GParsPool.executeAsync({calculateA()}, {calculateB()})*.get()  <span class="comment">//returns Futures instead and doesn't wait for results to be calculated</span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_composable_asynchronous_functions">Composable Asynchronous Functions</h3>
<div class="paragraph">
<p>Functions are to be composed. In fact, composing side-effect-free functions is very easy. Much easier and more reliable than composing objects, for example.</p>
</div>
<div class="paragraph">
<p>Given the same input, functions always return the same result, they never change their behavior unexpectedly nor they break when multiple threads call them at the same time.</p>
</div>
<div class="sect3">
<h4 id="_functions_in_strong_groovy_strong">Functions in <strong>Groovy</strong></h4>
<div class="paragraph">
<p>We can treat <strong>Groovy</strong> closures as functions. They take arguments, do their calculation and return a value. Provided you don&#8217;t let your closures touch anything outside their scope,
your closures are well-behaved, just like pure functions. Functions that you can combine for a higher good.</p>
</div>
<div class="listingblock">
<div class="title">A Higher Good Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> sum = (<span class="integer">0</span>..<span class="integer">100000</span>).inject(<span class="integer">0</span>, {a, b -&gt; a + b})</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>For this example, by combining a function adding two numbers <code>{a,b}</code> with the <em>inject</em> function, which iterates through the whole collection, you can quickly summarize all items.
Then, replacing the <em>adding</em> function with a <em>comparison</em> function immediately gives you a combined function to calculate maximums.</p>
</div>
<div class="listingblock">
<div class="title">Find The Maximums</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> max = myNumbers.inject(<span class="integer">0</span>, {a, b -&gt; a&gt;b?a:b})</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>You see, functional programming is popular for a reason.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_are_we_concurrent_yet">Are We Concurrent Yet?</h3>
<div class="paragraph">
<p>This all works just fine until you realize you&#8217;re not using the full power of your expensive hardware. These functions are just plain sequential! No parallelism is used!
All but one processor core is doing nothing, they&#8217;re idle, totally wasted!</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">A Generic Way to Use Asynchronous Functions</div>
<div class="paragraph">
<p>Those paying attention might decide to use the <em>Parallel Collection</em> techniques described earlier and they would certainly be correct.</p>
</div>
<div class="paragraph">
<p>For our scenario described here, where we process a collection, using those <em>parallel</em> methods would be the best choice. However, we&#8217;re now looking for a generic way to create and combine asynchronous functions.
This would help us, not only for collections processing, but mostly in other, more generic, cases like the one right below.</p>
</div>
</div>
</div>
<hr>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
All but one processor core is doing nothing! They&#8217;re idle! Totally wasted!
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p>To make things more obvious, here&#8217;s an example of combining four functions, which are supposed to check
whether a particular web page matches the contents of a local file.  We need to download the page, load the
file, calculate hashes of both and finally compare the resulting numbers.</p>
</div>
<div class="listingblock">
<div class="title">An Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td>
  <td class="code"><pre>Closure download = {<span class="predefined-type">String</span> url -&gt;
    url.toURL().text
}

Closure loadFile = {<span class="predefined-type">String</span> fileName -&gt;
    ...  <span class="comment">//load the file here</span>
}

Closure hash = {s -&gt; s.hashCode()}

Closure compare = {<span class="type">int</span> first, <span class="type">int</span> second -&gt;
    first == second
}

<span class="keyword">def</span> result = compare(hash(download(<span class="string"><span class="delimiter">'</span><span class="content">http://www.gpars.org</span><span class="delimiter">'</span></span>)), hash(loadFile(<span class="string"><span class="delimiter">'</span><span class="content">/coolStuff/gpars/website/index.html</span><span class="delimiter">'</span></span>)))
println <span class="string"><span class="delimiter">&quot;</span><span class="content">The result of comparison: </span><span class="delimiter">&quot;</span></span> + result</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>We need to download the page, load up the file, calculate hashes of both and finally compare the resulting
numbers.  Each of the functions is responsible for one particular job. One function downloads the content, a second
loads the file, and a third calculates the hashes and finally the fourth one will do the comparison.</p>
</div>
<div class="paragraph">
<p>Combining the functions is as simple as nesting their calls.</p>
</div>
<hr>
<div class="sect3">
<h4 id="_making_it_all_asynchronous">Making It All Asynchronous</h4>
<div class="paragraph">
<p>The downside of our code is that we haven&#8217;t leveraged the independence of the <em>download()</em> and the <em>loadFile()</em> functions.  Neither have we allowed the two hashes to be run concurrently.
They could well run in parallel, but our approach to combine functions restricts parallelism.</p>
</div>
<div class="paragraph">
<p>Obviously not all of the functions <strong>can</strong> run concurrently. Some functions depend on results of others. They cannot start before the other function finishes.
We need to block them until their parameters are available. The <em>hash()</em> functions needs a string to work on. The <em>compare()</em> function needs two numbers to compare.</p>
</div>
<div class="paragraph">
<p>So we can only take parallelism so far, while blocking parallelism of others. Seems like a challenging task.</p>
</div>
</div>
<div class="sect3">
<h4 id="_things_are_bright_in_the_functional_world">Things Are Bright in the Functional World</h4>
<div class="paragraph">
<p>Luckily, the dependencies between functions are already expressed implicitly in the code. There&#8217;s no need to duplicate that dependency information.
If one functions takes parameters and the parameters need to be calculated first by another function, we implicitly have a dependency here.</p>
</div>
<div class="paragraph">
<p>The <em>hash()</em> function depends on <em>loadFile()</em> as well as on the <em>download()</em> functions in our example.  The <em>inject</em> function in our earlier example depended on the results of the <em>addition</em> functions gradually invoked  on all elements of the collection.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Our task is, in fact, very simple !</div>
<div class="paragraph">
<p>However difficult it may seem at first, our task is, in fact, very simple. We only need to teach our functions to return a <em>promise</em> of their future results.
And we need to teach the other functions to accept those <em>promises</em> as parameters so that they will wait for the real values before they start their work.</p>
</div>
<div class="paragraph">
<p>And if we convince the functions to release the threads they hold, while waiting for the values, we get directly to where the magic can happen.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>In the best traditions of <strong>GPars</strong>, we&#8217;ve made it very straightforward for you to convince any function to believe in the <strong>promises</strong> of other functions.  Call the <em>asyncFun()</em> function on a closure and you&#8217;re asynchronous !</p>
</div>
<div class="listingblock">
<div class="title">Promises, Promises</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>withPool {
    <span class="keyword">def</span> maxPromise = numbers.inject(<span class="integer">0</span>, {a, b -&gt; a&gt;b?a:b}.asyncFun())

    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Look Ma, I can talk to the user while the math is being done for me!</span><span class="delimiter">&quot;</span></span>
    println maxPromise.get()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>inject</em> function doesn&#8217;t really care what objects are returned from the <em>addition</em> function,
maybe it&#8217;s a little surprised each call to the <em>addition</em> function returns so fast, but doesn&#8217;t moan much, keeps iterating and finally returns the overall result we expect.</p>
</div>
<div class="paragraph">
<p>Now is the time you should stand behind what you say and do what you want others to do. Don&#8217;t frown at the result and just accept that you got back just a <strong>promise</strong>.  A <strong>promise</strong> to get the answer delivered as soon as the calculation is complete.
The extra heat from your laptop is an indication that the calculation exploits natural parallelism in your functions and makes its best effort to deliver the result to you quickly.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">A Promise Is A Promise</div>
<div class="paragraph">
<p>The <em>promise</em> is a good old <em>DataflowVariable</em>, so you can query its status, register some notification hooks or even make it an input to a <strong>Dataflow</strong> algorithm !</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">An Promising Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre>withPool {
    <span class="keyword">def</span> sumPromise = (<span class="integer">0</span>..<span class="integer">100000</span>).inject(<span class="integer">0</span>, {a, b -&gt; a + b}.asyncFun())

    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Are we done yet? </span><span class="delimiter">&quot;</span></span> + sumPromise.bound

    sumPromise.whenBound {sum -&gt; println sum}
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Do You Need A Timeout ?</div>
<div class="paragraph">
<p>The <em>get()</em> method has also a variant with a timeout parameter, if you want to avoid the risk of waiting indefinitely.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_can_things_go_wrong">Can Things Go Wrong?</h4>
<div class="paragraph">
<p>Sure. But you&#8217;ll get an exception thrown from the <strong>promise</strong> <em>get()</em> method.</p>
</div>
<div class="listingblock">
<div class="title">An Exceptional Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre><span class="keyword">try</span> {
    sumPromise.get()

} <span class="keyword">catch</span> (MyCalculationException e) {
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Guess, things are not ideal today.</span><span class="delimiter">&quot;</span></span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_this_is_all_fine_but_what_functions_can_really_be_combined">This Is All Fine, But What Functions Can Really Be Combined?</h4>
<div class="paragraph">
<p>There are no limits to your ambitions. Take any sequential functions you need to combine and you should be able to combine their asynchronous variants as well.</p>
</div>
<div class="paragraph">
<p>Review our initial example comparing the content of a file with a web page. We simply make all the functions asynchronous by calling the <em>asyncFun()</em> method on them and we are ready to set off.</p>
</div>
<div class="listingblock">
<div class="title">Using  The <em>asyncFun()</em> Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td>
  <td class="code"><pre>    Closure download = {<span class="predefined-type">String</span> url -&gt;
        url.toURL().text
    }.asyncFun()

    Closure loadFile = {<span class="predefined-type">String</span> fileName -&gt;
        ...  <span class="comment">//load the file here</span>
    }.asyncFun()

    Closure hash = {s -&gt; s.hashCode()}.asyncFun()

    Closure compare = {<span class="type">int</span> first, <span class="type">int</span> second -&gt;
        first == second
    }.asyncFun()

    <span class="keyword">def</span> result = compare(hash(download(<span class="string"><span class="delimiter">'</span><span class="content">http://www.gpars.org</span><span class="delimiter">'</span></span>)), hash(loadFile(<span class="string"><span class="delimiter">'</span><span class="content">/coolStuff/gpars/website/index.html</span><span class="delimiter">'</span></span>)))

    println <span class="string"><span class="delimiter">'</span><span class="content">Allowed to do something else now</span><span class="delimiter">'</span></span>
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">The result of comparison: </span><span class="delimiter">&quot;</span></span> + result.get()</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_calling_asynchronous_functions_from_within_asynchronous_functions">Calling Asynchronous Functions from Within Asynchronous Functions</h4>
<div class="paragraph">
<p>Another very valuable attribute of asynchronous functions is that <code>promises</code> can be combined.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Promises can be combined !
</td>
</tr>
</table>
</div>
<hr>
<div class="listingblock">
<div class="title">An Asynchronous Function Within Another</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.withPool</span>

  withPool {
      Closure plus = {<span class="predefined-type">Integer</span> a, <span class="predefined-type">Integer</span> b -&gt;
          sleep <span class="integer">3000</span>
          println <span class="string"><span class="delimiter">'</span><span class="content">Adding numbers</span><span class="delimiter">'</span></span>
          a + b
      }.asyncFun();        <span class="comment">// ok, here's one func</span>

      Closure multiply = {<span class="predefined-type">Integer</span> a, <span class="predefined-type">Integer</span> b -&gt;
          sleep <span class="integer">2000</span>
          a * b
      }.asyncFun()        <span class="comment">// and second one</span>

      Closure measureTime = {-&gt;
          sleep <span class="integer">3000</span>
          <span class="integer">4</span>
      }.asyncFun();        <span class="comment">// and another</span>

          <span class="comment">// declare a function within a function</span>
      Closure distance = {<span class="predefined-type">Integer</span> initialDistance, <span class="predefined-type">Integer</span> velocity, <span class="predefined-type">Integer</span> time -&gt;
          plus(initialDistance, multiply(velocity, time))
      }.asyncFun();        <span class="comment">// and another</span>


      Closure chattyDistance = {<span class="predefined-type">Integer</span> initialDistance, <span class="predefined-type">Integer</span> velocity, <span class="predefined-type">Integer</span> time -&gt;
          println <span class="string"><span class="delimiter">'</span><span class="content">All parameters are now ready - starting</span><span class="delimiter">'</span></span>
          println <span class="string"><span class="delimiter">'</span><span class="content">About to call another asynchronous function</span><span class="delimiter">'</span></span>
          <span class="keyword">def</span> innerResultPromise = plus(initialDistance, multiply(velocity, time))
          println <span class="string"><span class="delimiter">'</span><span class="content">Returning the promise for the inner calculation as my own result</span><span class="delimiter">'</span></span>
          <span class="keyword">return</span> innerResultPromise
      }.asyncFun();        <span class="comment">// and declare (but not run) a final asynch.function</span>

          <span class="comment">// fine, now let's execute those previous asynch. functions</span>
      println <span class="string"><span class="delimiter">&quot;</span><span class="content">Distance = </span><span class="delimiter">&quot;</span></span> + distance(<span class="integer">100</span>, <span class="integer">20</span>, measureTime()).get() + <span class="string"><span class="delimiter">'</span><span class="content"> m</span><span class="delimiter">'</span></span>
      println <span class="string"><span class="delimiter">&quot;</span><span class="content">ChattyDistance = </span><span class="delimiter">&quot;</span></span> + chattyDistance(<span class="integer">100</span>, <span class="integer">20</span>, measureTime()).get() + <span class="string"><span class="delimiter">'</span><span class="content"> m</span><span class="delimiter">'</span></span>
  }</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>If an asynchronous function (e.g. like the <em>distance</em> function in this example) in its body calls another
asynchronous function (e.g. <em>plus</em> ) and returns the the promise of the invoked function, the inner
function&#8217;s ( <em>plus</em> ) resulting promise will combine with the outer function&#8217;s ( <em>distance</em> ) results promise.</p>
</div>
<div class="paragraph">
<p>The inner function ( <em>plus</em> ) will now bind its result to the outer function&#8217;s ( <em>distance</em> ) promise, once the inner function (plus) finishes its calculation.
This ability of promises to combine logic allows functions to cease their calculation without blocking a thread. This happens not only when waiting for parameters,
but also whenever they call another asynchronous function anywhere in their code body.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_methods_as_asynchronous_functions">Methods as Asynchronous Functions</h4>
<div class="paragraph">
<p>Methods can be referred to as closures using the <em>.&amp;</em> operator. These closures can then be transformed using the
<em>asyncFun</em> method into composable asynchronous functions just like ordinary closures.</p>
</div>
<div class="listingblock">
<div class="title">An Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td>
  <td class="code"><pre><span class="type">class</span> <span class="class">DownloadHelper</span> {

    <span class="predefined-type">String</span> download(<span class="predefined-type">String</span> url) {
        url.toURL().text
    }

    <span class="type">int</span> scanFor(<span class="predefined-type">String</span> word, <span class="predefined-type">String</span> text) {
        text.findAll(word).size()
    }

    <span class="predefined-type">String</span> lower(s) {
        s.toLowerCase()
    }
}

<span class="comment">//now we'll make the methods asynchronous</span>
withPool {
    <span class="directive">final</span> DownloadHelper d = <span class="keyword">new</span> DownloadHelper()
    Closure download = d.&amp;download.asyncFun()   <span class="comment">// notice the .&amp; syntax</span>
    Closure scanFor = d.&amp;scanFor.asyncFun()                <span class="comment">// and here</span>
    Closure lower = d.&amp;lower.asyncFun()                        <span class="comment">// and here</span>

    <span class="comment">//asynchronous processing</span>
    <span class="keyword">def</span> result = scanFor(<span class="string"><span class="delimiter">'</span><span class="content">groovy</span><span class="delimiter">'</span></span>, lower(download(<span class="string"><span class="delimiter">'</span><span class="content">http://www.infoq.com</span><span class="delimiter">'</span></span>)))
    println <span class="string"><span class="delimiter">'</span><span class="content">Doing something else for now</span><span class="delimiter">'</span></span>
    println result.get()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_annotations_to_create_asynchronous_functions">Using Annotations to Create Asynchronous Functions</h4>
<div class="paragraph">
<p>Instead of calling the <em>asyncFun()</em> function, the <em>@AsyncFun</em> annotation can be used to annotate Closure-typed fields.
The fields have to be initialized in-place and the containing class needs to be instantiated within a <em>withPool</em> block.</p>
</div>
<div class="listingblock">
<div class="title">An Annotation Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.withPool</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.AsyncFun</span>

<span class="type">class</span> <span class="class">DownloadingSearch</span> {
    <span class="annotation">@AsyncFun</span> Closure download = {<span class="predefined-type">String</span> url -&gt;
        url.toURL().text
    }

    <span class="annotation">@AsyncFun</span> Closure scanFor = {<span class="predefined-type">String</span> word, <span class="predefined-type">String</span> text -&gt;
        text.findAll(word).size()
    }

    <span class="annotation">@AsyncFun</span> Closure lower = {s -&gt; s.toLowerCase()}

    <span class="type">void</span> scan() {
        <span class="keyword">def</span> result = scanFor(<span class="string"><span class="delimiter">'</span><span class="content">groovy</span><span class="delimiter">'</span></span>, lower(download(<span class="string"><span class="delimiter">'</span><span class="content">http://www.infoq.com</span><span class="delimiter">'</span></span>)))  <span class="comment">//synchronous processing</span>

        println <span class="string"><span class="delimiter">'</span><span class="content">Allowed to do something else now</span><span class="delimiter">'</span></span>
        println result.get()
    }
}

withPool {
    <span class="keyword">new</span> DownloadingSearch().scan()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_alternative_pools">Alternative Pools</h5>
<div class="paragraph">
<p>The <em>AsyncFun</em> annotation, by default, uses an instance of <strong>GParsPool</strong> from the wrapping <code>withPool</code> block. You may, however, specify the type of pool explicitly:</p>
</div>
<div class="listingblock">
<div class="title">A Explicit Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="annotation">@AsyncFun</span>(GParsExecutorsPoolUtil) <span class="keyword">def</span> sum6 = {a, b -&gt; a + b }</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_blocking_functions_through_annotations">Blocking Functions Through Annotations</h5>
<div class="paragraph">
<p>The <em>AsyncFun</em> method also allows us to specify, whether the resulting function should allow blocking (true)
or non-blocking (false - default) semantics.</p>
</div>
<div class="listingblock">
<div class="title">An Example of Blocking Semantics</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="annotation">@AsyncFun</span>(blocking = <span class="predefined-constant">true</span>)
<span class="keyword">def</span> sum = {a, b -&gt; a + b }</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="_explicit_and_delayed_pool_assignment">Explicit and Delayed Pool Assignment</h5>
<div class="paragraph">
<p>When using the <em>GPars(Executors)PoolUtil.asyncFun()</em> function directly to create an asynchronous function,
you have two additional ways to assign a thread pool to the function.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The thread pool to be used by the function can be specified explicitly as an additional argument at creation time</p>
</li>
<li>
<p>The implicit thread pool can be obtained from the surrounding scope at invocation-time rather at creation time</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When specifying the thread pool explicitly, the call doesn&#8217;t need to be wrapped in a <em>withPool()</em> block:</p>
</div>
<div class="listingblock">
<div class="title">To Specify Thread Pools Explicitly</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td>
  <td class="code"><pre>Closure sPlus = {<span class="predefined-type">Integer</span> a, <span class="predefined-type">Integer</span> b -&gt;
    a + b
}

Closure sMultiply = {<span class="predefined-type">Integer</span> a, <span class="predefined-type">Integer</span> b -&gt;
    sleep <span class="integer">2000</span>
    a * b
}

println <span class="string"><span class="delimiter">&quot;</span><span class="content">Synchronous result: </span><span class="delimiter">&quot;</span></span> + sMultiply(sPlus(<span class="integer">10</span>, <span class="integer">30</span>), <span class="integer">100</span>)

<span class="directive">final</span> pool = <span class="keyword">new</span> FJPool();

Closure aPlus = GParsPoolUtil.asyncFun(sPlus, pool)
Closure aMultiply = GParsPoolUtil.asyncFun(sMultiply, pool)

<span class="keyword">def</span> result = aMultiply(aPlus(<span class="integer">10</span>, <span class="integer">30</span>), <span class="integer">100</span>)

println <span class="string"><span class="delimiter">&quot;</span><span class="content">Time to do something else while the calculation is running</span><span class="delimiter">&quot;</span></span>
println <span class="string"><span class="delimiter">&quot;</span><span class="content">Asynchronous result: </span><span class="delimiter">&quot;</span></span> + result.get()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>With a delayed pool assignment, only the function invocation must be surrounded with a <em>withPool()</em> block:</p>
</div>
<div class="listingblock">
<div class="title">A Delayed Pool Assignment Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre>Closure aPlus = GParsPoolUtil.asyncFun(sPlus)
Closure aMultiply = GParsPoolUtil.asyncFun(sMultiply)

withPool {
    <span class="keyword">def</span> result = aMultiply(aPlus(<span class="integer">10</span>, <span class="integer">30</span>), <span class="integer">100</span>)

    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Time to do something else while the calculation is running</span><span class="delimiter">&quot;</span></span>
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Asynchronous result: </span><span class="delimiter">&quot;</span></span> + result.get()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>For us, this is a very interesting domain to explore. So any comments, questions or suggestions are welcome on combining asynchronous functions or hints about its limits.</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fork_join_2">Fork-Join</h3>
<div class="paragraph">
<p><strong>Fork/Join</strong> or <em>Divide-and-Conquer</em>, is a very powerful abstraction to solve hierarchical problems.</p>
</div>
<div class="sect3">
<h4 id="_the_abstraction">The Abstraction</h4>
<div class="paragraph">
<p>When talking about hierarchical problems, think about quick sort, merge sort, file system or general tree navigation problems.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Fork/Join</strong> algorithms essentially split a problem into several smaller sub-problems and then recursively applies the same algorithm to each of the sub-problems.</p>
</li>
<li>
<p>Once the sub-problem is small enough, it is solved directly.</p>
</li>
<li>
<p>The solutions of all sub-problems are combined to solve their parent problem, which in turn helps solve its' own grand-parent problem.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">A Picture Is Worth A Thousand Words</div>
<div class="paragraph">
<p>Check out the fancy <a href="http://blog.krecan.net/2011/03/27/visualizing-forkjoin/">Interactive <strong>Fork/Join</strong>
visualization demo</a>. It shows you how threads co-operate to solve a common divide-and-conquer algorithm.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The mighty <strong>JSR-166y</strong> library co-ordinates <strong>Fork/Join</strong> orchestration rather nicely, but leaves a few rough edges, which can hurt you, if you don&#8217;t pay enough attention. You must still deal with threads, pools and/or
synchronization barriers.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_strong_gpars_strong_abstraction_convenience_layer">The <strong>GPars</strong> Abstraction Convenience Layer</h4>
<div class="paragraph">
<p><strong>GPars</strong> can hide the complexities of dealing with threads, pools and recursive tasks from you, yet let you
leverage the powerful <strong>Fork/Join</strong> implementation in <strong>jsr166y</strong>.</p>
</div>
<div class="listingblock">
<div class="title">A Complex Example to Walk A File Directory</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.runForkJoin</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.withPool</span>

withPool() {
    println <span class="string"><span class="delimiter">&quot;&quot;&quot;</span><span class="content">Number of files: </span><span class="inline"><span class="inline-delimiter">${</span>

        runForkJoin(<span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">./src</span><span class="delimiter">&quot;</span></span>)) {file -&gt;
            <span class="type">long</span> count = <span class="integer">0</span>
            file.eachFile {
                <span class="keyword">if</span> (<span class="local-variable">it</span>.isDirectory()) {
                    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Forking a child task for </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>
                    forkOffChild(<span class="local-variable">it</span>)           <span class="comment">//fork a child task</span>

                } <span class="keyword">else</span> {
                    count++
                }
            }
            <span class="keyword">return</span> count + (childrenResults.sum(<span class="integer">0</span>))
            <span class="comment">//use results of children tasks to calculate and store own result</span>
        }

    <span class="inline-delimiter">}</span></span><span class="delimiter">&quot;&quot;&quot;</span></span>.toString();
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>runForkJoin()</em> factory method uses the supplied recursive code together with the provided values
to build a hierarchical <strong>Fork/Join</strong> calculation. The number of values passed to the <em>runForkJoin()</em> method
must match the number of expected parameters of the closure. This must equal the same number of arguments passed to the <em>forkOffChild()</em> or <em>runChildDirectly()</em> methods.</p>
</div>
<div class="listingblock">
<div class="title">An Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> <span class="function">quicksort</span>(numbers) {

    withPool {

        runForkJoin(<span class="integer">0</span>, numbers) {index, list -&gt;

            <span class="keyword">def</span> groups = list.groupBy {<span class="local-variable">it</span> &lt;=&gt; list[list.size().intdiv(<span class="integer">2</span>)]}

            <span class="keyword">if</span> ((list.size() &lt; <span class="integer">2</span>) || (groups.size() == <span class="integer">1</span>)) {
                <span class="keyword">return</span> [<span class="key">index</span>: index, <span class="key">list</span>: list.clone()]
            }

            (-<span class="integer">1</span>..<span class="integer">1</span>).each {forkOffChild(<span class="local-variable">it</span>, groups[<span class="local-variable">it</span>] ?: <span class="type">[]</span>)}

            <span class="keyword">return</span> [<span class="key">index</span>: index, <span class="key">list</span>: childrenResults.sort {<span class="local-variable">it</span>.index}.sum {<span class="local-variable">it</span>.list}]

        }.list
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">It&#8217;s Asynchronous, Mate !</div>
<div class="paragraph">
<p>The important piece of the puzzle to note here is that <em>forkOffChild()</em> doesn&#8217;t wait for the child to run.
It merely schedules it for execution at a future time. If a child task throws an exception, don&#8217;t expect the exception to be fired from the <em>forkOffChild()</em> method itself.
The exception will have happened long after the parent has called <em>forkOffChild()</em>.</p>
</div>
<div class="paragraph">
<p>It&#8217;s the <em>getChildrenResults()</em> method that will re-throw any child sub-task exceptions back to the parent.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_alternative_approach">Alternative Approach</h5>
<div class="paragraph">
<p>Alternatively, the underlying mechanism of nested <strong>Fork/Join</strong> worker tasks can be used directly.
Custom-tailored workers can eliminate the performance overhead associated with parameter spreading
imposed when using the generic workers.</p>
</div>
<div class="paragraph">
<p>Also, custom workers can be implemented in <strong>Java</strong> for further increases in performance.</p>
</div>
<div class="listingblock">
<div class="title">A Custom Worker</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">FileCounter</span> <span class="directive">extends</span> AbstractForkJoinWorker&lt;<span class="predefined-type">Long</span>&gt; {
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">File</span> file;

    <span class="keyword">def</span> <span class="function">FileCounter</span>(<span class="directive">final</span> <span class="predefined-type">File</span> file) {
        <span class="local-variable">this</span>.file = file
    }

    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="predefined-type">Long</span> computeTask() {
        <span class="type">long</span> count = <span class="integer">0</span>;

        file.eachFile {
            <span class="keyword">if</span> (<span class="local-variable">it</span>.isDirectory()) {
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">Forking a thread for </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>
                forkOffChild(<span class="keyword">new</span> FileCounter(<span class="local-variable">it</span>))           <span class="comment">//fork a child task</span>

            } <span class="keyword">else</span> {
                count++
            }
        }
        <span class="keyword">return</span> count + ((childrenResults)?.sum() ?: <span class="integer">0</span>)  <span class="comment">//use results of children tasks to calculate and store own result</span>
    }
}

withPool(<span class="integer">1</span>) {pool -&gt;  <span class="comment">//feel free to experiment with the number of fork/join threads in the pool</span>
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Number of files: </span><span class="inline"><span class="inline-delimiter">${</span>runForkJoin(<span class="keyword">new</span> FileCounter(<span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">..</span><span class="delimiter">&quot;</span></span>)))<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <strong>AbstractForkJoinWorker</strong> subclasses can be written in both <strong>Java</strong> and <strong>Groovy</strong>. Either choicr lets you optimize for execution speed, if low performance of the worker becomes a bottleneck.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_fork_join_saves_your_resources">Fork / Join Saves Your Resources</h4>
<div class="paragraph">
<p><strong>Fork/Join</strong> operations can safely be run with small numbers of threads thanks to internal use of the <strong>TaskBarrier</strong> class to synchronize the threads.</p>
</div>
<div class="paragraph">
<p>While a thread is blocked inside an algorithm waiting for its sub-problems to be calculated, the thread is silently returned to it&#8217;s pool to take on any other available sub-problems from the task queue and process them.
Although the algorithm creates as many tasks as there are sub-directories and tasks wait for the sub-directory tasks to complete, often as few as a single thread is enough to keep the computation going and eventually calculate a valid result.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mergesort_example">Mergesort Example</h4>
<div class="listingblock">
<div class="title">Come on Punk, Merge my day !</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.runForkJoin</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.withPool</span>

<span class="comment">/**
 * Splits a list of numbers in half
 */</span>
<span class="keyword">def</span> <span class="function">split</span>(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; list) {
    <span class="type">int</span> listSize = list.size()
    <span class="type">int</span> middleIndex = listSize / <span class="integer">2</span>
    <span class="keyword">def</span> list1 = list[<span class="integer">0</span>..&lt;middleIndex]
    <span class="keyword">def</span> list2 = list[middleIndex..listSize - <span class="integer">1</span>]
    <span class="keyword">return</span> [list1, list2]
}

<span class="comment">/**
 * Merges two sorted lists into one
 */</span>
<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; merge(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; a, <span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; b) {
    <span class="type">int</span> i = <span class="integer">0</span>, j = <span class="integer">0</span>
    <span class="directive">final</span> <span class="type">int</span> newSize = a.size() + b.size()
    <span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; result = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Integer</span>&gt;(newSize)

    <span class="keyword">while</span> ((i &lt; a.size()) &amp;&amp; (j &lt; b.size())) {
        <span class="keyword">if</span> (a[i] &lt;= b[j]) result &lt;&lt; a[i++]
        <span class="keyword">else</span> result &lt;&lt; b[j++]
    }

    <span class="keyword">if</span> (i &lt; a.size()) result.addAll(a[i..-<span class="integer">1</span>])
    <span class="keyword">else</span> result.addAll(b[j..-<span class="integer">1</span>])
    <span class="keyword">return</span> result
}

<span class="directive">final</span> <span class="keyword">def</span> numbers = [<span class="integer">1</span>, <span class="integer">5</span>, <span class="integer">2</span>, <span class="integer">4</span>, <span class="integer">3</span>, <span class="integer">8</span>, <span class="integer">6</span>, <span class="integer">7</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>, <span class="integer">2</span>, <span class="integer">2</span>, <span class="integer">9</span>, <span class="integer">8</span>, <span class="integer">7</span>, <span class="integer">6</span>, <span class="integer">7</span>, <span class="integer">8</span>, <span class="integer">1</span>, <span class="integer">4</span>, <span class="integer">1</span>, <span class="integer">7</span>, <span class="integer">5</span>, <span class="integer">8</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">9</span>, <span class="integer">5</span>, <span class="integer">7</span>, <span class="integer">4</span>, <span class="integer">3</span>]

withPool(<span class="integer">3</span>) {  <span class="comment">//feel free to experiment with the number of fork/join threads in the pool</span>
    println <span class="string"><span class="delimiter">&quot;&quot;&quot;</span><span class="content">Sorted numbers: </span><span class="inline"><span class="inline-delimiter">${</span>
        runForkJoin(numbers) {nums -&gt;
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">Thread </span><span class="inline"><span class="inline-delimiter">${</span><span class="predefined-type">Thread</span>.currentThread().name[-<span class="integer">1</span>]<span class="inline-delimiter">}</span></span><span class="content">: Sorting </span><span class="inline"><span class="inline-delimiter">$</span>nums</span><span class="delimiter">&quot;</span></span>
            <span class="keyword">switch</span> (nums.size()) {
                <span class="keyword">case</span> <span class="integer">0</span>..<span class="integer">1</span>:
                    <span class="keyword">return</span> nums                                   <span class="comment">//store own result</span>
                <span class="keyword">case</span> <span class="integer">2</span>:
                    <span class="keyword">if</span> (nums[<span class="integer">0</span>] &lt;= nums[<span class="integer">1</span>]) <span class="keyword">return</span> nums     <span class="comment">//store own result</span>
                    <span class="keyword">else</span> <span class="keyword">return</span> nums[-<span class="integer">1</span>..<span class="integer">0</span>]                       <span class="comment">//store own result</span>
                <span class="keyword">default</span>:
                    <span class="keyword">def</span> splitList = split(nums)
                    [splitList[<span class="integer">0</span>], splitList[<span class="integer">1</span>]].each {forkOffChild <span class="local-variable">it</span>}  <span class="comment">//fork a child task</span>
                    <span class="keyword">return</span> merge(* childrenResults)      <span class="comment">//use results of children tasks to calculate and store own result</span>
            }
        }
    <span class="inline-delimiter">}</span></span><span class="delimiter">&quot;&quot;&quot;</span></span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_mergesort_example_using_a_custom_tailored_worker_class">Mergesort Example Using A Custom-tailored Worker Class</h4>
<div class="listingblock">
<div class="title">An Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">SortWorker</span> <span class="directive">extends</span> AbstractForkJoinWorker&lt;<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt;&gt; {
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">List</span> numbers

    <span class="keyword">def</span> <span class="function">SortWorker</span>(<span class="directive">final</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; numbers) {
        <span class="local-variable">this</span>.numbers = numbers.asImmutable()
    }

    <span class="comment">/**
     * Splits a list of numbers in half
     */</span>
    <span class="keyword">def</span> <span class="function">split</span>(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; list) {
        <span class="type">int</span> listSize = list.size()
        <span class="type">int</span> middleIndex = listSize / <span class="integer">2</span>
        <span class="keyword">def</span> list1 = list[<span class="integer">0</span>..&lt;middleIndex]
        <span class="keyword">def</span> list2 = list[middleIndex..listSize - <span class="integer">1</span>]
        <span class="keyword">return</span> [list1, list2]
    }

    <span class="comment">/**
     * Merges two sorted lists into one
     */</span>
    <span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; merge(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; a, <span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; b) {
        <span class="type">int</span> i = <span class="integer">0</span>, j = <span class="integer">0</span>
        <span class="directive">final</span> <span class="type">int</span> newSize = a.size() + b.size()

        <span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; result = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Integer</span>&gt;(newSize)

        <span class="keyword">while</span> ((i &lt; a.size()) &amp;&amp; (j &lt; b.size())) {
            <span class="keyword">if</span> (a[i] &lt;= b[j]) result &lt;&lt; a[i++]
            <span class="keyword">else</span> result &lt;&lt; b[j++]
        }

        <span class="keyword">if</span> (i &lt; a.size()) result.addAll(a[i..-<span class="integer">1</span>])
        <span class="keyword">else</span> result.addAll(b[j..-<span class="integer">1</span>])
        <span class="keyword">return</span> result
    }

    <span class="comment">/**
     * Sorts a small list or delegates to two children, if the list contains more than two elements.
     */</span>
    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; computeTask() {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Thread </span><span class="inline"><span class="inline-delimiter">${</span><span class="predefined-type">Thread</span>.currentThread().name[-<span class="integer">1</span>]<span class="inline-delimiter">}</span></span><span class="content">: Sorting </span><span class="inline"><span class="inline-delimiter">$</span>numbers</span><span class="delimiter">&quot;</span></span>

        <span class="keyword">switch</span> (numbers.size()) {
            <span class="keyword">case</span> <span class="integer">0</span>..<span class="integer">1</span>:
                <span class="keyword">return</span> numbers                                   <span class="comment">//store own result</span>

            <span class="keyword">case</span> <span class="integer">2</span>:
                <span class="keyword">if</span> (numbers[<span class="integer">0</span>] &lt;= numbers[<span class="integer">1</span>]) <span class="keyword">return</span> numbers     <span class="comment">//store own result</span>
                <span class="keyword">else</span> <span class="keyword">return</span> numbers[-<span class="integer">1</span>..<span class="integer">0</span>]                       <span class="comment">//store own result</span>

            <span class="keyword">default</span>:
                <span class="keyword">def</span> splitList = split(numbers)
                [<span class="keyword">new</span> SortWorker(splitList[<span class="integer">0</span>]), <span class="keyword">new</span> SortWorker(splitList[<span class="integer">1</span>])].each{forkOffChild <span class="local-variable">it</span>}  <span class="comment">//fork a child task</span>
                <span class="keyword">return</span> merge(* childrenResults)      <span class="comment">//use results of children tasks to calculate and store own result</span>
        }
    }
}

<span class="directive">final</span> <span class="keyword">def</span> numbers = [<span class="integer">1</span>, <span class="integer">5</span>, <span class="integer">2</span>, <span class="integer">4</span>, <span class="integer">3</span>, <span class="integer">8</span>, <span class="integer">6</span>, <span class="integer">7</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>, <span class="integer">2</span>, <span class="integer">2</span>, <span class="integer">9</span>, <span class="integer">8</span>, <span class="integer">7</span>, <span class="integer">6</span>, <span class="integer">7</span>, <span class="integer">8</span>, <span class="integer">1</span>, <span class="integer">4</span>, <span class="integer">1</span>, <span class="integer">7</span>, <span class="integer">5</span>, <span class="integer">8</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">9</span>, <span class="integer">5</span>, <span class="integer">7</span>, <span class="integer">4</span>, <span class="integer">3</span>]

withPool(<span class="integer">1</span>) {  <span class="comment">//feel free to experiment with the number of fork/join threads in the pool</span>
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Sorted numbers: </span><span class="inline"><span class="inline-delimiter">${</span>runForkJoin(<span class="keyword">new</span> SortWorker(numbers))<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_running_child_tasks_directly">Running Child Tasks Directly</h4>
<div class="paragraph">
<p>The <em>forkOffChild</em> method has a sibling&#8201;&#8212;&#8201;called the <em>runChildDirectly</em> method. This method will run the child task
directly and immediately within the current thread instead of scheduling the child task for asynchronous processing on the thread pool.
Typically you&#8217;d call <em>forkOffChild</em> on every sub-task but the last, which you invoke directly without the scheduling overhead.</p>
</div>
<div class="listingblock">
<div class="title">A Fork-In-Time-Saves-Nine</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td>
  <td class="code"><pre>Closure fib = {number -&gt;
    <span class="keyword">if</span> (number &lt;= <span class="integer">2</span>) {
        <span class="keyword">return</span> <span class="integer">1</span>
    }

    forkOffChild(number - <span class="integer">1</span>)  <span class="comment">// This task will run asynchronously, probably in a different thread</span>
    <span class="directive">final</span> <span class="keyword">def</span> result = runChildDirectly(number - <span class="integer">2</span>)     <span class="comment">//  This task is run directly within the current thread</span>
    <span class="keyword">return</span> (<span class="predefined-type">Integer</span>) getChildrenResults().sum() + result
}

withPool {
    <span class="keyword">assert</span> <span class="integer">55</span> == runForkJoin(<span class="integer">10</span>, fib)
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_availability_2">Availability</h4>
<div class="paragraph">
<p>This feature is only available when using in the <strong>Fork/Join</strong>-based <strong>GParsPool</strong> , but not <strong>GParsExecutorsPool</strong> .</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_parallel_speculations">Parallel Speculations</h3>
<div class="paragraph">
<p>With processor cores having become plentiful, some algorithms might benefit from brutal-force parallel
duplication.  Instead of deciding up-front about how to solve a problem, what algorithm to use or which
location to connect to, you run all potential solutions in parallel.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parallel_speculations_2">Parallel Speculations</h3>
<div class="paragraph">
<p>Imagine you need to perform a task like e.g. calculate an expensive function or read data from a file,
database or internet. Luckily, you know several good ways (e.g. functions or urls) to reach your
goal. However, all are not equal.</p>
</div>
<div class="paragraph">
<p>Although they return the same (as far as your needs are concerned) result, the elapsed time of each will differ and some may even fail (e.g. network issues).
What&#8217;s worse, no-one&#8217;s going to tell you which choice gives you the single best solution nor which paths might lead to no solution at all.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Shall I run <em>quick sort</em> or <em>merge sort</em> on my list?</p>
</li>
<li>
<p>Which url will work best?</p>
</li>
<li>
<p>Is this service available at its primary location or should I use the backup one?</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>GPars Speculations</strong> give you the option to try all the available alternatives in parallel and receive the result from the fastest functional path, silently ignoring the slow or broken ones.</p>
</div>
<div class="paragraph">
<p>This is what the <em>speculate</em> methods on <strong>GParsPool</strong> and <strong>GParsExecutorsPool</strong> can do for you.</p>
</div>
<div class="listingblock">
<div class="title">A Sort Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> numbers = ...
def quickSort = ...
def mergeSort = ...
def sortedNumbers = speculate(quickSort, mergeSort)</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>So we&#8217;re performing both a <em>quick sort</em> and a <em>merge sort</em> at the same time (concurrently), while getting the result of the
faster one.</p>
</div>
<div class="paragraph">
<p>Given the parallel resources available these days on mainstream hardware, running the two functions in parallel will not have a dramatic impact on speed of calculation of either one,
and thus we get the results of both in about the same time as if we ran only ran the faster of the two calculations.
And also, the result arrives sooner than when running the slower one. Yet we didn&#8217;t have to know up-front, which of the two sorting
algorithms would perform better on our data. Thus we speculated (guessed).</p>
</div>
<div class="paragraph">
<p>Similarly, downloading a document from several sources with different speeds and/or reliability might look like this:</p>
</div>
<div class="listingblock">
<div class="title">A Document DownLoad Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.speculate</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.withPool</span>

<span class="keyword">def</span> alternative1 = {
    <span class="string"><span class="delimiter">'</span><span class="content">http://www.dzone.com/links/index.html</span><span class="delimiter">'</span></span>.toURL().text
}

<span class="keyword">def</span> alternative2 = {
    <span class="string"><span class="delimiter">'</span><span class="content">http://www.dzone.com/</span><span class="delimiter">'</span></span>.toURL().text
}

<span class="keyword">def</span> alternative3 = {
    <span class="string"><span class="delimiter">'</span><span class="content">http://www.dzzzzzone.com/</span><span class="delimiter">'</span></span>.toURL().text  <span class="comment">//wrong url</span>
}

<span class="keyword">def</span> alternative4 = {
    <span class="string"><span class="delimiter">'</span><span class="content">http://dzone.com/</span><span class="delimiter">'</span></span>.toURL().text
}

withPool(<span class="integer">4</span>){
    println speculate([alternative1, alternative2, alternative3, alternative4]).contains(<span class="string"><span class="delimiter">'</span><span class="content">groovy</span><span class="delimiter">'</span></span>)
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Thread Starvation</div>
<div class="paragraph">
<p>Make sure the surrounding thread pool has enough threads to process all alternatives in parallel. The size of the pool should match
the number of closures supplied.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_alternatives_using_strong_dataflow_variables_strong_and_strong_streams_strong">Alternatives Using <strong>Dataflow Variables</strong> and <strong>Streams</strong></h3>
<div class="paragraph">
<p>In some use cases, we can ignore failing alternatives, so <strong>Dataflow</strong> variables or <strong>Streams</strong> may be used to obtain the results of the winning speculation.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">See this <strong>User Guide&#8217;s</strong> topic on <strong>Dataflow Concurrency</strong></div>
<div class="paragraph">
<p>Please refer to the <strong>Dataflow Concurrency</strong> section of this <strong>User Guide</strong> for details on <strong>Dataflow Variables</strong> and streams.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">An Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

<span class="keyword">def</span> alternative1 = {
    <span class="string"><span class="delimiter">'</span><span class="content">http://www.dzone.com/links/index.html</span><span class="delimiter">'</span></span>.toURL().text
}

<span class="keyword">def</span> alternative2 = {
    <span class="string"><span class="delimiter">'</span><span class="content">http://www.dzone.com/</span><span class="delimiter">'</span></span>.toURL().text
}

<span class="keyword">def</span> alternative3 = {
    <span class="string"><span class="delimiter">'</span><span class="content">http://www.dzzzzzone.com/</span><span class="delimiter">'</span></span>.toURL().text  <span class="comment">//will fail due to wrong url</span>
}

<span class="keyword">def</span> alternative4 = {
    <span class="string"><span class="delimiter">'</span><span class="content">http://dzone.com/</span><span class="delimiter">'</span></span>.toURL().text
}

<span class="comment">//Pick either one of the following, both will work:</span>
<span class="directive">final</span> <span class="keyword">def</span> result = <span class="keyword">new</span> DataflowQueue()
<span class="comment">//  final def result = new DataflowVariable()</span>

[alternative1, alternative2, alternative3, alternative4].each{code -&gt;
    task{
        <span class="keyword">try</span> {
            result &lt;&lt; code()
        }
        <span class="keyword">catch</span> (ignore) { }  <span class="comment">// We deliberately ignore unsuccessful urls.</span>
    }
}

println result.val.contains(<span class="string"><span class="delimiter">'</span><span class="content">groovy</span><span class="delimiter">'</span></span>)</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../images/divider.png" alt="divider" width="436">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_user_guide_to_strong_csp_strong">User Guide To <strong>CSP</strong></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_communicating_sequential_processes">Communicating Sequential Processes</h3>
<div class="paragraph">
<p>The <strong>CSP</strong> (Communicating Sequential Processes) abstraction builds on independent composable processes, which
exchange messages in a synchronous manner.  GPars leverages <a href="http://www.cs.kent.ac.uk/projects/ofa/jcsp/">the
<strong>JCSP</strong> library</a> developed at the University of Kent, UK.</p>
</div>
<div class="paragraph">
<p><em>Jon Kerridge</em>, the author of the <strong>CSP</strong> implementation in <strong>GPars</strong>, provides exhaustive examples on of <strong>GroovyCSP</strong> use at
<a href="http://www.soc.napier.ac.uk/~cs10/#_Toc271192596">www.soc.napier.ac.uk</a> or <a href="../JonKerridgeBook/index.html">here on our local mirror page.</a></p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Purpose</div>
<div class="paragraph">
<p>The <strong>GroovyCSP</strong> implementation leverages <strong>JCSP</strong>, a Java-based <strong>CSP</strong> library, which is licensed under LGPL. There
are some differences between the Apache 2 license, which <strong>GPars</strong> uses, and LGPL. Please make sure your
application conforms to the LGPL rules before enabling the use of <strong>JCSP</strong> in your code.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>If the LGPL license is not adequate for your use, you might consider checking out the <strong>Dataflow Concurrency</strong>
chapter of this <strong>User Guide</strong> to learn about <em>tasks</em> , <em>selectors</em> and <em>operators</em> , which may help you resolve
concurrency issues in ways similar to the <strong>CSP</strong> approach.  In fact, the dataflow and <strong>CSP</strong> concepts, as
implemented in <strong>GPars</strong>, are very close to each other.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Apache 2 License</div>
<div class="paragraph">
<p>By default, without actively adding an explicit dependency on <strong>JCSP</strong> in your build file or downloading and
including the <strong>JCSP</strong> jar file in your project, the standard commercial-software-friendly <em>Apache 2 License</em>
terms apply to your project. <strong>GPars</strong> directly only depends on software licensed under licenses compatible with
the <em>Apache 2 License</em>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_strong_csp_strong_model_principles">The <strong>CSP</strong> Model Principles</h3>
<div class="paragraph">
<p>In essence, the <strong>CSP</strong> model builds on independent concurrent processes, which mutually communicate through
channels using synchronous (i.e. rendezvous) message passing. Unlike actors or dataflow operators, which
revolve around the event-processing pattern, <strong>CSP</strong> processes place the focus of their activities (aka sequences
of steps) around the use of communications to remain mutually in sync along the way.</p>
</div>
<div class="paragraph">
<p>Since the addressing is indirect through channels, the processes do not need to know about one another. They
typically consist of a set of input and output channels and a body. Once a <strong>CSP</strong> process is started, it
obtains a thread from a thread pool and starts processing its body, pausing only when reading from a channel
or writing into a channel. Some implementations (e.g. <strong>GoLang</strong>) can also detach the thread from the <strong>CSP</strong>
process when blocked on a channel.</p>
</div>
<div class="paragraph">
<p><strong>CSP</strong> programs are deterministic. The same data on the program&#8217;s input will always generate the same output,
irrespective of the actual thread-scheduling scheme used. This helps a lot when debugging <strong>CSP</strong> programs as
well as analyzing deadlocks.</p>
</div>
<div class="paragraph">
<p>Determinism combined with indirect addressing results in a great level of composability of <strong>CSP</strong> processes. You
can combine small <strong>CSP</strong> processes into bigger ones just by connecting their input and output channels and then
wrapping them by another, bigger containing process.</p>
</div>
<div class="paragraph">
<p>The <strong>CSP</strong> model introduces non-determinism using <em>Alternatives</em>. A process can attempt to read a value from
multiple channels at the same time through a construct called <em>Alternative</em> or <em>Select</em>. The first value
that becomes available in any of the channels involved in the <em>Select</em> will be read and consumed by the
process. Since the order of messages received through a <em>Select</em> depends on unpredictable conditions during
program run-time, the value that will be read is non-deterministic.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="__strong_csp_strong_with_strong_gpars_strong_dataflow"><strong>CSP</strong> with <strong>GPars</strong> Dataflow</h3>
<div class="paragraph">
<p><strong>GPars</strong> provides all the necessary building blocks to create <strong>CSP</strong> processes.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>CSP</strong> processes can be modelled through <strong>GPars</strong> tasks using a <em>Closure</em>, a <em>Runnable</em> or a <em>Callable</em> to hold the actual implementation of the process</p>
</li>
<li>
<p><strong>CSP Channels</strong> should be modelled with <em>SyncDataflowQueue</em> and <em>SyncDataflowBroadcast</em> classes</p>
</li>
<li>
<p><strong>CSP Alternative</strong> is provided through the <em>Select</em> class with its <em>select</em> and _ prioritySelect_ methods</p>
</li>
</ul>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_processes">Processes</h3>
<div class="paragraph">
<p>To start a process, simply use the <em>task</em> factory method.</p>
</div>
<div class="listingblock">
<div class="title">Start A Process</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.scheduler.ResizeablePool</span>

group = <span class="keyword">new</span> DefaultPGroup(<span class="keyword">new</span> ResizeablePool(<span class="predefined-constant">true</span>))

<span class="keyword">def</span> t = group.task {
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">I am a process</span><span class="delimiter">&quot;</span></span>
}

t.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since each process consumes a thread for its lifetime, it&#8217;s advisable to use resizeable thread pools as in the example above.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A process can also be created from a <strong>Runnable</strong> or <strong>Callable</strong> object:</p>
</div>
<div class="listingblock">
<div class="title">A Runnable Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.scheduler.ResizeablePool</span>

group = <span class="keyword">new</span> DefaultPGroup(<span class="keyword">new</span> ResizeablePool(<span class="predefined-constant">true</span>))

<span class="type">class</span> <span class="class">MyProcess</span> <span class="directive">implements</span> <span class="predefined-type">Runnable</span> {

    <span class="annotation">@Override</span>
    <span class="type">void</span> run() {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">I am a process</span><span class="delimiter">&quot;</span></span>
    }
}
<span class="keyword">def</span> t = group.task <span class="keyword">new</span> MyProcess()

t.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <strong>Callable</strong> allows values to be returned through the <em>get()</em> method:</p>
</div>
<div class="listingblock">
<div class="title">A Callable Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.scheduler.ResizeablePool</span>

<span class="keyword">import</span> <span class="include">java.util.concurrent.Callable</span>

group = <span class="keyword">new</span> DefaultPGroup(<span class="keyword">new</span> ResizeablePool(<span class="predefined-constant">true</span>))

<span class="type">class</span> <span class="class">MyProcess</span> <span class="directive">implements</span> <span class="predefined-type">Callable</span>&lt;<span class="predefined-type">String</span>&gt; {

    <span class="annotation">@Override</span>
    <span class="predefined-type">String</span> call() {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">I am a process</span><span class="delimiter">&quot;</span></span>
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">CSP is great!</span><span class="delimiter">&quot;</span></span>
    }
}

<span class="keyword">def</span> t = group.task <span class="keyword">new</span> MyProcess()

println t.get()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_channels">Channels</h3>
<div class="paragraph">
<p>Processes typically need channels to communicate with their companion processes as well as with the outside world:</p>
</div>
<div class="listingblock">
<div class="title">A Channel Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovy.transform.TupleConstructor</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowReadChannel</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowWriteChannel</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.scheduler.ResizeablePool</span>

<span class="keyword">import</span> <span class="include">java.util.concurrent.Callable</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.SyncDataflowQueue</span>

group = <span class="keyword">new</span> DefaultPGroup(<span class="keyword">new</span> ResizeablePool(<span class="predefined-constant">true</span>))

<span class="annotation">@TupleConstructor</span>
<span class="type">class</span> <span class="class">Greeter</span> <span class="directive">implements</span> <span class="predefined-type">Callable</span>&lt;<span class="predefined-type">String</span>&gt; {
    DataflowReadChannel names
    DataflowWriteChannel greetings

    <span class="annotation">@Override</span>
    <span class="predefined-type">String</span> call() {
        <span class="keyword">while</span>(!<span class="predefined-type">Thread</span>.currentThread().isInterrupted()) {
            <span class="predefined-type">String</span> name = names.val
            greetings &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="delimiter">&quot;</span></span> + name
        }
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">CSP is great!</span><span class="delimiter">&quot;</span></span>
    }
}

<span class="keyword">def</span> a = <span class="keyword">new</span> SyncDataflowQueue()
<span class="keyword">def</span> b = <span class="keyword">new</span> SyncDataflowQueue()

group.task <span class="keyword">new</span> Greeter(a, b)

a &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>
a &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Dave</span><span class="delimiter">&quot;</span></span>
println b.val
println b.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Which Delivery Technique To Use for Messages ?</div>
<div class="paragraph">
<p>The <strong>CSP</strong> model uses synchronous messaging, however, in <strong>GPars</strong> you may consider using asynchronous channels as well as synchronous ones.</p>
</div>
<div class="paragraph">
<p>You can also combine these two types of channels within the same process.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_composition">Composition</h3>
<div class="paragraph">
<p>Grouping processes simply becomes a matter of connecting them with channels:</p>
</div>
<div class="listingblock">
<div class="title">A Grouping Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td>
  <td class="code"><pre>group = <span class="keyword">new</span> DefaultPGroup(<span class="keyword">new</span> ResizeablePool(<span class="predefined-constant">true</span>))

<span class="annotation">@TupleConstructor</span>
<span class="type">class</span> <span class="class">Formatter</span> <span class="directive">implements</span> <span class="predefined-type">Callable</span>&lt;<span class="predefined-type">String</span>&gt; {
    DataflowReadChannel rawNames
    DataflowWriteChannel formattedNames

    <span class="annotation">@Override</span>
    <span class="predefined-type">String</span> call() {
        <span class="keyword">while</span>(!<span class="predefined-type">Thread</span>.currentThread().isInterrupted()) {
            <span class="predefined-type">String</span> name = rawNames.val
            formattedNames &lt;&lt; name.toUpperCase()
        }
    }
}

<span class="annotation">@TupleConstructor</span>
<span class="type">class</span> <span class="class">Greeter</span> <span class="directive">implements</span> <span class="predefined-type">Callable</span>&lt;<span class="predefined-type">String</span>&gt; {
    DataflowReadChannel names
    DataflowWriteChannel greetings

    <span class="annotation">@Override</span>
    <span class="predefined-type">String</span> call() {
        <span class="keyword">while</span>(!<span class="predefined-type">Thread</span>.currentThread().isInterrupted()) {
            <span class="predefined-type">String</span> name = names.val
            greetings &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="delimiter">&quot;</span></span> + name
        }
    }
}

<span class="keyword">def</span> a = <span class="keyword">new</span> SyncDataflowQueue()
<span class="keyword">def</span> b = <span class="keyword">new</span> SyncDataflowQueue()
<span class="keyword">def</span> c = <span class="keyword">new</span> SyncDataflowQueue()

group.task <span class="keyword">new</span> <span class="predefined-type">Formatter</span>(a, b)
group.task <span class="keyword">new</span> Greeter(b, c)

a &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>
a &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Dave</span><span class="delimiter">&quot;</span></span>
println c.val
println c.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_alternatives">Alternatives</h3>
<div class="paragraph">
<p>To introduce non-determinist, <strong>GPars</strong> offers the <em>Select</em> class with its <em>select</em> and <em>prioritySelect</em> methods:</p>
</div>
<div class="listingblock">
<div class="title">A Select Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovy.transform.TupleConstructor</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.SyncDataflowQueue</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowReadChannel</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowWriteChannel</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.Select</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.scheduler.ResizeablePool</span>

<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.select</span>

group = <span class="keyword">new</span> DefaultPGroup(<span class="keyword">new</span> ResizeablePool(<span class="predefined-constant">true</span>))

<span class="annotation">@TupleConstructor</span>
<span class="type">class</span> <span class="class">Receptionist</span> <span class="directive">implements</span> <span class="predefined-type">Runnable</span> {
    DataflowReadChannel emails
    DataflowReadChannel phoneCalls
    DataflowReadChannel tweets
    DataflowWriteChannel forwardedMessages

    <span class="directive">private</span> <span class="directive">final</span> Select incomingRequests = select([phoneCalls, emails, tweets])  <span class="comment">//prioritySelect() would give highest precedence to phone calls</span>

    <span class="annotation">@Override</span>
    <span class="type">void</span> run() {
        <span class="keyword">while</span>(!<span class="predefined-type">Thread</span>.currentThread().isInterrupted()) {
            <span class="predefined-type">String</span> msg = incomingRequests.select()
            forwardedMessages &lt;&lt; msg.toUpperCase()
        }
    }
}

<span class="keyword">def</span> a = <span class="keyword">new</span> SyncDataflowQueue()
<span class="keyword">def</span> b = <span class="keyword">new</span> SyncDataflowQueue()
<span class="keyword">def</span> c = <span class="keyword">new</span> SyncDataflowQueue()
<span class="keyword">def</span> d = <span class="keyword">new</span> SyncDataflowQueue()

group.task <span class="keyword">new</span> Receptionist(a, b, c, d)

a &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">my email</span><span class="delimiter">&quot;</span></span>
b &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">my phone call</span><span class="delimiter">&quot;</span></span>
c &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">my tweet</span><span class="delimiter">&quot;</span></span>

<span class="comment">//The values come in random order since the process uses a Select to read its input</span>
<span class="integer">3</span>.times{
    println d.val.value
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_components">Components</h3>
<div class="paragraph">
<p><strong>CSP</strong> processes can be composed into larger entities. Suppose you already have a set of <strong>CSP</strong> processes (aka
<em>Runnable</em>/<em>Callable</em> classes), you can compose them into a larger process:</p>
</div>
<div class="listingblock">
<div class="title">A Larger Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td>
  <td class="code"><pre><span class="directive">final</span> <span class="type">class</span> <span class="class">Prefix</span> <span class="directive">implements</span> <span class="predefined-type">Callable</span> {
    <span class="directive">private</span> <span class="directive">final</span> DataflowChannel inChannel
    <span class="directive">private</span> <span class="directive">final</span> DataflowChannel outChannel
    <span class="directive">private</span> <span class="directive">final</span> <span class="keyword">def</span> prefix

    <span class="keyword">def</span> <span class="function">Prefix</span>(<span class="directive">final</span> inChannel, <span class="directive">final</span> outChannel, <span class="directive">final</span> prefix) {
        <span class="local-variable">this</span>.inChannel = inChannel;
        <span class="local-variable">this</span>.outChannel = outChannel;
        <span class="local-variable">this</span>.prefix = prefix
    }

    <span class="directive">public</span> <span class="keyword">def</span> <span class="function">call</span>() {
        outChannel &lt;&lt; prefix
        <span class="keyword">while</span> (<span class="predefined-constant">true</span>) {
            sleep <span class="integer">200</span>
            outChannel &lt;&lt; inChannel.val
        }
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Another Building Block</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td>
  <td class="code"><pre><span class="directive">final</span> <span class="type">class</span> <span class="class">Copy</span> <span class="directive">implements</span> <span class="predefined-type">Callable</span> {
    <span class="directive">private</span> <span class="directive">final</span> DataflowChannel inChannel
    <span class="directive">private</span> <span class="directive">final</span> DataflowChannel outChannel1
    <span class="directive">private</span> <span class="directive">final</span> DataflowChannel outChannel2

    <span class="keyword">def</span> <span class="function">Copy</span>(<span class="directive">final</span> inChannel, <span class="directive">final</span> outChannel1, <span class="directive">final</span> outChannel2) {
        <span class="local-variable">this</span>.inChannel = inChannel;
        <span class="local-variable">this</span>.outChannel1 = outChannel1;
        <span class="local-variable">this</span>.outChannel2 = outChannel2;
    }

    <span class="directive">public</span> <span class="keyword">def</span> <span class="function">call</span>() {
        <span class="directive">final</span> PGroup group = Dataflow.retrieveCurrentDFPGroup()
        <span class="keyword">while</span> (<span class="predefined-constant">true</span>) {
            <span class="keyword">def</span> i = inChannel.val
            group.task {
                outChannel1 &lt;&lt; i
                outChannel2 &lt;&lt; i
            }.join()
        }
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowChannel</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.SyncDataflowQueue</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>

group = <span class="keyword">new</span> DefaultPGroup(<span class="integer">6</span>)

<span class="keyword">def</span> <span class="function">fib</span>(DataflowChannel out) {
    group.task {
        <span class="keyword">def</span> a = <span class="keyword">new</span> SyncDataflowQueue()
        <span class="keyword">def</span> b = <span class="keyword">new</span> SyncDataflowQueue()
        <span class="keyword">def</span> c = <span class="keyword">new</span> SyncDataflowQueue()
        <span class="keyword">def</span> d = <span class="keyword">new</span> SyncDataflowQueue()
        [<span class="keyword">new</span> Prefix(d, a, <span class="integer">0L</span>), <span class="keyword">new</span> Prefix(c, d, <span class="integer">1L</span>), <span class="keyword">new</span> Copy(a, b, out), <span class="keyword">new</span> StatePairs(b, c)].each { group.task <span class="local-variable">it</span>}
    }
}

<span class="directive">final</span> SyncDataflowQueue ch = <span class="keyword">new</span> SyncDataflowQueue()
group.task <span class="keyword">new</span> Print(<span class="string"><span class="delimiter">'</span><span class="content">Fibonacci numbers</span><span class="delimiter">'</span></span>, ch)
fib(ch)

sleep <span class="integer">10000</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../images/divider.png" alt="divider" width="436">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_user_guide_to_strong_actors_strong">User Guide To <strong>Actors</strong></h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Actors</strong> offer a message passing-based concurrency model: programs are collections of independent active objects that exchange messages and have no mutable shared state.</p>
</div>
<div class="paragraph">
<p><strong>Actors</strong> can help us avoid issues such as deadlock, live-lock and starvation, which are common problems for shared memory based approaches.</p>
</div>
<div class="paragraph">
<p><strong>Actors</strong> are a way of leveraging the multi-core nature of today&#8217;s hardware without all the problems traditionally associated with shared-memory
multi-threading, which is why programming languages such as <strong>Erlang</strong> and <strong>Scala</strong> have taken up this model.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The actor support in <strong>GPars</strong> was originally inspired by the Actors library in Scala, but has since gone well beyond what Scala offers as standard.
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p>A nice article summarizing the key <a href="http://ruben.savanne.be/articles/concurrency-in-erlang-scala">concepts behind actors</a> has been written by <em>Ruben Vermeersch</em>.</p>
</div>
<div class="paragraph">
<p><strong>Actors</strong> always guarantee that <strong>at most one thread processes the actor&#8217;s body</strong> at any one time and also, under the covers, that the memory is synchronized
each time a thread is assigned to an actor so the actor&#8217;s state <strong>can be safely modified</strong> by code in the body <strong>without any other extra (synchronization or locking) effort</strong> .</p>
</div>
<div class="paragraph">
<p>Ideally actor&#8217;s code should <strong>never be invoked</strong> directly from outside so all the code of the actor class can only be executed by the thread
handling the last received message and hence all the actor&#8217;s code is <strong>implicitly thread-safe</strong> .</p>
</div>
<div class="paragraph">
<p>If any of the actor&#8217;s methods are allowed to be called by other objects directly, the thread-safety guarantee for the actor&#8217;s code and state are <strong>no longer valid</strong> .</p>
</div>
<hr>
<div class="sect2">
<h3 id="_types_of_actors">Types of Actors</h3>
<div class="paragraph">
<p>In general, you can find two types of actors in the wild&#8201;&#8212;&#8201;ones that hold <strong>implicit state</strong> and ones that don&#8217;t.</p>
</div>
<div class="paragraph">
<p><strong>GPars</strong> gives you both options.</p>
</div>
<div class="paragraph">
<p><strong>Stateless</strong> actors, represented in <strong>GPars</strong> by the <em>DynamicDispatchActor</em> and the <em>ReactiveActor</em> classes, keep no track of what messages have arrived
previously.  You may think of these as flat message handlers, which process messages as they come. Any state-based behavior has to be implemented by the user.</p>
</div>
<div class="paragraph">
<p>The <strong>stateful</strong> actors, represented in <strong>GPars</strong> by the <em>DefaultActor</em> class (and previously also by the <em>AbstractPooledActor</em> class), allow us to handle implicit state directly.
After receiving a message, the actor moves into a new state with different ways to handle future messages.</p>
</div>
<div class="paragraph">
<p>To give you an example, a freshly started actor may only accept some types of messages, e.g. encrypted messages for decryption, only after it has received the encryption keys.
The stateful actors allow to encode such dependencies directly in the structure of the message-handling code.  Implicit state management, however, comes at a slight performance cost,
mainly due to the lack of continuations support on JVM.</p>
</div>
</div>
<div class="sect2">
<h3 id="_actor_threading_model">Actor Threading Model</h3>
<div class="paragraph">
<p>Since actors are detached from the system threads, a large number of actors can share a relatively small thread pool.</p>
</div>
<div class="paragraph">
<p>This can go as far as having many concurrent actors share a single pooled thread while avoiding some of the threading limitations of the JVM.</p>
</div>
<div class="paragraph">
<p>In general, while the JVM can only give you a limited number of threads (typically around a couple of thousands), the number of actors is only
limited by the available memory. If an actor has no work to do, it doesn&#8217;t consume any threads.</p>
</div>
<div class="paragraph">
<p>Actor code is processed in chunks separated by quiet periods of waiting for new events (messages).  This can be naturally modeled through <em>continuations</em>.</p>
</div>
<div class="paragraph">
<p>As JVM doesn&#8217;t support continuations directly, they have to be simulated in the actors frameworks, which has slight impact on organization of the actors' code.
However, the benefits in most cases outweigh the difficulties.</p>
</div>
<hr>
<div class="listingblock">
<div class="title">An Actors Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.actor.Actor</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.actor.DefaultActor</span>

<span class="type">class</span> <span class="class">GameMaster</span> <span class="directive">extends</span> DefaultActor {
    <span class="type">int</span> secretNum

    <span class="type">void</span> afterStart() {
        secretNum = <span class="keyword">new</span> <span class="predefined-type">Random</span>().nextInt(<span class="integer">10</span>)
    }

    <span class="type">void</span> act() {
        loop {
            react { <span class="type">int</span> num -&gt;
                <span class="keyword">if</span> (num &gt; secretNum) {
                    reply <span class="string"><span class="delimiter">'</span><span class="content">too large</span><span class="delimiter">'</span></span>
                }
                <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; secretNum) {
                    reply <span class="string"><span class="delimiter">'</span><span class="content">too small</span><span class="delimiter">'</span></span>
                }
                <span class="keyword">else</span> {
                    reply <span class="string"><span class="delimiter">'</span><span class="content">you win</span><span class="delimiter">'</span></span>
                    terminate()
                }
            }
        }
    }
}

<span class="type">class</span> <span class="class">Player</span> <span class="directive">extends</span> DefaultActor {
    <span class="predefined-type">String</span> name
    Actor server
    <span class="type">int</span> myNum

    <span class="type">void</span> act() {
        loop {
            myNum = <span class="keyword">new</span> <span class="predefined-type">Random</span>().nextInt(<span class="integer">10</span>)
            server.send myNum
            react {
                <span class="keyword">switch</span> (<span class="local-variable">it</span>) {
                  <span class="keyword">case</span> <span class="string"><span class="delimiter">'</span><span class="content">too large</span><span class="delimiter">'</span></span>: println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: </span><span class="inline"><span class="inline-delimiter">$</span>myNum</span><span class="content"> was too large</span><span class="delimiter">&quot;</span></span>; <span class="keyword">break</span>
                  <span class="keyword">case</span> <span class="string"><span class="delimiter">'</span><span class="content">too small</span><span class="delimiter">'</span></span>: println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: </span><span class="inline"><span class="inline-delimiter">$</span>myNum</span><span class="content"> was too small</span><span class="delimiter">&quot;</span></span>; <span class="keyword">break</span>
                  <span class="keyword">case</span> <span class="string"><span class="delimiter">'</span><span class="content">you win</span><span class="delimiter">'</span></span>: println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: I won </span><span class="inline"><span class="inline-delimiter">$</span>myNum</span><span class="delimiter">&quot;</span></span>; terminate(); <span class="keyword">break</span>
                }
            }
        }
    }
}

<span class="keyword">def</span> master = <span class="keyword">new</span> GameMaster().start()
<span class="keyword">def</span> player = <span class="keyword">new</span> Player(<span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">Player</span><span class="delimiter">'</span></span>, <span class="key">server</span>: master).start()

<span class="comment">// This forces the main thread to wait until both actors have terminated.</span>
[master, player]*.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>example by <em>Jordi Campos i Miralles, Departament de Matemàtica Aplicada i Anàlisi, MAiA Facultat de
Matemàtiques, Universitat de Barcelona</em></p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_usage_of_actors">Usage of Actors</h3>
<div class="paragraph">
<p><strong>GPars</strong> provides consistent Actor APIs and DSLs. Actors, in principal, perform three specific operations&#8201;&#8212;&#8201;send
messages, receive messages and create new actors. Although not specifically enforced by <strong>GPars</strong>, messages
should be immutable or at least follow the <strong>hands-off</strong> policy when the sender never touches the messages after the message has been sent off.</p>
</div>
<div class="sect3">
<h4 id="_sending_messages">Sending Messages</h4>
<div class="paragraph">
<p>Messages can be sent to actors using the <em>send</em> method.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> passiveActor = Actors.actor{
    loop {
        react { msg -&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">Received: </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>; }
    }
}
passiveActor.send <span class="string"><span class="delimiter">'</span><span class="content">Message 1</span><span class="delimiter">'</span></span>
passiveActor &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Message 2</span><span class="delimiter">'</span></span>    <span class="comment">//using the &lt;&lt; operator</span>
passiveActor <span class="string"><span class="delimiter">'</span><span class="content">Message 3</span><span class="delimiter">'</span></span>       <span class="comment">//using the implicit call() method</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, the <em>&lt;&lt;</em> operator or the implicit <em>call</em> method can be used. A family of <em>sendAndWait</em>
methods is available to block the caller until a reply from the actor is available.  The <em>reply</em> is returned
from the <em>sendAndWait</em> method as a return value.  The <em>sendAndWait</em> methods may also return after a
timeout expires or in case of termination of the called actor.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> replyingActor = Actors.actor{
    loop {
        react { msg -&gt;
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">Received: </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>;
            reply <span class="string"><span class="delimiter">&quot;</span><span class="content">I've got </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>
        }
    }
}

<span class="keyword">def</span> reply1 = replyingActor.sendAndWait(<span class="string"><span class="delimiter">'</span><span class="content">Message 4</span><span class="delimiter">'</span></span>)

<span class="keyword">def</span> reply2 = replyingActor.sendAndWait(<span class="string"><span class="delimiter">'</span><span class="content">Message 5</span><span class="delimiter">'</span></span>, <span class="integer">10</span>, <span class="predefined-type">TimeUnit</span>.SECONDS)

use (TimeCategory) {
    <span class="keyword">def</span> reply3 = replyingActor.sendAndWait(<span class="string"><span class="delimiter">'</span><span class="content">Message 6</span><span class="delimiter">'</span></span>, <span class="integer">10</span>.seconds)
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>sendAndContinue</em> method allows the caller to continue its processing while the supplied closure is
waiting for a reply from the actor.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre>friend.sendAndContinue <span class="string"><span class="delimiter">'</span><span class="content">I need money!</span><span class="delimiter">'</span></span>, {money -&gt; pocket money}
println <span class="string"><span class="delimiter">'</span><span class="content">I can continue while my friend is collecting money for me</span><span class="delimiter">'</span></span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>sendAndPromise</em> method returns a <strong>Promise</strong> (aka Future) to the final reply and so allows the caller
to continue its processing while the actor is handling the submitted message.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>Promise loan = friend.sendAndPromise <span class="string"><span class="delimiter">'</span><span class="content">I need money!</span><span class="delimiter">'</span></span>
println <span class="string"><span class="delimiter">'</span><span class="content">I can continue while my friend is collecting money for me</span><span class="delimiter">'</span></span>
loan.whenBound {money -&gt; pocket money}  <span class="comment">// Asynchronous waiting for a reply.</span>
println <span class="string"><span class="delimiter">&quot;</span><span class="content">Received </span><span class="inline"><span class="inline-delimiter">${</span>loan.get()<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>  <span class="comment">// Synchronous waiting for a reply.</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>All <em>send</em> , <em>sendAndWait</em> or <em>sendAndContinue</em> methods will throw an exception if invoked on a non-active actor.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_receiving_messages">Receiving Messages</h4>
<div class="sect4">
<h5 id="_non_blocking_message_retrieval">Non-blocking Message Retrieval</h5>
<div class="paragraph">
<p>Calling the <em>react</em> method, optionally with a timeout parameter, from within the actor&#8217;s code will consume
the next message from the actor&#8217;s inbox, potentially waiting, if there is no message to be processed
immediately.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>println <span class="string"><span class="delimiter">'</span><span class="content">Waiting for a gift</span><span class="delimiter">'</span></span>
react {gift -&gt;
    <span class="keyword">if</span> (mySpouse.likes gift) reply <span class="string"><span class="delimiter">'</span><span class="content">Thank you!</span><span class="delimiter">'</span></span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Under the covers, the supplied closure is not invoked directly, but scheduled for processing by any thread in the thread pool once a message is available.
After scheduling, the current thread will then be detached from the actor and freed to process any other actor, which has received a message already.</p>
</div>
<div class="paragraph">
<p>To permit detaching actors from threads, the <em>react</em> method requires code to be written in a special <strong>continuation style</strong>.</p>
</div>
<div class="listingblock">
<div class="title">A <em>react</em> Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td>
  <td class="code"><pre>Actors.actor {
    loop {
        println <span class="string"><span class="delimiter">'</span><span class="content">Waiting for a gift</span><span class="delimiter">'</span></span>
        react {gift -&gt;
            <span class="keyword">if</span> (mySpouse.likes gift) reply <span class="string"><span class="delimiter">'</span><span class="content">Thank you!</span><span class="delimiter">'</span></span>
            <span class="keyword">else</span> {
                reply <span class="string"><span class="delimiter">'</span><span class="content">Try again, please</span><span class="delimiter">'</span></span>
                react {anotherGift -&gt;
                    <span class="keyword">if</span> (myChildren.like gift) reply <span class="string"><span class="delimiter">'</span><span class="content">Thank you!</span><span class="delimiter">'</span></span>
                }
                println <span class="string"><span class="delimiter">'</span><span class="content">Never reached</span><span class="delimiter">'</span></span>
            }
        }
        println <span class="string"><span class="delimiter">'</span><span class="content">Never reached</span><span class="delimiter">'</span></span>
    }
    println <span class="string"><span class="delimiter">'</span><span class="content">Never reached</span><span class="delimiter">'</span></span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>react</em> method has a special semantics to allow actors to be detached from threads when no messages
are available in their mailbox.  Essentially, <em>react</em> schedules the supplied code (closure) to be executed
upon next message arrival and returns.  The closure supplied to the <em>react</em> methods is the code where the
computation should resume. This is a <strong>continuation style</strong>.</p>
</div>
<div class="paragraph">
<p>Since actors have to preserve the guarantee that at most one thread is active within the actor&#8217;s body, the
next message cannot be handled before the current message processing finishes. Typically, there shouldn&#8217;t be
a need to put code after calls to <em>react</em>.  Some actor implementations even enforce this. However, <strong>GPars</strong>
does not - for performance reasons.  The <em>loop</em> method allows iterations within the actor body. Unlike typical
looping constructs, like <em>for</em> or <em>while</em> loops, <em>loop</em> cooperates with nested <em>react</em> blocks and will ensure looping across subsequent message retrievals.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sending_replies">Sending Replies</h4>
<div class="paragraph">
<p>The <em>reply</em> and <em>replyIfExists</em> methods are not only defined on the actors themselves, but for
<em>AbstractPooledActor</em> (not available in <em>DefaultActor</em> , <em>DynamicDispatchActor</em> nor <em>ReactiveActor</em> classes)
also on the processed messages themselves upon their reception, which is particularly handy when handling
multiple messages in a single call. In such cases, <em>reply()</em> invoked on the actor will send a reply to authors of
all the currently processed messages (the last one), whereas <em>reply()</em> called on messages sends a reply to
the author of that particular message only.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See DemoMultiMessage.groovy in our sample demos here
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_the_sender_property">The Sender Property</h5>
<div class="paragraph">
<p>Messages-upon-retrieval offer the sender property to identify the originator of the message. The property is available inside the Actor&#8217;s closure:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>react {tweet -&gt;
    <span class="keyword">if</span> (isSpam(tweet)) ignoreTweetsFrom sender
    sender.send <span class="string"><span class="delimiter">'</span><span class="content">Never write to me again!</span><span class="delimiter">'</span></span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="_forwarding">Forwarding</h5>
<div class="paragraph">
<p>When sending a message, a different actor can be specified as the sender so that potential replies to the
message will be forwarded to the specified actor and not to the actual originator.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> decryptor = Actors.actor {
    react {message -&gt;
        reply message.reverse()
<span class="comment">//      sender.send message.reverse()    //An alternative way to send replies</span>
    }
}

<span class="keyword">def</span> console = Actors.actor {  <span class="comment">//This actor will print out decrypted messages, since the replies are forwarded to it</span>
    react {
        println <span class="string"><span class="delimiter">'</span><span class="content">Decrypted message: </span><span class="delimiter">'</span></span> + <span class="local-variable">it</span>
    }
}

decryptor.send <span class="string"><span class="delimiter">'</span><span class="content">lellarap si yvoorG</span><span class="delimiter">'</span></span>, console  <span class="comment">//Specify an actor to send replies to</span>
console.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_creating_actors">Creating Actors</h4>
<div class="paragraph">
<p>Actors share a <strong>pool</strong> of threads, which are dynamically assigned to actors when the actors need to <strong>react</strong>
to messages sent to them. The threads are returned to the pool once a message has been processed and the actor is idle waiting for some more messages to arrive.</p>
</div>
<div class="paragraph">
<p>For example, this is how you create an actor that prints out all messages that it receives.</p>
</div>
<div class="listingblock">
<div class="title">Actor Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> console = Actors.actor {
    loop {
        react {
            println <span class="local-variable">it</span>
        }
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice the <em>loop()</em> method call, which ensures that the actor doesn&#8217;t stop after having processed the first
message.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example with a decryptor service, which can decrypt submitted messages and send the decrypted
messages back to the originators.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td>
  <td class="code"><pre><span class="directive">final</span> <span class="keyword">def</span> decryptor = Actors.actor {
    loop {
        react {<span class="predefined-type">String</span> message -&gt;
            <span class="keyword">if</span> (<span class="string"><span class="delimiter">'</span><span class="content">stopService</span><span class="delimiter">'</span></span> == message) {
                println <span class="string"><span class="delimiter">'</span><span class="content">Stopping decryptor</span><span class="delimiter">'</span></span>
                stop()
            }
            <span class="keyword">else</span> reply message.reverse()
        }
    }
}

Actors.actor {
    decryptor.send <span class="string"><span class="delimiter">'</span><span class="content">lellarap si yvoorG</span><span class="delimiter">'</span></span>
    react {
        println <span class="string"><span class="delimiter">'</span><span class="content">Decrypted message: </span><span class="delimiter">'</span></span> + <span class="local-variable">it</span>
        decryptor.send <span class="string"><span class="delimiter">'</span><span class="content">stopService</span><span class="delimiter">'</span></span>
    }
}.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of an actor that waits for up to 30 seconds to receive a reply to its message.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> friend = Actors.actor {
    react {
        <span class="comment">//this doesn't reply -&gt; caller won't receive any answer in time</span>
        println <span class="local-variable">it</span>
        <span class="comment">//reply 'Hello' //uncomment this to answer conversation</span>
        react {
            println <span class="local-variable">it</span>
        }
    }
}

<span class="keyword">def</span> me = Actors.actor {
    friend.send(<span class="string"><span class="delimiter">'</span><span class="content">Hi</span><span class="delimiter">'</span></span>)
    <span class="comment">//wait for answer 1sec</span>
    react(<span class="integer">1000</span>) {msg -&gt;
        <span class="keyword">if</span> (msg == Actor.TIMEOUT) {
            friend.send(<span class="string"><span class="delimiter">'</span><span class="content">I see, busy as usual. Never mind.</span><span class="delimiter">'</span></span>)
            stop()
        } <span class="keyword">else</span> {
            <span class="comment">//continue conversation</span>
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">Thank you for </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>
        }
    }
}

me.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_undelivered_messages">Undelivered Messages</h4>
<div class="paragraph">
<p>Sometimes messages cannot be delivered to the target actor. When special action needs to be taken for undelivered messages, at actor termination, all unprocessed messages from its queue have their
<em>onDeliveryError()</em> method called. The <em>onDeliveryError()</em> method or closure defined on the message can, for
example, send a notification back to the original sender of the message.</p>
</div>
<div class="listingblock">
<div class="title">Handling Undelivered Messages</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td>
  <td class="code"><pre><span class="directive">final</span> DefaultActor me
me = Actors.actor {
    <span class="keyword">def</span> message = <span class="integer">1</span>

    message.metaClass.onDeliveryError = {-&gt;
        <span class="comment">//send message back to the caller</span>
        me &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Could not deliver </span><span class="inline"><span class="inline-delimiter">$</span>delegate</span><span class="delimiter">&quot;</span></span>
    }

    <span class="keyword">def</span> actor = Actors.actor {
        react {
            <span class="comment">//wait 2sec in order next call in demo can be emitted</span>
            <span class="predefined-type">Thread</span>.sleep(<span class="integer">2000</span>)
            <span class="comment">//stop actor after first message</span>
            stop()
        }
    }

    actor &lt;&lt; message
    actor &lt;&lt; message

    react {
        <span class="comment">//print whatever comes back</span>
        println <span class="local-variable">it</span>
    }

}

me.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively the <em>onDeliveryError()</em> method can be specified on the sender itself. The method can be added
both dynamically</p>
</div>
<div class="listingblock">
<div class="title">A Dynamic Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td>
  <td class="code"><pre><span class="directive">final</span> DefaultActor me
me = Actors.actor {
    <span class="keyword">def</span> message1 = <span class="integer">1</span>
    <span class="keyword">def</span> message2 = <span class="integer">2</span>

    <span class="keyword">def</span> actor = Actors.actor {
        react {
            <span class="comment">//wait 2sec in order next call in demo can be emitted</span>
            <span class="predefined-type">Thread</span>.sleep(<span class="integer">2000</span>)
            <span class="comment">//stop actor after first message</span>
            stop()
        }
    }

    me.metaClass.onDeliveryError = {msg -&gt;
        <span class="comment">//callback on actor inaccessibility</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Could not deliver message </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>
    }

    actor &lt;&lt; message1
    actor &lt;&lt; message2

    actor.join()

}

me.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>and statically in actor definition:</p>
</div>
<div class="listingblock">
<div class="title">A Static Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre><span class="type">class</span> <span class="class">MyActor</span> <span class="directive">extends</span> DefaultActor {
    <span class="directive">public</span> <span class="type">void</span> onDeliveryError(msg) {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Could not deliver message </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>
    }
    ...
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_joining_actors">Joining Actors</h4>
<div class="paragraph">
<p>Actors provide a <em>join()</em> method to allow callers to wait for the actor to terminate. A variant accepting a timeout is also available.
The <strong>Groovy</strong> <em>spread-dot</em> ( *. ) operator comes in handy when joining multiple actors at a time.</p>
</div>
<div class="listingblock">
<div class="title">A Sample to Join Actors</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> master = <span class="keyword">new</span> GameMaster().start()
<span class="keyword">def</span> player = <span class="keyword">new</span> Player(<span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">Player</span><span class="delimiter">'</span></span>, <span class="key">server</span>: master).start()

[master, player]*.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_conditional_and_counting_loops">Conditional and Counting Loops</h5>
<div class="paragraph">
<p>The <em>loop()</em> method allows for either a condition or a number of iterations to be specified, optionally
accompanied with a closure to invoke once the loop finishes - <em>After Loop Termination Code Handler</em> .</p>
</div>
<div class="paragraph">
<p>The following actor will loop three times to receive 3 messages and then prints out the maximum of the
received messages.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td>
  <td class="code"><pre><span class="directive">final</span> Actor actor = Actors.actor {
    <span class="keyword">def</span> candidates = <span class="type">[]</span>
    <span class="keyword">def</span> printResult = {-&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">The best offer is </span><span class="inline"><span class="inline-delimiter">${</span>candidates.max()<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>}

    loop(<span class="integer">3</span>, printResult) {
        react {
            candidates &lt;&lt; <span class="local-variable">it</span>
        }
    }
}

actor <span class="integer">10</span>
actor <span class="integer">30</span>
actor <span class="integer">20</span>
actor.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The following actor will receive messages until a value greater then 30 arrives.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td>
  <td class="code"><pre><span class="directive">final</span> Actor actor = Actors.actor {
    <span class="keyword">def</span> candidates = <span class="type">[]</span>
    <span class="directive">final</span> Closure printResult = {-&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">Reached best offer - </span><span class="inline"><span class="inline-delimiter">${</span>candidates.max()<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>}

    loop({-&gt; candidates.max() &lt; <span class="integer">30</span>}, printResult) {
        react {
            candidates &lt;&lt; <span class="local-variable">it</span>
        }
    }
}

actor <span class="integer">10</span>
actor <span class="integer">20</span>
actor <span class="integer">25</span>
actor <span class="integer">31</span>
actor <span class="integer">20</span>
actor.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The <code>After Loop Termination Code Handler</code> can use an actor&#8217;s <em>react{}</em> but not <em>loop()</em> .
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Fair Vs Non-fair Actor Behavior</div>
<div class="paragraph">
<p><em>DefaultActor</em> can be set to behave in a fair or non-fair (default) manner. Depending on the strategy
chosen, the actor either makes the thread available to other actors sharing the same parallel group (fair),
or keeps the thread for itself until the message queue becomes empty (non-fair). Generally, non-fair actors
perform 2 - 3 times better than fair ones.</p>
</div>
<div class="paragraph">
<p>Use either the <em>fairActor()</em> factory method or the actor&#8217;s <em>makeFair()</em> method.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_custom_schedulers">Custom Schedulers</h4>
<div class="paragraph">
<p>Actors leverage the standard JDK concurrency library by default.  To provide a custom thread scheduler, use
the appropriate constructor parameter when creating a parallel group (<strong>PGroup</strong> class). The supplied scheduler will orchestrate threads in the group&#8217;s thread pool.</p>
</div>
<div class="paragraph">
<p>Please also see the numerous Actor sample demo programs.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_actors_principles">Actors Principles</h3>
<div class="paragraph">
<p>Actors share a <strong>pool</strong> of threads, which are dynamically assigned to actors when the actors need to <strong>react</strong>
to messages sent to them.  The threads are returned back to the pool once a message has been processed and
the actor is idle waiting for some more messages to arrive.  Actors become detached from the underlying
threads and so a relatively small thread pool can serve potentially unlimited number of actors.  Virtually
unlimited scalability in number of actors is the main advantage of <em>event-based actors</em> , which are detached
from the underlying physical threads.</p>
</div>
<div class="paragraph">
<p>Here are some examples of how to use actors. This is how you create an actor that prints out all messages
that it receives.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.actor.Actors.actor</span>

<span class="keyword">def</span> console = actor {
    loop {
        react {
            println <span class="local-variable">it</span>
        }
    }</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice the <em>loop()</em> method call, which ensures that the actor doesn&#8217;t stop after having processed the first
message.</p>
</div>
<div class="paragraph">
<p>As an alternative you can extend the <em>DefaultActor</em> class and override the <em>act()</em> method. Once you
instantiate the actor, you need to start it so that it attaches itself to the thread pool and can start
accepting messages.  The <em>actor()</em> factory method will take care of starting the actor.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td>
  <td class="code"><pre><span class="type">class</span> <span class="class">CustomActor</span> <span class="directive">extends</span> DefaultActor {
    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> act() {
        loop {
            react {
                println <span class="local-variable">it</span>
            }
        }
    }
}

<span class="keyword">def</span> console=<span class="keyword">new</span> CustomActor()
console.start()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Messages can be sent to the actor using multiple methods</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>console.send(<span class="string"><span class="delimiter">'</span><span class="content">Message</span><span class="delimiter">'</span></span>)
console <span class="string"><span class="delimiter">'</span><span class="content">Message</span><span class="delimiter">'</span></span>
console.sendAndWait <span class="string"><span class="delimiter">'</span><span class="content">Message</span><span class="delimiter">'</span></span>                                                     <span class="comment">//Wait for a reply</span>
console.sendAndContinue <span class="string"><span class="delimiter">'</span><span class="content">Message</span><span class="delimiter">'</span></span>, {reply -&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">I received reply: </span><span class="inline"><span class="inline-delimiter">$</span>reply</span><span class="delimiter">&quot;</span></span>}  <span class="comment">//Forward the reply to a function</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="sect3">
<h4 id="_creating_an_asynchronous_service">Creating An Asynchronous Service</h4>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.actor.Actors.actor</span>

<span class="directive">final</span> <span class="keyword">def</span> decryptor = actor {
    loop {
        react {<span class="predefined-type">String</span> message-&gt;
            reply message.reverse()
        }
    }
}

<span class="keyword">def</span> console = actor {
    decryptor.send <span class="string"><span class="delimiter">'</span><span class="content">lellarap si yvoorG</span><span class="delimiter">'</span></span>
    react {
        println <span class="string"><span class="delimiter">'</span><span class="content">Decrypted message: </span><span class="delimiter">'</span></span> + <span class="local-variable">it</span>
    }
}

console.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, you create new actors with the <em>actor()</em> method passing in the actor&#8217;s body as a closure
parameter. Inside the actor&#8217;s body, you can use <em>loop()</em> to iterate, <em>react()</em> to receive messages and
<em>reply()</em> to send a message to the actor, which has sent the currently processed message. The sender of the
current message is also available through the actor&#8217;s <em>sender</em> property.  When the decryptor actor doesn&#8217;t
find a message in its message queue at the time when <em>react()</em> is called, the <em>react()</em> method gives up the
thread and returns it back to the thread pool for other actors to pick it up.</p>
</div>
<div class="paragraph">
<p>Only after a new message arrives to the actor&#8217;s message queue, the closure of the <em>react()</em> method is scheduled for processing with the pool.
Event-based actors internally simulate continuations - actor&#8217;s work - is split into sequentially run chunks, which are invoked once a message is available in the inbox.
Each chunk for a single actor can be performed by a different thread from the thread pool.</p>
</div>
<div class="paragraph">
<p><strong>Groovy</strong>'s flexible syntax with closures allows our library to offer multiple ways to define actors. For instance, here&#8217;s an example of an actor that waits for up to 30 seconds to receive a reply to its message.
Actors allow time DSL, defined by org.codehaus.groovy.runtime.TimeCategory class, to be used for timeout specification to the <em>react()</em> method, provided the user wraps the call within a <em>TimeCategory</em> use block.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> friend = Actors.actor {
    react {
        <span class="comment">//this doesn't reply -&gt; caller won't receive any answer in time</span>
        println <span class="local-variable">it</span>
        <span class="comment">//reply 'Hello' //uncomment this to answer conversation</span>
        react {
            println <span class="local-variable">it</span>
        }
    }
}

<span class="keyword">def</span> me = Actors.actor {
    friend.send(<span class="string"><span class="delimiter">'</span><span class="content">Hi</span><span class="delimiter">'</span></span>)
    <span class="comment">//wait for answer 1sec</span>
    react(<span class="integer">1000</span>) {msg -&gt;
        <span class="keyword">if</span> (msg == Actor.TIMEOUT) {
            friend.send(<span class="string"><span class="delimiter">'</span><span class="content">I see, busy as usual. Never mind.</span><span class="delimiter">'</span></span>)
            stop()
        } <span class="keyword">else</span> {
            <span class="comment">//continue conversation</span>
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">Thank you for </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>
        }
    }
}

me.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>When a timeout expires when waiting for a message, the <code>Actor.TIMEOUT</code> message arrives instead. Also the <em>onTimeout()</em> handler is invoked, if present on the actor:</p>
</div>
<div class="listingblock">
<div class="title">An Actor Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> friend = Actors.actor {
    react {
        <span class="comment">//this doesn't reply -&gt; caller won't receive any answer in time</span>
        println <span class="local-variable">it</span>
        <span class="comment">//reply 'Hello' //uncomment this to answer conversation</span>
        react {
            println <span class="local-variable">it</span>
        }
    }
}

<span class="keyword">def</span> me = Actors.actor {
    friend.send(<span class="string"><span class="delimiter">'</span><span class="content">Hi</span><span class="delimiter">'</span></span>)

    delegate.metaClass.onTimeout = {-&gt;
        friend.send(<span class="string"><span class="delimiter">'</span><span class="content">I see, busy as usual. Never mind.</span><span class="delimiter">'</span></span>)
        stop()
    }

    <span class="comment">//wait for answer 1sec</span>
    react(<span class="integer">1000</span>) {msg -&gt;
        <span class="keyword">if</span> (msg != Actor.TIMEOUT) {
            <span class="comment">//continue conversation</span>
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">Thank you for </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>
        }
    }
}

me.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice the possibility to use <strong>Groovy</strong> meta-programming to define an actor&#8217;s lifecycle notification methods (e.g. <em>onTimeout()</em> ) dynamically.
Obviously, the lifecycle methods can be defined the usual way when you decide to define a new class for your actor.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre><span class="type">class</span> <span class="class">MyActor</span> <span class="directive">extends</span> DefaultActor {
    <span class="directive">public</span> <span class="type">void</span> onTimeout() {
        ...
    }

    <span class="directive">protected</span> <span class="type">void</span> act() {
       ...
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_actors_guarantee_thread_safety_for_non_thread_safe_code">Actors Guarantee Thread-safety For Non-thread-safe Code</h4>
<div class="paragraph">
<p>Actors guarantee that, always at most, one thread processes the actor&#8217;s body at a time. Under the covers the memory is synchronized each time a thread is assigned to an actor. Therefore, the actor&#8217;s state <strong>can be safely modified</strong> by code in the body without any other extra (synchronization or locking) effort.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre><span class="type">class</span> <span class="class">MyCounterActor</span> <span class="directive">extends</span> DefaultActor {
    <span class="directive">private</span> <span class="predefined-type">Integer</span> counter = <span class="integer">0</span>

    <span class="directive">protected</span> <span class="type">void</span> act() {
        loop {
            react {
                counter++
            }
        }
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Ideally, an actor&#8217;s code should never be invoked directly from outside so all code of the actor class can only be executed by the thread handling the last received message.
Therefore, all the actor&#8217;s code is <strong>implicitly thread-safe</strong>.  If any of the actor&#8217;s methods are allowed to be called by other objects directly, the thread-safety guarantee for the actor&#8217;s code and state is no longer valid.</p>
</div>
<div class="sect4">
<h5 id="_simple_calculator">Simple Calculator</h5>
<div class="paragraph">
<p>Here is a little bit more realistic example of an event-driven actor that receives two numeric messages, sums them up and sends the result to the console actor.</p>
</div>
<div class="listingblock">
<div class="title">A Calculator</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>

<span class="comment">//not necessary, just showing that a single-threaded pool can still handle multiple actors</span>
<span class="keyword">def</span> group = <span class="keyword">new</span> DefaultPGroup(<span class="integer">1</span>);

<span class="directive">final</span> <span class="keyword">def</span> console = group.actor {
    loop {
        react {
            println <span class="string"><span class="delimiter">'</span><span class="content">Result: </span><span class="delimiter">'</span></span> + <span class="local-variable">it</span>
        }
    }
}

<span class="directive">final</span> <span class="keyword">def</span> calculator = group.actor {
    react {a -&gt;
        react {b -&gt;
            console.send(a + b)
        }
    }
}

calculator.send <span class="integer">2</span>
calculator.send <span class="integer">3</span>

calculator.join()
group.shutdown()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that event-driven actors require special care regarding the <em>react()</em> method. Since <em>event_driven
actors</em> need to split the code into independent chunks assignable to different threads sequentially and
<strong>continuations</strong> are not natively supported on JVM, the chunks are created artificially. The <em>react()</em> method
creates the next message handler.  As soon as the current message handler finishes, the next message handler
(continuation) is scheduled.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="_concurrent_merge_sort_example">Concurrent Merge Sort Example</h5>
<div class="paragraph">
<p>For comparison, I&#8217;m also including a more involved example performing a concurrent merge sort of a list of integers using actors.
You can see that, thanks to flexibility of <strong>Groovy</strong>, we came pretty close to the <strong>Scala</strong> model, although I still miss <strong>Scala</strong> pattern-matching for message handling.</p>
</div>
<div class="listingblock">
<div class="title">A Sort Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.actor.Actors.actor</span>

Closure createMessageHandler(<span class="keyword">def</span> parentActor) {
    <span class="keyword">return</span> {
        react {<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; message -&gt;
            <span class="keyword">assert</span> message != <span class="predefined-constant">null</span>
            <span class="keyword">switch</span> (message.size()) {
                <span class="keyword">case</span> <span class="integer">0</span>..<span class="integer">1</span>:
                    parentActor.send(message)
                    <span class="keyword">break</span>
                <span class="keyword">case</span> <span class="integer">2</span>:
                    <span class="keyword">if</span> (message[<span class="integer">0</span>] &lt;= message[<span class="integer">1</span>]) parentActor.send(message)
                    <span class="keyword">else</span> parentActor.send(message[-<span class="integer">1</span>..<span class="integer">0</span>])
                    <span class="keyword">break</span>
                <span class="keyword">default</span>:
                    <span class="keyword">def</span> splitList = split(message)

                    <span class="keyword">def</span> child1 = actor(createMessageHandler(delegate))
                    <span class="keyword">def</span> child2 = actor(createMessageHandler(delegate))
                    child1.send(splitList[<span class="integer">0</span>])
                    child2.send(splitList[<span class="integer">1</span>])

                    react {message1 -&gt;
                        react {message2 -&gt;
                            parentActor.send merge(message1, message2)
                        }
                    }
            }
        }
    }
}

<span class="keyword">def</span> console = <span class="keyword">new</span> DefaultPGroup(<span class="integer">1</span>).actor {
    react {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Sorted array:</span><span class="char">\t</span><span class="inline"><span class="inline-delimiter">${</span><span class="local-variable">it</span><span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
        <span class="predefined-type">System</span>.exit <span class="integer">0</span>
    }
}

<span class="keyword">def</span> sorter = actor(createMessageHandler(console))
sorter.send([<span class="integer">1</span>, <span class="integer">5</span>, <span class="integer">2</span>, <span class="integer">4</span>, <span class="integer">3</span>, <span class="integer">8</span>, <span class="integer">6</span>, <span class="integer">7</span>, <span class="integer">3</span>, <span class="integer">9</span>, <span class="integer">5</span>, <span class="integer">3</span>])
console.join()

<span class="keyword">def</span> <span class="function">split</span>(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; list) {
    <span class="type">int</span> listSize = list.size()
    <span class="type">int</span> middleIndex = listSize / <span class="integer">2</span>
    <span class="keyword">def</span> list1 = list[<span class="integer">0</span>..&lt;middleIndex]
    <span class="keyword">def</span> list2 = list[middleIndex..listSize - <span class="integer">1</span>]
    <span class="keyword">return</span> [list1, list2]
}

<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; merge(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; a, <span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; b) {
    <span class="type">int</span> i = <span class="integer">0</span>, j = <span class="integer">0</span>
    <span class="directive">final</span> <span class="type">int</span> newSize = a.size() + b.size()
    <span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; result = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Integer</span>&gt;(newSize)

    <span class="keyword">while</span> ((i &lt; a.size()) &amp;&amp; (j &lt; b.size())) {
        <span class="keyword">if</span> (a[i] &lt;= b[j]) result &lt;&lt; a[i++]
        <span class="keyword">else</span> result &lt;&lt; b[j++]
    }

    <span class="keyword">if</span> (i &lt; a.size()) result.addAll(a[i..-<span class="integer">1</span>])
    <span class="keyword">else</span> result.addAll(b[j..-<span class="integer">1</span>])
    <span class="keyword">return</span> result
}
</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since <em>actors</em> reuse threads from a pool, the script will work with virtually any size thread pool, no matter how many actors are created along the way.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="_actor_lifecycle_methods">Actor Lifecycle Methods</h5>
<div class="paragraph">
<p>Each Actor can define lifecycle observing methods, which will be called whenever a certain lifecycle event occurs.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>afterStart()</em> - called right after the actor has been started.</p>
</li>
<li>
<p><em>afterStop(List undeliveredMessages)</em> - called right after the actor is stopped, passing in all the unprocessed messages from the queue.</p>
</li>
<li>
<p><em>onInterrupt(InterruptedException e)</em> - called when the actor&#8217;s thread gets interrupted. Thread interruption will result in the stopping the actor in any case.</p>
</li>
<li>
<p><em>onTimeout()</em> - called when no messages are sent to the actor within the timeout specified for the currently blocking react method.</p>
</li>
<li>
<p><em>onException(Throwable e)</em> - called when an exception occurs in the actor&#8217;s event handler. Actor will stop after return from this method.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can either define the methods statically in your Actor class or add them dynamically to the actor&#8217;s metaclass:</p>
</div>
<div class="listingblock">
<div class="title">An Actor Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td>
  <td class="code"><pre><span class="type">class</span> <span class="class">MyActor</span> <span class="directive">extends</span> DefaultActor {
    <span class="directive">public</span> <span class="type">void</span> afterStart() {
        ...
    }
    <span class="directive">public</span> <span class="type">void</span> onTimeout() {
        ...
    }

    <span class="directive">protected</span> <span class="type">void</span> act() {
       ...
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Another Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> myActor = actor {
    delegate.metaClass.onException = {
        log.error(<span class="string"><span class="delimiter">'</span><span class="content">Exception occurred</span><span class="delimiter">'</span></span>, <span class="local-variable">it</span>)
    }

...
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Performance Tips</div>
<div class="paragraph">
<p>To help performance, you may consider using the <em>silentStart()</em> method instead of <em>start()</em> when starting a <em>DynamicDispatchActor</em> or a <em>ReactiveActor</em>.
Calling <em>silentStart()</em> will by-pass some of the start-up machinery and as a result will also avoid calling the <em>afterStart()</em> method.
Due to its stateful nature, <em>DefaultActor</em> cannot be started silently.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_pool_management">Pool Management</h5>
<div class="paragraph">
<p><em>Actors</em> can be organized into groups and, as a default, there&#8217;s always an application-wide pooled actor group available.
And, just like the <em>Actors</em> abstract factory, can be used to create actors in the default group. Custom groups can be used as abstract factories to create new actors instances belonging to these groups.</p>
</div>
<div class="listingblock">
<div class="title">A Group Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> myGroup = <span class="keyword">new</span> DefaultPGroup()

<span class="keyword">def</span> actor1 = myGroup.actor {
...
}

<span class="keyword">def</span> actor2 = myGroup.actor {
...
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>parallelGroup</em> property of an actor points to the group it belongs to.
By default, it points to the default actor group, which is <em>Actors.defaultActorPGroup</em> , and can only be changed before the actor is started.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre><span class="type">class</span> <span class="class">MyActor</span> <span class="directive">extends</span> StaticDispatchActor&lt;<span class="predefined-type">Integer</span>&gt; {
    <span class="directive">private</span> <span class="directive">static</span> PGroup group = <span class="keyword">new</span> DefaultPGroup(<span class="integer">100</span>)

    MyActor(...) {
        <span class="local-variable">this</span>.parallelGroup = group
        ...
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The actors belonging to the same group share the underlying thread pool of that group.
The pool, by default, contains n + 1 threads, where <strong>n</strong> stands for the number of <strong>CPUs</strong> detected by the JVM.
The <strong>pool size</strong> can be set explicitly, either by setting the <em>gpars.poolsize</em> system property or, individually, for each actor group.
This is by specifying the appropriate constructor parameter.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> myGroup = <span class="keyword">new</span> DefaultPGroup(<span class="integer">10</span>)  <span class="comment">//the pool will contain 10 threads</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The thread pool can be manipulated through the appropriate <em>DefaultPGroup</em> class, which <strong>delegates</strong> to the
<em>Pool</em> interface of the thread pool. For example, the <em>resize()</em> method allows you to change the pool size
any time and the <em>resetDefaultSize()</em> sets it back to the default value. The <em>shutdown()</em> method can be
called when you need to safely finish all tasks, destroy the pool and stop all the threads in order to exit
JVM in an organized manner.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre>... (n+<span class="integer">1</span> threads <span class="keyword">in</span> the <span class="keyword">default</span> pool after startup)

Actors.defaultActorPGroup.resize <span class="integer">1</span>  <span class="comment">//use one-thread pool</span>

... (<span class="integer">1</span> thread <span class="keyword">in</span> the pool)

Actors.defaultActorPGroup.resetDefaultSize()

... (n+<span class="integer">1</span> threads <span class="keyword">in</span> the pool)

Actors.defaultActorPGroup.shutdown()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>As an alternative to the <em>DefaultPGroup</em>, which creates a pool of daemon threads, the <em>NonDaemonPGroup</em>
class can be used when non-daemon threads are required.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> daemonGroup = <span class="keyword">new</span> DefaultPGroup()

<span class="keyword">def</span> actor1 = daemonGroup.actor {
...
}

<span class="keyword">def</span> nonDaemonGroup = <span class="keyword">new</span> NonDaemonPGroup()

<span class="keyword">def</span> actor2 = nonDaemonGroup.actor {
...
}

<span class="type">class</span> <span class="class">MyActor</span> {
    <span class="keyword">def</span> <span class="function">MyActor</span>() {
        <span class="local-variable">this</span>.parallelGroup = nonDaemonGroup
    }

    <span class="type">void</span> act() {...}
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Actors belonging to the same group share the underlying thread pool.
With <em>pooled actor groups</em>, you can split your actors to leverage multiple thread pools of different sizes and so assign resources to different components of your system and tune their performance.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> coreActors = <span class="keyword">new</span> NonDaemonPGroup(<span class="integer">5</span>)  <span class="comment">//5 non-daemon threads pool</span>
<span class="keyword">def</span> helperActors = <span class="keyword">new</span> DefaultPGroup(<span class="integer">1</span>)  <span class="comment">//1 daemon thread pool</span>

<span class="keyword">def</span> priceCalculator = coreActors.actor {
...
}

<span class="keyword">def</span> paymentProcessor = coreActors.actor {
...
}

<span class="keyword">def</span> emailNotifier = helperActors.actor {
...
}

<span class="keyword">def</span> cleanupActor = helperActors.actor {
...
}

<span class="comment">//increase size of the core actor group</span>
coreActors.resize <span class="integer">6</span>

<span class="comment">//shutdown the group's pool once you no longer need the group to release resources</span>
helperActors.shutdown()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Do not forget to shutdown custom pooled actor groups, once you no longer need them and their actors, to preserve system resources.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="_the_default_actor_group">The Default Actor Group</h5>
<div class="paragraph">
<p>Actors that didn&#8217;t have their <em>parallelGroup</em> property changed or that were created through any of the factory methods on the <em>Actors</em> class can share a common group <em>Actors.defaultActorPGroup</em> .
This group uses a <strong>resizeable thread pool</strong> with an upper limit of <strong>1000 threads</strong> .  This gives you the comfort of having the pool automatically adjust to the demand of the actors.
On the other hand, with a growing number of actors, the pool may become too big an inefficient.
It&#8217;s advisable to group your actors into your own PGroups with fixed size thread pools for all but trivial applications.</p>
</div>
</div>
<div class="sect4">
<h5 id="_common_trap_app_terminates_while_actors_do_not_receive_messages">Common Trap: App Terminates While Actors Do Not Receive Messages</h5>
<div class="paragraph">
<p>Most likely you&#8217;re using daemon threads and pools, which is the default setting, and your main thread finishes.
Calling <em>actor.join()</em> on any, some or all of your actors would block the main thread until the actor terminates and thus keep all your actors running.</p>
</div>
<div class="paragraph">
<p>Alternatively, use instances of <em>NonDaemonPGroup</em> and assign some of your actors to these groups.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> nonDaemonGroup = <span class="keyword">new</span> NonDaemonPGroup()
<span class="keyword">def</span> myActor = nonDaemonGroup.actor {...}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>alternatively
.A Sample</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> nonDaemonGroup = <span class="keyword">new</span> NonDaemonPGroup()

<span class="type">class</span> <span class="class">MyActor</span> <span class="directive">extends</span> DefaultActor {
    <span class="keyword">def</span> <span class="function">MyActor</span>() {
        <span class="local-variable">this</span>.parallelGroup = nonDaemonGroup
    }

    <span class="type">void</span> act() {...}
}

<span class="keyword">def</span> myActor = <span class="keyword">new</span> MyActor()</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_blocking_actors">Blocking Actors</h5>
<div class="paragraph">
<p>Instead of event-driven continuation-styled actors, you may in some scenarios prefer using blocking actors.
Blocking actors hold a single pooled thread for their whole life-time including the time when waiting for messages.
They avoid some of the thread management overhead, since they never fight for threads after start, and also let you write straight code without the necessity of continuation style.
Since they only do blocking, message reads are via the <em>receive</em> method.  Obviously, the number of blocking actors running concurrently, is limited by the number of threads available in the shared pool.
On the other hand, blocking actors typically provide better performance compared to continuation-style actors, especially when the actor&#8217;s message queue rarely is empty.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> decryptor = blockingActor {
    <span class="keyword">while</span> (<span class="predefined-constant">true</span>) {
        receive {message -&gt;
            <span class="keyword">if</span> (message <span class="keyword">instanceof</span> <span class="predefined-type">String</span>) reply message.reverse()
            <span class="keyword">else</span> stop()
        }
    }
}

<span class="keyword">def</span> console = blockingActor {
    decryptor.send <span class="string"><span class="delimiter">'</span><span class="content">lellarap si yvoorG</span><span class="delimiter">'</span></span>
    println <span class="string"><span class="delimiter">'</span><span class="content">Decrypted message: </span><span class="delimiter">'</span></span> + receive()
    decryptor.send <span class="predefined-constant">false</span>
}

[decryptor, console]*.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Blocking actors increase the number of options to tune performance of your applications.
They may, in particular, be good candidates for high-traffic positions in your actor network.</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stateless_actors">Stateless Actors</h3>
<div class="sect3">
<h4 id="_dynamic_dispatch_actor">Dynamic Dispatch Actor</h4>
<div class="paragraph">
<p>The <em>DynamicDispatchActor</em> class is an actor allowing for an alternative structure of the message handling code.</p>
</div>
<div class="paragraph">
<p>In general, <em>DynamicDispatchActor</em> repeatedly scans for messages and dispatches arrived messages to one of the <em>onMessage(message)</em> methods defined on the actor.
The <em>DynamicDispatchActor</em> leverages the <strong>Groovy</strong> dynamic method dispatch mechanism under the covers.
Since, unlike <em>DefaultActor</em> descendants, a <em>DynamicDispatchActor</em> not <em>ReactiveActor</em> (discussed below) do not need to implicitly remember an actor&#8217;s state between subsequent message receptions,
they provide much better performance characteristics, generally comparable to other actor frameworks, like e.g. Scala Actors.</p>
</div>
<div class="listingblock">
<div class="title">A Dynamic Dispatch Actor Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.actor.Actors</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.actor.DynamicDispatchActor</span>

<span class="directive">final</span> <span class="type">class</span> <span class="class">MyActor</span> <span class="directive">extends</span> DynamicDispatchActor {

    <span class="type">void</span> onMessage(<span class="predefined-type">String</span> message) {
        println <span class="string"><span class="delimiter">'</span><span class="content">Received string</span><span class="delimiter">'</span></span>
    }

    <span class="type">void</span> onMessage(<span class="predefined-type">Integer</span> message) {
        println <span class="string"><span class="delimiter">'</span><span class="content">Received integer</span><span class="delimiter">'</span></span>
        reply <span class="string"><span class="delimiter">'</span><span class="content">Thanks!</span><span class="delimiter">'</span></span>
    }

    <span class="type">void</span> onMessage(<span class="predefined-type">Object</span> message) {
        println <span class="string"><span class="delimiter">'</span><span class="content">Received object</span><span class="delimiter">'</span></span>
        sender.send <span class="string"><span class="delimiter">'</span><span class="content">Thanks!</span><span class="delimiter">'</span></span>
    }

    <span class="type">void</span> onMessage(<span class="predefined-type">List</span> message) {
        println <span class="string"><span class="delimiter">'</span><span class="content">Received list</span><span class="delimiter">'</span></span>
        stop()
    }
}

<span class="directive">final</span> <span class="keyword">def</span> myActor = <span class="keyword">new</span> MyActor().start()

Actors.actor {
    myActor <span class="integer">1</span>
    myActor <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>
    myActor <span class="float">1.0</span>
    myActor(<span class="keyword">new</span> <span class="predefined-type">ArrayList</span>())
    myActor.join()
}.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>In some scenarios, typically when no implicit conversation-history-dependent state needs to be preserved for the actor,
the dynamic dispatch code structure may be more intuitive than the traditional one using nested <em>loop</em> and <em>react</em> statements.</p>
</div>
<div class="paragraph">
<p>The <em>DynamicDispatchActor</em> class also provides a handy facility to add message handlers dynamically at actor construction time
or any time later using the <em>when</em> handlers, optionally wrapped inside a <em>become</em> method:</p>
</div>
<div class="listingblock">
<div class="title">A DynamicDispatchActor Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td>
  <td class="code"><pre><span class="directive">final</span> Actor myActor = <span class="keyword">new</span> DynamicDispatchActor().become {
    when {<span class="predefined-type">String</span> msg -&gt; println <span class="string"><span class="delimiter">'</span><span class="content">A String</span><span class="delimiter">'</span></span>; reply <span class="string"><span class="delimiter">'</span><span class="content">Thanks</span><span class="delimiter">'</span></span>}
    when {<span class="predefined-type">Double</span> msg -&gt; println <span class="string"><span class="delimiter">'</span><span class="content">A Double</span><span class="delimiter">'</span></span>; reply <span class="string"><span class="delimiter">'</span><span class="content">Thanks</span><span class="delimiter">'</span></span>}
    when {msg -&gt; println <span class="string"><span class="delimiter">'</span><span class="content">A something ...</span><span class="delimiter">'</span></span>; reply <span class="string"><span class="delimiter">'</span><span class="content">What was that?</span><span class="delimiter">'</span></span>;stop()}
}
myActor.start()
Actors.actor {
    myActor <span class="string"><span class="delimiter">'</span><span class="content">Hello</span><span class="delimiter">'</span></span>
    myActor <span class="float">1.0d</span>
    myActor <span class="integer">10</span> <span class="keyword">as</span> <span class="predefined-type">BigDecimal</span>
    myActor.join()
}.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Obviously the two approaches can be combined:</p>
</div>
<div class="listingblock">
<div class="title">A Combined Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td>
  <td class="code"><pre><span class="directive">final</span> <span class="type">class</span> <span class="class">MyDDA</span> <span class="directive">extends</span> DynamicDispatchActor {

    <span class="type">void</span> onMessage(<span class="predefined-type">String</span> message) {
        println <span class="string"><span class="delimiter">'</span><span class="content">Received string</span><span class="delimiter">'</span></span>
    }

    <span class="type">void</span> onMessage(<span class="predefined-type">Integer</span> message) {
        println <span class="string"><span class="delimiter">'</span><span class="content">Received integer</span><span class="delimiter">'</span></span>
    }

    <span class="type">void</span> onMessage(<span class="predefined-type">Object</span> message) {
        println <span class="string"><span class="delimiter">'</span><span class="content">Received object</span><span class="delimiter">'</span></span>
    }

    <span class="type">void</span> onMessage(<span class="predefined-type">List</span> message) {
        println <span class="string"><span class="delimiter">'</span><span class="content">Received list</span><span class="delimiter">'</span></span>
        stop()
    }
}

<span class="directive">final</span> <span class="keyword">def</span> myActor = <span class="keyword">new</span> MyDDA().become {
    when {<span class="predefined-type">BigDecimal</span> num -&gt; println <span class="string"><span class="delimiter">'</span><span class="content">Received BigDecimal</span><span class="delimiter">'</span></span>}
    when {<span class="predefined-type">Float</span> num -&gt; println <span class="string"><span class="delimiter">'</span><span class="content">Got a float</span><span class="delimiter">'</span></span>}
}.start()

Actors.actor {
    myActor <span class="string"><span class="delimiter">'</span><span class="content">Hello</span><span class="delimiter">'</span></span>
    myActor <span class="float">1.0f</span>
    myActor <span class="integer">10</span> <span class="keyword">as</span> <span class="predefined-type">BigDecimal</span>
    myActor.send(<span class="type">[]</span>)
    myActor.join()
}.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The dynamic message handlers registered via <em>when</em>  will take precedence over the static <em>onMessage</em> handlers.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Fair or non-fair Behavior of DynamicDispatchActors</div>
<div class="paragraph">
<p><em>DynamicDispatchActor</em> can be set to behave in a fair on non-fair (default) manner. Depending on the
strategy chosen, the actor either makes the thread available to other actors sharing the same parallel group
(fair), or keeps the thread fot itself until the message queue gets empty (non-fair).</p>
</div>
<div class="paragraph">
<p>Generally, non-fair actors perform 2 - 3 times better than fair ones.</p>
</div>
<div class="paragraph">
<p>Use either the <em>fairMessageHandler()</em> factory method or the actor&#8217;s <em>makeFair()</em> method.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">A Fair Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>    <span class="keyword">def</span> fairActor = Actors.fairMessageHandler {...}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_static_dispatch_actor">Static Dispatch Actor</h4>
<div class="paragraph">
<p>While <em>DynamicDispatchActor</em> dispatches messages based on their run-time type and so pays extra performance penalty for each message,
<em>StaticDispatchActor</em> avoids run-time message checks and dispatches the message solely based on the compile-time information.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td>
  <td class="code"><pre><span class="directive">final</span> <span class="type">class</span> <span class="class">MyActor</span> <span class="directive">extends</span> StaticDispatchActor&lt;<span class="predefined-type">String</span>&gt; {
    <span class="type">void</span> onMessage(<span class="predefined-type">String</span> message) {
        println <span class="string"><span class="delimiter">'</span><span class="content">Received string </span><span class="delimiter">'</span></span> + message

        <span class="keyword">switch</span> (message) {
            <span class="keyword">case</span> <span class="string"><span class="delimiter">'</span><span class="content">hello</span><span class="delimiter">'</span></span>:
                reply <span class="string"><span class="delimiter">'</span><span class="content">Hi!</span><span class="delimiter">'</span></span>
                <span class="keyword">break</span>
            <span class="keyword">case</span> <span class="string"><span class="delimiter">'</span><span class="content">stop</span><span class="delimiter">'</span></span>:
                stop()
        }
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Instances of <em>StaticDispatchActor</em> have to override the <em>onMessage</em> method appropriate for the actor&#8217;s declared type parameter.
The <em>onMessage(T message)</em> method is then invoked with every received message.</p>
</div>
<div class="paragraph">
<p>A shorter route towards both fair and non-fair static dispatch actors is available through the helper factory methods:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td>
  <td class="code"><pre><span class="directive">final</span> actor = staticMessageHandler {<span class="predefined-type">String</span> message -&gt;
    println <span class="string"><span class="delimiter">'</span><span class="content">Received string </span><span class="delimiter">'</span></span> + message

    <span class="keyword">switch</span> (message) {
        <span class="keyword">case</span> <span class="string"><span class="delimiter">'</span><span class="content">hello</span><span class="delimiter">'</span></span>:
            reply <span class="string"><span class="delimiter">'</span><span class="content">Hi!</span><span class="delimiter">'</span></span>
            <span class="keyword">break</span>
        <span class="keyword">case</span> <span class="string"><span class="delimiter">'</span><span class="content">stop</span><span class="delimiter">'</span></span>:
            stop()
    }
}

println <span class="string"><span class="delimiter">'</span><span class="content">Reply: </span><span class="delimiter">'</span></span> + actor.sendAndWait(<span class="string"><span class="delimiter">'</span><span class="content">hello</span><span class="delimiter">'</span></span>)
actor <span class="string"><span class="delimiter">'</span><span class="content">bye</span><span class="delimiter">'</span></span>
actor <span class="string"><span class="delimiter">'</span><span class="content">stop</span><span class="delimiter">'</span></span>
actor.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>When compared to the <em>DynamicDispatchActor</em>, the <em>StaticDispatchActor</em> class is limited to a single handler method.</p>
</div>
<div class="paragraph">
<p>This simplified creation without any <strong>when</strong> handlers, plus the considerable performance benefits, should make <em>StaticDispatchActor</em> your default choice for straightforward message handlers.
Use this wnmb hen dispatching based on message run-time type is not necessary.</p>
</div>
<div class="paragraph">
<p>For example, <em>StaticDispatchActors</em> make dataflow operators four times faster than the <em>DynamicDispatchActor</em> .</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_reactive_actor">Reactive Actor</h4>
<div class="paragraph">
<p>The <em>ReactiveActor</em> class, constructed typically by calling <em>Actors.reactor()</em> or <em>DefaultPGroup.reactor()</em>, allows ar more event-driven approach.</p>
</div>
<div class="paragraph">
<p>When a reactive actor receives a message, the supplied block of code, which makes up the reactive actor&#8217;s body, is run with the message as a parameter.
The result returned from the code is sent in reply.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td>
  <td class="code"><pre><span class="directive">final</span> <span class="keyword">def</span> group = <span class="keyword">new</span> DefaultPGroup()

<span class="directive">final</span> <span class="keyword">def</span> doubler = group.reactor {
    <span class="integer">2</span> * <span class="local-variable">it</span>
}

group.actor {
    println <span class="string"><span class="delimiter">'</span><span class="content">Double of 10 = </span><span class="delimiter">'</span></span> + doubler.sendAndWait(<span class="integer">10</span>)
}

group.actor {
    println <span class="string"><span class="delimiter">'</span><span class="content">Double of 20 = </span><span class="delimiter">'</span></span> + doubler.sendAndWait(<span class="integer">20</span>)
}

group.actor {
    println <span class="string"><span class="delimiter">'</span><span class="content">Double of 30 = </span><span class="delimiter">'</span></span> + doubler.sendAndWait(<span class="integer">30</span>)
}

<span class="keyword">for</span>(i <span class="keyword">in</span> (<span class="integer">1</span>..<span class="integer">10</span>)) {
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Double of </span><span class="inline"><span class="inline-delimiter">$</span>i</span><span class="content"> = </span><span class="inline"><span class="inline-delimiter">${</span>doubler.sendAndWait(i)<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
}

doubler.stop()
doubler.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of an actor that submits a batch of numbers to a <em>ReactiveActor</em> for processing and then prints the results gradually as they arrive.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.actor.Actor</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.actor.Actors</span>

<span class="directive">final</span> <span class="keyword">def</span> doubler = Actors.reactor {
    <span class="integer">2</span> * <span class="local-variable">it</span>
}

Actor actor = Actors.actor {
    (<span class="integer">1</span>..<span class="integer">10</span>).each {doubler &lt;&lt; <span class="local-variable">it</span>}
    <span class="type">int</span> i = <span class="integer">0</span>
    loop {
        i += <span class="integer">1</span>
        <span class="keyword">if</span> (i &gt; <span class="integer">10</span>) stop()
        <span class="keyword">else</span> {
            react {message -&gt;
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">Double of </span><span class="inline"><span class="inline-delimiter">$</span>i</span><span class="content"> = </span><span class="inline"><span class="inline-delimiter">$</span>message</span><span class="delimiter">&quot;</span></span>
            }
        }
    }
}

actor.join()
doubler.stop()
doubler.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Essentially, reactive actors provide a convenience shortcut for an actor that would wait for messages in a loop, process them and send back the result.
This is schematically how the reactive actor looks inside:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">class</span> <span class="class">ReactiveActor</span> <span class="directive">extends</span> DefaultActor {
    Closure body

    <span class="type">void</span> act() {
        loop {
            react {message -&gt;
                reply body(message)
            }
        }
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Fair or Non-fair Behavior of ReactiveActors</div>
<div class="paragraph">
<p><em>ReactiveActor</em> can be set to behave in a fair or unfair (default) manner.</p>
</div>
<div class="paragraph">
<p>Depending on the strategy chosen, the actor either makes the thread available to other actors sharing the same parallel group (fair), or keeps the thread for itself until the message queue is empty (non-fair).
Generally, non-fair actors perform 2–3 times better than fair ones.</p>
</div>
<div class="paragraph">
<p>Use either the <em>fairReactor()</em> factory method or the actor&#8217;s <em>makeFair()</em> method.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">A Fair Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>    <span class="keyword">def</span> fairActor = Actors.fairReactor {...}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_tips_and_tricks">Tips and Tricks</h3>
<div class="sect3">
<h4 id="_structuring_actor_s_code">Structuring Actor&#8217;s Code</h4>
<div class="paragraph">
<p>When extending the <em>DefaultActor</em> class, you can call any actor&#8217;s methods from within the <em>act()</em> method and
use the <em>react()</em> or <em>loop()</em> methods in them.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td>
  <td class="code"><pre><span class="type">class</span> <span class="class">MyDemoActor</span> <span class="directive">extends</span> DefaultActor {

    <span class="directive">protected</span> <span class="type">void</span> act() {
        handleA()
    }

    <span class="directive">private</span> <span class="type">void</span> handleA() {
        react {a -&gt;
            handleB(a)
        }
    }

    <span class="directive">private</span> <span class="type">void</span> handleB(<span class="type">int</span> a) {
        react {b -&gt;
            println a + b
            reply a + b
        }
    }
}

<span class="directive">final</span> <span class="keyword">def</span> demoActor = <span class="keyword">new</span> MyDemoActor()
demoActor.start()

Actors.actor {
    demoActor <span class="integer">10</span>
    demoActor <span class="integer">20</span>
    react {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>
    }
}.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Bear in mind that the methods <em>handleA()</em> and <em>handleB()</em> in all our examples will only schedule the supplied message handlers to run as continuations of the current calculation in reaction to the next message arriving.</p>
</div>
<div class="paragraph">
<p>Alternatively, when using the <em>actor()</em> factory method, you can add event-handling code through the meta class as closures.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td>
  <td class="code"><pre>Actor demoActor = Actors.actor {
    delegate.metaClass {
        handleA = {-&gt;
            react {a -&gt;
                 handleB(a)
            }
        }

        handleB = {a -&gt;
            react {b -&gt;
                println a + b
                reply a + b
            }
        }
    }

    handleA()
}

Actors.actor {
    demoActor <span class="integer">10</span>
    demoActor <span class="integer">20</span>
    react {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>
    }
}.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Closures, which have the actor set as their delegate, can also be used to structure event-handling code.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td>
  <td class="code"><pre>Closure handleB = {a -&gt;
    react {b -&gt;
        println a + b
        reply a + b
    }
}

Closure handleA = {-&gt;
    react {a -&gt;
        handleB(a)
    }
}

Actor demoActor = Actors.actor {
    handleA.delegate = delegate
    handleB.delegate = delegate

    handleA()
}

Actors.actor {
    demoActor <span class="integer">10</span>
    demoActor <span class="integer">20</span>
    react {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>
    }
}.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_event_driven_loops">Event-Driven Loops</h4>
<div class="paragraph">
<p>When coding event-driven actors, please kepp in mind that calls to <em>react()</em> and <em>loop()</em> methods have slightly different semantics.</p>
</div>
<div class="paragraph">
<p>This becomes a bit of a challenge once you try to implement any types of loops in your actors.  On the other hand,
if you leverage the fact that <em>react()</em> only schedules a continuation and returns, you may call methods recursively without fear of stack overflow.
Look at the examples below that use these three described techniques for structuring actor&#8217;s code.</p>
</div>
<div class="sect4">
<h5 id="_a_subclass_of_em_defaultactor_em">A Subclass Of <em>DefaultActor</em></h5>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td>
  <td class="code"><pre><span class="type">class</span> <span class="class">MyLoopActor</span> <span class="directive">extends</span> DefaultActor {

    <span class="directive">protected</span> <span class="type">void</span> act() {
        outerLoop()
    }

    <span class="directive">private</span> <span class="type">void</span> outerLoop() {
        react {a -&gt;
            println <span class="string"><span class="delimiter">'</span><span class="content">Outer: </span><span class="delimiter">'</span></span> + a
            <span class="keyword">if</span> (a != <span class="integer">0</span>) innerLoop()
            <span class="keyword">else</span> println <span class="string"><span class="delimiter">'</span><span class="content">Done</span><span class="delimiter">'</span></span>
        }
    }

    <span class="directive">private</span> <span class="type">void</span> innerLoop() {
        react {b -&gt;
            println <span class="string"><span class="delimiter">'</span><span class="content">Inner </span><span class="delimiter">'</span></span> + b
            <span class="keyword">if</span> (b == <span class="integer">0</span>) outerLoop()
            <span class="keyword">else</span> innerLoop()
        }
    }
}

<span class="directive">final</span> <span class="keyword">def</span> actor = <span class="keyword">new</span> MyLoopActor().start()
actor <span class="integer">10</span>
actor <span class="integer">20</span>
actor <span class="integer">0</span>
actor <span class="integer">0</span>
actor.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="_enhancing_the_actor_s_metaclass">Enhancing The Actor&#8217;s MetaClass</h4>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td>
  <td class="code"><pre>Actor actor = Actors.actor {

  delegate.metaClass {
      outerLoop = {-&gt;
          react {a -&gt;
              println <span class="string"><span class="delimiter">'</span><span class="content">Outer: </span><span class="delimiter">'</span></span> + a
              <span class="keyword">if</span> (a!=<span class="integer">0</span>) innerLoop()
              <span class="keyword">else</span> println <span class="string"><span class="delimiter">'</span><span class="content">Done</span><span class="delimiter">'</span></span>
          }
      }

      innerLoop = {-&gt;
          react {b -&gt;
              println <span class="string"><span class="delimiter">'</span><span class="content">Inner </span><span class="delimiter">'</span></span> + b
              <span class="keyword">if</span> (b==<span class="integer">0</span>) outerLoop()
              <span class="keyword">else</span> innerLoop()
          }
      }
  }

  outerLoop()
}

actor <span class="integer">10</span>
actor <span class="integer">20</span>
actor <span class="integer">0</span>
actor <span class="integer">0</span>
actor.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_using_groovy_closures">Using Groovy Closures</h4>
<div class="listingblock">
<div class="title">A Groovy Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td>
  <td class="code"><pre>Closure innerLoop

Closure outerLoop = {-&gt;
    react {a -&gt;
        println <span class="string"><span class="delimiter">'</span><span class="content">Outer: </span><span class="delimiter">'</span></span> + a
        <span class="keyword">if</span> (a!=<span class="integer">0</span>) innerLoop()
        <span class="keyword">else</span> println <span class="string"><span class="delimiter">'</span><span class="content">Done</span><span class="delimiter">'</span></span>
    }
}

innerLoop = {-&gt;
    react {b -&gt;
        println <span class="string"><span class="delimiter">'</span><span class="content">Inner </span><span class="delimiter">'</span></span> + b
        <span class="keyword">if</span> (b==<span class="integer">0</span>) outerLoop()
        <span class="keyword">else</span> innerLoop()
    }
}

Actor actor = Actors.actor {
    outerLoop.delegate = delegate
    innerLoop.delegate = delegate

    outerLoop()
}

actor <span class="integer">10</span>
actor <span class="integer">20</span>
actor <span class="integer">0</span>
actor <span class="integer">0</span>
actor.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Plus don&#8217;t forget about the idea of using the actor&#8217;s <em>loop()</em> method to create a loop that runs until the actor terminates.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td>
  <td class="code"><pre><span class="type">class</span> <span class="class">MyLoopingActor</span> <span class="directive">extends</span> DefaultActor {

  <span class="directive">protected</span> <span class="type">void</span> act() {
      loop {
          outerLoop()
      }
  }

  <span class="directive">private</span> <span class="type">void</span> outerLoop() {
      react {a -&gt;
          println <span class="string"><span class="delimiter">'</span><span class="content">Outer: </span><span class="delimiter">'</span></span> + a
          <span class="keyword">if</span> (a!=<span class="integer">0</span>) innerLoop()
          <span class="keyword">else</span> println <span class="string"><span class="delimiter">'</span><span class="content">Done for now, but will loop again</span><span class="delimiter">'</span></span>
      }
  }

  <span class="directive">private</span> <span class="type">void</span> innerLoop() {
      react {b -&gt;
          println <span class="string"><span class="delimiter">'</span><span class="content">Inner </span><span class="delimiter">'</span></span> + b
          <span class="keyword">if</span> (b == <span class="integer">0</span>) outerLoop()
          <span class="keyword">else</span> innerLoop()
      }
  }
}

<span class="directive">final</span> <span class="keyword">def</span> actor = <span class="keyword">new</span> MyLoopingActor().start()
actor <span class="integer">10</span>
actor <span class="integer">20</span>
actor <span class="integer">0</span>
actor <span class="integer">0</span>
actor <span class="integer">10</span>
actor.stop()
actor.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_active_objects">Active Objects</h3>
<div class="paragraph">
<p>Active objects provide an <strong>OO</strong> facade on top of actors. This allows you to avoid dealing directly with the actor machinery, having to match messages, wait for results and send replies. Ouch !</p>
</div>
<div class="sect3">
<h4 id="_actors_with_a_friendly_facade">Actors With a Friendly Facade</h4>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.activeobject.ActiveObject</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.activeobject.ActiveMethod</span>

<span class="annotation">@ActiveObject</span>
<span class="type">class</span> <span class="class">Decryptor</span> {
    <span class="annotation">@ActiveMethod</span>
    <span class="keyword">def</span> <span class="function">decrypt</span>(<span class="predefined-type">String</span> encryptedText) {
        <span class="keyword">return</span> encryptedText.reverse()
    }

    <span class="annotation">@ActiveMethod</span>
    <span class="keyword">def</span> <span class="function">decrypt</span>(<span class="predefined-type">Integer</span> encryptedNumber) {
        <span class="keyword">return</span> -<span class="integer">1</span>*encryptedNumber + <span class="integer">142</span>
    }
}

<span class="directive">final</span> Decryptor decryptor = <span class="keyword">new</span> Decryptor()
<span class="keyword">def</span> part1 = decryptor.decrypt(<span class="string"><span class="delimiter">'</span><span class="content"> noitcA ni yvoorG</span><span class="delimiter">'</span></span>)
<span class="keyword">def</span> part2 = decryptor.decrypt(<span class="integer">140</span>)
<span class="keyword">def</span> part3 = decryptor.decrypt(<span class="string"><span class="delimiter">'</span><span class="content">noitide dn</span><span class="delimiter">'</span></span>)

print part1.get()
print part2.get()
println part3.get()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>You mark active objects with the <em>@ActiveObject</em> annotation. This will ensure a hidden actor instance is
created for each instance of your class.  Now you can mark methods with the <em>@ActiveMethod</em> annotation
indicating that you want the method to be invoked asynchronously by the target object&#8217;s internal actor.  An
optional boolean <em>blocking</em> parameter to the <em>@ActiveMethod</em> annotation specifies, whether the caller should
block until a result is available or whether instead the caller should only receive a <em>promise</em> for a future
result in a form of a <em>DataflowVariable</em> and so the caller is not blocked waiting.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Blocking or Not ?</div>
<div class="paragraph">
<p>By default, all active methods are set to be <strong>non-blocking</strong> . However, methods that declare their return type explicitly,
must be configured as blocking, otherwise the compiler will report an error. Only <em>def</em>, <em>void</em> and <em>DataflowVariable</em> are permissible return types for non-blocking methods.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Under the covers, <strong>GPars</strong> will translate your method call to <strong>a message being sent to the internal actor</strong>.
The actor will eventually handle that message by invoking the desired method on behalf of the caller and once finished a reply will be sent back to the caller.
Non-blocking methods return promises for results, aka <em>DataflowVariables</em> .</p>
</div>
<hr>
<div class="sect4">
<h5 id="_but_blocking_means_we_re_not_really_asynchronous_are_we">But Blocking Means We&#8217;re Not Really Asynchronous, Are We?</h5>
<div class="paragraph">
<p>Indeed, if you mark your active methods as <em>blocking</em> , the caller will be blocked waiting for the result, just like when doing normal plain method invocation.
All we&#8217;ve achieved is being thread-safe inside the Active object from concurrent access.
Something the <em>synchronized</em> keyword could give you as well.
So it&#8217;s the <strong>non-blocking</strong> methods that should drive your decision towards using active objects.
Blocking methods will then provide the usual synchronous semantics yet give the consistency guarantees across concurrent method invocations.
The blocking methods are then still very useful when used in combination with non-blocking ones.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.activeobject.ActiveMethod</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.activeobject.ActiveObject</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowVariable</span>

<span class="annotation">@ActiveObject</span>
<span class="type">class</span> <span class="class">Decryptor</span> {
    <span class="annotation">@ActiveMethod</span>(blocking=<span class="predefined-constant">true</span>)
    <span class="predefined-type">String</span> decrypt(<span class="predefined-type">String</span> encryptedText) {
        encryptedText.reverse()
    }

    <span class="annotation">@ActiveMethod</span>(blocking=<span class="predefined-constant">true</span>)
    <span class="predefined-type">Integer</span> decrypt(<span class="predefined-type">Integer</span> encryptedNumber) {
        -<span class="integer">1</span>*encryptedNumber + <span class="integer">142</span>
    }
}

<span class="directive">final</span> Decryptor decryptor = <span class="keyword">new</span> Decryptor()
print decryptor.decrypt(<span class="string"><span class="delimiter">'</span><span class="content"> noitcA ni yvoorG</span><span class="delimiter">'</span></span>)
print decryptor.decrypt(<span class="integer">140</span>)
println decryptor.decrypt(<span class="string"><span class="delimiter">'</span><span class="content">noitide dn</span><span class="delimiter">'</span></span>)</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_non_blocking_semantics">Non-Blocking Semantics</h5>
<div class="paragraph">
<p>Calling the non-blocking active method will return as soon as the actor has been sent a message.
The caller is now allowed to do whatever it likes, while the actor is taking care of the calculation.</p>
</div>
<div class="paragraph">
<p>The state of the calculation can be polled using the <em>bound</em> property on the promise.
Calling the <em>get()</em> method on the returned promise will block the caller until a value is available.
The call to <em>get()</em> will eventually return a value or throw an exception, depending on the outcome of the actual calculation.</p>
</div>
<hr>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The <em>get()</em> method has a variant with a timeout parameter, to avoid the risk of waiting indefinitely.
</td>
</tr>
</table>
</div>
<hr>
<div class="sect5">
<h6 id="_annotation_rules">Annotation Rules</h6>
<div class="paragraph">
<p>There are a few rules to follow when annotating your objects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <em>ActiveMethod</em> annotations are only accepted in classes annotated as <em>ActiveObject</em></p>
</li>
<li>
<p>Only instance (non-static) methods can be annotated as <em>ActiveMethod</em></p>
</li>
<li>
<p>You can override active methods with non-active ones and vice versa</p>
</li>
<li>
<p>Subclasses of active objects can declare additional active methods, provided they are themselves annotated
as <em>ActiveObject</em></p>
</li>
<li>
<p>Combining concurrent use of active and non-active methods may result in race conditions. Ideally design
your active objects as completely encapsulated classes with all non-private methods marked as active</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_inheritance">Inheritance</h5>
<div class="paragraph">
<p>The <em>@ActiveObject</em> annotation can appear on any class in an inheritance hierarchy. The actor field will only be created in top-most annotated class in the hierarchy, the subclasses will reuse the field.</p>
</div>
<div class="listingblock">
<div class="title">An Annotated Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.activeobject.ActiveObject</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.activeobject.ActiveMethod</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowVariable</span>

<span class="annotation">@ActiveObject</span>
<span class="type">class</span> <span class="class">A</span> {
    <span class="annotation">@ActiveMethod</span>
    <span class="keyword">def</span> <span class="function">fooA</span>(value) {
        ...
    }
}

<span class="type">class</span> <span class="class">B</span> <span class="directive">extends</span> A {
}

<span class="annotation">@ActiveObject</span>
<span class="type">class</span> <span class="class">C</span> <span class="directive">extends</span> B {
    <span class="annotation">@ActiveMethod</span>
    <span class="keyword">def</span> <span class="function">fooC</span>(value1, value2) {
        ...
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>In our example, the actor field will be generated into class <em>A</em>.
Class <em>C</em> has to be annotated with <em>@ActiveObject</em> since it holds the <em>@ActiveMethod</em> annotation on method <em>fooC()</em> , while class <em>B</em> does not need the annotation, since none of its methods is active.</p>
</div>
</div>
<div class="sect4">
<h5 id="_groups">Groups</h5>
<div class="paragraph">
<p>Just like actors can be grouped around thread pools, active objects can be configured to use threads from particular parallel groups.</p>
</div>
<div class="listingblock">
<div class="title">A Group Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="annotation">@ActiveObject</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">group1</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">MyActiveObject</span> {
    ...
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>value</em> parameter to the <em>@ActiveObject</em> annotation specifies a name of parallel group to bind the
internal actor to.  Only threads from the specified group will be used to run internal actors of instances
of the class.</p>
</div>
<div class="paragraph">
<p>The groups, however, need to be created and registered prior to creation of any of the active object instances belonging to that group.
If not specified explicitly, an active object will use the default actor group - <em>Actors.defaultActorPGroup</em> .</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="directive">final</span> DefaultPGroup group = <span class="keyword">new</span> DefaultPGroup(<span class="integer">10</span>)
ActiveObjectRegistry.instance.register(<span class="string"><span class="delimiter">&quot;</span><span class="content">group1</span><span class="delimiter">&quot;</span></span>, group)</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_alternative_names_for_the_internal_actor">Alternative Names For The Internal Actor</h4>
<div class="paragraph">
<p>You will probably only rarely run into name collisions with the default name for the active object&#8217;s internal actor field.
May you need to change the default name <em>internalActiveObjectActor</em> , use the <em>actorName</em> parameter to the <em>@ActiveObject</em> annotation.</p>
</div>
<div class="listingblock">
<div class="title">A Named Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="annotation">@ActiveObject</span>(actorName = <span class="string"><span class="delimiter">&quot;</span><span class="content">alternativeActorName</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">MyActiveObject</span> {
    ...
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Actor Naming Conventions</div>
<div class="paragraph">
<p>Alternative names for internal actors as well as their desired groups cannot be overriden in subclasses.</p>
</div>
<div class="paragraph">
<p>Make sure you only specify these values in the top-most active objects in your inheritance
hierarchy. Obviously, the top most active object is still allowed to subclass other classes, just none of
the predecessors must be an active object.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_classic_examples">Classic Examples</h3>
<div class="sect3">
<h4 id="_a_few_examples_of_actors_usage">A Few Examples of Actors Usage</h4>
<div class="ulist">
<ul>
<li>
<p>The Sieve of Eratosthenes</p>
</li>
<li>
<p>Sleeping Barber</p>
</li>
<li>
<p>Dining Philosophers</p>
</li>
<li>
<p>Word Sort</p>
</li>
<li>
<p>Load Balancer</p>
</li>
</ul>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_the_sieve_of_eratosthenes">The Sieve of Eratosthenes</h4>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Problem description</a></p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.actor.DynamicDispatchActor</span>

<span class="comment">/**
 * Demonstrates concurrent implementation of the Sieve of Eratosthenes using actors
 *
 * In principle, the algorithm consists of concurrently run chained filters,
 * each of which detects whether the current number can be divided by a single prime number.
 * (generate nums 1, 2, 3, 4, 5, ...) -&gt; (filter by mod 2) -&gt; (filter by mod 3) -&gt; (filter by mod 5) -&gt; (filter by mod 7) -&gt; (filter by mod 11) -&gt; (caution! Primes falling out here)
 * The chain is built (grows) on the fly, whenever a new prime is found.
 */</span>

<span class="type">int</span> requestedPrimeNumberBoundary = <span class="integer">1000</span>

<span class="directive">final</span> <span class="keyword">def</span> firstFilter = <span class="keyword">new</span> FilterActor(<span class="integer">2</span>).start()

<span class="comment">/**
 * Generating candidate numbers and sending them to the actor chain
 */</span>
(<span class="integer">2</span>..requestedPrimeNumberBoundary).each {
    firstFilter <span class="local-variable">it</span>
}
firstFilter.sendAndWait <span class="string"><span class="delimiter">'</span><span class="content">Poison</span><span class="delimiter">'</span></span>

<span class="comment">/**
 * Filter out numbers that can be divided by a single prime number
 */</span>
<span class="directive">final</span> <span class="type">class</span> <span class="class">FilterActor</span> <span class="directive">extends</span> DynamicDispatchActor {
    <span class="directive">private</span> <span class="directive">final</span> <span class="type">int</span> myPrime
    <span class="directive">private</span> <span class="keyword">def</span> follower

    <span class="keyword">def</span> <span class="function">FilterActor</span>(<span class="directive">final</span> myPrime) { <span class="local-variable">this</span>.myPrime = myPrime; }

    <span class="comment">/**
     * Try to divide the received number with the prime. If the number cannot be divided, send it along the chain.
     * If there's no-one to send it to, I'm the last in the chain, the number is a prime and so I will create and chain
     * a new actor responsible for filtering by this newly found prime number.
     */</span>
    <span class="keyword">def</span> <span class="function">onMessage</span>(<span class="type">int</span> value) {
        <span class="keyword">if</span> (value % myPrime != <span class="integer">0</span>) {
            <span class="keyword">if</span> (follower) follower value
            <span class="keyword">else</span> {
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">Found </span><span class="inline"><span class="inline-delimiter">$</span>value</span><span class="delimiter">&quot;</span></span>
                follower = <span class="keyword">new</span> FilterActor(value).start()
            }
        }
    }

    <span class="comment">/**
     * Stop the actor on poisson reception
     */</span>
    <span class="keyword">def</span> <span class="function">onMessage</span>(<span class="keyword">def</span> poisson) {
        <span class="keyword">if</span> (follower) {
            <span class="keyword">def</span> sender = sender
            follower.sendAndContinue(poisson, {<span class="local-variable">this</span>.stop(); sender?.send(<span class="string"><span class="delimiter">'</span><span class="content">Done</span><span class="delimiter">'</span></span>)})  <span class="comment">//Pass the poisson along and stop after a reply</span>
        } <span class="keyword">else</span> {  <span class="comment">//I am the last in the chain</span>
            stop()
            reply <span class="string"><span class="delimiter">'</span><span class="content">Done</span><span class="delimiter">'</span></span>
        }
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_sleeping_barber">Sleeping Barber</h4>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Sleeping_barber_problem">Problem description</a></p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.actor.DefaultActor</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.actor.Actor</span>

<span class="directive">final</span> <span class="keyword">def</span> group = <span class="keyword">new</span> DefaultPGroup()

<span class="directive">final</span> <span class="keyword">def</span> barber = group.actor {
    <span class="directive">final</span> <span class="keyword">def</span> random = <span class="keyword">new</span> <span class="predefined-type">Random</span>()
    loop {
        react {message -&gt;
            <span class="keyword">switch</span> (message) {
                <span class="keyword">case</span> <span class="key">Enter</span>:
                    message.customer.send <span class="keyword">new</span> Start()
                    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Barber: Processing customer </span><span class="inline"><span class="inline-delimiter">${</span>message.customer.name<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
                    doTheWork(random)
                    message.customer.send <span class="keyword">new</span> Done()
                    reply <span class="keyword">new</span> Next()
                    <span class="keyword">break</span>
                <span class="keyword">case</span> <span class="key">Wait</span>:
                    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Barber: No customers. Going to have a sleep</span><span class="delimiter">&quot;</span></span>
                    <span class="keyword">break</span>
            }
        }
    }
}

<span class="directive">private</span> <span class="keyword">def</span> <span class="function">doTheWork</span>(<span class="predefined-type">Random</span> random) {
    <span class="predefined-type">Thread</span>.sleep(random.nextInt(<span class="integer">10</span>) * <span class="integer">1000</span>)
}

<span class="directive">final</span> Actor waitingRoom

waitingRoom = group.actor {
    <span class="directive">final</span> <span class="type">int</span> capacity = <span class="integer">5</span>
    <span class="directive">final</span> <span class="predefined-type">List</span>&lt;Customer&gt; waitingCustomers = <span class="type">[]</span>
    <span class="type">boolean</span> barberAsleep = <span class="predefined-constant">true</span>

    loop {
        react {message -&gt;
            <span class="keyword">switch</span> (message) {
                <span class="keyword">case</span> <span class="key">Enter</span>:
                    <span class="keyword">if</span> (waitingCustomers.size() == capacity) {
                        reply <span class="keyword">new</span> Full()
                    } <span class="keyword">else</span> {
                        waitingCustomers &lt;&lt; message.customer
                        <span class="keyword">if</span> (barberAsleep) {
                            <span class="keyword">assert</span> waitingCustomers.size() == <span class="integer">1</span>
                            barberAsleep = <span class="predefined-constant">false</span>
                            waitingRoom.send <span class="keyword">new</span> Next()
                        }
                        <span class="keyword">else</span> reply <span class="keyword">new</span> Wait()
                    }
                    <span class="keyword">break</span>
                <span class="keyword">case</span> <span class="key">Next</span>:
                    <span class="keyword">if</span> (waitingCustomers.size()&gt;<span class="integer">0</span>) {
                        <span class="keyword">def</span> customer = waitingCustomers.remove(<span class="integer">0</span>)
                        barber.send <span class="keyword">new</span> Enter(<span class="key">customer</span>:customer)
                    } <span class="keyword">else</span> {
                        barber.send <span class="keyword">new</span> Wait()
                        barberAsleep = <span class="predefined-constant">true</span>
                    }
            }
        }
    }

}

<span class="type">class</span> <span class="class">Customer</span> <span class="directive">extends</span> DefaultActor {
    <span class="predefined-type">String</span> name
    Actor localBarbers

    <span class="type">void</span> act() {
        localBarbers &lt;&lt; <span class="keyword">new</span> Enter(<span class="key">customer</span>:<span class="local-variable">this</span>)
        loop {
            react {message -&gt;
                <span class="keyword">switch</span> (message) {
                    <span class="keyword">case</span> <span class="key">Full</span>:
                        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Customer: </span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: The waiting room is full. I am leaving.</span><span class="delimiter">&quot;</span></span>
                        stop()
                        <span class="keyword">break</span>
                    <span class="keyword">case</span> <span class="key">Wait</span>:
                        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Customer: </span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: I will wait.</span><span class="delimiter">&quot;</span></span>
                        <span class="keyword">break</span>
                    <span class="keyword">case</span> <span class="key">Start</span>:
                        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Customer: </span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: I am now being served.</span><span class="delimiter">&quot;</span></span>
                        <span class="keyword">break</span>
                    <span class="keyword">case</span> <span class="key">Done</span>:
                        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Customer: </span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: I have been served.</span><span class="delimiter">&quot;</span></span>
                        stop();
                        <span class="keyword">break</span>

                }
            }
        }
    }
}

<span class="type">class</span> <span class="class">Enter</span> { Customer customer }
<span class="type">class</span> <span class="class">Full</span> {}
<span class="type">class</span> <span class="class">Wait</span> {}
<span class="type">class</span> <span class="class">Next</span> {}
<span class="type">class</span> <span class="class">Start</span> {}
<span class="type">class</span> <span class="class">Done</span> {}

<span class="keyword">def</span> customers = <span class="type">[]</span>
customers &lt;&lt; <span class="keyword">new</span> Customer(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Joe</span><span class="delimiter">'</span></span>, <span class="key">localBarbers</span>:waitingRoom).start()
customers &lt;&lt; <span class="keyword">new</span> Customer(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Dave</span><span class="delimiter">'</span></span>, <span class="key">localBarbers</span>:waitingRoom).start()
customers &lt;&lt; <span class="keyword">new</span> Customer(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Alice</span><span class="delimiter">'</span></span>, <span class="key">localBarbers</span>:waitingRoom).start()

sleep <span class="integer">15000</span>
customers &lt;&lt; <span class="keyword">new</span> Customer(<span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">James</span><span class="delimiter">'</span></span>, <span class="key">localBarbers</span>: waitingRoom).start()
sleep <span class="integer">5000</span>
customers*.join()
barber.stop()
waitingRoom.stop()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_dining_philosophers">Dining Philosophers</h4>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Dining_philosophers_problem">Problem description</a></p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.actor.DefaultActor</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.actor.Actors</span>

Actors.defaultActorPGroup.resize <span class="integer">5</span>

<span class="directive">final</span> <span class="type">class</span> <span class="class">Philosopher</span> <span class="directive">extends</span> DefaultActor {
    <span class="directive">private</span> <span class="predefined-type">Random</span> random = <span class="keyword">new</span> <span class="predefined-type">Random</span>()

    <span class="predefined-type">String</span> name
    <span class="keyword">def</span> forks = <span class="type">[]</span>

    <span class="type">void</span> act() {
        <span class="keyword">assert</span> <span class="integer">2</span> == forks.size()
        loop {
            think()
            forks*.send <span class="keyword">new</span> Take()
            <span class="keyword">def</span> messages = <span class="type">[]</span>
            react {a -&gt;
                messages &lt;&lt; [a, sender]
                react {b -&gt;
                    messages &lt;&lt; [b, sender]
                    <span class="keyword">if</span> ([a, b].any {Rejected.isCase <span class="local-variable">it</span>}) {
                        println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: </span><span class="char">\t</span><span class="content">Oops, can't get my forks! Giving up.</span><span class="delimiter">&quot;</span></span>
                        <span class="directive">final</span> <span class="keyword">def</span> accepted = messages.find {Accepted.isCase <span class="local-variable">it</span>[<span class="integer">0</span>]}
                        <span class="keyword">if</span> (accepted!=<span class="predefined-constant">null</span>) accepted[<span class="integer">1</span>].send <span class="keyword">new</span> Finished()
                    } <span class="keyword">else</span> {
                        eat()
                        reply <span class="keyword">new</span> Finished()
                    }
                }
            }
        }
    }

    <span class="type">void</span> think() {
        println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: </span><span class="char">\t</span><span class="content">I'm thinking</span><span class="delimiter">&quot;</span></span>
        <span class="predefined-type">Thread</span>.sleep random.nextInt(<span class="integer">5000</span>)
        println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: </span><span class="char">\t</span><span class="content">I'm done thinking</span><span class="delimiter">&quot;</span></span>
    }

    <span class="type">void</span> eat() {
        println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: </span><span class="char">\t</span><span class="content">I'm EATING</span><span class="delimiter">&quot;</span></span>
        <span class="predefined-type">Thread</span>.sleep random.nextInt(<span class="integer">2000</span>)
        println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: </span><span class="char">\t</span><span class="content">I'm done EATING</span><span class="delimiter">&quot;</span></span>
    }
}

<span class="directive">final</span> <span class="type">class</span> <span class="class">Fork</span> <span class="directive">extends</span> DefaultActor {

    <span class="predefined-type">String</span> name
    <span class="type">boolean</span> available = <span class="predefined-constant">true</span>

    <span class="type">void</span> act() {
        loop {
            react {message -&gt;
                <span class="keyword">switch</span> (message) {
                    <span class="keyword">case</span> <span class="key">Take</span>:
                        <span class="keyword">if</span> (available) {
                            available = <span class="predefined-constant">false</span>
                            reply <span class="keyword">new</span> Accepted()
                        } <span class="keyword">else</span> reply <span class="keyword">new</span> Rejected()
                        <span class="keyword">break</span>
                    <span class="keyword">case</span> <span class="key">Finished</span>:
                        <span class="keyword">assert</span> !available
                        available = <span class="predefined-constant">true</span>
                        <span class="keyword">break</span>
                    <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Cannot process the message: </span><span class="inline"><span class="inline-delimiter">$</span>message</span><span class="delimiter">&quot;</span></span>)
                }
            }
        }
    }
}

<span class="directive">final</span> <span class="type">class</span> <span class="class">Take</span> {}
<span class="directive">final</span> <span class="type">class</span> <span class="class">Accepted</span> {}
<span class="directive">final</span> <span class="type">class</span> <span class="class">Rejected</span> {}
<span class="directive">final</span> <span class="type">class</span> <span class="class">Finished</span> {}

<span class="keyword">def</span> forks = [
        <span class="keyword">new</span> Fork(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Fork 1</span><span class="delimiter">'</span></span>),
        <span class="keyword">new</span> Fork(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Fork 2</span><span class="delimiter">'</span></span>),
        <span class="keyword">new</span> Fork(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Fork 3</span><span class="delimiter">'</span></span>),
        <span class="keyword">new</span> Fork(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Fork 4</span><span class="delimiter">'</span></span>),
        <span class="keyword">new</span> Fork(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Fork 5</span><span class="delimiter">'</span></span>)
]

<span class="keyword">def</span> philosophers = [
        <span class="keyword">new</span> Philosopher(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Joe</span><span class="delimiter">'</span></span>, <span class="key">forks</span>:[forks[<span class="integer">0</span>], forks[<span class="integer">1</span>]]),
        <span class="keyword">new</span> Philosopher(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Dave</span><span class="delimiter">'</span></span>, <span class="key">forks</span>:[forks[<span class="integer">1</span>], forks[<span class="integer">2</span>]]),
        <span class="keyword">new</span> Philosopher(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Alice</span><span class="delimiter">'</span></span>, <span class="key">forks</span>:[forks[<span class="integer">2</span>], forks[<span class="integer">3</span>]]),
        <span class="keyword">new</span> Philosopher(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">James</span><span class="delimiter">'</span></span>, <span class="key">forks</span>:[forks[<span class="integer">3</span>], forks[<span class="integer">4</span>]]),
        <span class="keyword">new</span> Philosopher(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Phil</span><span class="delimiter">'</span></span>, <span class="key">forks</span>:[forks[<span class="integer">4</span>], forks[<span class="integer">0</span>]]),
]

forks*.start()
philosophers*.start()

sleep <span class="integer">10000</span>
forks*.stop()
philosophers*.stop()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_word_sort">Word Sort</h4>
<div class="paragraph">
<p>Given a folder name, the script will sort words in all files in the folder. The <em>SortMaster</em> actor creates a given number of <em>WordSortActors</em> ,
splits among them the files to sort words in and collects the results.</p>
</div>
<div class="paragraph">
<p><a href="http://fupeg.blogspot.com/2009/06/scala-concurrency.html">Inspired by Scala Concurrency blog post by Michael Galpin</a></p>
</div>
<div class="listingblock">
<div class="title">A Sample, Sort-Of</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
</pre></td>
  <td class="code"><pre><span class="comment">//Messages</span>
<span class="directive">private</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">FileToSort</span> { <span class="predefined-type">String</span> fileName }
<span class="directive">private</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">SortResult</span> { <span class="predefined-type">String</span> fileName; <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; words }

<span class="comment">//Worker actor</span>
<span class="type">class</span> <span class="class">WordSortActor</span> <span class="directive">extends</span> DefaultActor {

    <span class="directive">private</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; sortedWords(<span class="predefined-type">String</span> fileName) {
        parseFile(fileName).sort {<span class="local-variable">it</span>.toLowerCase()}
    }

    <span class="directive">private</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; parseFile(<span class="predefined-type">String</span> fileName) {
        <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; words = <span class="type">[]</span>
        <span class="keyword">new</span> <span class="predefined-type">File</span>(fileName).splitEachLine(<span class="string"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span>) {words.addAll(<span class="local-variable">it</span>)}
        <span class="keyword">return</span> words
    }

    <span class="type">void</span> act() {
        loop {
            react {message -&gt;
                <span class="keyword">switch</span> (message) {
                    <span class="keyword">case</span> <span class="key">FileToSort</span>:
                        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Sorting file=</span><span class="inline"><span class="inline-delimiter">${</span>message.fileName<span class="inline-delimiter">}</span></span><span class="content"> on thread </span><span class="inline"><span class="inline-delimiter">${</span><span class="predefined-type">Thread</span>.currentThread().name<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
                        reply <span class="keyword">new</span> SortResult(<span class="key">fileName</span>: message.fileName, <span class="key">words</span>: sortedWords(message.fileName))
                }
            }
        }
    }
}

<span class="comment">//Master actor</span>
<span class="directive">final</span> <span class="type">class</span> <span class="class">SortMaster</span> <span class="directive">extends</span> DefaultActor {

    <span class="predefined-type">String</span> docRoot = <span class="string"><span class="delimiter">'</span><span class="content">/</span><span class="delimiter">'</span></span>
    <span class="type">int</span> numActors = <span class="integer">1</span>

    <span class="predefined-type">List</span>&lt;<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt;&gt; sorted = <span class="type">[]</span>
    <span class="directive">private</span> <span class="predefined-type">CountDownLatch</span> startupLatch = <span class="keyword">new</span> <span class="predefined-type">CountDownLatch</span>(<span class="integer">1</span>)
    <span class="directive">private</span> <span class="predefined-type">CountDownLatch</span> doneLatch

    <span class="directive">private</span> <span class="type">void</span> beginSorting() {
        <span class="type">int</span> cnt = sendTasksToWorkers()
        doneLatch = <span class="keyword">new</span> <span class="predefined-type">CountDownLatch</span>(cnt)
    }

    <span class="directive">private</span> <span class="predefined-type">List</span> createWorkers() {
        <span class="keyword">return</span> (<span class="integer">1</span>..numActors).collect {<span class="keyword">new</span> WordSortActor().start()}
    }

    <span class="directive">private</span> <span class="type">int</span> sendTasksToWorkers() {
        <span class="predefined-type">List</span>&lt;Actor&gt; workers = createWorkers()
        <span class="type">int</span> cnt = <span class="integer">0</span>
        <span class="keyword">new</span> <span class="predefined-type">File</span>(docRoot).eachFile {
            workers[cnt % numActors] &lt;&lt; <span class="keyword">new</span> FileToSort(<span class="key">fileName</span>: <span class="local-variable">it</span>)
            cnt += <span class="integer">1</span>
        }
        <span class="keyword">return</span> cnt
    }

    <span class="directive">public</span> <span class="type">void</span> waitUntilDone() {
        startupLatch.await()
        doneLatch.await()
    }

    <span class="type">void</span> act() {
        beginSorting()
        startupLatch.countDown()
        loop {
            react {
                <span class="keyword">switch</span> (<span class="local-variable">it</span>) {
                    <span class="keyword">case</span> <span class="key">SortResult</span>:
                        sorted &lt;&lt; <span class="local-variable">it</span>.words
                        doneLatch.countDown()
                        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Received results for file=</span><span class="inline"><span class="inline-delimiter">${</span><span class="local-variable">it</span>.fileName<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
                }
            }
        }
    }
}

<span class="comment">//start the actors to sort words</span>
<span class="keyword">def</span> master = <span class="keyword">new</span> SortMaster(<span class="key">docRoot</span>: <span class="string"><span class="delimiter">'</span><span class="content">c:/tmp/Logs/</span><span class="delimiter">'</span></span>, <span class="key">numActors</span>: <span class="integer">5</span>).start()
master.waitUntilDone()
println <span class="string"><span class="delimiter">'</span><span class="content">Done</span><span class="delimiter">'</span></span>

<span class="predefined-type">File</span> file = <span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">c:/tmp/Logs/sorted_words.txt</span><span class="delimiter">&quot;</span></span>)
file.withPrintWriter { printer -&gt;
    master.sorted.each { printer.println <span class="local-variable">it</span> }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_load_balancer">Load Balancer</h4>
<div class="paragraph">
<p>Demonstrates work balancing among adaptable set of workers. The load balancer receives tasks and queues them
in a temporary task queue. When a worker finishes his assignment, it asks the load balancer for a new task.</p>
</div>
<div class="paragraph">
<p>If the load balancer doesn&#8217;t have any tasks available in the task queue, the worker is stopped.  If the
number of tasks in the task queue exceeds certain limit, a new worker is created to increase size of the
worker pool.</p>
</div>
<div class="listingblock">
<div class="title">A Load Balancer Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.actor.Actor</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.actor.DefaultActor</span>

<span class="comment">/**
 * Demonstrates work balancing among adaptable set of workers.
 * The load balancer receives tasks and queues them in a temporary task queue.
 * When a worker finishes his assignment, it asks the load balancer for a new task.
 * If the load balancer doesn't have any tasks available in the task queue, the worker is stopped.
 * If the number of tasks in the task queue exceeds certain limit, a new worker is created
 * to increase size of the worker pool.
 */</span>

<span class="directive">final</span> <span class="type">class</span> <span class="class">LoadBalancer</span> <span class="directive">extends</span> DefaultActor {
    <span class="type">int</span> workers = <span class="integer">0</span>
    <span class="predefined-type">List</span> taskQueue = <span class="type">[]</span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> QUEUE_SIZE_TRIGGER = <span class="integer">10</span>

    <span class="type">void</span> act() {
        loop {
            react { message -&gt;
                <span class="keyword">switch</span> (message) {
                    <span class="keyword">case</span> <span class="key">NeedMoreWork</span>:
                        <span class="keyword">if</span> (taskQueue.size() == <span class="integer">0</span>) {
                            println <span class="string"><span class="delimiter">'</span><span class="content">No more tasks in the task queue. Terminating the worker.</span><span class="delimiter">'</span></span>
                            reply DemoWorker.EXIT
                            workers -= <span class="integer">1</span>
                        } <span class="keyword">else</span> reply taskQueue.remove(<span class="integer">0</span>)
                        <span class="keyword">break</span>
                    <span class="keyword">case</span> <span class="key">WorkToDo</span>:
                        taskQueue &lt;&lt; message
                        <span class="keyword">if</span> ((workers == <span class="integer">0</span>) || (taskQueue.size() &gt;= QUEUE_SIZE_TRIGGER)) {
                            println <span class="string"><span class="delimiter">'</span><span class="content">Need more workers. Starting one.</span><span class="delimiter">'</span></span>
                            workers += <span class="integer">1</span>
                            <span class="keyword">new</span> DemoWorker(<span class="local-variable">this</span>).start()
                        }
                }
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">Active workers=</span><span class="inline"><span class="inline-delimiter">${</span>workers<span class="inline-delimiter">}</span></span><span class="char">\t</span><span class="content">Tasks in queue=</span><span class="inline"><span class="inline-delimiter">${</span>taskQueue.size()<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
            }
        }
    }
}

<span class="directive">final</span> <span class="type">class</span> <span class="class">DemoWorker</span> <span class="directive">extends</span> DefaultActor {
    <span class="directive">final</span> <span class="directive">static</span> <span class="predefined-type">Object</span> EXIT = <span class="keyword">new</span> <span class="predefined-type">Object</span>()
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">Random</span> random = <span class="keyword">new</span> <span class="predefined-type">Random</span>()

    Actor balancer

    <span class="keyword">def</span> <span class="function">DemoWorker</span>(balancer) {
        <span class="local-variable">this</span>.balancer = balancer
    }

    <span class="type">void</span> act() {
        loop {
            <span class="local-variable">this</span>.balancer &lt;&lt; <span class="keyword">new</span> NeedMoreWork()
            react {
                <span class="keyword">switch</span> (<span class="local-variable">it</span>) {
                    <span class="keyword">case</span> <span class="key">WorkToDo</span>:
                        processMessage(<span class="local-variable">it</span>)
                        <span class="keyword">break</span>
                    <span class="keyword">case</span> <span class="key">EXIT</span>: terminate()
                }
            }
        }

    }

    <span class="directive">private</span> <span class="type">void</span> processMessage(message) {
        <span class="directive">synchronized</span> (random) {
            <span class="predefined-type">Thread</span>.sleep random.nextInt(<span class="integer">5000</span>)
        }
    }
}
<span class="directive">final</span> <span class="type">class</span> <span class="class">WorkToDo</span> {}
<span class="directive">final</span> <span class="type">class</span> <span class="class">NeedMoreWork</span> {}

<span class="directive">final</span> Actor balancer = <span class="keyword">new</span> LoadBalancer().start()

<span class="comment">//produce tasks</span>
<span class="keyword">for</span> (i <span class="keyword">in</span> <span class="integer">1</span>..<span class="integer">20</span>) {
    <span class="predefined-type">Thread</span>.sleep <span class="integer">100</span>
    balancer &lt;&lt; <span class="keyword">new</span> WorkToDo()
}

<span class="comment">//produce tasks in a parallel thread</span>
<span class="predefined-type">Thread</span>.start {
    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="integer">1</span>..<span class="integer">10</span>) {
        <span class="predefined-type">Thread</span>.sleep <span class="integer">1000</span>
        balancer &lt;&lt; <span class="keyword">new</span> WorkToDo()
    }
}

<span class="predefined-type">Thread</span>.sleep <span class="integer">35000</span>  <span class="comment">//let the queues get empty</span>
balancer &lt;&lt; <span class="keyword">new</span> WorkToDo()
balancer &lt;&lt; <span class="keyword">new</span> WorkToDo()
<span class="predefined-type">Thread</span>.sleep <span class="integer">10000</span>

balancer.stop()
balancer.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../images/divider.png" alt="divider" width="436">
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_user_guide_to_strong_agents_strong">User Guide To <strong>Agents</strong></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <strong>Agent</strong> class is a thread-safe non-blocking shared mutable state wrapper implementation inspired by
<strong>Agents</strong> in <strong>Clojure</strong>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Shared Mutable State can&#8217;t be avoided</div>
<div class="paragraph">
<p>A lot of the concurrency problems disappear when you eliminate the need for <em>Shared Mutable State</em> with your
architecture.  Indeed, concepts like <strong>actors</strong>, <strong>CSP</strong> or <strong>dataflow concurrency</strong> avoid or isolate mutable state
completely.</p>
</div>
<div class="paragraph">
<p>In some cases, however, sharing mutable data is either inevitable or makes the design more
natural and understandable. For example, think of a shopping cart in a typical e-commerce application, when
multiple <span class="blue">AJAX</span> requests may hit the cart with read or write requests concurrently.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_introduction">Introduction</h3>
<div class="paragraph">
<p>In the <strong>Clojure</strong> programing language, you can find a concept of <strong>Agents</strong>, the purpose of which is to protect
mutable data that need to be shared across threads.  <strong>Agents</strong> hide the data and protect it from direct
access. Clients can only send commands (functions) to the <strong>agent</strong>. The commands will be serialized and
processed against the data one-by-one in turn.</p>
</div>
<div class="paragraph">
<p>With the commands being executed serially, the commands do not need to care about concurrency and can assume the data is all theirs when run.
Although implemented differently, <strong>GPars Agents</strong>, called <em>Agent</em> , fundamentally behave like <strong>actors</strong>. They accept messages and
process them asynchronously.  The messages, however, must be commands (functions or <strong>Groovy</strong> closures) and
will be executed inside the <strong>agent</strong>.  After reception, the received function is run against the internal state
of the <strong>Agent</strong> and the return value of the function is considered to be the new internal state of the <strong>Agent</strong>.</p>
</div>
<div class="paragraph">
<p>Essentially, <strong>agents</strong> safe-guard mutable values by allowing only a single <em>agent-managed thread</em> to make
modifications to them. The mutable values are <strong>not directly accessible</strong> from outside, but instead <em>requests
have to be sent to the agent</em> and the <strong>agent</strong> is guaranteed to process the requests sequentially on behalf of the
callers.  <strong>Agents</strong> guarantee sequential execution of all requests and so consistency of the values.</p>
</div>
<div class="listingblock">
<div class="title">Schematically -</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre>agent = <span class="keyword">new</span> Agent(<span class="integer">0</span>)  <span class="comment">//created a new Agent wrapping an integer with initial value 0</span>
agent.send {increment()}  <span class="comment">//asynchronous send operation, sending the increment() function</span>
...

<span class="comment">//after some delay to process the message the internal Agent's state has been updated</span>
...

assert agent.val== <span class="integer">1</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>To wrap integers, we can certainly use <code>AtomicXXX</code> types on the <strong>Java</strong> platform, but when the state is a more complex object we need more support.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_concepts">Concepts</h3>
<div class="paragraph">
<p><strong>GPars</strong> provides an <strong>Agent</strong> class, which is a special-purpose, thread-safe, non-blocking implementation inspired
by <strong>Agents</strong> in <strong>Clojure</strong>.</p>
</div>
<div class="paragraph">
<p>An <strong>Agent</strong> wraps a reference to mutable state, held inside a single field, and accepts code (closures or
commands) as messages, which can be sent to the <strong>Agent</strong> just like to any other actor using the <strong class="red">'&lt;&lt;'</strong> operator,
the <em>send()</em> methods or the <em>implicit call()</em> method.</p>
</div>
<div class="paragraph">
<p>At some point after reception of a closure / command, the closure is invoked against the internal mutable field and can make changes to it.
The closure is guaranteed to be run without intervention from other threads and so may freely alter the internal state of
the <strong>Agent</strong> held in the internal <em>data</em> field.</p>
</div>
<div class="paragraph">
<p>The whole update process is of the <code>fire-and-forget</code> type since, once the message (closure) is sent to the
Agent, the caller thread can go off to do other things and come back later to check the current value with
<strong>Agent.val</strong> or <strong>Agent.valAsync(closure)</strong>.</p>
</div>
<div class="sect3">
<h4 id="_basic_rules">Basic Rules</h4>
<div class="ulist">
<ul>
<li>
<p>When executed, the submitted commands obtain the <strong>agent</strong>'s state as a parameter.</p>
</li>
<li>
<p>The submitted commands /closures can call any methods on the *agent8&#8217;s state.</p>
</li>
<li>
<p>Replacing the state object with a new one is also possible and is done using the <strong>updateValue()</strong> method.</p>
</li>
<li>
<p>The <em>return value</em> of the submitted closure doesn&#8217;t have a special meaning and is ignored.</p>
</li>
<li>
<p>If the message sent to an <strong>Agent</strong> is <code>not a closure</code>, it is considered to be a new value for the internal reference field.</p>
</li>
<li>
<p>The <em>val</em> property of an <strong>Agent</strong> will wait until all preceding commands in the agent&#8217;s queue are consumed and then safely return the value of the <strong>Agent</strong>.</p>
</li>
<li>
<p>The <em>valAsync()</em> method will do the same <strong class="red">without</strong> blocking the caller.</p>
</li>
<li>
<p>The <em>instantVal</em> property will return an immediate snapshot of the internal <strong>agent</strong>'s state.</p>
</li>
<li>
<p>All <strong>Agent</strong> instances share a default daemon thread pool. Setting the <em>threadPool</em> property of an <strong>Agent</strong> instance will allow it to use a different thread pool.</p>
</li>
<li>
<p>Exceptions thrown by the commands can be collected using the <em>errors</em> property.</p>
</li>
</ul>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_examples">Examples</h3>
<div class="sect3">
<h4 id="_shared_list_of_members">Shared List of Members</h4>
<div class="paragraph">
<p>The <strong>Agent</strong> wraps a list of members, who have been added to the club. To add a new member, a message (command to
add a member) has to be sent to the <em>clubMembers</em> Agent.</p>
</div>
<div class="listingblock">
<div class="title">A Sample -</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.agent.Agent</span> <span class="include">import</span>
java.util.concurrent.ExecutorService <span class="keyword">import</span> <span class="include">java.util.concurrent.Executors</span>

<span class="comment">/**
 * Create a new Agent wrapping a list of strings
 */</span>
<span class="keyword">def</span> clubMembers = <span class="keyword">new</span> Agent&lt;<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt;&gt;([<span class="string"><span class="delimiter">'</span><span class="content">Me</span><span class="delimiter">'</span></span>])  <span class="comment">//add Me</span>

clubMembers.send {<span class="local-variable">it</span>.add <span class="string"><span class="delimiter">'</span><span class="content">James</span><span class="delimiter">'</span></span>}  <span class="comment">//add James</span>

<span class="directive">final</span> <span class="predefined-type">Thread</span> t1 = <span class="predefined-type">Thread</span>.start {
    clubMembers.send {<span class="local-variable">it</span>.add <span class="string"><span class="delimiter">'</span><span class="content">Joe</span><span class="delimiter">'</span></span>}  <span class="comment">//add Joe</span>
}

<span class="directive">final</span> <span class="predefined-type">Thread</span> t2 = <span class="predefined-type">Thread</span>.start {
    clubMembers &lt;&lt; {<span class="local-variable">it</span>.add <span class="string"><span class="delimiter">'</span><span class="content">Dave</span><span class="delimiter">'</span></span>}  <span class="comment">//add Dave</span>
    clubMembers {<span class="local-variable">it</span>.add <span class="string"><span class="delimiter">'</span><span class="content">Alice</span><span class="delimiter">'</span></span>}    <span class="comment">//add Alice (using the implicit call() method)</span>
}

[t1, t2]*.join()
println clubMembers.val
clubMembers.valAsync {println <span class="string"><span class="delimiter">&quot;</span><span class="content">Current members: </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>}

clubMembers.await()</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_shared_conference_counting_number_of_registrations">Shared Conference Counting Number of Registrations</h4>
<div class="paragraph">
<p>The <strong>Conference</strong> class allows registration and un-registration, however these methods can only be called from
the commands sent to the <em>conference</em> <strong>Agent</strong>.</p>
</div>
<div class="listingblock">
<div class="title">A Conference Sample -</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.agent.Agent</span>

<span class="comment">/**
 * Conference stores number of registrations and allows parties to register and unregister.
 * It inherits from the Agent class and adds the register() and unregister() private methods,
 * which callers may use it the commands they submit to the Conference.
 */</span>
<span class="type">class</span> <span class="class">Conference</span> <span class="directive">extends</span> Agent&lt;<span class="predefined-type">Long</span>&gt; {
    <span class="keyword">def</span> <span class="function">Conference</span>() { <span class="local-variable">super</span>(<span class="integer">0</span>) }
    <span class="directive">private</span> <span class="keyword">def</span> <span class="function">register</span>(<span class="type">long</span> num) { data += num }
    <span class="directive">private</span> <span class="keyword">def</span> <span class="function">unregister</span>(<span class="type">long</span> num) { data -= num }
}

<span class="directive">final</span> Agent conference = <span class="keyword">new</span> Conference()  <span class="comment">//new Conference created</span>

<span class="comment">/**
 * Three external parties will try to register/unregister concurrently
 */</span>

<span class="directive">final</span> <span class="predefined-type">Thread</span> t1 = <span class="predefined-type">Thread</span>.start {
    conference &lt;&lt; {register(<span class="integer">10L</span>)}               <span class="comment">//send a command to register 10 attendees</span>
}

<span class="directive">final</span> <span class="predefined-type">Thread</span> t2 = <span class="predefined-type">Thread</span>.start {
    conference &lt;&lt; {register(<span class="integer">5L</span>)}                <span class="comment">//send a command to register 5 attendees</span>
}

<span class="directive">final</span> <span class="predefined-type">Thread</span> t3 = <span class="predefined-type">Thread</span>.start {
    conference &lt;&lt; {unregister(<span class="integer">3L</span>)}              <span class="comment">//send a command to unregister 3 attendees</span>
}

[t1, t2, t3]*.join()

<span class="keyword">assert</span> <span class="integer">12L</span> == conference.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_factory_methods">Factory Methods</h3>
<div class="paragraph">
<p><strong>Agent</strong> instances can also be created using the <em>Agent.agent()</em> factory method.</p>
</div>
<div class="listingblock">
<div class="title">A Sample to Make an Agent Instance</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> clubMembers = Agent.agent [<span class="string"><span class="delimiter">'</span><span class="content">Me</span><span class="delimiter">'</span></span>]  <span class="comment">//add Me</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_listeners_and_validators">Listeners and Validators</h3>
<div class="paragraph">
<p>Agents allow the user to add listeners and validators. While listeners are notified each time the
internal state changes, validators get a chance to reject or veto a coming change by throwing an exception.</p>
</div>
<div class="listingblock">
<div class="title">A Concrete Example -</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td>
  <td class="code"><pre><span class="directive">final</span> Agent counter = <span class="keyword">new</span> Agent()

counter.addListener {oldValue, newValue -&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">Changing value from </span><span class="inline"><span class="inline-delimiter">$</span>oldValue</span><span class="content"> to </span><span class="inline"><span class="inline-delimiter">$</span>newValue</span><span class="delimiter">&quot;</span></span>}
counter.addListener {agent, oldValue, newValue -&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">Agent </span><span class="inline"><span class="inline-delimiter">$</span>agent</span><span class="content"> changing value from </span><span class="inline"><span class="inline-delimiter">$</span>oldValue</span><span class="content"> to </span><span class="inline"><span class="inline-delimiter">$</span>newValue</span><span class="delimiter">&quot;</span></span>}

counter.addValidator {oldValue, newValue -&gt; <span class="keyword">if</span> (oldValue &gt; newValue) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>(<span class="string"><span class="delimiter">'</span><span class="content">Things can only go up in Groovy</span><span class="delimiter">'</span></span>)}
counter.addValidator {agent, oldValue, newValue -&gt; <span class="keyword">if</span> (oldValue == newValue) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>(<span class="string"><span class="delimiter">'</span><span class="content">Things never stay the same for $agent</span><span class="delimiter">'</span></span>)}

counter <span class="integer">10</span>
counter <span class="integer">11</span>
counter {updateValue <span class="integer">12</span>}
counter <span class="integer">10</span>  <span class="comment">//Will be rejected</span>

counter {updateValue <span class="local-variable">it</span> - <span class="integer">1</span>}  <span class="comment">//Will be rejected</span>
counter {updateValue <span class="local-variable">it</span>}  <span class="comment">//Will be rejected</span>
counter {updateValue <span class="integer">11</span>}  <span class="comment">//Will be rejected</span>
counter <span class="integer">12</span>  <span class="comment">//Will be rejected</span>

counter <span class="integer">20</span>
counter.await()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Both listeners and validators are essentially closures taking two or three arguments. Exceptions thrown from the validators
will be logged inside the <strong>agent</strong> and can be tested using the <em>hasErrors()</em> method or retrieved through the <em>errors</em> property.</p>
</div>
<div class="listingblock">
<div class="title">Testing for Errors Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">assert</span> counter.hasErrors()
<span class="keyword">assert</span> counter.errors.size() == <span class="integer">5</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_validator_gotchas">Validator Gotchas</h3>
<div class="paragraph">
<p><strong>Groovy</strong> is not very strict on variable data types and immutability, so <strong>agent</strong> users should be aware of potential bumps on the road.</p>
</div>
<div class="paragraph">
<p>If the submitted code modifies the state directly, validators will not be able to un-do the change in case of a validation rule violation.
There are two possible solutions available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Make sure you never change the supplied object representing current agent state</p>
</li>
<li>
<p>Use custom copy strategy on the agent to allow the agent to create copies of the internal state</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In both cases you need to call <em>updateValue()</em> to set and validate the new state properly.</p>
</div>
<div class="paragraph">
<p>The problem as well as both of the solutions follows :</p>
</div>
<hr>
<div class="listingblock">
<div class="title">A Validator Sample -</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td>
  <td class="code"><pre><span class="comment">//Create an agent storing names, rejecting 'Joe'</span>
<span class="directive">final</span> Closure rejectJoeValidator = {oldValue, newValue -&gt; <span class="keyword">if</span> (<span class="string"><span class="delimiter">'</span><span class="content">Joe</span><span class="delimiter">'</span></span> <span class="keyword">in</span> newValue) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>(<span class="string"><span class="delimiter">'</span><span class="content">Joe is not allowed to enter our list.</span><span class="delimiter">'</span></span>)}

Agent agent = <span class="keyword">new</span> Agent(<span class="type">[]</span>)
agent.addValidator rejectJoeValidator

agent {<span class="local-variable">it</span> &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Dave</span><span class="delimiter">'</span></span>}                    <span class="comment">//Accepted</span>
agent {<span class="local-variable">it</span> &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Joe</span><span class="delimiter">'</span></span>}                     <span class="comment">//Erroneously accepted, since by-passes the validation mechanism</span>
println agent.val

<span class="comment">//Solution 1 - never alter the supplied state object</span>
agent = <span class="keyword">new</span> Agent(<span class="type">[]</span>)
agent.addValidator rejectJoeValidator

agent {updateValue([<span class="string"><span class="delimiter">'</span><span class="content">Dave</span><span class="delimiter">'</span></span>, * <span class="local-variable">it</span>])}      <span class="comment">//Accepted</span>
agent {updateValue([<span class="string"><span class="delimiter">'</span><span class="content">Joe</span><span class="delimiter">'</span></span>, * <span class="local-variable">it</span>])}       <span class="comment">//Rejected</span>
println agent.val

<span class="comment">//Solution 2 - use custom copy strategy on the agent</span>
agent = <span class="keyword">new</span> Agent(<span class="type">[]</span>, {<span class="local-variable">it</span>.clone()})
agent.addValidator rejectJoeValidator

agent {updateValue <span class="local-variable">it</span> &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Dave</span><span class="delimiter">'</span></span>}        <span class="comment">//Accepted</span>
agent {updateValue <span class="local-variable">it</span> &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Joe</span><span class="delimiter">'</span></span>}         <span class="comment">//Rejected, since 'it' is now just a copy of the internal agent's state</span>
println agent.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_grouping">Grouping</h3>
<div class="paragraph">
<p>By default, all <strong>Agent</strong> instances belong to the same group sharing its daemon thread pool.</p>
</div>
<div class="paragraph">
<p>Custom groups can also create instances of <strong>Agent</strong>. These instances will belong to the group, which created
them, and will share a thread pool.  To create an <strong>Agent</strong> instance belonging to a group, call the <em>agent()</em>
factory method on the group. This way you can organize and tune performance of agents.</p>
</div>
<div class="listingblock">
<div class="title">Create Groups Around a Thread Pools</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="directive">final</span> <span class="keyword">def</span> group = <span class="keyword">new</span> NonDaemonPGroup(<span class="integer">5</span>)  <span class="comment">//create a group around a thread pool</span>
<span class="keyword">def</span> clubMembers = group.agent([<span class="string"><span class="delimiter">'</span><span class="content">Me</span><span class="delimiter">'</span></span>])  <span class="comment">//add Me</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Custom Thread Pools for Agents</div>
<div class="paragraph">
<p>The default thread pool for <strong>agents</strong> contains daemon threads. Make sure that your custom thread pools either
use daemon threads, too, which can be achieved either by using <strong>DefaultPGroup</strong> or by providing your own thread
factory to a <em>thread pool constructor</em>.</p>
</div>
<div class="paragraph">
<p>Alterntively, in case your thread pools use non-daemon threads, such as when using the <strong>NonDaemonPGroup</strong> group class,
make sure you shutdown the group or the thread pool explicitly by calling its <code>shutdown()</code> method, otherwise your applications will [red]never exit.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_direct_pool_replacement">Direct Pool Replacement</h4>
<div class="paragraph">
<p>Alternatively, by calling the <em>attachToThreadPool()</em> method on an <strong>Agent</strong> instance, a custom thread pool can be specified for it.</p>
</div>
<div class="listingblock">
<div class="title"><strong>attachToThreadPool()</strong> Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> clubMembers = <span class="keyword">new</span> Agent&lt;<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt;&gt;([<span class="string"><span class="delimiter">'</span><span class="content">Me</span><span class="delimiter">'</span></span>])  <span class="comment">//add Me</span>

<span class="directive">final</span> <span class="predefined-type">ExecutorService</span> pool = <span class="predefined-type">Executors</span>.newFixedThreadPool(<span class="integer">10</span>)
clubMembers.attachToThreadPool(<span class="keyword">new</span> DefaultPool(pool))</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Remember, like <strong>actors</strong>, a single <strong>Agent</strong> instance (aka agent) can never use more than one thread at a time
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_the_shopping_cart_example">The Shopping Cart Example</h4>
<div class="listingblock">
<div class="title">A Sample -</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.agent.Agent</span>

<span class="type">class</span> <span class="class">ShoppingCart</span> {
    <span class="directive">private</span> <span class="keyword">def</span> cartState = <span class="keyword">new</span> Agent([:])
<span class="comment">//----------------- public methods below here ----------------------------------</span>
    <span class="directive">public</span> <span class="type">void</span> addItem(<span class="predefined-type">String</span> product, <span class="type">int</span> quantity) {
        cartState &lt;&lt; {<span class="local-variable">it</span>[product] = quantity}  <span class="comment">//the &lt;&lt; operator sends</span>
                                               <span class="comment">//a message to the Agent</span>
    }    <span class="directive">public</span> <span class="type">void</span> removeItem(<span class="predefined-type">String</span> product) {
        cartState &lt;&lt; {<span class="local-variable">it</span>.remove(product)}
    }    <span class="directive">public</span> <span class="predefined-type">Object</span> listContent() {
        <span class="keyword">return</span> cartState.val
    }    <span class="directive">public</span> <span class="type">void</span> clearItems() {
        cartState &lt;&lt; performClear
    }

    <span class="directive">public</span> <span class="type">void</span> increaseQuantity(<span class="predefined-type">String</span> product, <span class="type">int</span> quantityChange) {
        cartState &lt;&lt; <span class="local-variable">this</span>.&amp;changeQuantity.curry(product, quantityChange)
    }
<span class="comment">//----------------- private methods below here ---------------------------------</span>
    <span class="directive">private</span> <span class="type">void</span> changeQuantity(<span class="predefined-type">String</span> product, <span class="type">int</span> quantityChange, <span class="predefined-type">Map</span> items) {
        items[product] = (items[product] ?: <span class="integer">0</span>) + quantityChange
    }    <span class="directive">private</span> Closure performClear = { <span class="local-variable">it</span>.clear() }
}
<span class="comment">//----------------- script code below here -------------------------------------</span>
<span class="directive">final</span> ShoppingCart cart = <span class="keyword">new</span> ShoppingCart()
cart.addItem <span class="string"><span class="delimiter">'</span><span class="content">Pilsner</span><span class="delimiter">'</span></span>, <span class="integer">10</span>
cart.addItem <span class="string"><span class="delimiter">'</span><span class="content">Budweisser</span><span class="delimiter">'</span></span>, <span class="integer">5</span>
cart.addItem <span class="string"><span class="delimiter">'</span><span class="content">Staropramen</span><span class="delimiter">'</span></span>, <span class="integer">20</span>

cart.removeItem <span class="string"><span class="delimiter">'</span><span class="content">Budweisser</span><span class="delimiter">'</span></span>
cart.addItem <span class="string"><span class="delimiter">'</span><span class="content">Budweisser</span><span class="delimiter">'</span></span>, <span class="integer">15</span>

println <span class="string"><span class="delimiter">&quot;</span><span class="content">Contents </span><span class="inline"><span class="inline-delimiter">${</span>cart.listContent()<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>

cart.increaseQuantity <span class="string"><span class="delimiter">'</span><span class="content">Budweisser</span><span class="delimiter">'</span></span>, <span class="integer">3</span>
println <span class="string"><span class="delimiter">&quot;</span><span class="content">Contents </span><span class="inline"><span class="inline-delimiter">${</span>cart.listContent()<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>

cart.clearItems()
println <span class="string"><span class="delimiter">&quot;</span><span class="content">Contents </span><span class="inline"><span class="inline-delimiter">${</span>cart.listContent()<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>You might have noticed two implementation strategies in the code.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Public methods may internally just send the required code off to the <strong>Agent</strong>, instead of executing the same functionality directly</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">And so Typically Sequential Code Like This</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">void</span> addItem(<span class="predefined-type">String</span> product, <span class="type">int</span> quantity) {
    cartState[product]=quantity
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Becomes</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">void</span> addItem(<span class="predefined-type">String</span> product, <span class="type">int</span> quantity) {
    cartState &lt;&lt; {<span class="local-variable">it</span>[product] = quantity}
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Public methods may send references to internal private methods or closures, which hold the desired functionality to perform the deed.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">A Public-to-Private Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">void</span> clearItems() {
    cartState &lt;&lt; performClear
}

<span class="directive">private</span> Closure performClear = { <span class="local-variable">it</span>.clear() }</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Currying might be necessary</strong>, if the closure takes other arguments besides the current internal state
 instance. See the <em>increaseQuantity</em> method.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_the_printer_service_example">The Printer Service Example</h4>
<div class="paragraph">
<p>Another example - suppose a not thread-safe printer service is shared by multiple threads.
The printer needs to have the document and quality properties set before printing. Obviously we have a potential for race conditions if not guarded properly.
Callers don&#8217;t want to block until the printer is available, which the <code>fire-and-forget</code> nature of <strong>actors</strong> solves very elegantly.</p>
</div>
<div class="listingblock">
<div class="title">A Sample Printer Service</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.agent.Agent</span>

<span class="comment">/**
 * A non-thread-safe service that slowly prints documents on at a time
 */</span>
<span class="type">class</span> <span class="class">PrinterService</span> {
    <span class="predefined-type">String</span> document
    <span class="predefined-type">String</span> quality

    <span class="directive">public</span> <span class="type">void</span> printDocument() {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Printing </span><span class="inline"><span class="inline-delimiter">$</span>document</span><span class="content"> in </span><span class="inline"><span class="inline-delimiter">$</span>quality</span><span class="content"> quality</span><span class="delimiter">&quot;</span></span>
        <span class="predefined-type">Thread</span>.sleep <span class="integer">5000</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Done printing </span><span class="inline"><span class="inline-delimiter">$</span>document</span><span class="delimiter">&quot;</span></span>
    }
}

<span class="keyword">def</span> printer = <span class="keyword">new</span> Agent&lt;PrinterService&gt;(<span class="keyword">new</span> PrinterService())

<span class="directive">final</span> <span class="predefined-type">Thread</span> thread1 = <span class="predefined-type">Thread</span>.start {
    <span class="keyword">for</span> (num <span class="keyword">in</span> (<span class="integer">1</span>..<span class="integer">3</span>)) {
        <span class="directive">final</span> <span class="predefined-type">String</span> text = <span class="string"><span class="delimiter">&quot;</span><span class="content">document </span><span class="inline"><span class="inline-delimiter">$</span>num</span><span class="delimiter">&quot;</span></span>
        printer &lt;&lt; {printerService -&gt;
            printerService.document = text
            printerService.quality = <span class="string"><span class="delimiter">'</span><span class="content">High</span><span class="delimiter">'</span></span>
            printerService.printDocument()
        }
        <span class="predefined-type">Thread</span>.sleep <span class="integer">200</span>
    }
    println <span class="string"><span class="delimiter">'</span><span class="content">Thread 1 is ready to do something else. All print tasks have been submitted</span><span class="delimiter">'</span></span>
}

<span class="directive">final</span> <span class="predefined-type">Thread</span> thread2 = <span class="predefined-type">Thread</span>.start {
    <span class="keyword">for</span> (num <span class="keyword">in</span> (<span class="integer">1</span>..<span class="integer">4</span>)) {
        <span class="directive">final</span> <span class="predefined-type">String</span> text = <span class="string"><span class="delimiter">&quot;</span><span class="content">picture </span><span class="inline"><span class="inline-delimiter">$</span>num</span><span class="delimiter">&quot;</span></span>
        printer &lt;&lt; {printerService -&gt;
            printerService.document = text
            printerService.quality = <span class="string"><span class="delimiter">'</span><span class="content">Medium</span><span class="delimiter">'</span></span>
            printerService.printDocument()
        }
        <span class="predefined-type">Thread</span>.sleep <span class="integer">500</span>
    }
    println <span class="string"><span class="delimiter">'</span><span class="content">Thread 2 is ready to do something else. All print tasks have been submitted</span><span class="delimiter">'</span></span>
}

[thread1, thread2]*.join()
printer.await()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For the latest updates, see the respective <a href="Demos.html">Demos</a>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_reading_the_value">Reading The Value</h3>
<div class="paragraph">
<p>To follow the <strong>Clojure</strong> philosophy closely, the <strong>Agent</strong> class gives reads higher priority than to writes.  By
using the <em>instantVal</em> property, your read request will bypass the incoming message queue of the <strong>Agent</strong> and
returns the current snapshot of the internal state.  The <em>val</em> property will wait in the message queue for
processing, just like the non-blocking variant <em>valAsync(Clojure cl)</em> , which will invoke the provided
closure with the internal state as a parameter.</p>
</div>
<div class="paragraph">
<p>You have to bear in mind that the <em>instantVal</em> property might return although correct, but randomly looking
results, since the internal state of the <strong>Agent</strong> at the time of <em>instantVal</em> execution is non-deterministic
and depends on the messages that have been processed before the thread scheduler executes the body of
<em>instantVal</em> .</p>
</div>
<div class="paragraph">
<p>The <em>await()</em> method lets you wait for the processing of all the messages submitted to the <strong>Agent</strong> before and so may
block the calling thread.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_state_copy_strategy">State Copy Strategy</h3>
<div class="paragraph">
<p>To avoid leaking the internal state, the <strong>Agent</strong> class can specify a <code>copy strategy</code> as the second
constructor argument.  With the <code>copy strategy</code> specified, the internal state is processed by the <code>copy
strategy</code> closure and the output value of the <code>copy strategy</code> value is returned to the caller instead of the
actual internal state. This applies to <em>instantVal</em>, <em>val</em> as well as to <em>valAsync()</em> .</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_error_handling">Error Handling</h3>
<div class="paragraph">
<p>Exceptions thrown from within the submitted commands are stored inside the <strong>agent</strong> and can be obtained from
the <em>errors</em> property.  The property is cleared once read.</p>
</div>
<div class="listingblock">
<div class="title">A Sample of Error Handling</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> clubMembers = <span class="keyword">new</span> Agent&lt;<span class="predefined-type">List</span>&gt;()
<span class="keyword">assert</span> clubMembers.errors.empty

    clubMembers.send {<span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">'</span><span class="content">test1</span><span class="delimiter">'</span></span>)}
    clubMembers.send {<span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>(<span class="string"><span class="delimiter">'</span><span class="content">test2</span><span class="delimiter">'</span></span>)}
    clubMembers.await()

    <span class="predefined-type">List</span> errors = clubMembers.errors
    <span class="keyword">assert</span> <span class="integer">2</span> == errors.size()
    <span class="keyword">assert</span> errors[<span class="integer">0</span>] <span class="keyword">instanceof</span> <span class="exception">IllegalStateException</span>
    <span class="keyword">assert</span> <span class="string"><span class="delimiter">'</span><span class="content">test1</span><span class="delimiter">'</span></span> == errors[<span class="integer">0</span>].message
    <span class="keyword">assert</span> errors[<span class="integer">1</span>] <span class="keyword">instanceof</span> <span class="exception">IllegalArgumentException</span>
    <span class="keyword">assert</span> <span class="string"><span class="delimiter">'</span><span class="content">test2</span><span class="delimiter">'</span></span> == errors[<span class="integer">1</span>].message

    <span class="keyword">assert</span> clubMembers.errors.empty</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_fair_and_non_fair_strong_agents_strong">Fair and Non-fair <strong>Agents</strong></h3>
<div class="paragraph">
<p><strong>Agents</strong> can be either fair or non-fair. Fair <strong>agents</strong> give up the thread after processing each message, unfair <strong>agents</strong> keep a thread until their message queue is empty.
As a result, non-fair <strong>agents</strong> tend to perform better than fair ones.</p>
</div>
<div class="paragraph">
<p>The default setting for all <strong>Agent</strong> instances is to be <strong>non-fair</strong>, however by calling its <em>makeFair()</em> method the instance can be made fair.</p>
</div>
<div class="listingblock">
<div class="title">A Sample To Make It Fair</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> clubMembers = <span class="keyword">new</span> Agent&lt;<span class="predefined-type">List</span>&gt;([<span class="string"><span class="delimiter">'</span><span class="content">Me</span><span class="delimiter">'</span></span>])  <span class="comment">//add Me</span>
clubMembers.makeFair()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../images/divider.png" alt="divider" width="436">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_user_guide_to_strong_dataflow_strong">User Guide to <strong>Dataflow</strong></h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Dataflow</strong> concurrency offers an alternative concurrency model, which is inherently safe and robust.</p>
</div>
<hr>
<div class="sect2">
<h3 id="_introduction_2">Introduction</h3>
<div class="paragraph">
<p>Check out this small example written in <strong>Groovy</strong> using <strong>GPars</strong> to sum results of calculations performed by three concurrently run tasks:</p>
</div>
<div class="listingblock">
<div class="title">A Simple Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

<span class="directive">final</span> <span class="keyword">def</span> x = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> y = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> z = <span class="keyword">new</span> DataflowVariable()

task {
    z &lt;&lt; x.val + y.val
}

task {
    x &lt;&lt; <span class="integer">10</span>
}

task {
    y &lt;&lt; <span class="integer">5</span>
}

println <span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="inline"><span class="inline-delimiter">${</span>z.val<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The same algorithm rewritten using the <em>Dataflows</em> class looks like this :</p>
</div>
<div class="listingblock">
<div class="title">A <em>Dataflows</em> Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

<span class="directive">final</span> <span class="keyword">def</span> df = <span class="keyword">new</span> Dataflows()

task {
    df.z = df.x + df.y
}

task {
    df.x = <span class="integer">10</span>
}

task {
    df.y = <span class="integer">5</span>
}

println <span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="inline"><span class="inline-delimiter">${</span>df.z<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>We start three logical tasks, which can run in parallel and perform their particular activities. The tasks
need to exchange data and they do so using <code>Dataflow Variables</code>.  Think of <code>Dataflow Variables</code> as one-shot
channels safely and reliably transferring data from producers to their consumers.</p>
</div>
<div class="paragraph">
<p>The <code>Dataflow Variables</code> have pretty straightforward semantics. When a task needs to read a value from a
<code>DataflowVariable</code> (through the val property), it will block until the value has been set by another task or
thread (using the <strong class="red">'&lt;&lt;'</strong> operator). Each <code>Dataflow Variable</code> can be set <strong>only once</strong> in its lifetime.</p>
</div>
<div class="paragraph">
<p>Notice that you don&#8217;t have to bother with ordering and synchronizing the tasks or threads and their access to shared variables.
The values are magically transferred among tasks at the right time without your intervention.
The data flow seamlessly among tasks / threads without your intervention or care.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_implementation_detail">Implementation Detail</h3>
<div class="paragraph">
<p>The three tasks in the example <strong class="blue">do not necessarily need to be mapped to three physical threads</strong>. Tasks represent so-called "green" or "logical" threads and can be mapped under the covers to any number of physical threads.
The actual mapping depends on the scheduler, but the outcome of dataflow algorithms doesn&#8217;t depend on the actual scheduling.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Re-binding Is Possible</div>
<div class="paragraph">
<p>The <em>bind</em> operation of <code>dataflow variables</code> silently accepts re-binding to a value, which is equal to an already bound value. We can call the <em>bindUnique</em> method to reject equal values on already-bound variables.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_benefits">Benefits</h3>
<div class="paragraph">
<p>Here&#8217;s what you gain by using <code>Dataflow Concurrency</code> (by <a href="http://www.jonasboner.com">Jonas Bonér</a>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No race-conditions</p>
</li>
<li>
<p>No live-locks</p>
</li>
<li>
<p>Deterministic deadlocks</p>
</li>
<li>
<p>Completely deterministic programs</p>
</li>
<li>
<p>BEAUTIFUL code.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This doesn&#8217;t sound bad, does it?</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_concepts_2">Concepts</h3>
<div class="sect3">
<h4 id="_dataflow_programming">Dataflow Programming</h4>
<div class="sect4">
<h5 id="_quoting_wikipedia">Quoting Wikipedia</h5>
<div class="paragraph">
<p>Operations (in <code>Dataflow</code> programs) consist of "black boxes" with inputs and outputs, all of which are always explicitly defined.
They run as soon as all of their inputs become valid, as opposed to when the program encounters them.
Whereas a traditional program essentially consists of a series of statements saying "do this, now do this", a <code>dataflow</code> program is more like a series of workers on an assembly line,
who will do their assigned task as soon as the materials arrive.</p>
</div>
<div class="paragraph">
<p>This is why dataflow languages are inherently parallel: the operations have no hidden state to keep track of, and the operations are all "ready" at the same time.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_principles">Principles</h3>
<div class="paragraph">
<p>With <code>Dataflow Concurrency</code>, you can safely share variables across tasks. These variable (in <strong>Groovy</strong> instances of the <code>DataflowVariable</code> class) can only be assigned (using the <strong class="red">'&lt;&lt;'</strong> operator) a value  once in their lifetime.
The values of the variables, on the other hand, can be read multiple times (in <strong>Groovy</strong> through the <code>val</code> property), even before the value has been assigned. In such cases, the reading task is suspended until the value is set by another task.
So you can simply write your code for each task sequentially using <code>Dataflow Variables</code> and the underlying mechanics will make sure you get all the values you need in a thread-safe manner.</p>
</div>
<div class="paragraph">
<p>In brief, you generally perform three operations with <code>Dataflow variables</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create a <code>dataflow variable</code></p>
</li>
<li>
<p>Wait for the variable to be bound (read it)</p>
</li>
<li>
<p>Bind the variable (write to it)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And these are the three essential rules your programs have to follow:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When the program encounters an unbound variable it waits for a value.</p>
</li>
<li>
<p>It&#8217;s not possible to change the value of a dataflow variable once it&#8217;s bound.</p>
</li>
<li>
<p><code>Dataflow variables</code> makes it easy to create concurrent stream agents.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_dataflow_queues_and_broadcasts">Dataflow Queues and Broadcasts</h3>
<div class="paragraph">
<p>Before you check our samples of <strong>Dataflow Variables</strong>, <strong>Tasks</strong> and <strong>Operators</strong>, you should learn a bit about streams and queues to have a full picture of <code>Dataflow Concurrency</code>.
Except for <code>dataflow variables</code>, there are also the concepts of <em>DataflowQueues</em> and <em>DataflowBroadcast</em> that you can leverage in your code.</p>
</div>
<div class="paragraph">
<p>You may think of them as thread-safe buffers or queues for message transfer among concurrent tasks or threads. Check out a typical producer-consumer demo:</p>
</div>
<div class="listingblock">
<div class="title">A Producer-Consumer Demo</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

<span class="keyword">def</span> words = [<span class="string"><span class="delimiter">'</span><span class="content">Groovy</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">fantastic</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">concurrency</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">fun</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">enjoy</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">safe</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">GPars</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">data</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">flow</span><span class="delimiter">'</span></span>]
<span class="directive">final</span> <span class="keyword">def</span> buffer = <span class="keyword">new</span> DataflowQueue()

task {
    <span class="keyword">for</span> (word <span class="keyword">in</span> words) {
        buffer &lt;&lt; word.toUpperCase()  <span class="comment">//add to the buffer</span>
    }
}

task {
    <span class="keyword">while</span>(<span class="predefined-constant">true</span>) println buffer.val  <span class="comment">//read from the buffer in a loop</span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Both <em>DataflowBroadcasts</em> and <em>DataflowQueues</em> , just like <code>DataflowVariables</code> , implement the <code>DataflowChannel</code> interface with common methods allowing us to write to them and read values from them.</p>
</div>
<div class="paragraph">
<p>The ability to treat both types identically through the <em>DataflowChannel</em> interface comes in handy once you start using them to wire <em>tasks</em> , <em>operators</em> or <em>selectors</em> together.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">DataflowChannels Combine Two Interfaces</div>
<div class="paragraph">
<p>The <em>DataflowChannel</em> interface combines two interfaces, each serving its purpose:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>DataflowReadChannel holds all the methods necessary for reading values from a channel - <strong>getVal()</strong>, <strong>getValAsync()</strong>, <strong>whenBound()</strong>, etc.</p>
</li>
<li>
<p>DataflowWriteChannel holds all the methods necessary for writing values into a channel - <strong>bind()</strong>, <strong class="red">'&lt;&lt;'</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You may prefer using these dedicated interfaces instead of the general <em>DataflowChannel</em> interface, to better express your intended usage.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Please refer to the API doc for more details about the channel interfaces.</p>
</div>
<hr>
<div class="sect3">
<h4 id="_point_to_point_communication">Point-to-point Communication</h4>
<div class="paragraph">
<p>The <em>DataflowQueue</em> class can be viewed as a point-to-point (1 to 1, many to 1) communication channel. It allows one or more producers send messages to one reader.
If multiple readers read from the same <em>DataflowQueue</em> , they will each consume different messages.</p>
</div>
<div class="paragraph">
<p>Or to put it a different way, each message is consumed by exactly one reader.  You can easily imagine a simple load-balancing scheme built around a shared
<em>DataflowQueue</em> with readers being added dynamically when the consumer part of your algorithm needs to scale up.  This is also a useful default choice when connecting tasks or operators.</p>
</div>
</div>
<div class="sect3">
<h4 id="_publish_subscribe_communication">Publish-subscribe Communication</h4>
<div class="paragraph">
<p>The <em>DataflowBroadcast</em> class offers a publish-subscribe (1 to many, many to many) communication model. One or more producers write messages, while all registered readers will receive all the messages. Each message
is thus consumed by all readers with a valid subscription at the point when the message is written to the channel. The readers subscribe by calling the <em>createReadChannel()</em> method.</p>
</div>
<div class="listingblock">
<div class="title">A Pub-Sub Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre>DataflowWriteChannel broadcastStream = <span class="keyword">new</span> DataflowBroadcast()
DataflowReadChannel stream1 = broadcastStream.createReadChannel()
DataflowReadChannel stream2 = broadcastStream.createReadChannel()

broadcastStream &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Message1</span><span class="delimiter">'</span></span>
broadcastStream &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Message2</span><span class="delimiter">'</span></span>
broadcastStream &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Message3</span><span class="delimiter">'</span></span>

<span class="keyword">assert</span> stream1.val == stream2.val
<span class="keyword">assert</span> stream1.val == stream2.val
<span class="keyword">assert</span> stream1.val == stream2.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Under the covers, <em>DataflowBroadcast</em> uses the <em>DataflowStream</em> class to implement the message delivery.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_dataflowstream">DataflowStream</h3>
<div class="paragraph">
<p>The <em>DataflowStream</em> class represents a deterministic dataflow channel. It&#8217;s built around the concept of a functional queue and so provides a lock-free thread-safe implementation for message passing.</p>
</div>
<div class="paragraph">
<p>Essentially, you may think of <em>DataflowStream</em> mechanisms as a 1-to-many communication channel, since when a reader consumes a messages, other readers will still be able to read the same message.
Also, all messages arrive to all readers in the same order.</p>
</div>
<div class="paragraph">
<p>Since the <em>DataflowStream</em> is implemented as a functional queue, its API requires users to traverse the values in the stream themselves.
On the other hand, <em>DataflowStream</em> offers handy methods for value filtering or transformation together with interesting performance characteristics.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Semantics for the <em>DataflowStream</em> Differ From The <em>DataflowChannel</em> Interface</div>
<div class="paragraph">
<p>The <em>DataflowStream</em> class, unlike the other communication elements, does not implement the <em>DataflowChannel</em> interface, since the semantics of its use is different.
Use <em>DataflowStreamReadAdapter</em> and <em>DataflowStreamWriteAdapter</em> classes to wrap instances of the <em>DataflowChannel</em> class in a <em>DataflowReadChannel</em> or <em>DataflowWriteChannel</em> implementations.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">A Sample of DataflowStream Usage</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.stream.DataflowStream</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.scheduler.ResizeablePool</span>

<span class="comment">/**
 * Demonstrates concurrent implementation of the Sieve of Eratosthenes using dataflow tasks
 *
 * In principle, the algorithm consists of a concurrently run chained filters,
 * each of which detects whether the current number can be divided by a single prime number.
 * (generate nums 1, 2, 3, 4, 5, ...) -&gt; (filter by mod 2) -&gt; (filter by mod 3) -&gt; (filter by mod 5) -&gt; (filter by mod 7) -&gt; (filter by mod 11) -&gt; (caution! Primes falling out here)
 * The chain is built (grows) on the fly, whenever a new prime is found
 */</span>

<span class="comment">/**
 * We need a resizeable thread pool, since tasks consume threads while waiting, blocked for values from the DataflowQueue.val
 */</span>
group = <span class="keyword">new</span> DefaultPGroup(<span class="keyword">new</span> ResizeablePool(<span class="predefined-constant">true</span>))

<span class="directive">final</span> <span class="type">int</span> requestedPrimeNumberCount = <span class="integer">100</span>

<span class="comment">/**
 * Generating candidate numbers
 */</span>
<span class="directive">final</span> DataflowStream candidates = <span class="keyword">new</span> DataflowStream()
group.task {
    candidates.generate(<span class="integer">2</span>, {<span class="local-variable">it</span> + <span class="integer">1</span>}, {<span class="local-variable">it</span> &lt; <span class="integer">1000</span>})
}

<span class="comment">/**
 * Chain a new filter for a particular prime number to the end of the Sieve
 * @param inChannel The current end channel to consume
 * @param prime The prime number to divide future prime candidates with
 * @return A new channel ending the whole chain
 */</span>
<span class="keyword">def</span> <span class="function">filter</span>(DataflowStream inChannel, <span class="type">int</span> prime) {
    inChannel.filter { number -&gt;
        group.task {
            number % prime != <span class="integer">0</span>
        }
    }
}

<span class="comment">/**
 * Consume Sieve output and add additional filters for all found primes
 */</span>
<span class="keyword">def</span> currentOutput = candidates
requestedPrimeNumberCount.times {

    <span class="type">int</span> prime = currentOutput.first
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Found: </span><span class="inline"><span class="inline-delimiter">$</span>prime</span><span class="delimiter">&quot;</span></span>
    currentOutput = filter(currentOutput, prime)
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>For convenience and for the ability to use <em>DataflowStream</em> objects with other dataflow constructs, like e.g. operators, you can wrap it with <em>DataflowReadAdapter</em> for read access or <em>DataflowWriteAdapter</em> for write access.</p>
</div>
<div class="paragraph">
<p>The <em>DataflowStream</em> class is designed for single-threaded producers and consumers. If multiple threads are supposed to read or write values to the stream, their access to the stream must be serialized externally or adapters should be used.</p>
</div>
<div class="sect3">
<h4 id="_dataflowstream_adapters">DataflowStream Adapters</h4>
<div class="paragraph">
<p>The <em>DataflowStream</em> API as well as the semantics of its use are very different from the one defined by <em>Dataflow(Read/Write)Channel</em>. Adapters have to be used in order to allow <em>DataflowStreams</em> to work with other dataflow elements.
The <em>DataflowStreamReadAdapter</em> class will wrap a <em>DataflowStream</em> with the necessary methods to read values, while the <em>DataflowStreamWriteAdapter</em> class provides write methods around the wrapped <em>DataflowStream</em> method.</p>
</div>
</div>
<div class="sect3">
<h4 id="_thread_safety">Thread Safety</h4>
<div class="paragraph">
<p>It&#8217;s important to mention that the <em>DataflowStreamWriteAdapter</em> is thread safe. It allows multiple threads to add values to the wrapped <em>DataflowStream</em> through the adapter.
On the other hand, the <em>DataflowStreamReadAdapter</em> is designed to be used by a single thread.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <em>DataflowStreamWriteAdapter</em> is thread safe
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p>To minimize overhead and stay in-line with <em>DataflowStream</em> semantics, the <em>DataflowStreamReadAdapter</em> class is not thread-safe and should only be used from within a single thread.</p>
</div>
<div class="paragraph">
<p>If multiple threads need to read from a <em>DataflowStream</em>, they should create their own wrapping of <em>DataflowStreamReadAdapter</em> .</p>
</div>
<div class="paragraph">
<p>Thanks to the adapters, <em>DataflowStream</em> can be used for communications between operators or selectors, as these expect <em>Dataflow(Read/Write)Channels</em> .</p>
</div>
<div class="listingblock">
<div class="title">DataflowStreamAdapters Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.stream.DataflowStream</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.stream.DataflowStreamReadAdapter</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.stream.DataflowStreamWriteAdapter</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.selector</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.operator</span>

<span class="comment">/**
 * Demonstrates the use of DataflowStreamAdapters to allow dataflow operators to use DataflowStreams
 */</span>

<span class="directive">final</span> DataflowStream a = <span class="keyword">new</span> DataflowStream()
<span class="directive">final</span> DataflowStream b = <span class="keyword">new</span> DataflowStream()
<span class="keyword">def</span> aw = <span class="keyword">new</span> DataflowStreamWriteAdapter(a)
<span class="keyword">def</span> bw = <span class="keyword">new</span> DataflowStreamWriteAdapter(b)
<span class="keyword">def</span> ar = <span class="keyword">new</span> DataflowStreamReadAdapter(a)
<span class="keyword">def</span> br = <span class="keyword">new</span> DataflowStreamReadAdapter(b)

<span class="keyword">def</span> result = <span class="keyword">new</span> DataflowQueue()

<span class="keyword">def</span> op1 = operator(ar, bw) {
    bindOutput <span class="local-variable">it</span>
}
<span class="keyword">def</span> op2 = selector([br], [result]) {
    result &lt;&lt; <span class="local-variable">it</span>
}

aw &lt;&lt; <span class="integer">1</span>
aw &lt;&lt; <span class="integer">2</span>
aw &lt;&lt; <span class="integer">3</span>
<span class="keyword">assert</span>([<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>] == [result.val, result.val, result.val])
op1.stop()
op2.stop()
op1.join()
op2.join()
</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Also the ability to select a value from multiple <em>DataflowChannels</em> can only be used through an adapter around a <em>DataflowStream</em>.</p>
</div>
<div class="listingblock">
<div class="title">A DataflowStream Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.Select</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.stream.DataflowStream</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.stream.DataflowStreamReadAdapter</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.stream.DataflowStreamWriteAdapter</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.select</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

<span class="comment">/**
 * Demonstrates the use of DataflowStreamAdapters to allow dataflow select to select on DataflowStreams
 */</span>

<span class="directive">final</span> DataflowStream a = <span class="keyword">new</span> DataflowStream()
<span class="directive">final</span> DataflowStream b = <span class="keyword">new</span> DataflowStream()

<span class="keyword">def</span> aw = <span class="keyword">new</span> DataflowStreamWriteAdapter(a)
<span class="keyword">def</span> bw = <span class="keyword">new</span> DataflowStreamWriteAdapter(b)
<span class="keyword">def</span> ar = <span class="keyword">new</span> DataflowStreamReadAdapter(a)
<span class="keyword">def</span> br = <span class="keyword">new</span> DataflowStreamReadAdapter(b)

<span class="directive">final</span> Select&lt;?&gt; select = select(ar, br)
task {
    aw &lt;&lt; <span class="integer">1</span>
    aw &lt;&lt; <span class="integer">2</span>
    aw &lt;&lt; <span class="integer">3</span>
}

<span class="keyword">assert</span> <span class="integer">1</span> == select().value
<span class="keyword">assert</span> <span class="integer">2</span> == select().value
<span class="keyword">assert</span> <span class="integer">3</span> == select().value

task {
    bw &lt;&lt; <span class="integer">4</span>
    aw &lt;&lt; <span class="integer">5</span>
    bw &lt;&lt; <span class="integer">6</span>
}

<span class="keyword">def</span> result = (<span class="integer">1</span>..<span class="integer">3</span>).collect{select()}.sort{<span class="local-variable">it</span>.value}

<span class="keyword">assert</span> result*.value == [<span class="integer">4</span>, <span class="integer">5</span>, <span class="integer">6</span>]
<span class="keyword">assert</span> result*.index == [<span class="integer">1</span>, <span class="integer">0</span>, <span class="integer">1</span>]</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you don&#8217;t need any of the functional queue <em>DataflowStream-special</em> functionality, like generation, filtering or mapping, you might consider using the <em>DataflowBroadcast</em> class instead.</p>
</div>
<div class="paragraph">
<p>This class offers the <em>publish-subscribe</em> communication model through the <em>DataflowChannel</em> interface.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_bind_handlers">Bind Handlers</h3>
<div class="listingblock">
<div class="title">What A Bind</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> a = <span class="keyword">new</span> DataflowVariable()

a &gt;&gt; {println <span class="string"><span class="delimiter">&quot;</span><span class="content">The variable has just been bound to </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>}

a.whenBound {println <span class="string"><span class="delimiter">&quot;</span><span class="content">Just to confirm that the variable has been really set to </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>}
...</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Bind handlers</code> can be registered on all dataflow channels (variables, queues or broadcasts) either using the <strong class="red">'&gt;&gt;'</strong> operator and/or the <em>then()</em> or the <em>whenBound()</em> methods.
They will be run only after a value is bound to the variable.</p>
</div>
<div class="paragraph">
<p><code>Dataflow queues</code> and <code>broadcasts</code> also support a <em>wheneverBound</em> method to register a closure or a message handler to run each time a value is bound to them.</p>
</div>
<div class="listingblock">
<div class="title">A DataflowQueue().wheneverBound Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> queue = <span class="keyword">new</span> DataflowQueue()
queue.wheneverBound {println <span class="string"><span class="delimiter">&quot;</span><span class="content">A value </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="content"> arrived to the queue</span><span class="delimiter">&quot;</span></span>}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Obviously, nothing prevents you from having more than a single handler for a single promise: They will all trigger in parallel once the <strong>promise</strong> has a concrete value:</p>
</div>
<div class="listingblock">
<div class="title">A <code>wheneverBound</code> Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre>Promise bookingPromise = task {
    <span class="directive">final</span> data = collectData()
    <span class="keyword">return</span> broker.makeBooking(data)
}

bookingPromise.whenBound {booking -&gt; printAgenda booking}
bookingPromise.whenBound {booking -&gt; sendMeAnEmailTo booking}
bookingPromise.whenBound {booking -&gt; updateTheCalendar booking}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Parallel Speculations Anyone ?</div>
<div class="paragraph">
<p>Dataflow variables and broadcasts are one of several possible ways to implement <em>Parallel Speculations</em>.
For details, please check out <em>Parallel Speculations</em> in the <em>Parallel Collections</em> section of the <strong>User Guide</strong>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bind_handlers_grouping">Bind Handlers Grouping</h3>
<div class="paragraph">
<p>When you need to wait for multiple <code>DataflowVariables Promises</code> to be bound, we can benefit from calling the <em>whenAllBound()</em> function. It&#8217;s available on the <em>Dataflow</em> class as well as on <em>PGroup</em> instances.</p>
</div>
<div class="listingblock">
<div class="title">whenAllBound() Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td>
  <td class="code"><pre>    <span class="directive">final</span> group = <span class="keyword">new</span> NonDaemonPGroup()

    <span class="comment">//Calling asynchronous services and receiving back promises for the reservations</span>
    Promise flightReservation = flightBookingService(<span class="string"><span class="delimiter">'</span><span class="content">PAR &lt;-&gt; BRU</span><span class="delimiter">'</span></span>)
    Promise hotelReservation = hotelBookingService(<span class="string"><span class="delimiter">'</span><span class="content">BRU:Feb 24 20015 - Feb 29 2015</span><span class="delimiter">'</span></span>)
    Promise taxiReservation = taxiBookingService(<span class="string"><span class="delimiter">'</span><span class="content">BRU:Feb 24 2015 10:31</span><span class="delimiter">'</span></span>)

    <span class="comment">//when all reservations have been made, we need to build an agenda for our trip</span>
    Promise agenda = group.whenAllBound(flightReservation, hotelReservation, taxiReservation) {flight, hotel, taxi -&gt;
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Agenda: </span><span class="inline"><span class="inline-delimiter">$</span>flight</span><span class="content"> | </span><span class="inline"><span class="inline-delimiter">$</span>hotel</span><span class="content"> | </span><span class="inline"><span class="inline-delimiter">$</span>taxi</span><span class="delimiter">&quot;</span></span>
    }

    <span class="comment">//since this is a demo, we only print the agenda and block when it's ready</span>
    println agenda.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you don&#8217;t know the number of parameters the <em>whenAllBound()</em> handler needs, then use a closure with one argument of type <em>List</em>:</p>
</div>
<div class="listingblock">
<div class="title">whenAllBound() Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre>Promise module1 = task {
    compile(module1Sources)
}
Promise module2 = task {
    compile(module2Sources)
}

<span class="comment">//We don't know the number of modules that will be jarred together, so use a List</span>
<span class="directive">final</span> jarCompiledModules = {<span class="predefined-type">List</span> modules -&gt; ...}

whenAllBound([module1, module2], jarCompiledModules)</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_bind_handler_chaining">Bind Handler Chaining</h3>
<div class="paragraph">
<p>All dataflow channels also support the <em>then()</em> method to register a callback handler to invoke when a value becomes available. Unlike <em>whenBound()</em>, the <em>then()</em> method allows us to use chaining, giving us the option to transfer resulting values between functions asynchronously.</p>
</div>
<hr>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<strong>Groovy</strong> allows us to leave out some of the <em>dots</em> in the <em>then()</em> method chains.
</td>
</tr>
</table>
</div>
<hr>
<div class="listingblock">
<div class="title">A Pointless Sample - No Need To Join The Dots !</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre><span class="directive">final</span> DataflowVariable variable = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> DataflowVariable result = <span class="keyword">new</span> DataflowVariable()

variable.then {<span class="local-variable">it</span> * <span class="integer">2</span>} then {<span class="local-variable">it</span> + <span class="integer">1</span>} then {result &lt;&lt; <span class="local-variable">it</span>}
variable &lt;&lt; <span class="integer">4</span>
<span class="keyword">assert</span> <span class="integer">9</span> == result.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">This could be nicely combined with <em>Asynchronous functions</em></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre><span class="directive">final</span> DataflowVariable variable = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> DataflowVariable result = <span class="keyword">new</span> DataflowVariable()

<span class="directive">final</span> doubler = {<span class="local-variable">it</span> * <span class="integer">2</span>}
<span class="directive">final</span> adder = {<span class="local-variable">it</span> + <span class="integer">1</span>}

variable.then doubler then adder then {result &lt;&lt; <span class="local-variable">it</span>}

<span class="predefined-type">Thread</span>.start {variable &lt;&lt; <span class="integer">4</span>}

<span class="keyword">assert</span> <span class="integer">9</span> == result.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">or <em>ActiveObjects</em></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td>
  <td class="code"><pre><span class="annotation">@ActiveObject</span>
<span class="type">class</span> <span class="class">ActiveDemoCalculator</span> {
    <span class="annotation">@ActiveMethod</span>
    <span class="keyword">def</span> <span class="function">doubler</span>(<span class="type">int</span> value) {
        value * <span class="integer">2</span>
    }

    <span class="annotation">@ActiveMethod</span>
    <span class="keyword">def</span> <span class="function">adder</span>(<span class="type">int</span> value) {
        value + <span class="integer">1</span>
    }
}

<span class="directive">final</span> DataflowVariable result = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> calculator = <span class="keyword">new</span> ActiveDemoCalculator();

calculator.doubler(<span class="integer">4</span>).then {calculator.adder <span class="local-variable">it</span>}.then {result &lt;&lt; <span class="local-variable">it</span>}

<span class="keyword">assert</span> <span class="integer">9</span> == result.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Motivation for Chaining Promises</div>
<div class="paragraph">
<p><code>Chaining</code> can save quite some code when calling other asynchronous services from within <em>whenBound()</em> handlers.</p>
</div>
<div class="paragraph">
<p>Asynchronous services, such as <em>Asynchronous Functions</em> or <em>Active Methods</em>, return <strong>Promises</strong> for their results. To obtain the actual results, your handlers would have to block to wait for the value to be bound. This locks the current thread in an unproductive state.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">An Unproductive Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>variable.whenBound {value -&gt;
    Promise promise = asyncFunction(value)
    println promise.get()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>or, alternatively, it could register another (nested) <em>whenBound()</em> handler, which would result in unnecessarily complex code.</p>
</div>
<div class="listingblock">
<div class="title">An Unnecessarily Complex Nested Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>variable.whenBound {value -&gt;
    asyncFunction(value).whenBound {
        println <span class="local-variable">it</span>
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>For an illustration, compare the following two code snippets. One is using <em>whenBound()</em> and one using <em>then()</em> chaining. They&#8217;re both equivalent in terms of functionality and behavior.</p>
</div>
<div class="listingblock">
<div class="title">A <em>whenBound()</em> Sample Plus a <em>then()</em> Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td>
  <td class="code"><pre><span class="directive">final</span> DataflowVariable variable = <span class="keyword">new</span> DataflowVariable()

<span class="directive">final</span> doubler = {<span class="local-variable">it</span> * <span class="integer">2</span>}
<span class="directive">final</span> inc = {<span class="local-variable">it</span> + <span class="integer">1</span>}

<span class="comment">//Using whenBound()</span>
variable.whenBound {value -&gt;
    task {
        doubler(value)
    }.whenBound {doubledValue -&gt;
        task {
            inc(doubledValue)
        }.whenBound {incrementedValue -&gt;
            println incrementedValue
        }
    }
}

<span class="comment">//Using then() chaining</span>
variable.then doubler then inc then <span class="local-variable">this</span>.&amp;println

<span class="predefined-type">Thread</span>.start {variable &lt;&lt; <span class="integer">4</span>}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Chaining Promises solves both of these issues elegantly:</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>variable &gt;&gt; asyncFunction &gt;&gt; {println <span class="local-variable">it</span>}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>RightShift</em> <em class="red">'&gt;&gt;'</em> operator has been overloaded to call <em>then()</em> method and, therefore, can be chained the same way:</p>
</div>
<div class="listingblock">
<div class="title">A Chaining Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre><span class="directive">final</span> DataflowVariable variable = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> DataflowVariable result = <span class="keyword">new</span> DataflowVariable()

<span class="directive">final</span> doubler = {<span class="local-variable">it</span> * <span class="integer">2</span>}
<span class="directive">final</span> adder = {<span class="local-variable">it</span> + <span class="integer">1</span>}

variable &gt;&gt; doubler &gt;&gt; adder &gt;&gt; {result &lt;&lt; <span class="local-variable">it</span>}

<span class="predefined-type">Thread</span>.start {variable &lt;&lt; <span class="integer">4</span>}

<span class="keyword">assert</span> <span class="integer">9</span> == result.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="sect3">
<h4 id="_error_handling_for_promise_chaining">Error Handling for Promise Chaining</h4>
<div class="paragraph">
<p>Asynchronous operations may obviously throw exceptions. It&#8217;s important to be able to handle them easily and with little effort.
<strong>GPars</strong> <strong>romise</strong> objects can implicitly propagate exceptions from asynchronous calculations across <strong>promise</strong> chains.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Promises</strong> propagate result values as well as exceptions. The blocking <em>get()</em> method re-throws any exception that was bound to the <strong>Promise</strong> so the caller can handle it.</p>
</li>
<li>
<p>For <code>asynchronous notifications</code> - the <em>whenBound()</em> handler closure - gets the exception passed in as an argument.</p>
</li>
<li>
<p>The <em>then()</em> method accepts two arguments - a <strong>value handler</strong> and an optional <strong>error handler</strong>. These will  be invoked depending on whether the result is a regular value or an exception.
If no errorHandler is  specified, the exception is re-thrown to the <strong>Promise</strong> returned by <em>then()</em> .</p>
</li>
<li>
<p>Exactly the same behavior for <em>then()</em> methods holds true for the <em>whenAllBound()</em> method, which listens on multiple <strong>Promises</strong> to get bound.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">A Sample of Error Handling</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre>Promise&lt;<span class="predefined-type">Integer</span>&gt; initial = <span class="keyword">new</span> DataflowVariable&lt;<span class="predefined-type">Integer</span>&gt;()
Promise&lt;<span class="predefined-type">String</span>&gt; result = initial.then {<span class="local-variable">it</span> * <span class="integer">2</span>} then {<span class="integer">100</span> / <span class="local-variable">it</span>}  <span class="comment">// Will throw exception for 0</span>
.then {println <span class="string"><span class="delimiter">&quot;</span><span class="content">Log the value </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="content"> as it passes by</span><span class="delimiter">&quot;</span></span>; <span class="keyword">return</span> <span class="local-variable">it</span>}  <span class="comment">// No error handler is defined,</span>
                                                                <span class="comment">// so exceptions are ignored</span>
                                                                <span class="comment">// and silently re-thrown to the next handler in chain</span>
.then({<span class="string"><span class="delimiter">&quot;</span><span class="content">The result for </span><span class="inline"><span class="inline-delimiter">$</span>num</span><span class="content"> is </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>}, {<span class="string"><span class="delimiter">&quot;</span><span class="content">Error detected for </span><span class="inline"><span class="inline-delimiter">$</span>num</span><span class="content">: </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>}) <span class="comment">// Here the exception is caught</span>

initial &lt;&lt; <span class="integer">0</span>

println result.get()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>ErrorHandler</strong> is a closure that accepts instances of <em>Throwable</em> as its' only (optional) argument. It returns a value that should be bound to the result of the <em>then()</em> method call, i.e. the returned <strong>Promise</strong>.
If an exception is thrown from within an error handler, it&#8217;s bound to the resulting <strong>Promise</strong> as an error.</p>
</div>
<div class="listingblock">
<div class="title">Re-throwing Potential Exceptions</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>promise.then({<span class="local-variable">it</span>+<span class="integer">1</span>})                  <span class="comment">// Implicitly re-throws potential exceptions bound to promise</span>
promise.then({<span class="local-variable">it</span>+<span class="integer">1</span>}, {e -&gt; <span class="keyword">throw</span> e})  <span class="comment">// Explicitly re-throws potential exceptions bound to promise</span>

promise.then({<span class="local-variable">it</span>+<span class="integer">1</span>}, {e -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>(<span class="string"><span class="delimiter">'</span><span class="content">Error occurred</span><span class="delimiter">'</span></span>, e})
<span class="comment">// Explicitly re-throws a new exception wrapping a potential exception bound to a *Promise*</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_where_do_you_want_this_exception">Where Do You Want This Exception ?</h4>
<div class="paragraph">
<p>Exception handling in <strong>Java</strong> has try-catch statements. The behavior of <strong>GPars</strong> <strong>Promise</strong> objects gives an asynchronous invocation freedom to handle exceptions at anywhere it&#8217;s most convenient.
You can freely ignore exceptions in your code if you want to, then just assume things work. Even so, remember that exceptions are not accidentally swallowed.</p>
</div>
<div class="listingblock">
<div class="title">A Exceptional Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre>task {
    <span class="string"><span class="delimiter">'</span><span class="content">gpars.org</span><span class="delimiter">'</span></span>.toURL().text  <span class="comment">//should throw MalformedURLException</span>
}

.then {page -&gt; page.toUpperCase()}
.then {page -&gt; page.contains(<span class="string"><span class="delimiter">'</span><span class="content">GROOVY</span><span class="delimiter">'</span></span>)}
.then({mentionsGroovy -&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">Groovy found: </span><span class="inline"><span class="inline-delimiter">$</span>mentionsGroovy</span><span class="delimiter">&quot;</span></span>}, {error -&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">Error: </span><span class="inline"><span class="inline-delimiter">$</span>error</span><span class="delimiter">&quot;</span></span>}).join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="sect4">
<h5 id="_handling_concrete_exception_types">Handling Concrete Exception Types</h5>
<div class="paragraph">
<p>You may also be more specific about the handled exception types like this :</p>
</div>
<div class="listingblock">
<div class="title">A Specific Exception Handling Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>url.then(download)
    .then(calculateHash, {<span class="exception">MalformedURLException</span> e -&gt; <span class="keyword">return</span> <span class="integer">0</span>}) <span class="comment">// &lt;- specific !</span>
    .then(formatResult)
    .then(printResult, printError)
    .then(sendNotificationEmail);</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_customer_site_exception_handling">Customer-site Exception Handling</h5>
<div class="paragraph">
<p>You may wish to leave an exception completely un-handled, then let clients (consumers) handle it:</p>
</div>
<div class="listingblock">
<div class="title">A Delayed Exception Handling Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>Promise&lt;<span class="predefined-type">Object</span>&gt; result = url.then(download).then(calculateHash).then(formatResult).then(printResult);
<span class="keyword">try</span> {
    result.get()
} <span class="keyword">catch</span> (<span class="exception">Exception</span> e) {
    <span class="comment">//handle exceptions here</span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="_putting_it_all_together">Putting It All Together</h4>
<div class="paragraph">
<p>By combining <em>whenAllBound()</em> and <em>then</em> (or <strong class="red">'&gt;&gt;'</strong>) methods, we can easily manage large asynchronous scenarios in a convenient way:</p>
</div>
<div class="listingblock">
<div class="title">A Large Asynchronous Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td>
  <td class="code"><pre>withPool {

    Closure download = {<span class="predefined-type">String</span> url -&gt;
        sleep <span class="integer">3000</span>  <span class="comment">//Simulate a web read</span>
        <span class="string"><span class="delimiter">'</span><span class="content">web content</span><span class="delimiter">'</span></span>
    }.asyncFun()

    Closure loadFile = {<span class="predefined-type">String</span> fileName -&gt;
        <span class="string"><span class="delimiter">'</span><span class="content">file content</span><span class="delimiter">'</span></span>  <span class="comment">//simulate a local file read</span>
    }.asyncFun()

    Closure hash = {s -&gt; s.hashCode()}

    Closure compare = {<span class="type">int</span> first, <span class="type">int</span> second -&gt;
        first == second
    }

    Closure errorHandler = {println <span class="string"><span class="delimiter">&quot;</span><span class="content">Error detected: </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>}

    <span class="keyword">def</span> all = whenAllBound([
                  download(<span class="string"><span class="delimiter">'</span><span class="content">http://www.gpars.org</span><span class="delimiter">'</span></span>) &gt;&gt; hash,
                  loadFile(<span class="string"><span class="delimiter">'</span><span class="content">/coolStuff/gpars/website/index.html</span><span class="delimiter">'</span></span>) &gt;&gt; hash
              ], compare).then({println <span class="local-variable">it</span>}, errorHandler)
    all.join()  <span class="comment">//optionally block until the calculation is all done</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that only the initial action (function) needs to be asynchronous. The functions further down the pipeline will be invoked asynchronously by your <strong>Promise</strong>, even if they are synchronous.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_implementing_the_strong_fork_join_strong_pattern_with_strong_promises_strong">Implementing the <strong>Fork/join</strong> Pattern With <strong>Promises</strong></h4>
<div class="paragraph">
<p><strong>Promises</strong> are very flexible and can be used as an implementation vehicle for many different scenarios.
Here&#8217;s one handy additional capability of a <strong>Promise</strong>.</p>
</div>
<div class="paragraph">
<p>The _thenForkAndJoin() method triggers one or several activities once the current <strong>Promise</strong> becomes bound and returns a completed <strong>Promise</strong> object, bound only after all the activities finish.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see how this fits into the picture:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>then()</em> - permits activity chaining, so that one activity is performed after another</p>
</li>
<li>
<p><em>whenAllBound()</em> - allows joining multiple activities; a new activity is started only after they all finish</p>
</li>
<li>
<p><em>task()</em> - allows us to create (fork) multiple asynchronous activities</p>
</li>
<li>
<p><em>thenForkAndJoin()</em> - a short-hand syntax for forking several activities and joining on them</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So with <em>thenForkAndJoin()</em> you simply create multiple activities that should be triggered by a shared (triggering) <strong>Promise</strong>.</p>
</div>
<div class="listingblock">
<div class="title">A Sample of  Multiple Activities</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>promise.thenForkAndJoin(task1, task2, task3).then{...}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Once all the activities return a result, they&#8217;re collected into a list and bound into the <strong>Promise</strong> returned by <em>thenForkAndJoin()</em> .</p>
</div>
<div class="listingblock">
<div class="title">A thenForkAndJoin() Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>task {
    <span class="integer">2</span>
}.thenForkAndJoin({ <span class="local-variable">it</span> ** <span class="integer">2</span> }, { <span class="local-variable">it</span>**<span class="integer">3</span> }, { <span class="local-variable">it</span>**<span class="integer">4</span> }, { <span class="local-variable">it</span>**<span class="integer">5</span> }).then({ println <span class="local-variable">it</span>}).join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_lazy_strong_dataflow_strong_tasks_and_variables">Lazy <strong>Dataflow</strong> Tasks and Variables</h3>
<div class="paragraph">
<p>Sometimes you may need to combine the qualities of <code>Dataflow Variables</code> with a lazy initialization.</p>
</div>
<div class="listingblock">
<div class="title">A Lazy Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>Closure&lt;<span class="predefined-type">String</span>&gt; download = {url -&gt;
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Downloading</span><span class="delimiter">&quot;</span></span>
    url.toURL().text
}

<span class="keyword">def</span> pageContent = <span class="keyword">new</span> LazyDataflowVariable(download.curry(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://gpars.org</span><span class="delimiter">&quot;</span></span>))</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Instances of <em>LazyDataflowVariable</em> have an initializer declared at construction time. An instance is only triggered when someone asks for its value, either through the blocking <em>get()</em> method or using any of the non-blocking callback methods, such as <em>then()</em> .  Since <em>LazyDataflowVariables</em> preserve all the goodness of ordinary <em>DataflowVariables</em> , you can chain them together easily with other <em>lazy</em> or <em>ordinary</em> <code>Dataflow Variables</code>.</p>
</div>
<hr>
<div class="sect3">
<h4 id="_a_bigger_example">A Bigger Example</h4>
<div class="paragraph">
<p>This discussion deserves a more practical example. So, taking inspiration from <a href="http://blog.jcoglan.com/2013/03/30/callbacks-are-imperative-promises-are-functional-nodes-biggest-missed-opportunity/">this long post</a>,
the following piece of code demonstrates how to  use <em>LazyDataflowVariables</em> to lazily and asynchronously load mutually dependent components into memory.  The component modules will be loaded in the order of their dependencies and concurrently, if possible.</p>
</div>
<div class="paragraph">
<p>Each module will only be loaded once, irrespective of the number of modules that depend on it.  Thanks to <code>laziness</code>, only the modules that are transitively needed will be loaded.  Our example uses a simple "diamond" dependency scheme:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>D depends on B and C</p>
</li>
<li>
<p>C depends on A</p>
</li>
<li>
<p>B depends on A</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When loading D, A will get loaded first. B and C will be loaded concurrently once A has been loaded. D will start loading once both B and C have been loaded.</p>
</div>
<div class="listingblock">
<div class="title">A Diamond Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> moduleA = <span class="keyword">new</span> LazyDataflowVariable({-&gt;
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Loading moduleA into memory</span><span class="delimiter">&quot;</span></span>
    sleep <span class="integer">3000</span>
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Loaded moduleA into memory</span><span class="delimiter">&quot;</span></span>
    <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">moduleA</span><span class="delimiter">&quot;</span></span>
})

<span class="keyword">def</span> moduleB = <span class="keyword">new</span> LazyDataflowVariable({-&gt;
    moduleA.then {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">-&gt;Loading moduleB into memory, since moduleA is ready</span><span class="delimiter">&quot;</span></span>
        sleep <span class="integer">3000</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">  Loaded moduleB into memory</span><span class="delimiter">&quot;</span></span>
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">moduleB</span><span class="delimiter">&quot;</span></span>
    }
})

<span class="keyword">def</span> moduleC = <span class="keyword">new</span> LazyDataflowVariable({-&gt;
    moduleA.then {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">-&gt;Loading moduleC into memory, since moduleA is ready</span><span class="delimiter">&quot;</span></span>
        sleep <span class="integer">3000</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">  Loaded moduleC into memory</span><span class="delimiter">&quot;</span></span>
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">moduleC</span><span class="delimiter">&quot;</span></span>
    }
})

<span class="keyword">def</span> moduleD = <span class="keyword">new</span> LazyDataflowVariable({-&gt;
    whenAllBound(moduleB, moduleC) { b, c -&gt;
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">--&gt;Loading moduleD into memory, since moduleB and moduleC are ready</span><span class="delimiter">&quot;</span></span>
        sleep <span class="integer">3000</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">   Loaded moduleD into memory</span><span class="delimiter">&quot;</span></span>
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">moduleD</span><span class="delimiter">&quot;</span></span>
    }
})

println <span class="string"><span class="delimiter">&quot;</span><span class="content">Nothing loaded so far</span><span class="delimiter">&quot;</span></span>
println <span class="string"><span class="delimiter">&quot;</span><span class="content">===================================================================</span><span class="delimiter">&quot;</span></span>
println <span class="string"><span class="delimiter">&quot;</span><span class="content">Load module: </span><span class="delimiter">&quot;</span></span> + moduleD.get()
println <span class="string"><span class="delimiter">&quot;</span><span class="content">===================================================================</span><span class="delimiter">&quot;</span></span>
println <span class="string"><span class="delimiter">&quot;</span><span class="content">All requested modules loaded</span><span class="delimiter">&quot;</span></span></pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_making_tasks_lazy">Making Tasks Lazy</h4>
<div class="paragraph">
<p>The <em>lazyTask()</em> method is available alongside the <em>task()</em> method to give the us a task-oriented abstraction for delayed activities.
A <strong>Lazy Task</strong> returns an instance of a <em>LazyDataflowVariable</em> (like a <strong>Promise</strong> ) with the initializer set by the provided closure.
As soon as someone asks for the value, the task will start asynchronously and eventually deliver a value into the <em>LazyDataflowVariable</em> .</p>
</div>
<div class="listingblock">
<div class="title">A Lazy Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.Dataflow</span>

<span class="keyword">def</span> pageContent = Dataflow.lazyTask {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Downloading</span><span class="delimiter">&quot;</span></span>
        <span class="string"><span class="delimiter">&quot;</span><span class="content">http://gpars.org</span><span class="delimiter">&quot;</span></span>.toURL().text
    }

println <span class="string"><span class="delimiter">&quot;</span><span class="content">No-one has asked for the value just yet. Bound = </span><span class="inline"><span class="inline-delimiter">${</span>pageContent.bound<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
sleep <span class="integer">1000</span>
println <span class="string"><span class="delimiter">&quot;</span><span class="content">Now going to ask for a value</span><span class="delimiter">&quot;</span></span>
println pageContent.get().size()
println <span class="string"><span class="delimiter">&quot;</span><span class="content">Repetitive requests will receive the already calculated value. No additional downloading.</span><span class="delimiter">&quot;</span></span>
println pageContent.get().size()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_dataflow_expressions">Dataflow Expressions</h3>
<div class="paragraph">
<p>Look at the magic below:</p>
</div>
<div class="listingblock">
<div class="title">A Dataflow Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> initialDistance = <span class="keyword">new</span> DataflowVariable()
<span class="keyword">def</span> acceleration = <span class="keyword">new</span> DataflowVariable()
<span class="keyword">def</span> time = <span class="keyword">new</span> DataflowVariable()

task {
    initialDistance &lt;&lt; <span class="integer">100</span>
    acceleration &lt;&lt; <span class="integer">2</span>
    time &lt;&lt; <span class="integer">10</span>
}

<span class="keyword">def</span> result = initialDistance + acceleration*<span class="float">0.5</span>*time**<span class="integer">2</span>
println <span class="string"><span class="delimiter">'</span><span class="content">Total distance </span><span class="delimiter">'</span></span> + result.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>We use <strong>DataflowVariables</strong> that represent several parameters to a mathematical equation calculating total distance of an accelerating object.
In the equation itself, however, we use the <strong>DataflowVariable</strong> directly. We do not refer to the values they represent and yet we are able to do the math correctly. This shows that <strong>DataflowVariables</strong> can be very flexible.</p>
</div>
<div class="paragraph">
<p>For example, you can call methods on them and these methods are dispatched to the bound values:</p>
</div>
<div class="listingblock">
<div class="title">A <strong>DataflowVariable</strong> Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> name = <span class="keyword">new</span> DataflowVariable()
task {
    name &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">  adam   </span><span class="delimiter">'</span></span>
}
println name.toUpperCase().trim().val</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can pass other <strong>DataflowVariables</strong> as arguments to such methods and the real values will be passed automatically instead:</p>
</div>
<div class="listingblock">
<div class="title">Another <strong>DataflowVariable</strong> as An Argument Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> title = <span class="keyword">new</span> DataflowVariable()
<span class="keyword">def</span> searchPhrase = <span class="keyword">new</span> DataflowVariable()
task {
    title &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content"> Groovy in Action 2nd edition   </span><span class="delimiter">'</span></span>
}

task {
    searchPhrase &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">2nd</span><span class="delimiter">'</span></span>
}

println title.trim().contains(searchPhrase).val</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And you can also query properties of the bound value using directly the <strong>DataflowVariable</strong>:</p>
</div>
<div class="listingblock">
<div class="title">A <strong>DataflowVariable</strong> Sample To Query Book Title Properties</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> book = <span class="keyword">new</span> DataflowVariable()
<span class="keyword">def</span> searchPhrase = <span class="keyword">new</span> DataflowVariable()
task {
    book &lt;&lt; [
             <span class="key">title</span>:<span class="string"><span class="delimiter">'</span><span class="content">Groovy in Action 2nd edition   </span><span class="delimiter">'</span></span>,
             <span class="key">author</span>:<span class="string"><span class="delimiter">'</span><span class="content">Dierk Koenig</span><span class="delimiter">'</span></span>,
             <span class="key">publisher</span>:<span class="string"><span class="delimiter">'</span><span class="content">Manning</span><span class="delimiter">'</span></span>]
}

task {
    searchPhrase &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">2nd</span><span class="delimiter">'</span></span>
}

book.title.trim().contains(searchPhrase).whenBound {println <span class="local-variable">it</span>}  <span class="comment">//Asynchronous waiting</span>

println book.title.trim().contains(searchPhrase).val  <span class="comment">//Synchronous waiting</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Please note that the result is still a <strong>DataflowVariable</strong> (<code>DataflowExpression</code> to be precise), from which you can get the real value from both synchronously and asynchronously.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_bind_error_notification">Bind Error Notification</h3>
<div class="paragraph">
<p><em>DataflowVariables</em> offer the ability to send notifications to registered listeners whenever a bind operation fails.
The <em>getBindErrorManager()</em> method allows listeners to be added and removed.  The listeners are notified in case of a failed attempt to bind a value (through <code>bind()</code>, <code>bindSafely()</code>, <code>bindUnique()</code> or <code>leftShift()</code> ) or an error (through <strong>bindError()</strong>).</p>
</div>
<div class="listingblock">
<div class="title">Reporting  Bind Operation FailED</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td>
  <td class="code"><pre>        <span class="directive">final</span> DataflowVariable variable = <span class="keyword">new</span> DataflowVariable()

        variable.getBindErrorManager().addBindErrorListener(<span class="keyword">new</span> BindErrorListener() {
            <span class="annotation">@Override</span>
            <span class="type">void</span> onBindError(<span class="directive">final</span> <span class="predefined-type">Object</span> oldValue, <span class="directive">final</span> <span class="predefined-type">Object</span> failedValue, <span class="directive">final</span> <span class="type">boolean</span> uniqueBind) {
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">Bind failed!</span><span class="delimiter">&quot;</span></span>
            }

            <span class="annotation">@Override</span>
            <span class="type">void</span> onBindError(<span class="directive">final</span> <span class="predefined-type">Object</span> oldValue, <span class="directive">final</span> <span class="predefined-type">Throwable</span> failedError) {
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">Binding an error failed!</span><span class="delimiter">&quot;</span></span>
            }

            <span class="annotation">@Override</span>
            <span class="directive">public</span> <span class="type">void</span> onBindError(<span class="directive">final</span> <span class="predefined-type">Throwable</span> oldError, <span class="directive">final</span> <span class="predefined-type">Object</span> failedValue, <span class="directive">final</span> <span class="type">boolean</span> uniqueBind) {
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">Bind failed!</span><span class="delimiter">&quot;</span></span>
            }

            <span class="annotation">@Override</span>
            <span class="directive">public</span> <span class="type">void</span> onBindError(<span class="directive">final</span> <span class="predefined-type">Throwable</span> oldError, <span class="directive">final</span> <span class="predefined-type">Throwable</span> failedError) {
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">Binding an error failed!</span><span class="delimiter">&quot;</span></span>
            }

        })</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This lets us customize responses to any attempt to bind an already bound <strong>Dataflow Variable</strong>. For example, using <em>bindSafely()</em>, you do not receive bind exceptions back to the caller, but rather, a registered <em>BindErrorListener</em> is notified.</p>
</div>
</div>
<div class="sect2">
<h3 id="_further_reading">Further Reading</h3>
<div class="ulist">
<ul>
<li>
<p><a href="http://github.com/jboner/scala-dataflow/tree/f9a38992f5abed4df0b12f6a5293f703aa04dc33/src">Scala Dataflow library</a> by Jonas Bonér</p>
</li>
<li>
<p><a href="http://jonasboner.com/talks/state_youre_doing_it_wrong/html/all.html">JVM concurrency presentation slides</a> by Jonas Bonér</p>
</li>
<li>
<p><a href="http://github.com/larrytheliquid/dataflow/tree/master">Dataflow Concurrency library for Ruby</a></p>
</li>
</ul>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_tasks">Tasks</h3>
<div class="paragraph">
<p>The <strong>Dataflow Task</strong> give us an easy-to-grasp abstraction of mutually-independent logical tasks or threads. These can run concurrently and exchange data solely through <code>Dataflow Variables</code>, <code>Queues</code>, <code>Broadcasts</code> and <code>Streams</code>. A <strong>Dataflow Task</strong> with it&#8217;s easy-to-express mutual dependencies and inherently sequential body could also be used as a practical implementation of a UML <em>Activity Diagrams</em> .</p>
</div>
<div class="paragraph">
<p>Check out the examples.</p>
</div>
<hr>
<div class="sect3">
<h4 id="_a_simple_mashup_example">A Simple Mashup Example</h4>
<div class="paragraph">
<p>In this example, we&#8217;re downloading the front pages of three popular web sites, each in their own task, while in a separate task we&#8217;re filtering out sites talking about <strong>Groovy</strong> today and forming the output. The output task synchronizes automatically with the three download tasks on the three Dataflow variables through which the content of each website is passed to the output task.</p>
</div>
<div class="listingblock">
<div class="title">What Wonderful A Mashup !</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.withPool</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowVariable</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>


<span class="comment">/**
 * A simple mashup sample, downloads content of three websites
 * and checks how many of them refer to Groovy.
 */</span>

<span class="keyword">def</span> dzone = <span class="keyword">new</span> DataflowVariable()
<span class="keyword">def</span> jroller = <span class="keyword">new</span> DataflowVariable()
<span class="keyword">def</span> theserverside = <span class="keyword">new</span> DataflowVariable()

task {
    println <span class="string"><span class="delimiter">'</span><span class="content">Started downloading from DZone</span><span class="delimiter">'</span></span>
    dzone &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">http://www.dzone.com</span><span class="delimiter">'</span></span>.toURL().text
    println <span class="string"><span class="delimiter">'</span><span class="content">Done downloading from DZone</span><span class="delimiter">'</span></span>
}

task {
    println <span class="string"><span class="delimiter">'</span><span class="content">Started downloading from JRoller</span><span class="delimiter">'</span></span>
    jroller &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">http://www.jroller.com</span><span class="delimiter">'</span></span>.toURL().text
    println <span class="string"><span class="delimiter">'</span><span class="content">Done downloading from JRoller</span><span class="delimiter">'</span></span>
}

task {
    println <span class="string"><span class="delimiter">'</span><span class="content">Started downloading from TheServerSide</span><span class="delimiter">'</span></span>
    theserverside &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">http://www.theserverside.com</span><span class="delimiter">'</span></span>.toURL().text
    println <span class="string"><span class="delimiter">'</span><span class="content">Done downloading from TheServerSide</span><span class="delimiter">'</span></span>
}

task {
    withPool {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Number of Groovy sites today: </span><span class="delimiter">&quot;</span></span> +
                ([dzone, jroller, theserverside].findAllParallel {
                    <span class="local-variable">it</span>.val.toUpperCase().contains <span class="string"><span class="delimiter">'</span><span class="content">GROOVY</span><span class="delimiter">'</span></span>
                }).size()
    }
}.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_grouping_tasks">Grouping Tasks</h4>
<div class="paragraph">
<p>Dataflow tasks can be organized into groups for performance fine-tuning. Groups provide a handy <em>task()</em> factory method to create tasks attached to these groups.
Using groups allows us to organize tasks or operators around different thread pools (wrapped inside the group).  While the Dataflow.task() command schedules the task on a default thread pool <code>(java.util.concurrent.Executor, fixed size=#cpu+1, daemon threads)</code>,
we might prefer defining our own thread pool(s) to run these tasks.</p>
</div>
<div class="listingblock">
<div class="title">A Personal Thread Pool Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>

<span class="keyword">def</span> group = <span class="keyword">new</span> DefaultPGroup()

group.with {
    task {
        ...
    }

    task {
        ...
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Custom Thread Pools for <strong>Dataflow</strong></div>
<div class="paragraph">
<p>The default thread pool for dataflow tasks has daemon threads. This means our application will exit as soon as the main thread finishes and <strong>won&#8217;t</strong> wait for all tasks to complete!</p>
</div>
<div class="paragraph">
<p>When grouping tasks, make sure the custom thread pools either :</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>use daemon threads ( achieved by using <strong>DefaultPGroup</strong> )</p>
</li>
<li>
<p>provide a thread factory to a thread pool constructor</p>
</li>
<li>
<p>or in case the thread pools use non-daemon threads, ( from the <strong>NonDaemonPGroup</strong> group class ), we must shutdown the group or the thread pool explicitly by calling its <strong>shutdown()</strong> method, otherwise our application will not exit.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>We can selectively override the default group used for tasks, operators, callbacks and other dataflow elements inside a code block using the <em>Dataflow.usingGroup()</em> method:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre>Dataflow.usingGroup(group) {
    task {
        <span class="string"><span class="delimiter">'</span><span class="content">http://gpars.codehaus.org</span><span class="delimiter">'</span></span>.toURL().text  <span class="comment">//should throw MalformedURLException</span>
    }
    .then {page -&gt; page.toUpperCase()}
    .then {page -&gt; page.contains(<span class="string"><span class="delimiter">'</span><span class="content">GROOVY</span><span class="delimiter">'</span></span>)}
    .then({mentionsGroovy -&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">Groovy found: </span><span class="inline"><span class="inline-delimiter">$</span>mentionsGroovy</span><span class="delimiter">&quot;</span></span>}, {error -&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">Error: </span><span class="inline"><span class="inline-delimiter">$</span>error</span><span class="delimiter">&quot;</span></span>}).join()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can always override the default group by being specific:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre>Dataflow.usingGroup(group) {
    anotherGroup.task {
        <span class="string"><span class="delimiter">'</span><span class="content">http://gpars.codehaus.org</span><span class="delimiter">'</span></span>.toURL().text  <span class="comment">//should throw MalformedURLException</span>
    }
    .then(anotherGroup) {page -&gt; page.toUpperCase()}
    .then(anotherGroup) {page -&gt; page.contains(<span class="string"><span class="delimiter">'</span><span class="content">GROOVY</span><span class="delimiter">'</span></span>)}.then(anotherGroup) {println Dataflow.retrieveCurrentDFPGroup();<span class="local-variable">it</span>}
    .then(anotherGroup, {mentionsGroovy -&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">Groovy found: </span><span class="inline"><span class="inline-delimiter">$</span>mentionsGroovy</span><span class="delimiter">&quot;</span></span>}, {error -&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">Error: </span><span class="inline"><span class="inline-delimiter">$</span>error</span><span class="delimiter">&quot;</span></span>}).join()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_a_mashup_variant_with_methods">A Mashup Variant With Methods</h4>
<div class="paragraph">
<p>To avoid giving you wrong impression about structuring the Dataflow code, here&#8217;s a rewrite of the mashup example, with a <em>downloadPage()</em> method performing the actual download in a separate task.
It returns a <em>DataflowVariable</em> instance, so that the main application thread could eventually get hold of the downloaded content.</p>
</div>
<div class="paragraph">
<p>Dataflow variables can obviously be passed around as parameters or return values.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td>
  <td class="code"><pre><span class="keyword">package</span> groovyx.gpars.samples.dataflow

<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsExecutorsPool.withPool</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowVariable</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>


<span class="comment">/**
 * A simple mashup sample, downloads content of three websites and checks how many of them refer to Groovy.
 */</span>
<span class="directive">final</span> <span class="predefined-type">List</span> urls = [<span class="string"><span class="delimiter">'</span><span class="content">http://www.dzone.com</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">http://www.jroller.com</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">http://www.theserverside.com</span><span class="delimiter">'</span></span>]

task {
    <span class="keyword">def</span> pages = urls.collect { downloadPage(<span class="local-variable">it</span>) }
    withPool {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Number of Groovy sites today: </span><span class="delimiter">&quot;</span></span> +
                (pages.findAllParallel {
                    <span class="local-variable">it</span>.val.toUpperCase().contains <span class="string"><span class="delimiter">'</span><span class="content">GROOVY</span><span class="delimiter">'</span></span>
                }).size()
    }
}.join()

<span class="keyword">def</span> <span class="function">downloadPage</span>(<span class="keyword">def</span> url) {
    <span class="keyword">def</span> page = <span class="keyword">new</span> DataflowVariable()
    task {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Started downloading from </span><span class="inline"><span class="inline-delimiter">$</span>url</span><span class="delimiter">&quot;</span></span>
        page &lt;&lt; url.toURL().text
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Done downloading from </span><span class="inline"><span class="inline-delimiter">$</span>url</span><span class="delimiter">&quot;</span></span>
    }
    <span class="keyword">return</span> page
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_a_physical_calculation_example">A Physical Calculation Example</h4>
<div class="paragraph">
<p>Dataflow programs naturally scale with the number of processors. Up to a certain level, the more processors you have the faster the program runs.
Check out, for example, the following script, which calculates parameters of a simple physical experiment and prints out the results.</p>
</div>
<div class="paragraph">
<p>Each task performs its part of the calculation and may depend on values calculated by some other tasks and its' results might be needed by some of the other tasks.
With <code>Dataflow Concurrency</code> you can split the work between tasks or reorder the tasks themselves as you like and the dataflow mechanics will ensure the calculation is accomplished correctly.</p>
</div>
<div class="listingblock">
<div class="title">A DataflowVariable Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowVariable</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

<span class="directive">final</span> <span class="keyword">def</span> mass = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> radius = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> volume = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> density = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> acceleration = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> time = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> velocity = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> decelerationForce = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> deceleration = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> distance = <span class="keyword">new</span> DataflowVariable()

<span class="keyword">def</span> t = task {
    println <span class="string"><span class="delimiter">&quot;&quot;&quot;</span><span class="content">

Calculating distance required to stop a moving ball.
....................................................
The ball has a radius of </span><span class="inline"><span class="inline-delimiter">${</span>radius.val<span class="inline-delimiter">}</span></span><span class="content"> meters and is made of a material with </span><span class="inline"><span class="inline-delimiter">${</span>density.val<span class="inline-delimiter">}</span></span><span class="content"> kg/m3 density,
which means that the ball has a volume of </span><span class="inline"><span class="inline-delimiter">${</span>volume.val<span class="inline-delimiter">}</span></span><span class="content"> m3 and a mass of </span><span class="inline"><span class="inline-delimiter">${</span>mass.val<span class="inline-delimiter">}</span></span><span class="content"> kg.
The ball has been accelerating with </span><span class="inline"><span class="inline-delimiter">${</span>acceleration.val<span class="inline-delimiter">}</span></span><span class="content"> m/s2 from 0 for </span><span class="inline"><span class="inline-delimiter">${</span>time.val<span class="inline-delimiter">}</span></span><span class="content"> seconds and so reached a velocity of </span><span class="inline"><span class="inline-delimiter">${</span>velocity.val<span class="inline-delimiter">}</span></span><span class="content"> m/s.

Given our ability to push the ball backwards with a force of </span><span class="inline"><span class="inline-delimiter">${</span>decelerationForce.val<span class="inline-delimiter">}</span></span><span class="content"> N (Newton), we can cause a deceleration
of </span><span class="inline"><span class="inline-delimiter">${</span>deceleration.val<span class="inline-delimiter">}</span></span><span class="content"> m/s2 and so stop the ball at a distance of </span><span class="inline"><span class="inline-delimiter">${</span>distance.val<span class="inline-delimiter">}</span></span><span class="content"> m.
...................................................

This example has been calculated asynchronously in multiple tasks using *GPars* Dataflow concurrency in Groovy.
Author: </span><span class="inline"><span class="inline-delimiter">${</span>author.val<span class="inline-delimiter">}</span></span><span class="content">
</span><span class="delimiter">&quot;&quot;&quot;</span></span>

    <span class="predefined-type">System</span>.exit <span class="integer">0</span>
}

task {
    mass &lt;&lt; volume.val * density.val
}

task {
    volume &lt;&lt; <span class="predefined-type">Math</span>.PI * (radius.val ** <span class="integer">3</span>)
}

task {
    radius &lt;&lt; <span class="float">2.5</span>
    density &lt;&lt;         <span class="float">998.2071</span>  <span class="comment">//water</span>
    acceleration &lt;&lt; <span class="float">9.80665</span> <span class="comment">//free fall</span>
    decelerationForce &lt;&lt; <span class="integer">900</span>
}

task {
    println <span class="string"><span class="delimiter">'</span><span class="content">Enter your name:</span><span class="delimiter">'</span></span>
    <span class="keyword">def</span> name = <span class="keyword">new</span> <span class="predefined-type">InputStreamReader</span>(<span class="predefined-type">System</span>.in).readLine()
    author &lt;&lt; (name?.trim()?.size()&gt;<span class="integer">0</span> ? name : <span class="string"><span class="delimiter">'</span><span class="content">anonymous</span><span class="delimiter">'</span></span>)
}

task {
    time &lt;&lt; <span class="integer">10</span>
    velocity &lt;&lt; acceleration.val * time.val
}

task {
    deceleration &lt;&lt; decelerationForce.val / mass.val
}

task {
    distance &lt;&lt; deceleration.val * ((velocity.val/deceleration.val) ** <span class="integer">2</span>) * <span class="float">0.5</span>
}

t.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
I did my best to make all the physical calculations right. Feel free to change the values and see how long a distance you need to stop the rolling ball.
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_deterministic_deadlocks">Deterministic Deadlocks</h3>
<div class="paragraph">
<p>If you happen to introduce a deadlock in your dependencies, the deadlock will occur each time you run the code. No randomness is allowed.
That&#8217;s one of the benefits of <code>Dataflow Concurrency</code>.  Irrespective of the actual thread scheduling scheme, if you don&#8217;t get a deadlock in tests,
you won&#8217;t get them in production.</p>
</div>
<div class="listingblock">
<div class="title">A Deterministic Deadlock Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre>task {
    println a.val
    b &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Hi there</span><span class="delimiter">'</span></span>
}

task {
    println b.val
    a &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Hello man</span><span class="delimiter">'</span></span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="__strong_dataflows_strong_map"><strong>Dataflows</strong> Map</h3>
<div class="paragraph">
<p>As a handy shortcut the <em>Dataflows</em> class can help you reduce the amount of code you need to leverage <code>Dataflow Variables</code>.</p>
</div>
<div class="listingblock">
<div class="title">A Convenience Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> df = <span class="keyword">new</span> Dataflows()
df.x = <span class="string"><span class="delimiter">'</span><span class="content">value1</span><span class="delimiter">'</span></span>

<span class="keyword">assert</span> df.x == <span class="string"><span class="delimiter">'</span><span class="content">value1</span><span class="delimiter">'</span></span>

Dataflow.task {df.y = <span class="string"><span class="delimiter">'</span><span class="content">value2}</span></span><span class="error">
</span>
<span class="keyword">assert</span> df.y == <span class="string"><span class="delimiter">'</span><span class="content">value2</span><span class="delimiter">'</span></span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Think of <strong>Dataflows</strong> as a map with <code>Dataflow Variables</code> as keys storing their bound values as appropriate map values.
The semantics of reading a value (e.g. df.x) and binding a value (e.g. df.x = 'value') are identical to the semantics of plain <code>Dataflow Variables</code> (x.val and x &lt;&lt; 'value' respectively).</p>
</div>
<hr>
<div class="sect3">
<h4 id="_mixing_em_dataflows_em_and_strong_groovy_strong_em_with_em_blocks">Mixing <em>Dataflows</em> and <strong>Groovy</strong> <em>with</em> blocks</h4>
<div class="paragraph">
<p>When inside a <em>with</em> block of a <strong>Dataflows</strong> instance, the <code>Dataflow Variables</code> stored inside the <strong>Dataflows</strong> instance can be accessed directly without the need to prefix them with the <strong>Dataflows</strong> instance identifier.</p>
</div>
<div class="listingblock">
<div class="title">A <em>with</em> block Makes Coding Easier</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre><span class="keyword">new</span> Dataflows().with {
    x = <span class="string"><span class="delimiter">'</span><span class="content">value1</span><span class="delimiter">'</span></span>
    <span class="keyword">assert</span> x == <span class="string"><span class="delimiter">'</span><span class="content">value1</span><span class="delimiter">'</span></span>

    Dataflow.task {y = <span class="string"><span class="delimiter">'</span><span class="content">value2}</span></span><span class="error">
</span>
    <span class="keyword">assert</span> y == <span class="string"><span class="delimiter">'</span><span class="content">value2</span><span class="delimiter">'</span></span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_returning_values_from_a_task">Returning Values From A Task</h3>
<div class="paragraph">
<p>Typically, <strong>Dataflow</strong> tasks communicate through <code>Dataflow Variables</code>. On top of that, tasks can also return values, again through a <code>Dataflow Variable</code>.
When you invoke the <em>task()</em> factory method, you get back an instance of a  <strong>Promise</strong> (implemented as <code>DataflowVariable</code>), through which you can listen for the task&#8217;s return value,
just like when using any other <strong>Promise</strong> or <code>DataflowVariable</code>.</p>
</div>
<div class="listingblock">
<div class="title">A Task Returns A Value Using a <strong>Promise</strong></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre>    <span class="directive">final</span> Promise t1 = task {
        <span class="keyword">return</span> <span class="integer">10</span>
    }
    <span class="directive">final</span> Promise t2 = task {
        <span class="keyword">return</span> <span class="integer">20</span>
    }

    <span class="keyword">def</span> results = [t1, t2]*.val

    println <span class="string"><span class="delimiter">'</span><span class="content">Both sub-tasks finished and returned values: </span><span class="delimiter">'</span></span> + results</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The value can also be obtained without blocking the caller using the <em>whenBound()</em> method.
</td>
</tr>
</table>
</div>
<hr>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> task = task {
    println <span class="string"><span class="delimiter">'</span><span class="content">The task is running and calculating the return value</span><span class="delimiter">'</span></span>
    <span class="integer">30</span>        <span class="comment">// the value to be returned</span>
}
task &gt;&gt; {value -&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">The task finished and returned </span><span class="inline"><span class="inline-delimiter">$</span>value</span><span class="delimiter">&quot;</span></span>}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_joining_tasks">Joining Tasks</h3>
<div class="paragraph">
<p>Using the <em>join()</em> operation on the resulting <code>Dataflow Variable</code> of a task, you can block until the task finishes.</p>
</div>
<div class="listingblock">
<div class="title">A Bloacking Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre> task {
     <span class="directive">final</span> Promise t1 = task {
         println <span class="string"><span class="delimiter">'</span><span class="content">First sub-task running.</span><span class="delimiter">'</span></span>
     }
     <span class="directive">final</span> Promise t2 = task {
         println <span class="string"><span class="delimiter">'</span><span class="content">Second sub-task running</span><span class="delimiter">'</span></span>
     }
     [t1, t2]*.join()
     println <span class="string"><span class="delimiter">'</span><span class="content">Both sub-tasks finished</span><span class="delimiter">'</span></span>
 }.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_selects">Selects</h3>
<div class="paragraph">
<p>Frequently, a value needs to be obtained from one of several dataflow channels (such as variables, queues, broadcasts or streams). The <em>Select</em> class is suitable for these scenarios.</p>
</div>
<div class="paragraph">
<p><em>Select</em> can scan several dataflow channels and pick one channel from all the input channels, with a value that&#8217;s ready to be read. The value from that chosen channel is read and returned
to the caller together with the index of the originating channel.  Picking the channel is either random, or based on channel priority, in which case, channels with a lower position index in the <em>Select</em> constructor have higher priority.</p>
</div>
<div class="listingblock">
<div class="title">Selecting A Value From Multiple Channels</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowVariable</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.select</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

<span class="comment">/**
 * Shows a basic use of Select, which monitors a set of input channels for values and makes these values
 * available on its output irrespective of their original input channel.
 * Note that dataflow variables and queues can be combined for Select.
 *
 * You might also consider checking out the prioritySelect method, which prioritizes values by the index of their input channel
 */</span>
<span class="keyword">def</span> a = <span class="keyword">new</span> DataflowVariable()
<span class="keyword">def</span> b = <span class="keyword">new</span> DataflowVariable()
<span class="keyword">def</span> c = <span class="keyword">new</span> DataflowQueue()

task {
    sleep <span class="integer">3000</span>
    a &lt;&lt; <span class="integer">10</span>
}

task {
    sleep <span class="integer">1000</span>
    b &lt;&lt; <span class="integer">20</span>
}

task {
    sleep <span class="integer">5000</span>
    c &lt;&lt; <span class="integer">30</span>
}

<span class="keyword">def</span> select = select([a, b, c])

println <span class="string"><span class="delimiter">&quot;</span><span class="content">The fastest result is </span><span class="inline"><span class="inline-delimiter">${</span>select().value<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">A <em>select()</em> Method Returns What ?</div>
<div class="paragraph">
<p>Note that the return type from <em>select()</em> is <em>SelectResult</em> , holding the value as well as the original channel index.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>There are several ways to read values from a <strong>Select</strong>:</p>
</div>
<div class="listingblock">
<div class="title">How Do I <strong>Select</strong> Thee ? Let Me Count The Ways !</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> sel = select(a, b, c, d)
<span class="keyword">def</span> result = sel.select()                                       <span class="comment">//Random selection</span>
<span class="keyword">def</span> result = sel()                                              <span class="comment">//Random selection (a short-hand variant)</span>
<span class="keyword">def</span> result = sel.select([<span class="predefined-constant">true</span>, <span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>])              <span class="comment">//Random selection with guards specified</span>
<span class="keyword">def</span> result = sel([<span class="predefined-constant">true</span>, <span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>])                     <span class="comment">//Random selection with guards specified (a short-hand variant)</span>

<span class="keyword">def</span> result = sel.prioritySelect()                               <span class="comment">//Priority selection</span>
<span class="keyword">def</span> result = sel.prioritySelect([<span class="predefined-constant">true</span>, <span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>])      <span class="comment">//Priority selection with guards specifies</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, the <em>Select</em> method blocks processing of the caller until a value is available to be read. The alternative <em>selectToPromise()</em> and <em>prioritySelectToPromise()</em>
methods give us a way to obtain a <strong>Promise</strong> of a  value that can be selected later. Through the returned <strong>Promise</strong>, you can register a callback to invoke asynchronously whenever the next value is selected.</p>
</div>
<div class="listingblock">
<div class="title">Random And Priority Seletions</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> sel = select(a, b, c, d)

Promise result = sel.selectToPromise()                                       <span class="comment">//Random selection</span>
Promise result = sel.selectToPromise([<span class="predefined-constant">true</span>, <span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>])              <span class="comment">//Random selection with guards specified</span>

Promise result = sel.prioritySelectToPromise()                               <span class="comment">//Priority selection</span>
Promise result = sel.prioritySelectToPromise([<span class="predefined-constant">true</span>, <span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>])      <span class="comment">//Priority selection with guards specifies</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Another Way ?</div>
<p>Alternatively, the <em>Select</em> method can have it&#8217;s value sent to a declared <em>MessageStream</em> (e.g. an <strong>Actor</strong>) without blocking the caller.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> handler = actor {...}
<span class="keyword">def</span> sel = select(a, b, c, d)

sel.select(handler)                                         <span class="comment">//Random selection</span>
sel(handler)                                                <span class="comment">//Random selection (a short-hand variant)</span>
sel.select(handler, [<span class="predefined-constant">true</span>, <span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>])              <span class="comment">//Random selection with guards specified</span>
sel(handler, [<span class="predefined-constant">true</span>, <span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>])                     <span class="comment">//Random selection with guards specified (a short-hand variant)</span>

sel.prioritySelect(handler)                                 <span class="comment">//Priority selection</span>
sel.prioritySelect(handler, [<span class="predefined-constant">true</span>, <span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>])      <span class="comment">//Priority selection with guards specifies</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_guards">Guards</h3>
<div class="paragraph">
<p><strong>Guards</strong> let the caller omit some input channels from the selection. <strong>Guards</strong> are specified as a List of boolean flags passed to the <em>select()</em> or <em>prioritySelect()</em> methods.</p>
</div>
<div class="listingblock">
<div class="title">A Useful Filter Tool</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> sel = select(leaders, seniors, experts, juniors)
<span class="keyword">def</span> teamLead = sel([<span class="predefined-constant">true</span>, <span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>, <span class="predefined-constant">false</span>]).value        <span class="comment">//Only 'leaders' and 'seniors' qualify for becoming a teamLead here</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>A typical use for <strong>Guards</strong> is to make <strong>Selects</strong> flexible enough to adapt to changes in user state.</p>
</div>
<div class="listingblock">
<div class="title">Guards Enable/Disable Channels During Value Selection</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.select</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

<span class="comment">/**
 * Demonstrates the ability to enable/disable channels during a value selection on a Select by providing boolean guards.
 */</span>
<span class="directive">final</span> DataflowQueue operations = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowQueue numbers = <span class="keyword">new</span> DataflowQueue()

<span class="keyword">def</span> t = task {
    <span class="directive">final</span> <span class="keyword">def</span> select = select(operations, numbers)
    <span class="integer">3</span>.times {
        <span class="keyword">def</span> instruction = select([<span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>]).value
        <span class="keyword">def</span> num1 = select([<span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>]).value
        <span class="keyword">def</span> num2 = select([<span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>]).value
        <span class="directive">final</span> <span class="keyword">def</span> formula = <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>num1</span><span class="content"> </span><span class="inline"><span class="inline-delimiter">$</span>instruction</span><span class="content"> </span><span class="inline"><span class="inline-delimiter">$</span>num2</span><span class="delimiter">&quot;</span></span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>formula</span><span class="content"> = </span><span class="inline"><span class="inline-delimiter">${</span><span class="keyword">new</span> GroovyShell().evaluate(formula)<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
    }
}

task {
    operations &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">+</span><span class="delimiter">'</span></span>
    operations &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">+</span><span class="delimiter">'</span></span>
    operations &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">*</span><span class="delimiter">'</span></span>
}

task {
    numbers &lt;&lt; <span class="integer">10</span>
    numbers &lt;&lt; <span class="integer">20</span>
    numbers &lt;&lt; <span class="integer">30</span>
    numbers &lt;&lt; <span class="integer">40</span>
    numbers &lt;&lt; <span class="integer">50</span>
    numbers &lt;&lt; <span class="integer">60</span>
}

t.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_priority_select">Priority Select</h3>
<div class="paragraph">
<p>When certain channels should have precedence over others when selecting, the <strong>prioritySelect</strong> methods should be used instead.</p>
</div>
<div class="listingblock">
<div class="title">A <strong>prioritySelect</strong> Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td>
  <td class="code"><pre><span class="comment">/**
 * Here's a simply usecase for Priority Select. It monitors a set of input channels for values and makes these values
 * available on its output irrespective of their original input channel.
 *
 * Note that dataflow variables, queues and broadcasts can be combined for Select.
 *
 * Unlike plain select method call, the prioritySelect call gives precedence to input channels with lower index.
 * Available messages from high priority channels will be served before messages from lower-priority channels.
 * Messages received through a single input channel will have their mutual order preserved.
 *
 */</span>
<span class="keyword">def</span> critical = <span class="keyword">new</span> DataflowVariable()
<span class="keyword">def</span> ordinary = <span class="keyword">new</span> DataflowQueue()
<span class="keyword">def</span> whoCares = <span class="keyword">new</span> DataflowQueue()

task {
    ordinary &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">All working fine</span><span class="delimiter">'</span></span>
    whoCares &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">I feel a bit tired</span><span class="delimiter">'</span></span>
    ordinary &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">We are on target</span><span class="delimiter">'</span></span>
}

task {
    ordinary &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">I have just started my work. Busy. Will come back later...</span><span class="delimiter">'</span></span>
    sleep <span class="integer">5000</span>
    ordinary &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">I am done for now</span><span class="delimiter">'</span></span>
}

task {
    whoCares &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Huh, what is that noise</span><span class="delimiter">'</span></span>
    ordinary &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Here I am to do some clean-up work</span><span class="delimiter">'</span></span>
    whoCares &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">I wonder whether unplugging this cable will eliminate that nasty sound.</span><span class="delimiter">'</span></span>
    critical &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">The server room runs on UPS!</span><span class="delimiter">'</span></span>
    whoCares &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">The sound has disappeared</span><span class="delimiter">'</span></span>
}

<span class="keyword">def</span> select = select([critical, ordinary, whoCares])

println <span class="string"><span class="delimiter">'</span><span class="content">Starting to monitor our IT department</span><span class="delimiter">'</span></span>

sleep <span class="integer">3000</span>
<span class="integer">10</span>.times {println <span class="string"><span class="delimiter">&quot;</span><span class="content">Received: </span><span class="inline"><span class="inline-delimiter">${</span>select.prioritySelect().value<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_collecting_results_of_asynchronous_computations">Collecting Results of Asynchronous Computations</h3>
<div class="paragraph">
<p>No matter whether they are <strong>dataflow tasks</strong> , <strong>active objects' methods</strong> or <strong>asynchronous functions</strong>, asynchronous activities always return a <strong>Promise</strong>.
<strong>Promises</strong> implement the <em>SelectableChannel</em> interface and so can be passed in <em>selects</em> for selection together with other <strong>Promises</strong> as well as <em>read channels</em> .</p>
</div>
<div class="paragraph">
<p>Similarly to <strong>Java</strong>'s <em>CompletionService</em> , our <strong>GPars</strong> <em>Select</em> method enables you to obtain results of asynchronous activities as soon as each becomes available.
Also, we can use a <em>Select</em> to give us the first/fastest result from the first of several computations running in parallel.</p>
</div>
<div class="listingblock">
<div class="title">How To Pick The Fastest Result</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.Promise</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.Select</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>
<span class="comment">/**
 * Demonstrates the use of dataflow tasks and selects to pick the fastest result of concurrently run calculations.
 */</span>

<span class="directive">final</span> group = <span class="keyword">new</span> DefaultPGroup()
group.with {
    Promise p1 = task {
        sleep(<span class="integer">1000</span>)
        <span class="integer">10</span> * <span class="integer">10</span> + <span class="integer">1</span>
    }
    Promise p2 = task {
        sleep(<span class="integer">1000</span>)
        <span class="integer">5</span> * <span class="integer">20</span> + <span class="integer">2</span>
    }
    Promise p3 = task {
        sleep(<span class="integer">1000</span>)
        <span class="integer">1</span> * <span class="integer">100</span> + <span class="integer">3</span>
    }

    <span class="directive">final</span> alt = <span class="keyword">new</span> Select(group, p1, p2, p3)

    <span class="keyword">def</span> result = alt.select()
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="delimiter">&quot;</span></span> + result
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_timeouts_2">Timeouts</h3>
<div class="paragraph">
<p>The <em>Select.createTimeout()</em> method will create a <strong>DataflowVariable</strong> bound to a value after a declared time period.
This can be leveraged in <em>Selects</em> so that they unblock(resume processing) after a desired delay, if none of the other channels delivers a value before that time.
Simply pass a <strong>timeout channel</strong> as another input channel to the <em>Select</em> .</p>
</div>
<div class="listingblock">
<div class="title">A <strong>Timeout Channel</strong> Helps Pick The Fastest Answer</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.Promise</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.Select</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>
<span class="comment">/**
 * Demonstrates the use of dataflow tasks and selects to pick the fastest result of concurrently run calculations.
 */</span>

<span class="directive">final</span> group = <span class="keyword">new</span> DefaultPGroup()
group.with {
    Promise p1 = task {
        sleep(<span class="integer">1000</span>)
        <span class="integer">10</span> * <span class="integer">10</span> + <span class="integer">1</span>
    }
    Promise p2 = task {
        sleep(<span class="integer">1000</span>)
        <span class="integer">5</span> * <span class="integer">20</span> + <span class="integer">2</span>
    }
    Promise p3 = task {
        sleep(<span class="integer">1000</span>)
        <span class="integer">1</span> * <span class="integer">100</span> + <span class="integer">3</span>
    }

    <span class="directive">final</span> timeoutChannel = Select.createTimeout(<span class="integer">500</span>)

    <span class="directive">final</span> alt = <span class="keyword">new</span> Select(group, p1, p2, p3, timeoutChannel)

    <span class="keyword">def</span> result = alt.select()
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="delimiter">&quot;</span></span> + result
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_cancellations">Cancellations</h3>
<div class="paragraph">
<p>Ok, so we have our answer. What bout the other tasks that continue to work on their answer? If we need to cancel those other tasks once an answer was found or maybe a timeout expired,
then the best way is to set a flag that our tasks periodically monitor.</p>
</div>
<hr>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Intentionally, There&#8217;s no cancellation machinery built into <em>DataflowVariables</em> or <em>Tasks</em>
</td>
</tr>
</table>
</div>
<hr>
<div class="listingblock">
<div class="title">A Sample To Pick The Fastest Answer And Cancel The Others</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.Promise</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.Select</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>

<span class="keyword">import</span> <span class="include">java.util.concurrent.atomic.AtomicBoolean</span>

<span class="comment">/**
 * Demonstrates the use of dataflow tasks and selects to pick the fastest result of concurrently run calculations.
 * It shows a waY to cancel the slower tasks once a result is known
 */</span>

<span class="directive">final</span> group = <span class="keyword">new</span> DefaultPGroup()
<span class="directive">final</span> done = <span class="keyword">new</span> <span class="predefined-type">AtomicBoolean</span>()

group.with {
    Promise p1 = task {
        sleep(<span class="integer">1000</span>)
        <span class="keyword">if</span> (done.get()) <span class="keyword">return</span>
        <span class="integer">10</span> * <span class="integer">10</span> + <span class="integer">1</span>
    }
    Promise p2 = task {
        sleep(<span class="integer">1000</span>)
        <span class="keyword">if</span> (done.get()) <span class="keyword">return</span>
        <span class="integer">5</span> * <span class="integer">20</span> + <span class="integer">2</span>
    }
    Promise p3 = task {
        sleep(<span class="integer">1000</span>)
        <span class="keyword">if</span> (done.get()) <span class="keyword">return</span>
        <span class="integer">1</span> * <span class="integer">100</span> + <span class="integer">3</span>
    }

    <span class="directive">final</span> alt = <span class="keyword">new</span> Select(group, p1, p2, p3, Select.createTimeout(<span class="integer">500</span>))

    <span class="keyword">def</span> result = alt.select()
    done.set(<span class="predefined-constant">true</span>)

    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="delimiter">&quot;</span></span> + result
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_operators">Operators</h3>
<div class="paragraph">
<p><code>Dataflow Operators</code> and <code>Selectors</code> provide a full <strong>Dataflow</strong> implementation with all the usual ceremony.</p>
</div>
</div>
<div class="sect2">
<h3 id="_concepts_3">Concepts</h3>
<div class="paragraph">
<p>Full <code>Dataflow Concurrency</code> builds on the concept of channels connecting operators and selectors. These objects consume values coming through input channels,
transform them into new values and output the new values into their output channels.</p>
</div>
<div class="paragraph">
<p><em>Operators</em> wait for <strong>every</strong> input channel to have a value before starting to process them but <em>Selectors</em> only wait for the first available value on <strong>any</strong> of its' input channels.</p>
</div>
<div class="listingblock">
<div class="title">An Operator Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>operator(<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d]) {x, y, z -&gt;
    ...
    bindOutput <span class="integer">0</span>, x + y + z
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">A Sample Cache</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td>
  <td class="code"><pre><span class="comment">/**
 * CACHE
 *
 * Caches sites' contents. Accepts requests for url content, outputs the content. Outputs requests for download
 * if the site is not in cache yet.
 */</span>
operator(<span class="key">inputs</span>: [urlRequests], <span class="key">outputs</span>: [downloadRequests, sites]) {request -&gt;

    <span class="keyword">if</span> (!request.content) {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">[Cache] Retrieving </span><span class="inline"><span class="inline-delimiter">${</span>request.site<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>

        <span class="keyword">def</span> content = cache[request.site]

        <span class="keyword">if</span> (content) {
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">[Cache] Found in cache</span><span class="delimiter">&quot;</span></span>
            bindOutput <span class="integer">1</span>, [<span class="key">site</span>: request.site, <span class="key">word</span>:request.word, <span class="key">content</span>: content]
        } <span class="keyword">else</span> {
            <span class="keyword">def</span> downloads = pendingDownloads[request.site]
            <span class="keyword">if</span> (downloads != <span class="predefined-constant">null</span>) {
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">[Cache] Awaiting download</span><span class="delimiter">&quot;</span></span>
                downloads &lt;&lt; request
            } <span class="keyword">else</span> {
                pendingDownloads[request.site] = <span class="type">[]</span>
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">[Cache] Asking for download</span><span class="delimiter">&quot;</span></span>
                bindOutput <span class="integer">0</span>, request
            }
        }

    } <span class="keyword">else</span> {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">[Cache] Caching </span><span class="inline"><span class="inline-delimiter">${</span>request.site<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>

        cache[request.site] = request.content
        bindOutput <span class="integer">1</span>, request

        <span class="keyword">def</span> downloads = pendingDownloads[request.site]

        <span class="keyword">if</span> (downloads != <span class="predefined-constant">null</span>) {
            <span class="keyword">for</span> (downloadRequest <span class="keyword">in</span> downloads) {
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">[Cache] Waking up</span><span class="delimiter">&quot;</span></span>
                bindOutput <span class="integer">1</span>, [<span class="key">site</span>: downloadRequest.site, <span class="key">word</span>:downloadRequest.word, <span class="key">content</span>: request.content]
            }
            pendingDownloads.remove(request.site)
        }
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Exception Handling Explained</div>
<div class="paragraph">
<p>Standard error handling prints an error message to the standard error output and terminates the operator in case an uncaught exception is thrown from withing the operator&#8217;s body.
To alter the behavior, you can register your own event listener. See the <em>Operator Lifecycle</em> section for more details.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">Exception Handling Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> listener = <span class="keyword">new</span> DataflowEventAdapter() {

    <span class="annotation">@Override</span>
    <span class="type">boolean</span> onException(<span class="directive">final</span> DataflowProcessor processor, <span class="directive">final</span> <span class="predefined-type">Throwable</span> e) {
        logChannel &lt;&lt; e
        <span class="keyword">return</span> <span class="predefined-constant">false</span>   <span class="comment">//Indicate whether to terminate the operator or not</span>
    }
}

op = group.operator(<span class="key">inputs</span>: [a, b], <span class="key">outputs</span>: [c], <span class="key">listeners</span>: [listener]) {x, y -&gt;
    ...
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="sect3">
<h4 id="_types_of_operators">Types of Operators</h4>
<div class="paragraph">
<p>There are specialized versions of operator methods for specific purposes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>operator - the basic general-purpose operator</p>
</li>
<li>
<p>selector - operator triggered by a value being available on any input channel</p>
</li>
<li>
<p>prioritySelector - a selector that prefers delivering messages from lower-indexed input channels over higher-indexed ones</p>
</li>
<li>
<p>splitter - a single-input operator copying its input values to all of its output channels</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_wiring_operators_together">Wiring Operators Together</h5>
<div class="paragraph">
<p>Operators are typically combined into networks, like when some operators consume output produced by other operators.</p>
</div>
<div class="listingblock">
<div class="title">Using Several Operators</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>operator(<span class="key">inputs</span>:[a, b], <span class="key">outputs</span>:[c, d]) {...}
splitter(c, [e, f])
selector(<span class="key">inputs</span>:[e, d]: <span class="key">outputs</span>:<span class="type">[]</span>) {...}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>You may alternatively refer to output channels through operators themselves:</p>
</div>
<div class="listingblock">
<div class="title">A More Complex Operator Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> op1 = operator(<span class="key">inputs</span>:[a, b], <span class="key">outputs</span>:[c, d]) {...}
<span class="keyword">def</span> sp1 = splitter(op1.outputs[<span class="integer">0</span>], [e, f])                            <span class="comment">//takes the first output of op1</span>

selector(<span class="key">inputs</span>:[sp1.outputs[<span class="integer">0</span>], op1.outputs[<span class="integer">1</span>]]: <span class="key">outputs</span>:<span class="type">[]</span>) {...}   <span class="comment">//takes the first output of sp1 and the second output of op1</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="_grouping_operators">Grouping Operators</h4>
<div class="paragraph">
<p><strong>Dataflow</strong> operators can be organized into groups for performance fine-tuning. Groups provide a handy <em>operator()</em> factory method to create tasks attached to the groups.</p>
</div>
<div class="listingblock">
<div class="title">For Performance Fine-tuning ? Use <strong>Groups</strong></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>

<span class="keyword">def</span> group = <span class="keyword">new</span> DefaultPGroup()

group.with {
    operator(<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d]) {x, y, z -&gt;
        ...
        bindOutput <span class="integer">0</span>, x + y + z
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Custom Thread Pools For <strong>Dataflow</strong></div>
<div class="paragraph">
<p>The default thread pool for dataflow operators contains daemon threads, which means your application will exit as soon as the main thread finishes and won&#8217;t wait for all tasks to complete.</p>
</div>
<div class="paragraph">
<p>When grouping operators, make sure your custom thread pools use either daemon threads, too, which can be achieved by using DefaultPGroup or by providing your own thread factory to a thread pool constructor, or in case your thread
pools use non-daemon threads, such as when using the NonDaemonPGroup group class, make sure you shutdown the group or the thread pool explicitly by calling its shutdown() method, otherwise your applications will not exit.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>You may selectively override the default group used for tasks, operators, callbacks and other dataflow
elements inside a code block using the <em>Dataflow.usingGroup()</em> method:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>Dataflow.usingGroup(group) {
    operator(<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d]) {x, y, z -&gt;
        ...
        bindOutput <span class="integer">0</span>, x + y + z
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can always override the default group by being specific:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>Dataflow.usingGroup(group) {
    anotherGroup.operator(<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d]) {x, y, z -&gt;
        ...
        bindOutput <span class="integer">0</span>, x + y + z
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_constructing_operators">Constructing Operators</h3>
<div class="paragraph">
<p>The construction properties of an operator, such as <em>inputs</em>, <em>outputs</em>, <em>stateObject</em> or <em>maxForks</em> cannot
be modified once the operator has been build.  You may find the <em>groovyx.gpars.dataflow.ProcessingNode</em>
class helpful when gradually collecting channels and values into lists before you finally build an operator.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.Dataflow</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.ProcessingNode.node</span>

<span class="comment">/**
 * Shows how to build operators using the ProcessingNode class
 */</span>

<span class="directive">final</span> DataflowQueue aValues = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowQueue bValues = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowQueue results = <span class="keyword">new</span> DataflowQueue()

<span class="comment">//Create a config and gradually set the required properties - channels, code, etc.</span>
<span class="keyword">def</span> adderConfig = node {valueA, valueB -&gt;
    bindOutput valueA + valueB
}
adderConfig.inputs &lt;&lt; aValues
adderConfig.inputs &lt;&lt; bValues
adderConfig.outputs &lt;&lt; results

<span class="comment">//Build the operator</span>
<span class="directive">final</span> adder = adderConfig.operator(Dataflow.DATA_FLOW_GROUP)

<span class="comment">//Now the operator is running and processing the data</span>
aValues &lt;&lt; <span class="integer">10</span>
aValues &lt;&lt; <span class="integer">20</span>
bValues &lt;&lt; <span class="integer">1</span>
bValues &lt;&lt; <span class="integer">2</span>

<span class="keyword">assert</span> [<span class="integer">11</span>, <span class="integer">22</span>] == (<span class="integer">1</span>..<span class="integer">2</span>).collect {
    results.val
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_holding_state_in_operators">Holding State in Operators</h3>
<div class="paragraph">
<p>Although operators can frequently do without keeping state between subsequent invocations, <strong>GPars</strong> allows
operators to maintain state, if desired by the developer. One obvious way is to leverage the <strong>Groovy</strong> closure
capabilities to close-over their context:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="type">int</span> counter = <span class="integer">0</span>
operator(<span class="key">inputs</span>: [a], <span class="key">outputs</span>: [b]) {value -&gt;
    counter += <span class="integer">1</span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Another way, which allows you to avoid declaring the state object outside of the operator definition, is to pass the state object
into the operator as a <em>stateObject</em> parameter at construction time:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>operator(<span class="key">inputs</span>: [a], <span class="key">outputs</span>: [b], <span class="key">stateObject</span>: [<span class="key">counter</span>: <span class="integer">0</span>]) {value -&gt;
    stateObject.counter += <span class="integer">1</span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_parallelize_operators">Parallelize Operators</h3>
<div class="paragraph">
<p>By default an operator&#8217;s body is processed by a single thread at a time. While this is a safe setting
allowing the operator&#8217;s body to be written in a non-thread-safe manner, once an operator becomes "hot" and
data start to accumulate in the operator&#8217;s input queues, you might consider allowing multiple threads to run
the operator&#8217;s body concurrently. Bear in mind that in such a case you need to avoid or protect shared
resources from multi-threaded access.  To enable multiple threads to run the operator&#8217;s body concurrently,
pass an extra <em>maxForks</em> parameter when creating an operator:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> op = operator(<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d, e], <span class="key">maxForks</span>: <span class="integer">2</span>) {x, y, z -&gt;
    bindOutput <span class="integer">0</span>, x + y + z
    bindOutput <span class="integer">1</span>, x * y * z
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of the <em>maxForks</em> parameter indicates the maximum of threads running the operator
concurrently. Only positive numbers are allowed with value 1 being the default.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Thread Starvation</div>
<div class="paragraph">
<p>Please always make sure the <strong>group</strong> serving the operator holds enough threads to support all requested
forks.  Using groups allows you to organize tasks or operators around different thread pools (wrapped inside
the group).  While the Dataflow.task() command schedules the task on a default thread pool
(java.util.concurrent.Executor, fixed size=#cpu+1, daemon threads), you may prefer being able to define your
own thread pool(s) to run your tasks.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> group = <span class="keyword">new</span> DefaultPGroup(<span class="integer">10</span>)
group.operator((<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d, e], <span class="key">maxForks</span>: <span class="integer">5</span>) {x, y, z -&gt; ...}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The default group uses a resizeable thread pool as so will never run out of threads.</p>
</div>
<hr>
<div class="sect3">
<h4 id="_synchronizing_outputs">Synchronizing Outputs</h4>
<div class="paragraph">
<p>When enabling internal parallelization of an operator by setting the value for <em>maxForks</em> to a value greater
than 1 it is important to remember that without explicit or implicit synchronization in the operators' body
race-conditions may occur.  Especially bear in mind that values written to multiple output channels are not
guarantied to be written atomically in the same order to all the channels</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre>operator(<span class="key">inputs</span>:[inputChannel], <span class="key">outputs</span>:[a, b], <span class="key">maxForks</span>:<span class="integer">5</span>) {msg -&gt;
    bindOutput <span class="integer">0</span>, msg
    bindOutput <span class="integer">1</span>, msg
}
inputChannel &lt;&lt; <span class="integer">1</span>
inputChannel &lt;&lt; <span class="integer">2</span>
inputChannel &lt;&lt; <span class="integer">3</span>
inputChannel &lt;&lt; <span class="integer">4</span>
inputChannel &lt;&lt; <span class="integer">5</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>May result in output channels having the values mixed-up something like:</pre>
</div>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre>a -&gt; <span class="integer">1</span>, <span class="integer">3</span>, <span class="integer">2</span>, <span class="integer">4</span>, <span class="integer">5</span>
b -&gt; <span class="integer">2</span>, <span class="integer">1</span>, <span class="integer">3</span>, <span class="integer">5</span>, <span class="integer">4</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Explicit synchronization is one way to get correctly bound all output channels and protect operator not-thread local state:</pre>
</div>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> lock = <span class="keyword">new</span> <span class="predefined-type">Object</span>()
operator(<span class="key">inputs</span>:[inputChannel], <span class="key">outputs</span>:[a, b], <span class="key">maxForks</span>:<span class="integer">5</span>) {msg -&gt;
    doStuffThatIsThreadSafe()

    <span class="directive">synchronized</span>(lock) {
        doSomethingThatMustNotBeAccessedByMultipleThreadsAtTheSameTime()
        bindOutput <span class="integer">0</span>, msg
        bindOutput <span class="integer">1</span>, <span class="integer">2</span>*msg
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Obviously you need to weight the pros and cons here, since synchronization may defeat the purpose of setting
<em>maxForks</em> to a value greater than 1.</p>
</div>
<div class="paragraph">
<p>To set values of all the operator&#8217;s output channels in one atomic step, you may also consider calling either
the <em>bindAllOutputsAtomically</em> method, passing in a single value to write to all output channels or the
<em>bindAllOutputsAtomically</em> method, which takes a multiple values, each of which will be written to the
output channel with the same position index.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>operator(<span class="key">inputs</span>:[inputChannel], <span class="key">outputs</span>:[a, b], <span class="key">maxForks</span>:<span class="integer">5</span>) {msg -&gt;
    doStuffThatIsThreadSafe()
        bindAllOutputValuesAtomically msg, <span class="integer">2</span>*msg
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Which Bind Do I Use ?</div>
<div class="literalblock">
<div class="content">
<pre>Using the _bindAllOutputs_ or the _bindAllOutputValues_ methods will not guarantee atomicity of writes across al the output channels when using internal parallelism.</pre>
</div>
</div>
<div class="paragraph">
<p>If preserving the order of messages in multiple output channels is not an issue, <em>bindAllOutputs</em> as well as <em>bindAllOutputValues</em> will provide better performance over the atomic variants.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_operator_lifecycle">Operator Lifecycle</h4>
<div class="paragraph">
<p>Dataflow operators and selectors fire several events during their lifecycle, which allows the interested parties to obtain notifications and potential alter operator&#8217;s behavior.
The <em>DataflowEventListener</em> interface offers a couple of callback methods:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">interface</span> DataflowEventListener {
    <span class="comment">/**
     * Invoked immediately after the operator starts by a pooled thread before the first message is obtained
     *
     * @param processor The reporting dataflow operator/selector
     */</span>
    <span class="type">void</span> afterStart(DataflowProcessor processor);

    <span class="comment">/**
     * Invoked immediately after the operator terminates
     *
     * @param processor The reporting dataflow operator/selector
     */</span>
    <span class="type">void</span> afterStop(DataflowProcessor processor);

    <span class="comment">/**
     * Invoked if an exception occurs.
     * If any of the listeners returns true, the operator will terminate.
     * Exceptions outside of the operator's body or listeners' messageSentOut() handlers will terminate the operator irrespective of the listeners' votes.
     *
     * @param processor The reporting dataflow operator/selector
     * @param e         The thrown exception
     * @return True, if the operator should terminate in response to the exception, false otherwise.
     */</span>
    <span class="type">boolean</span> onException(DataflowProcessor processor, <span class="predefined-type">Throwable</span> e);

    <span class="comment">/**
     * Invoked when a message becomes available in an input channel.
     *
     * @param processor The reporting dataflow operator/selector
     * @param channel   The input channel holding the message
     * @param index     The index of the input channel within the operator
     * @param message   The incoming message
     * @return The original message or a message that should be used instead
     */</span>
    <span class="predefined-type">Object</span> messageArrived(DataflowProcessor processor, DataflowReadChannel&lt;<span class="predefined-type">Object</span>&gt; channel, <span class="type">int</span> index, <span class="predefined-type">Object</span> message);

    <span class="comment">/**
     * Invoked when a control message (instances of ControlMessage) becomes available in an input channel.
     *
     * @param processor The reporting dataflow operator/selector
     * @param channel   The input channel holding the message
     * @param index     The index of the input channel within the operator
     * @param message   The incoming message
     * @return The original message or a message that should be used instead
     */</span>
    <span class="predefined-type">Object</span> controlMessageArrived(DataflowProcessor processor, DataflowReadChannel&lt;<span class="predefined-type">Object</span>&gt; channel, <span class="type">int</span> index, <span class="predefined-type">Object</span> message);

    <span class="comment">/**
     * Invoked when a message is being bound to an output channel.
     *
     * @param processor The reporting dataflow operator/selector
     * @param channel   The output channel to send the message to
     * @param index     The index of the output channel within the operator
     * @param message   The message to send
     * @return The original message or a message that should be used instead
     */</span>
    <span class="predefined-type">Object</span> messageSentOut(DataflowProcessor processor, DataflowWriteChannel&lt;<span class="predefined-type">Object</span>&gt; channel, <span class="type">int</span> index, <span class="predefined-type">Object</span> message);

    <span class="comment">/**
     * Invoked when all messages required to trigger the operator become available in the input channels.
     *
     * @param processor The reporting dataflow operator/selector
     * @param messages  The incoming messages
     * @return The original list of messages or a modified/new list of messages that should be used instead
     */</span>
    <span class="predefined-type">List</span>&lt;<span class="predefined-type">Object</span>&gt; beforeRun(DataflowProcessor processor, <span class="predefined-type">List</span>&lt;<span class="predefined-type">Object</span>&gt; messages);

    <span class="comment">/**
     * Invoked when the operator completes a single run
     *
     * @param processor The reporting dataflow operator/selector
     * @param messages  The incoming messages that have been processed
     */</span>
    <span class="type">void</span> afterRun(DataflowProcessor processor, <span class="predefined-type">List</span>&lt;<span class="predefined-type">Object</span>&gt; messages);

    <span class="comment">/**
     * Invoked when the fireCustomEvent() method is triggered manually on a dataflow operator/selector
     *
     * @param processor The reporting dataflow operator/selector
     * @param data      The custom piece of data provided as part of the event
     * @return A value to return from the fireCustomEvent() method to the caller (event initiator)
     */</span>
    <span class="predefined-type">Object</span> customEvent(DataflowProcessor processor, <span class="predefined-type">Object</span> data);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>A default implementation is provided through the <em>DataflowEventAdapter</em> class.</p>
</div>
<div class="paragraph">
<p>Listeners provide a way to handle exceptions, when they occur inside operators. A listener may typically log such exceptions,
notify a supervising entity, generate an alternative output or perform any steps required to recover from the situation.
If there&#8217;s no listener registered or if any of the listeners returns <em>true</em> the operator will terminate, preserving the contract of <em>afterStop()</em> .
Exceptions that occur outside the actual operator&#8217;s body, i.e. at the parameter preparation phase before the body is triggered
or at the clean-up and channel subscription phase, after the body finishes, always lead to operator termination.</p>
</div>
<div class="paragraph">
<p>The <em>fireCustomEvent()</em> method available on operators and selectors may be used to communicate back and forth between operator&#8217;s body
and the interested listeners:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td>
  <td class="code"><pre><span class="directive">final</span> listener = <span class="keyword">new</span> DataflowEventAdapter() {
    <span class="annotation">@Override</span>
    <span class="predefined-type">Object</span> customEvent(DataflowProcessor processor, <span class="predefined-type">Object</span> data) {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Log: Getting quite high on the scale </span><span class="inline"><span class="inline-delimiter">$</span>data</span><span class="delimiter">&quot;</span></span>
        <span class="keyword">return</span> <span class="integer">100</span>  <span class="comment">//The value to use instead</span>
    }
}

op = group.operator(<span class="key">inputs</span>: [a, b], <span class="key">outputs</span>: [c], <span class="key">listeners</span>: [listener]) {x, y -&gt;
    <span class="directive">final</span> sum = x + y
    <span class="keyword">if</span> (sum &gt; <span class="integer">100</span>) bindOutput(fireCustomEvent(sum))  <span class="comment">//Reporting that the sum is too high, binding the lowered value that comes back</span>
    <span class="keyword">else</span> bindOutput sum
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_selectors">Selectors</h3>
<div class="paragraph">
<p>Selector&#8217;s body should be a closure consuming either one or two arguments.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>selector (inputs : [a, b, c], outputs : [d, e]) {value -&gt;
    ....
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The two-argument closure will get a value plus an index of the input channel, the value of which is
currently being processed.  This allows the selector to distinguish between values coming through different
input channels.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>selector (inputs : [a, b, c], outputs : [d, e]) {value, index -&gt;
    ....
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="sect3">
<h4 id="_priority_selector">Priority Selector</h4>
<div class="paragraph">
<p>When priorities need to be preserved among input channels, a <em>DataflowPrioritySelector</em> should be used.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>prioritySelector(inputs : [a, b, c], outputs : [d, e]) {value, index -&gt;
    ...
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The priority selector will always prefer values from channels with lower position index over values coming
through the channels with higher position index.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_join_selector">Join Selector</h4>
<div class="paragraph">
<p>A selector without a body closure specified will copy all incoming values to all of its output channels.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> join = selector (inputs : [programmers, analysis, managers], outputs : [employees, colleagues])</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_internal_parallelism">Internal Parallelism</h4>
<div class="paragraph">
<p>The <em>maxForks</em> attribute allowing for internal selectors parallelism is also available.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>selector (inputs : [a, b, c], outputs : [d, e], maxForks : <span class="integer">5</span>) {value -&gt;
    ....
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_guards_2">Guards</h4>
<div class="paragraph">
<p>Just like <em>Selects</em> , <em>Selectors</em> also allow the users to temporarily include/exclude individual input
channels from selection.  The <em>guards</em> input property can be used to set the initial mask on all input
channels and the <em>setGuards</em> and <em>setGuard</em> methods are then available in the selector&#8217;s body.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.selector</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

<span class="comment">/**
 * Demonstrates the ability to enable/disable channels during a value selection on a select by providing boolean guards.
 */</span>
<span class="directive">final</span> DataflowQueue operations = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowQueue numbers = <span class="keyword">new</span> DataflowQueue()

<span class="keyword">def</span> instruction
<span class="keyword">def</span> nums = <span class="type">[]</span>

selector(<span class="key">inputs</span>: [operations, numbers], <span class="key">outputs</span>: <span class="type">[]</span>, <span class="key">guards</span>: [<span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>]) {value, index -&gt;   <span class="comment">//initial guards is set here</span>
    <span class="keyword">if</span> (index == <span class="integer">0</span>) {
        instruction = value
        setGuard(<span class="integer">0</span>, <span class="predefined-constant">false</span>)  <span class="comment">//setGuard() used here</span>
        setGuard(<span class="integer">1</span>, <span class="predefined-constant">true</span>)
    }
    <span class="keyword">else</span> nums &lt;&lt; value
    <span class="keyword">if</span> (nums.size() == <span class="integer">2</span>) {
        setGuards([<span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>])                                    <span class="comment">//setGuards() used here</span>
        <span class="directive">final</span> <span class="keyword">def</span> formula = <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>nums[<span class="integer">0</span>]<span class="inline-delimiter">}</span></span><span class="content"> </span><span class="inline"><span class="inline-delimiter">$</span>instruction</span><span class="content"> </span><span class="inline"><span class="inline-delimiter">${</span>nums[<span class="integer">1</span>]<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>formula</span><span class="content"> = </span><span class="inline"><span class="inline-delimiter">${</span><span class="keyword">new</span> GroovyShell().evaluate(formula)<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
        nums.clear()
    }
}

task {
    operations &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">+</span><span class="delimiter">'</span></span>
    operations &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">+</span><span class="delimiter">'</span></span>
    operations &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">*</span><span class="delimiter">'</span></span>
}

task {
    numbers &lt;&lt; <span class="integer">10</span>
    numbers &lt;&lt; <span class="integer">20</span>
    numbers &lt;&lt; <span class="integer">30</span>
    numbers &lt;&lt; <span class="integer">40</span>
    numbers &lt;&lt; <span class="integer">50</span>
    numbers &lt;&lt; <span class="integer">60</span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Warning</div>
<div class="paragraph">
<p>Avoid combining <em>guards</em> and <em>maxForks</em> greater than 1. Although the <em>Selector</em> is thread-safe and won&#8217;t be damaged in any way, the guards are likely not to be set the way you expect. The multiple threads running the selector&#8217;s body concurrently will tend to over-write each-other&#8217;s settings to the <em>guards</em> property.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_shutting_down_dataflow_networks">Shutting Down Dataflow Networks</h3>
<div class="paragraph">
<p>Shutting down a network of dataflow processors (operators and selectors) may sometimes be a non-trivial
task, especially if you need a generic mechanism that will not leave any messages unprocessed.</p>
</div>
<div class="paragraph">
<p>Dataflow operators and selectors can be terminated in three ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>by calling the terminate() method on all operators that need to be terminated</p>
</li>
<li>
<p>by sending a poisson message</p>
</li>
<li>
<p>by setting up a network of activity monitors that will shutdown the network after all messages have been processed</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Check out the details on the ways that <strong>GPars</strong> provides.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Shutting down the thread pool</div>
<div class="paragraph">
<p>If you use a custom <em>PGroup</em> to maintain a thread pool for your dataflow network, you should not forget to
shutdown the pool once the network is terminated.  Otherwise the thread pool will consume system resources
and, in case of using non-daemon threads, it will prevent JVM from exit.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_emergency_shutdown">Emergency Shutdown</h3>
<div class="paragraph">
<p>You can call <em>terminate()</em> on any operator/selector to immediately shut it down. Provided you keep track of
all your processors, perhaps by adding them to a list, the fastest way to stop the network would be:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>allMyProcessors*.terminate()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This should, however, be treated as an emergency exit, since no guarantees can be given regarding messages
processed nor finished work.  Operators will simply terminate instantly leaving work unfinished and
abandoning messages in the input channels.  Certainly, the lifecycle event listeners hooked to the
operators/selectors will have their <em>afterStop()</em> event handlers invoked in order to, for example, release
resources or output a note into the log.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> op1 = operator(<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d, e]) {x, y, z -&gt; }

<span class="keyword">def</span> op2 = selector(<span class="key">inputs</span>: [d], <span class="key">outputs</span>: [f, out]) { }

<span class="keyword">def</span> op3 = prioritySelector(<span class="key">inputs</span>: [e, f], <span class="key">outputs</span>: [b]) {value, index -&gt; }

[op1, op2, op3]*.terminate()  <span class="comment">//Terminate all operators by calling the terminate() method on them</span>
op1.join()
op2.join()
op3.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Shutting down the whole JVM through <em>System.exit()</em> will obviously shutdown the dataflow network, however, no lifecycle listeners will be invoked.
</td>
</tr>
</table>
</div>
<hr>
<div class="sect3">
<h4 id="_stopping_operators_gently">Stopping Operators Gently</h4>
<div class="paragraph">
<p>Operators handle incoming messages repeatedly. The only safe moment for stopping an operator without the
risk of loosing any messages is right after the operator has finished processing messages and is just about
to look for more messages in its incoming pipes.  This is exactly what the <em>terminateAfterNextRun()</em> method
does. It will schedule the operator for shutdown after the next set of messages gets handled.</p>
</div>
<div class="paragraph">
<p>The unprocessed messages will stay in the input channels, which allows you to handle them later, perhaps
with a different operator/selector or in some other way. Using <em>terminateAfterNextRun()</em> you will not loose
any input messages.  This may be particularly handy when you use a group of operators/selectors to
load-balance messages coming from a channel.  Once the work-load decreases, the terminateAfterNextRun()
method may be used to safely reduce the pool of load-balancing operators.</p>
</div>
<div class="sect4">
<h5 id="_detecting_shutdown">Detecting shutdown</h5>
<div class="paragraph">
<p>Operators and electors offer a handy <em>join()</em> method for those who need to block until the operator terminates.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>allMyProcessors*.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the easies way to wait until the whole dataflow network shuts down, irrespective of the shutdown method used.</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_poisonpill">PoisonPill</h3>
<div class="paragraph">
<p><em>PoisonPill</em> is a common term for a strategy that uses special-purpose messages to stop entities that
receive it.  <strong>GPars</strong> offers the <em>PoisonPill</em> class, which has exactly such effect or operators and
selectors. Since <em>PoisonPill</em> is a <em>ControlMessage</em>, it is invisible to operator&#8217;s body and custom code does
not need to handle it in any way.  <em>DataflowEventListeners</em> may react to <em>ControlMessages</em> through the
<em>controlMessageArrived()</em> handler method.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> op1 = operator(<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d, e]) {x, y, z -&gt; }

<span class="keyword">def</span> op2 = selector(<span class="key">inputs</span>: [d], <span class="key">outputs</span>: [f, out]) { }

<span class="keyword">def</span> op3 = prioritySelector(<span class="key">inputs</span>: [e, f], <span class="key">outputs</span>: [b]) {value, index -&gt; }

a &lt;&lt; PoisonPill.instance  <span class="comment">//Send the poisson</span>

op1.join()
op2.join()
op3.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>After receiving a poison pill, an operator terminates, right after it finishes the current calculation and makes sure the poison is sent to all its output channels.
This is so that the poison can spread to the connected operators. Also, although operators typically wait for all inputs to have a value, in case of <em>PoisonPills</em>, the operator will terminate immediately as soon as a <em>PoisonPill</em> appears on any of its inputs.
The values already obtained from the other channels will be lost. It can be considered an error in the design of the network, if these messages were supposed to be processed.  They would need a proper value as their peer and not a PoisonPill in order to be processes normally.</p>
</div>
<div class="paragraph">
<p>Selectors, on the other hand, will patiently wait for <em>PoisonPill</em> to be received from all their input channels before sending it on the the output channels.
This behavior prevents networks containing <strong>feed-back loops involving selectors</strong> from being shutdown using <em>PoisonPill</em> .
A selector would never receive a <em>PoisonPill</em> from the channel that comes back from behind the selector. A different shutdown strategy should be used for such networks.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Operators and Selectors Should Only Terminate Themselves</div>
<div class="paragraph">
<p>Given the potential variety of operator networks and their asynchronous nature, a good termination strategy is that operators and selectors should only ever terminate themselves.</p>
</div>
<div class="paragraph">
<p>All ways of terminating them from outside (either by calling the <em>terminate()</em> method or by sending poison down the stream) may result in messages being lost somewhere in the pipes.
This happens when the reading operators terminate before they fully handle the messages waiting in their input channels.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_immediate_poison_pill">Immediate Poison Pill</h3>
<div class="paragraph">
<p>Especially for selectors to shutdown immediately after receiving a poison pill, a notion of <strong>immediate poison pill</strong> has been introduced.
Since normal, non-immediate poison pills merely close the input channel leaving the selector alive until at least one input channel remains open, the immediate poison pill closes the selector instantly.
Obviously, unprocessed messages from the other selector&#8217;s input channels will not be handled by the selector, once it reads an immediate poison pill.</p>
</div>
<div class="paragraph">
<p>With immediate poison pill you can safely shutdown networks with selectors involved in feedback loops.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> op1 = selector(<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d, e]) {value, index -&gt; }
<span class="keyword">def</span> op2 = selector(<span class="key">inputs</span>: [d], <span class="key">outputs</span>: [f, out]) { }
<span class="keyword">def</span> op3 = prioritySelector(<span class="key">inputs</span>: [e, f], <span class="key">outputs</span>: [b]) {value, index -&gt; }

a &lt;&lt; PoisonPill.immediateInstance

[op1, op2, op3]*.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_poison_with_counting">Poison With Counting</h3>
<div class="paragraph">
<p>When sending a poison pill down the operator network you may need to be notified when all the operators or a specified number of them have been stopped.
The <em>CountingPoisonPill</em> class serves exactly this purpose:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre>operator(<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d, e]) {x, y, z -&gt; }
selector(<span class="key">inputs</span>: [d], <span class="key">outputs</span>: [f, out]) { }
prioritySelector(<span class="key">inputs</span>: [e, f], <span class="key">outputs</span>: [b]) {value, index -&gt; }

<span class="comment">//Send the poisson indicating the number of operators than need to be terminated before we can continue</span>
<span class="directive">final</span> pill = <span class="keyword">new</span> CountingPoisonPill(<span class="integer">3</span>)
a &lt;&lt; pill

<span class="comment">//Wait for all operators to terminate</span>
pill.join()
<span class="comment">//At least 3 operators should be terminated by now</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>termination</em> property of the <em>CountingPoisonPill</em> class is a regular <em>Promise&lt;Boolean&gt;</em> and so has a lot of handy properties.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre><span class="comment">//Send the poisson indicating the number of operators than need to be terminated before we can continue</span>
<span class="directive">final</span> pill = <span class="keyword">new</span> CountingPoisonPill(<span class="integer">3</span>)
pill.termination.whenBound {println <span class="string"><span class="delimiter">&quot;</span><span class="content">Reporting asynchronously that the network has been stopped</span><span class="delimiter">&quot;</span></span>}
a &lt;&lt; pill

<span class="keyword">if</span> (pill.termination.bound) println <span class="string"><span class="delimiter">&quot;</span><span class="content">Wow, that was quick. We are done already!</span><span class="delimiter">&quot;</span></span>
<span class="keyword">else</span> println <span class="string"><span class="delimiter">&quot;</span><span class="content">Things are being slow today. The network is still running.</span><span class="delimiter">&quot;</span></span>

<span class="comment">//Wait for all operators to terminate</span>
<span class="keyword">assert</span> pill.termination.get()
<span class="comment">//At least 3 operators should be terminated by now</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>An immediate variant of <em>CountingPoisonPill</em> is also available - <em>ImmediateCountingPoisonPill</em> .</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> op1 = selector(<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d, e]) {value, index -&gt; }
<span class="keyword">def</span> op2 = selector(<span class="key">inputs</span>: [d], <span class="key">outputs</span>: [f, out]) { }
<span class="keyword">def</span> op3 = prioritySelector(<span class="key">inputs</span>: [e, f], <span class="key">outputs</span>: [b]) {value, index -&gt; }

<span class="directive">final</span> pill = <span class="keyword">new</span> ImmediateCountingPoisonPill(<span class="integer">3</span>)
a &lt;&lt; pill
pill.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>ImmediateCountingPoisonPill</em> will safely and instantly shutdown dataflow networks even with selectors
involved in feedback loops, which normal non-immediate poison pill would not be able to.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_poison_strategies">Poison Strategies</h3>
<div class="paragraph">
<p>To correctly shutdown a network using <em>PoisonPill</em> you must identify the appropriate set of channels to send
<em>PoisonPill</em> to.  <em>PoisonPill</em> will spread in the network the usual way through the channels and processors
down the stream. Typically the right channels to send <em>PoisonPill</em> to will be those that serve as <strong>data
sources</strong> for the network.  This may be difficult to achieve for general cases or for complex networks. On
the other hand, for networks with a prevalent direction of message flow <em>PoisonPill</em> provides a very
straightforward way to shutdown the whole network gracefully.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Load-balancing Prevents Poison Shutdown</div>
<div class="paragraph">
<p>Load-balancing architectures, which use multiple operators reading messages off a shared channel (queue),
will also prevent poison shutdown to work properly, since only one of the reading operators will get to read
the poison message.  You may consider using <strong>forked operators</strong> instead, by setting the <em>maxForks</em> property
to a value greater than 1.  Another alternative is to manually split the message stream into multiple
channels, each of which would be consumed by one of the original operators.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_termination_tips_and_tricks">Termination Tips and Tricks</h3>
<div class="paragraph">
<p>Notice that <strong>GPars</strong> <em>tasks</em> return a <em>DataflowVariable</em>, which is bound to a value as soon as the task finishes.
The 'terminator' operator below leverages the fact that <em>DataflowVariables</em> are implementations of the <em>DataflowReadChannel</em> interface and thus can be consumed by operators.
As soon as both tasks finish, the operator will send a <em>PoisonPill</em> down the <em>q</em> channel to stop the consumer as soon as it processes all data.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.NonDaemonPGroup</span>


<span class="keyword">def</span> group = <span class="keyword">new</span> NonDaemonPGroup()

<span class="directive">final</span> DataflowQueue q = <span class="keyword">new</span> DataflowQueue()

<span class="comment">// final destination</span>
<span class="keyword">def</span> customs = group.operator(<span class="key">inputs</span>: [q], <span class="key">outputs</span>: <span class="type">[]</span>) { value -&gt;
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Customs received </span><span class="inline"><span class="inline-delimiter">$</span>value</span><span class="delimiter">&quot;</span></span>
}

<span class="comment">// big producer</span>
<span class="keyword">def</span> green = group.task {
    (<span class="integer">1</span>..<span class="integer">100</span>).each {
        q &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">green channel </span><span class="delimiter">'</span></span> + <span class="local-variable">it</span>
        sleep <span class="integer">10</span>
    }
}

<span class="comment">// little producer</span>
<span class="keyword">def</span> red = group.task {
    (<span class="integer">1</span>..<span class="integer">10</span>).each {
        q &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">red channel </span><span class="delimiter">'</span></span> + <span class="local-variable">it</span>
        sleep <span class="integer">15</span>
    }
}

<span class="keyword">def</span> terminator = group.operator(<span class="key">inputs</span>: [green, red], <span class="key">outputs</span>: <span class="type">[]</span>) { t1, t2 -&gt;
    q &lt;&lt; PoisonPill.instance
}

customs.join()
group.shutdown()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_keeping_poisonpill_inside_a_given_network">Keeping PoisonPill Inside a Given Network</h3>
<div class="paragraph">
<p>If your network passed values through channels to entities outside of it, you may need to stop the
<em>PoisonPill</em> messages on the network boundaries. This can be easily achieved by putting a single-input
single-output filtering operator on each such channel.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>operator(networkLeavingChannel, otherNetworkEnteringChannel) {value -&gt;
    <span class="keyword">if</span> (!(value instanceOf PoisonPill)) bindOutput <span class="local-variable">it</span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>Pipeline</em> DSL may be also helpful here:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>networkLeavingChannel.filter { !(<span class="local-variable">it</span> instanceOf PoisonPill) } into otherNetworkEnteringChannel</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Check out the <em>Pipeline DSL</em> section to find out more on pipelines.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_graceful_shutdown">Graceful Shutdown</h3>
<div class="paragraph">
<p><strong>GPars</strong> provides a generic way to shutdown a dataflow network. Unlike the previously mentioned mechanisms this
approach will keep the network running until all the messages get handled and than gracefully shuts all
operators down letting you know when this happens.  You have to pay a modest performance penalty,
though. This is unavoidable since we need to keep track of what&#8217;s happening inside the network.</p>
</div>
<div class="listingblock">
<div class="title">A Graceful Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowBroadcast</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.operator.component.GracefulShutdownListener</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.operator.component.GracefulShutdownMonitor</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.PGroup</span>

PGroup group = <span class="keyword">new</span> DefaultPGroup(<span class="integer">10</span>)
<span class="directive">final</span> a = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> b = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> c = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> d = <span class="keyword">new</span> DataflowQueue&lt;<span class="predefined-type">Object</span>&gt;()
<span class="directive">final</span> e = <span class="keyword">new</span> DataflowBroadcast&lt;<span class="predefined-type">Object</span>&gt;()
<span class="directive">final</span> f = <span class="keyword">new</span> DataflowQueue&lt;<span class="predefined-type">Object</span>&gt;()
<span class="directive">final</span> result = <span class="keyword">new</span> DataflowQueue&lt;<span class="predefined-type">Object</span>&gt;()

<span class="directive">final</span> monitor = <span class="keyword">new</span> GracefulShutdownMonitor(<span class="integer">100</span>);

<span class="keyword">def</span> op1 = group.operator(<span class="key">inputs</span>: [a, b], <span class="key">outputs</span>: [c], <span class="key">listeners</span>: [<span class="keyword">new</span> GracefulShutdownListener(monitor)]) {x, y -&gt;
    sleep <span class="integer">5</span>
    bindOutput x + y
}
<span class="keyword">def</span> op2 = group.operator(<span class="key">inputs</span>: [c], <span class="key">outputs</span>: [d, e], <span class="key">listeners</span>: [<span class="keyword">new</span> GracefulShutdownListener(monitor)]) {x -&gt;
    sleep <span class="integer">10</span>
    bindAllOutputs <span class="integer">2</span>*x
}
<span class="keyword">def</span> op3 = group.operator(<span class="key">inputs</span>: [d], <span class="key">outputs</span>: [f], <span class="key">listeners</span>: [<span class="keyword">new</span> GracefulShutdownListener(monitor)]) {x -&gt;
    sleep <span class="integer">5</span>
    bindOutput x + <span class="integer">40</span>
}
<span class="keyword">def</span> op4 = group.operator(<span class="key">inputs</span>: [e.createReadChannel(), f], <span class="key">outputs</span>: [result], <span class="key">listeners</span>: [<span class="keyword">new</span> GracefulShutdownListener(monitor)]) {x, y -&gt;
    sleep <span class="integer">5</span>
    bindOutput x + y
}

<span class="integer">100</span>.times{a &lt;&lt; <span class="integer">10</span>}
<span class="integer">100</span>.times{b &lt;&lt; <span class="integer">20</span>}

<span class="directive">final</span> shutdownPromise = monitor.shutdownNetwork()

<span class="integer">100</span>.times{<span class="keyword">assert</span> <span class="integer">160</span> == result.val}

shutdownPromise.get()
[op1, op2, op3, op4]*.join()

group.shutdown()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>First, we need an instance of <em>GracefulShutdownMonitor</em> , which will orchestrate the shutdown process.
It relies on instances of <em>GracefulShutdownListener</em> attached to all operators/selectors.
These listeners observe their respective processors together with their input channels and report to the shared <em>GracefulShutdownMonitor</em>.
Once <em>shutdownNetwork()</em> is called on <em>GracefulShutdownMonitor</em> , it will periodically check for reported activities, query the state of operators as well as the number of messages in their input channels.</p>
</div>
<div class="paragraph">
<p>Please make sure that no new messages enter the dataflow network after the shutdown has been initiated, since this may cause the network to never terminate.
The shutdown process should only be started after all data producers have ceased sending additional messages to the monitored network.</p>
</div>
<div class="paragraph">
<p>The <em>shutdownNetwork()</em> method returns a <strong>Promise</strong> so that you can do the usual set of tricks with it - block waiting for the network to terminate using the <em>get()</em> method, register a callback using the <em>whenBound()</em> method or make it trigger a whole set of activities through the <em>then()</em> method.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Limitations of Graceful Sshutdown</div>
<div class="ulist">
<ul>
<li>
<p>For <em>GracefulShutdownListener</em> to work correctly, its <em>messageArrived()</em> event handler must see the
original value that has arrived through the input channel. Since some event listeners may alter the
messages as they pass through the listeners it is advisable to add the <em>GracefulShutdownListener</em> first to
the list of listeners on each dataflow processor.</p>
</li>
<li>
<p>Also, graceful shutdown will not work for those rare operators that have listeners, which turn control
messages into plain value messages in the <em>controlMessageArrived()</em> event handler.</p>
</li>
<li>
<p>Third and last, load-balancing architectures, which use multiple operators reading messages off a shared
channel (queue), will also prevent graceful shutdown to work properly. You may consider using <strong>forked
operators</strong> instead, by setting the <em>maxForks</em> property to a value greater than 1. Another alternative is
to manually split the message stream into multiple channels, each of which would be consumed by one of the
original operators.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_application_frameworks">Application Frameworks</h3>
<div class="paragraph">
<p><code>Dataflow Operators</code> and `Selectors1 can be successfully used to build high-level domain-specific frameworks for problems that naturally fit the flow model.</p>
</div>
<div class="sect3">
<h4 id="_building_flow_frameworks_on_top_of_strong_gpars_dataflow_strong">Building Flow Frameworks on Top of <strong>GPars Dataflow</strong></h4>
<div class="paragraph">
<p><strong>GPars</strong> dataflow can be viewed as bottom-line language-level infrastructure.</p>
</div>
<div class="paragraph">
<p>Operators, selectors, channels and event listeners can be very useful at language level to combine, for example, with <strong>actors</strong> or parallel collections.
Whenever a need comes for asynchronous handling of events that come through one of more channels, a dataflow operator or a small dataflow network could be a very good fit.
Unlike tasks, operators are lightweight and release threads when there&#8217;s no message to process.
Unlike <strong>actors</strong>, operators are addressed indirectly through channels and may easily combine messages from multiple channels into one action.</p>
</div>
<div class="paragraph">
<p>Alternatively, operators can be looked at as continuous functions, which instantly and repeatedly transform
their input values into output.  We believe that a concurrency-friendly general-purpose programming language
should provide this type of abstraction.</p>
</div>
<div class="paragraph">
<p>At the same time, dataflow elements can be easily used as building blocks for constructing domain-specific workflow-like frameworks.
These frameworks can offer higher-level abstractions specialized to a single problem domain, which would be inappropriate for a general-purpose language-level library.
Each of the higher-level concepts is then mapped to (potentially several) <strong>GPars</strong> concepts.</p>
</div>
<div class="paragraph">
<p>For example, a network solving data-mining problems may consist of several data sources, data cleaning nodes, categorization nodes, reporting nodes and others.
Image processing networks, on the other hand, may need nodes specialized in image compression and format transformation.
Similarly, networks for data encryption, mp3 encoding, work-flow management as well as many other domains that would benefit from dataflow-based solutions.
These will differ in many aspects - the type of nodes in the network, the type and frequency of events, the load-balancing scheme, potential constraints on branching, the need for
visualization, debugging and logging, the way users define the networks and interact with them as well as many others.</p>
</div>
<div class="paragraph">
<p>The higher-level application-specific frameworks should put effort into providing abstractions best suited
for the given domain and hide <strong>GPars</strong> complexities.</p>
</div>
<div class="paragraph">
<p>For example, the visual graph of the network that the user manipulates on the screen should typically not show all the channels that participate in the
network. Debugging or logging channels, which rarely contribute to the core of the solution, are among the
first good candidates to consider for exclusion. Also channels and lifecycle-event listeners, which
orchestrate aspects such as load balancing or graceful shutdown, will probably be not exposed to the user,
although they will be part of the generated and executed network.</p>
</div>
<div class="paragraph">
<p>Similarly, a single channel in the domain-specific model will in reality translate into multiple channels perhaps with one or more
logging/transforming/filtering operators connecting them together. The function associated with a node will
most likely be wrapped with some additional infrastructural code to form the operator&#8217;s body.</p>
</div>
<div class="paragraph">
<p><strong>GPars</strong> gives you the underlying components that the end user may be abstracted away completely by the application-specific framework.
This keeps <strong>GPars</strong> domain-agnostic and universal, yet useful at the implementation level.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_pipeline_dsl">Pipeline DSL</h3>
<div class="sect3">
<h4 id="_a_dsl_for_building_operators_pipelines">A DSL for Building Operators Pipelines</h4>
<div class="paragraph">
<p>Building dataflow networks can be further simplified. <strong>GPars</strong> offers handy shortcuts for the common scenario
of building (mostly linear) pipelines of operators.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> toUpperCase = {s -&gt; s.toUpperCase()}

<span class="directive">final</span> encrypt = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowReadChannel encrypted = encrypt | toUpperCase | {<span class="local-variable">it</span>.reverse()} | {<span class="string"><span class="delimiter">'</span><span class="content">###encrypted###</span><span class="delimiter">'</span></span> + <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">###</span><span class="delimiter">'</span></span>}

encrypt &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">I need to keep this message secret!</span><span class="delimiter">&quot;</span></span>
encrypt &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">GPars can build linear operator pipelines really easily</span><span class="delimiter">&quot;</span></span>

println encrypted.val
println encrypted.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This saves you from directly creating, wiring and manipulating all the channels and operators that are to
form the pipeline.  The <em>pipe</em> operator lets you hook an output of one function/operator/process to the
input of another one. Just like chaining system processes on the command line.</p>
</div>
<div class="paragraph">
<p>The <em>pipe</em> operator is a handy shorthand for a more generic <em>chainWith()</em> method:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> toUpperCase = {s -&gt; s.toUpperCase()}

<span class="directive">final</span> encrypt = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowReadChannel encrypted = encrypt.chainWith toUpperCase chainWith {<span class="local-variable">it</span>.reverse()} chainWith {<span class="string"><span class="delimiter">'</span><span class="content">###encrypted###</span><span class="delimiter">'</span></span> + <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">###</span><span class="delimiter">'</span></span>}

encrypt &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">I need to keep this message secret!</span><span class="delimiter">&quot;</span></span>
encrypt &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">GPars can build linear operator pipelines really easily</span><span class="delimiter">&quot;</span></span>

println encrypted.val
println encrypted.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_combining_pipelines_with_straight_operators">Combining Pipelines with Straight Operators</h4>
<div class="paragraph">
<p>Since each operator pipeline has an entry and an exit channel, pipelines can be wired into more complex
operator networks.  Only your imagination can limit your ability to mix pipelines with channels and
operators in the same network definitions.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> toUpperCase = {s -&gt; s.toUpperCase()}
<span class="keyword">def</span> save = {text -&gt;
    <span class="comment">//Just pretending to be saving the text to disk, database or whatever</span>
    println <span class="string"><span class="delimiter">'</span><span class="content">Saving </span><span class="delimiter">'</span></span> + text
}

<span class="directive">final</span> toEncrypt = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowReadChannel encrypted = toEncrypt.chainWith toUpperCase chainWith {<span class="local-variable">it</span>.reverse()} chainWith {<span class="string"><span class="delimiter">'</span><span class="content">###encrypted###</span><span class="delimiter">'</span></span> + <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">###</span><span class="delimiter">'</span></span>}

<span class="directive">final</span> DataflowQueue fork1 = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowQueue fork2 = <span class="keyword">new</span> DataflowQueue()
splitter(encrypted, [fork1, fork2])  <span class="comment">//Split the data flow</span>

fork1.chainWith save  <span class="comment">//Hook in the save operation</span>

<span class="comment">//Hook in a sneaky decryption pipeline</span>
<span class="directive">final</span> DataflowReadChannel decrypted = fork2.chainWith {<span class="local-variable">it</span>[<span class="integer">15</span>..-<span class="integer">4</span>]} chainWith {<span class="local-variable">it</span>.reverse()} chainWith {<span class="local-variable">it</span>.toLowerCase()}
      .chainWith {<span class="string"><span class="delimiter">'</span><span class="content">Groovy leaks! Check out a decrypted secret message: </span><span class="delimiter">'</span></span> + <span class="local-variable">it</span>}

toEncrypt &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">I need to keep this message secret!</span><span class="delimiter">&quot;</span></span>
toEncrypt &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">GPars can build operator pipelines really easy</span><span class="delimiter">&quot;</span></span>

println decrypted.val
println decrypted.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Type of Channel Preservation</div>
<div class="paragraph">
<p>The type of the channel is preserved across the whole pipeline. E.g. if you start chaining off a synchronous
 channel, all the channels in the pipeline will be synchronous. In that case, obviously, the whole chain blocks, including the writer who writes into the channel at head, until someone reads data off the tail of the pipeline.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td>
  <td class="code"><pre><span class="directive">final</span> SyncDataflowQueue queue = <span class="keyword">new</span> SyncDataflowQueue()
<span class="directive">final</span> result = queue.chainWith {<span class="local-variable">it</span> * <span class="integer">2</span>}.chainWith {<span class="local-variable">it</span> + <span class="integer">1</span>} chainWith {<span class="local-variable">it</span> * <span class="integer">100</span>}

<span class="predefined-type">Thread</span>.start {
    <span class="integer">5</span>.times {
        println result.val
    }
}

queue &lt;&lt; <span class="integer">1</span>
queue &lt;&lt; <span class="integer">2</span>
queue &lt;&lt; <span class="integer">3</span>
queue &lt;&lt; <span class="integer">4</span>
queue &lt;&lt; <span class="integer">5</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_joining_pipelines">Joining Pipelines</h4>
<div class="paragraph">
<p>Two pipelines (or channels) can be connected using the <em>into()</em> method:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td>
  <td class="code"><pre><span class="directive">final</span> encrypt = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowWriteChannel messagesToSave = <span class="keyword">new</span> DataflowQueue()
encrypt.chainWith toUpperCase chainWith {<span class="local-variable">it</span>.reverse()} into messagesToSave

task {
    encrypt &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">I need to keep this message secret!</span><span class="delimiter">&quot;</span></span>
    encrypt &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">GPars can build operator pipelines really easy</span><span class="delimiter">&quot;</span></span>
}

task {
    <span class="integer">2</span>.times {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Saving </span><span class="delimiter">&quot;</span></span> + messagesToSave.val
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The output of the <em>encryption</em> pipeline is directly connected to the input of the <em>saving</em> pipeline (a
single channel in out case).</p>
</div>
</div>
<div class="sect3">
<h4 id="_forking_the_strong_dataflow_strong">Forking the <strong>Dataflow</strong></h4>
<div class="paragraph">
<p>When a need comes to copy the output of a pipeline/channel into more than one following pipeline/channel, the <em>split()</em> method will help you:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre><span class="directive">final</span> encrypt = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowWriteChannel messagesToSave = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowWriteChannel messagesToLog = <span class="keyword">new</span> DataflowQueue()

encrypt.chainWith toUpperCase chainWith {<span class="local-variable">it</span>.reverse()}.split(messagesToSave, messagesToLog)</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_tapping_into_a_pipeline">Tapping into a Pipeline</h4>
<div class="paragraph">
<p>Like <em>split()</em> the <em>tap()</em> method allows you to fork the data flow into multiple channels. Tapping, however,
is slightly more convenient in some scenarios, since it treats one of the two new forks as the successor of
the pipeline.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>queue.chainWith {<span class="local-variable">it</span> * <span class="integer">2</span>}.tap(logChannel).chainWith{<span class="local-variable">it</span> + <span class="integer">1</span>}.tap(logChannel).into(PrintChannel)</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_merging_channels">Merging Channels</h4>
<div class="paragraph">
<p>Merging allows you to join multiple read channels as inputs for a single dataflow operator. The function
passed as the second argument needs to accept as many arguments as there are channels being merged - each
will hold a value of the corresponding channel.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>maleChannel.merge(femaleChannel) {m, f -&gt; m.marry(f)}.into(mortgageCandidatesChannel)</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_separation">Separation</h4>
<div class="paragraph">
<p><em>Separation</em> is the opposite operation to <em>merge</em>. The supplied closure returns a list of values, each of
which will be output into an output channel with the corresponding position index.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>queue1.separate([queue2, queue3, queue4]) {a -&gt; [a-<span class="integer">1</span>, a, a+<span class="integer">1</span>]}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_choices">Choices</h4>
<div class="paragraph">
<p>The <em>binaryChoice()</em> and <em>choice()</em> methods allow you to send a value to one out of two (or many) output
channels, as indicated by the return value from a closure.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre>queue1.binaryChoice(queue2, queue3) {a -&gt; a &gt; <span class="integer">0</span>}
queue1.choice([queue2, queue3, queue4]) {a -&gt; a % <span class="integer">3</span>}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_filtering">Filtering</h4>
<div class="paragraph">
<p>The <em>filter()</em> method allows to filter data in the pipeline using boolean predicates.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre>        <span class="directive">final</span> DataflowQueue queue1 = <span class="keyword">new</span> DataflowQueue()
        <span class="directive">final</span> DataflowQueue queue2 = <span class="keyword">new</span> DataflowQueue()

        <span class="directive">final</span> odd = {num -&gt; num % <span class="integer">2</span> != <span class="integer">0</span> }

        queue1.filter(odd) into queue2
        (<span class="integer">1</span>..<span class="integer">5</span>).each {queue1 &lt;&lt; <span class="local-variable">it</span>}
        <span class="keyword">assert</span> <span class="integer">1</span> == queue2.val
        <span class="keyword">assert</span> <span class="integer">3</span> == queue2.val
        <span class="keyword">assert</span> <span class="integer">5</span> == queue2.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_null_values">Null Values</h4>
<div class="paragraph">
<p>If a chained function returns a <em>null</em> value, it is normally passed along the pipeline as a valid value. To
indicate to the operator that no value should be passed further down the pipeline, a <em>NullObject.nullObject</em>
instance must be returned.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td>
  <td class="code"><pre>        <span class="directive">final</span> DataflowQueue queue1 = <span class="keyword">new</span> DataflowQueue()
        <span class="directive">final</span> DataflowQueue queue2 = <span class="keyword">new</span> DataflowQueue()

        <span class="directive">final</span> odd = {num -&gt;
            <span class="keyword">if</span> (num == <span class="integer">5</span>) <span class="keyword">return</span> <span class="predefined-constant">null</span>  <span class="comment">//null values are normally passed on</span>
            <span class="keyword">if</span> (num % <span class="integer">2</span> != <span class="integer">0</span>) <span class="keyword">return</span> num
            <span class="keyword">else</span> <span class="keyword">return</span> NullObject.nullObject  <span class="comment">//this value gets blocked</span>
        }

        queue1.chainWith odd into queue2
        (<span class="integer">1</span>..<span class="integer">5</span>).each {queue1 &lt;&lt; <span class="local-variable">it</span>}
        <span class="keyword">assert</span> <span class="integer">1</span> == queue2.val
        <span class="keyword">assert</span> <span class="integer">3</span> == queue2.val
        <span class="keyword">assert</span> <span class="predefined-constant">null</span> == queue2.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_customizing_thread_pools">Customizing Thread Pools</h4>
<div class="paragraph">
<p>All of the Pipeline DSL methods allow for custom thread pools or <em>PGroups</em> to be specified:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td>
  <td class="code"><pre>channel | {<span class="local-variable">it</span> * <span class="integer">2</span>}

channel.chainWith(closure)
channel.chainWith(pool) {<span class="local-variable">it</span> * <span class="integer">2</span>}
channel.chainWith(group) {<span class="local-variable">it</span> * <span class="integer">2</span>}

channel.into(otherChannel)
channel.into(pool, otherChannel)
channel.into(group, otherChannel)

channel.split(otherChannel1, otherChannel2)
channel.split(otherChannels)
channel.split(pool, otherChannel1, otherChannel2)
channel.split(pool, otherChannels)
channel.split(group, otherChannel1, otherChannel2)
channel.split(group, otherChannels)

channel.tap(otherChannel)
channel.tap(pool, otherChannel)
channel.tap(group, otherChannel)

channel.merge(otherChannel)
channel.merge(otherChannels)
channel.merge(pool, otherChannel)
channel.merge(pool, otherChannels)
channel.merge(group, otherChannel)
channel.merge(group, otherChannels)

channel.filter( otherChannel)
channel.filter(pool, otherChannel)
channel.filter(group, otherChannel)

channel.binaryChoice( trueBranch, falseBranch)
channel.binaryChoice(pool, trueBranch, falseBranch)
channel.binaryChoice(group, trueBranch, falseBranch)

channel.choice( branches)
channel.choice(pool, branches)
channel.choice(group, branches)

channel.separate( outputs)
channel.separate(pool, outputs)
channel.separate(group, outputs)
</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_overriding_the_default_strong_pgroup_strong">Overriding the Default <strong>PGroup</strong></h3>
<div class="paragraph">
<p>To avoid the necessity to specify PGroup for each Pipeline DSL method separately you may override the value
of the default Dataflow PGroup.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>Dataflow.usingGroup(group) {
    channel.choice(branches)
}
<span class="comment">//Is identical to</span>
channel.choice(group, branches)</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>Dataflow.usingGroup()</em> method resets the value of the default dataflow PGroup for the given code block
to the value specified.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_the_pipeline_builder">The Pipeline Builder</h3>
<div class="paragraph">
<p>The <em>Pipeline</em> class offers an intuitive builder for operator pipelines. The greatest benefit of using the
<em>Pipeline</em> class compared to chaining the channels directly is the ease with which a custom thread
pool/group can be applied to all the operators along the constructed chain.  The available methods and
overloaded operators are identical to the ones available on channels directly.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The greatest benefit of using the <em>Pipeline</em> class is easy usage
</td>
</tr>
</table>
</div>
<hr>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.operator.Pipeline</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.scheduler.DefaultPool</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.scheduler.Pool</span>

<span class="directive">final</span> DataflowQueue queue = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowQueue result1 = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowQueue result2 = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> Pool pool = <span class="keyword">new</span> DefaultPool(<span class="predefined-constant">false</span>, <span class="integer">2</span>)

<span class="directive">final</span> negate = {-<span class="local-variable">it</span>}

<span class="directive">final</span> Pipeline pipeline = <span class="keyword">new</span> Pipeline(pool, queue)

pipeline | {<span class="local-variable">it</span> * <span class="integer">2</span>} | {<span class="local-variable">it</span> + <span class="integer">1</span>} | negate
pipeline.split(result1, result2)

queue &lt;&lt; <span class="integer">1</span>
queue &lt;&lt; <span class="integer">2</span>
queue &lt;&lt; <span class="integer">3</span>

<span class="keyword">assert</span> -<span class="integer">3</span> == result1.val
<span class="keyword">assert</span> -<span class="integer">5</span> == result1.val
<span class="keyword">assert</span> -<span class="integer">7</span> == result1.val

<span class="keyword">assert</span> -<span class="integer">3</span> == result2.val
<span class="keyword">assert</span> -<span class="integer">5</span> == result2.val
<span class="keyword">assert</span> -<span class="integer">7</span> == result2.val

pool.shutdown()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_passing_construction_parameters_through_the_pipeline_dsl">Passing Construction Parameters Through the Pipeline DSL</h3>
<div class="paragraph">
<p>You are likely to frequently need the ability to pass additional initialization parameters to the operators,
such as the listeners to attach or the value for <em>maxForks</em>. Just like when building operators directly, the
Pipeline DSL methods accept an optional map of parameters to pass in.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="keyword">new</span> Pipeline(group, queue1).merge([<span class="key">maxForks</span>: <span class="integer">4</span>, <span class="key">listeners</span>: [listener]], queue2) {a, b -&gt; a + b}.into queue3</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_implementation">Implementation</h3>
<div class="paragraph">
<p>The Dataflow Concurrency in <strong>GPars</strong> builds on the same principles as the <strong>Actor</strong> support. All of the dataflow
tasks share a thread pool and so the number threads created through <em>Dataflow.task()</em> factory method don&#8217;t
need to correspond to the number of physical threads required from the system.  The <em>PGroup.task()</em> factory
method can be used to attach the created task to a group. Since each group defines its own thread pool, you
can easily organize tasks around different thread pools just like you do with <strong>actors</strong>.</p>
</div>
<div class="sect3">
<h4 id="_combining_strong_actors_strong_and_code_dataflow_concurrency_code">Combining <strong>Actors</strong> and <code>Dataflow Concurrency</code></h4>
<div class="paragraph">
<p>The good news is that you can combine <strong>actors</strong> and <code>Dataflow Concurrency</code> in any way you feel fit for your
particular problem at hands. You can freely you use Dataflow Variables from <strong>Actors</strong>.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td>
  <td class="code"><pre><span class="directive">final</span> DataflowVariable a = <span class="keyword">new</span> DataflowVariable()

<span class="directive">final</span> Actor doubler = Actors.actor {
    react {message-&gt;
        a &lt;&lt; <span class="integer">2</span> * message
    }
}

<span class="directive">final</span> Actor fakingDoubler = actor {
    react {
        doubler.send <span class="local-variable">it</span>  <span class="comment">//send a number to the doubler</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Result </span><span class="inline"><span class="inline-delimiter">${</span>a.val<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>  <span class="comment">//wait for the result to be bound to 'a'</span>
    }
}

fakingDoubler &lt;&lt; <span class="integer">10</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example you see the <em>fakingDoubler</em> using both messages and a <em>DataflowVariable</em> to communicate with the <em>doubler</em> <strong>Actor</strong>.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_using_plain_strong_java_strong_threads">Using Plain <strong>Java</strong> Threads</h3>
<div class="paragraph">
<p>The <em>DataflowVariable</em> as well as the <em>DataflowQueue</em> classes can obviously be used from any thread of your application, not only from the tasks created by <em>Dataflow.task()</em>.
Consider the following example:</p>
</div>
<div class="listingblock">
<div class="title">A DataflowVariable Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowVariable</span>

<span class="directive">final</span> DataflowVariable a = <span class="keyword">new</span> DataflowVariable&lt;<span class="predefined-type">String</span>&gt;()
<span class="directive">final</span> DataflowVariable b = <span class="keyword">new</span> DataflowVariable&lt;<span class="predefined-type">String</span>&gt;()

<span class="predefined-type">Thread</span>.start {
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Received: </span><span class="inline"><span class="inline-delimiter">$</span>a</span><span class="content">.val</span><span class="delimiter">&quot;</span></span>
    <span class="predefined-type">Thread</span>.sleep <span class="integer">2000</span>
    b &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Thank you</span><span class="delimiter">'</span></span>
}

<span class="predefined-type">Thread</span>.start {
    <span class="predefined-type">Thread</span>.sleep <span class="integer">2000</span>
    a &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">An important message from the second thread</span><span class="delimiter">'</span></span>
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Reply: </span><span class="inline"><span class="inline-delimiter">$</span>b</span><span class="content">.val</span><span class="delimiter">&quot;</span></span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re creating two plain <em>java.lang.Thread</em> instances, which exchange data using the two data flow
variables. Obviously, neither the <strong>Actor</strong> lifecycle methods, nor the send/react functionality or thread
pooling take effect in such scenarios.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_synchronous_variables_and_channels">Synchronous Variables and Channels</h3>
<div class="paragraph">
<p>When using asynchronous dataflow channels, apart from the fact that readers have to wait for a value to be available for consumption, the communicating parties remain completely independent.
Writers don&#8217;t wait for their messages to get consumed. Readers obtain values immediately as they come and ask.
Synchronous channels, on the other hand, can synchronize writers with the readers as well as multiple readers among themselves.</p>
</div>
<div class="paragraph">
<p>This is particularly useful when you need to increase the level of determinism.</p>
</div>
<div class="paragraph">
<p>The writer-to-reader partial ordering imposed by asynchronous communication is complemented with reader-to-writer partial ordering, when using synchronous communication.
In other words, you are guaranteed that whatever the reader did before reading a value from a synchronous channel preceded whatever the writer did after writing the value.
Also, with synchronous communication writers can never get too far ahead of readers, which simplifies reasoning about the system and reduces the need to manage data production speed in order to avoid system overload.</p>
</div>
<div class="sect3">
<h4 id="_synchronous_dataflow_queue">Synchronous Dataflow Queue</h4>
<div class="paragraph">
<p>The <em>SyncDataflowQueue</em> class should be used for point-to-point (1:1 or n:1) communication. Each message written to the queue will be consumed by exactly one reader.
Writers are blocked until their message is consumed, readers are blocked until there&#8217;s a value available for them to read.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Synchronous channels block both the writer and the readers until all parties are ready
</td>
</tr>
</table>
</div>
<hr>
<div class="listingblock">
<div class="title">A Synchronous Channel Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.SyncDataflowQueue</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.NonDaemonPGroup</span>

<span class="comment">/**
 * Shows how synchronous dataflow queues can be used to throttle fast producer
 * when serving data to a slow consumer. Unlike when using asynchronous channels,
 * synchronous channels block both the writer and the readers until all parties
 * are ready to exchange messages.
 */</span>

<span class="keyword">def</span> group = <span class="keyword">new</span> NonDaemonPGroup()

<span class="directive">final</span> SyncDataflowQueue channel = <span class="keyword">new</span> SyncDataflowQueue()

<span class="keyword">def</span> producer = group.task {
    (<span class="integer">1</span>..<span class="integer">30</span>).each {
        channel &lt;&lt; <span class="local-variable">it</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Just sent </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>
    }
    channel &lt;&lt; -<span class="integer">1</span>
}

<span class="keyword">def</span> consumer = group.task {
    <span class="keyword">while</span> (<span class="predefined-constant">true</span>) {
        sleep <span class="integer">500</span>  <span class="comment">//simulating a slow consumer</span>
        <span class="directive">final</span> <span class="predefined-type">Object</span> msg = channel.val
        <span class="keyword">if</span> (msg == -<span class="integer">1</span>) <span class="keyword">return</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Received </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>
    }
}

consumer.join()

group.shutdown()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_synchronous_dataflow_broadcast">Synchronous Dataflow Broadcast</h3>
<div class="paragraph">
<p>The <em>SyncDataflowBroadcast</em> class should be used for publish-subscribe (1:n or n:m) communication.</p>
</div>
<div class="paragraph">
<p>Each message written to the broadcast will be consumed by all subscribed readers.
Writers are blocked until their message is consumed by all readers, readers are blocked until there&#8217;s a value available for them to read and all the other subscribed readers ask for the message as well.
With <em>SyncDataflowBroadcast</em>, you get all readers processing the same message at the same time and waiting for one-another before getting the next one.</p>
</div>
<div class="listingblock">
<div class="title">A SyncDataflowBroadcast Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.SyncDataflowBroadcast</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.NonDaemonPGroup</span>

<span class="comment">/**
 * Shows how synchronous dataflow broadcasts can be used to throttle fast producer
 * when serving data to slow consumers. Unlike when using asynchronous channels,
 * synchronous channels block both the writer and the readers
 * until all parties are ready to exchange messages.
 */</span>

<span class="keyword">def</span> group = <span class="keyword">new</span> NonDaemonPGroup()

<span class="directive">final</span> SyncDataflowBroadcast channel = <span class="keyword">new</span> SyncDataflowBroadcast()

<span class="keyword">def</span> subscription1 = channel.createReadChannel()
<span class="keyword">def</span> fastConsumer = group.task {
    <span class="keyword">while</span> (<span class="predefined-constant">true</span>) {
        sleep <span class="integer">10</span>  <span class="comment">//simulating a fast consumer</span>
        <span class="directive">final</span> <span class="predefined-type">Object</span> msg = subscription1.val
        <span class="keyword">if</span> (msg == -<span class="integer">1</span>) <span class="keyword">return</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Fast consumer received </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>
    }
}

<span class="keyword">def</span> subscription2 = channel.createReadChannel()
<span class="keyword">def</span> slowConsumer = group.task {
    <span class="keyword">while</span> (<span class="predefined-constant">true</span>) {
        sleep <span class="integer">500</span>  <span class="comment">//simulating a slow consumer</span>
        <span class="directive">final</span> <span class="predefined-type">Object</span> msg = subscription2.val
        <span class="keyword">if</span> (msg == -<span class="integer">1</span>) <span class="keyword">return</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Slow consumer received </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>
    }
}

<span class="keyword">def</span> producer = group.task {
    (<span class="integer">1</span>..<span class="integer">30</span>).each {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Sending </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>
        channel &lt;&lt; <span class="local-variable">it</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Sent </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>
    }
    channel &lt;&lt; -<span class="integer">1</span>
}

[fastConsumer, slowConsumer]*.join()

group.shutdown()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_synchronous_dataflow_variable">Synchronous Dataflow Variable</h3>
<div class="paragraph">
<p>Unlike <em>DataflowVariable</em>, which is asynchronous and only blocks the readers until a value is bound to the
variable, the <em>SyncDataflowVariable</em> class provides a one-shot data exchange mechanism that blocks the
writer and all readers until a specified number of waiting parties is reached.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.SyncDataflowVariable</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.NonDaemonPGroup</span>

<span class="directive">final</span> NonDaemonPGroup group = <span class="keyword">new</span> NonDaemonPGroup()

<span class="comment">//two readers required to exchange the message</span>
<span class="directive">final</span> SyncDataflowVariable value = <span class="keyword">new</span> SyncDataflowVariable(<span class="integer">2</span>)

<span class="keyword">def</span> writer = group.task {
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Writer about to write a value</span><span class="delimiter">&quot;</span></span>
    value &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Hello</span><span class="delimiter">'</span></span>
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Writer has written the value</span><span class="delimiter">&quot;</span></span>
}

<span class="keyword">def</span> reader = group.task {
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Reader about to read a value</span><span class="delimiter">&quot;</span></span>
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Reader has read the value: </span><span class="inline"><span class="inline-delimiter">${</span>value.val<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
}

<span class="keyword">def</span> slowReader = group.task {
    sleep <span class="integer">5000</span>
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Slow reader about to read a value</span><span class="delimiter">&quot;</span></span>
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Slow reader has read the value: </span><span class="inline"><span class="inline-delimiter">${</span>value.val<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
}

[reader, slowReader]*.join()

group.shutdown()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_kanban_flow">Kanban Flow</h3>
<table class="tableblock frame-topbot grid-all spread">
<caption class="title">Table 1. Kanban Flow API Links</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">API Link</th>
<th class="tableblock halign-left valign-top">API Link</th>
<th class="tableblock halign-left valign-top">API Link</th>
<th class="tableblock halign-left valign-top">API Link</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="../api/groovydoc/groovyx/gpars/dataflow/KanbanFlow.html">Kanban Flow</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="../api/groovydoc/groovyx/gpars/dataflow/KanbanLink.html">Kanban Link</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="../api/groovydoc/groovyx/gpars/dataflow/KanbanTray.html">Kanban Tray</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="../api/groovydoc/groovyx/gpars/dataflow/ProcessingNode.html">Processing Node</a></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_kanbanflow_description">KanbanFlow Description</h3>
<div class="paragraph">
<p>A <em>KanbanFlow</em> is a composed object that uses dataflow abstractions to define dependencies between multiple concurrent producer and consumer operators.</p>
</div>
<div class="paragraph">
<p>Each link between a producer and a consumer is defined by a <em>KanbanLink</em>.</p>
</div>
<div class="paragraph">
<p>Inside each <em>KanbanLink</em>, the communication between producer and consumer follows the <em>KanbanFlow</em> pattern as described in <a href="http://people.canoo.com/mittie/kanbanflow.html">The KanbanFlow Pattern</a>.
They use objects of type <em>KanbanTray</em> to send products downstream and to signal requests for further products back to the producer.</p>
</div>
<div class="paragraph">
<p>The figure below illustrates a <em>KanbanLink</em> with one producer, one consumer and five trays numbered 0 to 4.
Tray number 0 has been used to take a product from producer to consumer, has been emptied by the consumer and is now sent back to the producer&#8217;s input queue.
Trays 1 and 2 wait to carry products waiting for consumption, while trays 3 and 4 wait to be used by producers.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/dataflow_kanban.png" alt="dataflow kanban">
</div>
</div>
<hr>
<div class="paragraph">
<p>A <em>KanbanFlow</em> object links producers to consumers thus creating <em>KanbanLink</em> objects.
In the course of this activity, a second link may be constructed where the producer is the same object that acted as the consumer in a formerly created link such that the two links become connected to build a chain.</p>
</div>
<div class="paragraph">
<p>Here is an example of a <em>KanbanFlow</em> with only one link, e.g. one producer and one consumer.  The producer always sends the number 1 downstream and the consumer prints this number.</p>
</div>
<div class="listingblock">
<div class="title">A Kanban Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.ProcessingNode.node</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.KanbanFlow</span>

<span class="keyword">def</span> producer = node { down -&gt; down <span class="integer">1</span> }
<span class="keyword">def</span> consumer = node { up   -&gt; println up.take() }

<span class="keyword">new</span> KanbanFlow().with {
    link producer to consumer
    start()
    <span class="comment">// run for a while</span>
    stop()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>To put a product into a tray and send the tray downstream, one can either use the <strong>send()</strong> method, the <strong>&lt;&lt;</strong> operator, or use the tray as a method object.
The following lines are equivalent:</p>
</div>
<div class="listingblock">
<div class="title">A Sample of Equivalent Choices</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>node { down -&gt; down.send <span class="integer">1</span> }
node { down -&gt; down &lt;&lt; <span class="integer">1</span> }
node { down -&gt; down <span class="integer">1</span> }</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>When a product is taken from the input tray with the <strong>take()</strong> method, the empty tray is automatically released.</p>
</div>
<hr>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
You should call <strong>take()</strong> only once!
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p>If you prefer not to use an empty tray to send products downstream (as typically the case when a <em>ProcessingNode</em> acts as a filter), you must release the tray in order to keep it in play.
Otherwise, the number of trays in the system decreases.</p>
</div>
<div class="paragraph">
<p>You can release a tray either by calling the <strong>release()</strong> method or by using the <strong>~</strong> operator (think "shake it off").
The following lines are equivalent:</p>
</div>
<div class="listingblock">
<div class="title">More Equivalent Choices</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre>node { down -&gt; down.release() }
node { down -&gt; ~down }</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Tray Release</div>
<div class="paragraph">
<p>Trays are automatically released, if you call any of the <strong>take()</strong> or <strong>send()</strong> methods.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_various_linking_structures">Various Linking Structures</h4>
<div class="paragraph">
<p>In addition to linear chains, a <em>KanbanFlow</em> can also link a single producer to multiple consumers (like a tree) or link multiple producers to a single consumer (collector)
or any combination of the above that results in a directed acyclic graph (<strong>DAG</strong>).</p>
</div>
<div class="paragraph">
<p>The <em>KanbanFlowTest</em> class has many examples for such structures, including scenarios where a single producer delegates work to multiple consumers with:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a <strong>work-stealing</strong> strategy where all consumers get their pick from the downstream,</p>
</li>
<li>
<p>a <strong>master-slave</strong> strategy where a producer chooses from the available consumers, and</p>
</li>
<li>
<p>a <strong>broadcast</strong> strategy where a producer sends all products to all consumers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cycles are forbidden by default but when enabled, they can be used as so-called generators.
A producer can even be his own consumer that increases a product value every cycle. The generator itself remains state-free since the value is only stored as a product riding on a tray.
Such a generator can be used for e.g. lazy sequences or as a the <code>heartbeat</code> of a subsequent flow.</p>
</div>
<div class="paragraph">
<p>The approach of generator <code>loops</code> can be equally applied to collectors, where a collector does not maintain any internal state but sends a collection to itself, adding products at each call.</p>
</div>
<div class="paragraph">
<p>Generally speaking, a <em>ProcessingNode</em> can link to itself to export state to the tray/product that it sends to itself. Access to the product is then <strong>thread-safe by design</strong>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_composing_kanbanflows">Composing KanbanFlows</h4>
<div class="paragraph">
<p>Just as <em>KanbanLink</em> objects can be chained together to form a <em>KanbanFlow</em>, flows themselves can be composed again to form new, greater flows from existing smaller ones.</p>
</div>
<div class="listingblock">
<div class="title">A KanbanFlow Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> firstFlow = <span class="keyword">new</span> KanbanFlow()
<span class="keyword">def</span> producer  = node(counter)
<span class="keyword">def</span> consumer  = node(repeater)
firstFlow.link(producer).to(consumer)

<span class="keyword">def</span> secondFlow = <span class="keyword">new</span> KanbanFlow()
<span class="keyword">def</span> producer2  = node(repeater)
<span class="keyword">def</span> consumer2  = node(reporter)
secondFlow.link(producer2).to(consumer2)

flow = firstFlow + secondFlow

flow.start()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_customizing_concurrency_characteristics">Customizing Concurrency Characteristics</h4>
<div class="paragraph">
<p>The amount of concurrency in a kanban system is determined by the number of trays (sometimes called <strong>WIP</strong> = <em>work-in-progress</em>). With no trays in the streams, the system does nothing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>With one tray only, the system is confined to sequential execution.</p>
</li>
<li>
<p>With more trays, concurrency begins.</p>
</li>
<li>
<p>With more trays than available processing units, the system begins to waste resources.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The number of trays can be controlled in various ways. They are typically set when starting the flow.</p>
</div>
<div class="listingblock">
<div class="title">Setting Tray Counts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>flow.start(<span class="integer">0</span>) <span class="comment">// start without trays</span>
flow.start(<span class="integer">1</span>) <span class="comment">// start with one tray per link in the flow</span>
flow.start()  <span class="comment">// start with the optimal number of trays</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition to the trays, the <em>KanbanFlow</em> may also be constrained by its underlying <em>ThreadPool</em>. A pool of size <strong>1</strong> for example will not allow much concurrency.</p>
</div>
<div class="paragraph">
<p><em>KanbanFlows</em> use a default pool that is dimensioned by the number of available cores. This can be customized by setting the <strong>pooledGroup</strong> property.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_tests">Tests</h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/GPars/GPars/blob/master/src/test/groovy/groovyx/gpars/dataflow/KanbanFlowTest.groovy">Kanban Flow Test in <strong>Groovy</strong></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_kanban_code_samples_in_strong_groovy_strong">Kanban Code Samples in <strong>Groovy</strong></h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/GPars/GPars/blob/master/src/test/groovy/groovyx/gpars/samples/dataflow/kanban/DemoKanbanFlow.groovy">Demo Kanban Flow</a></p>
</li>
<li>
<p><a href="https://github.com/GPars/GPars/blob/master/src/test/groovy/groovyx/gpars/samples/dataflow/kanban/DemoKanbanFlowBroadcast.groovy">Demo Kanban Flow Broadcast</a></p>
</li>
<li>
<p><a href="https://github.com/GPars/GPars/blob/master/src/test/groovy/groovyx/gpars/samples/dataflow/kanban/DemoKanbanFlowCycle.groovy">Demo Kanban Flow Cycle</a></p>
</li>
<li>
<p><a href="https://github.com/GPars/GPars/blob/master/src/test/groovy/groovyx/gpars/samples/dataflow/kanban/DemoKanbanLazyPrimeSequenceLoops.groovy">Demo Kanban Lazy Prime Sequence Loops</a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_classic_examples_2">Classic Examples</h3>
<div class="sect3">
<h4 id="_the_sieve_of_eratosthenes_implementation_using_code_dataflow_tasks_code">The Sieve of Eratosthenes Implementation using <code>Dataflow Tasks</code></h4>
<div class="listingblock">
<div class="title">A Sample Solution of The Sieve of Eratosthenes</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

<span class="comment">/**
 * Demonstrates concurrent implementation of the Sieve of Eratosthenes using dataflow tasks
 */</span>

<span class="directive">final</span> <span class="type">int</span> requestedPrimeNumberCount = <span class="integer">1000</span>

<span class="directive">final</span> DataflowQueue initialChannel = <span class="keyword">new</span> DataflowQueue()

<span class="comment">/**
 * Generating candidate numbers
 */</span>
task {
    (<span class="integer">2</span>..<span class="integer">10000</span>).each {
        initialChannel &lt;&lt; <span class="local-variable">it</span>
    }
}

<span class="comment">/**
 * Chain a new filter for a particular prime number to the end of the Sieve
 * @param inChannel The current end channel to consume
 * @param prime The prime number to divide future prime candidates with
 * @return A new channel ending the whole chain
 */</span>
<span class="keyword">def</span> <span class="function">filter</span>(inChannel, <span class="type">int</span> prime) {
    <span class="keyword">def</span> outChannel = <span class="keyword">new</span> DataflowQueue()

    task {
        <span class="keyword">while</span> (<span class="predefined-constant">true</span>) {
            <span class="keyword">def</span> number = inChannel.val
            <span class="keyword">if</span> (number % prime != <span class="integer">0</span>) {
                outChannel &lt;&lt; number
            }
        }
    }
    <span class="keyword">return</span> outChannel
}

<span class="comment">/**
 * Consume Sieve output and add additional filters for all found primes
 */</span>
<span class="keyword">def</span> currentOutput = initialChannel
requestedPrimeNumberCount.times {
    <span class="type">int</span> prime = currentOutput.val
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Found: </span><span class="inline"><span class="inline-delimiter">$</span>prime</span><span class="delimiter">&quot;</span></span>
    currentOutput = filter(currentOutput, prime)
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_sieve_of_eratosthenes_using_both_code_dataflow_tasks_code_and_code_operators_code">The Sieve of Eratosthenes using both <code>Dataflow Tasks</code> and <code>Operators</code></h4>
<div class="listingblock">
<div class="title">A More Complex Solution</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td>
  <td class="code"><pre>       <span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
       <span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.operator</span>
       <span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

       <span class="comment">/**
        * Demonstrates concurrent implementation of the Sieve of Eratosthenes using dataflow tasks and operators
        */</span>

       <span class="directive">final</span> <span class="type">int</span> requestedPrimeNumberCount = <span class="integer">100</span>

       <span class="directive">final</span> DataflowQueue initialChannel = <span class="keyword">new</span> DataflowQueue()

       <span class="comment">/**
        * Generating candidate numbers
        */</span>
       task {
           (<span class="integer">2</span>..<span class="integer">1000</span>).each {
               initialChannel &lt;&lt; <span class="local-variable">it</span>
           }
       }

       <span class="comment">/**
        * Chain a new filter for a particular prime number to the end of the Sieve
        * @param inChannel The current end channel to consume
        * @param prime The prime number to divide future prime candidates with
        * @return A new channel ending the whole chain
        */</span>
       <span class="keyword">def</span> <span class="function">filter</span>(inChannel, <span class="type">int</span> prime) {
           <span class="keyword">def</span> outChannel = <span class="keyword">new</span> DataflowQueue()

           operator([<span class="key">inputs</span>: [inChannel], <span class="key">outputs</span>: [outChannel]]) {
               <span class="keyword">if</span> (<span class="local-variable">it</span> % prime != <span class="integer">0</span>) {
                   bindOutput <span class="local-variable">it</span>
               }
           }
           <span class="keyword">return</span> outChannel
       }

       <span class="comment">/**
        * Consume Sieve output and add additional filters for all found primes
        */</span>
       <span class="keyword">def</span> currentOutput = initialChannel
       requestedPrimeNumberCount.times {
           <span class="type">int</span> prime = currentOutput.val
           println <span class="string"><span class="delimiter">&quot;</span><span class="content">Found: </span><span class="inline"><span class="inline-delimiter">$</span>prime</span><span class="delimiter">&quot;</span></span>
           currentOutput = filter(currentOutput, prime)
       }</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../images/divider.png" alt="divider" width="436">
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_user_guide_to_strong_stm_strong">User Guide To <strong>STM</strong></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="__em_software_transactional_memory_em"><em>Software Transactional Memory</em></h3>
<div class="paragraph">
<p><code>Software Transactional Memory</code> (<strong>STM</strong>) gives developers transactional semantics for accessing in-memory data. This is similar to database concepts.</p>
</div>
<div class="paragraph">
<p>When multiple threads share data in memory, by marking blocks of code as transactional (atomic), the developer delegates the responsibility for data consistency to the <strong>STM</strong> engine.
<strong>GPars</strong> leverages the <a href="https://github.com/pveentjer/Multiverse">Multiverse <strong>STM</strong> engine</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_running_a_piece_of_code_atomically">Running A Piece of Code Atomically</h3>
<div class="paragraph">
<p>When using <strong>STM</strong>, developers organize their code into transactions. A transaction is a piece of code, which is executed <strong>atomically</strong> - either <strong>1)</strong> all the code is run or <strong>2)</strong> none at all.</p>
</div>
<div class="paragraph">
<p>The data used by the transactional code remains <strong>consistent</strong> irrespective of whether the transaction finishes normally or abruptly.  While running inside a transaction, the code is given an illusion of being <strong>isolated</strong> from other concurrently running transactions so that changes to data in one transaction are not visible in the other ones until the transactions commit. This gives us the <strong>ACI</strong> part of the <strong>ACID</strong> characteristics of database transactions. The <strong>durability</strong> transactional aspect so typical for databases, is not typically mandated for <strong>Stm</strong>.</p>
</div>
<div class="paragraph">
<p><strong>GPars</strong> allows developers to specify transaction boundaries by using the <em>atomic</em> closures.</p>
</div>
<div class="listingblock">
<div class="title">Sample of <strong>ACI</strong> Transaction Boundaries</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.stm.GParsStm</span>
<span class="keyword">import</span> <span class="include">org.multiverse.api.references.TxnInteger</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">org.multiverse.api.StmUtils.newTxnInteger</span>

<span class="directive">public</span> <span class="type">class</span> <span class="class">Account</span> {
    <span class="directive">private</span> <span class="directive">final</span> TxnInteger amount = newTxnInteger(<span class="integer">0</span>);

    <span class="directive">public</span> <span class="type">void</span> transfer(<span class="directive">final</span> <span class="type">int</span> a) {
        GParsStm.atomic {
            amount.increment(a);
        }
    }

    <span class="directive">public</span> <span class="type">int</span> getCurrentAmount() {
        GParsStm.atomicWithInt {
            amount.get();
        }
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are several types of <em>atomic</em> closures, each for a different type of return value:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>atomic</em> - returning <em>Object</em></p>
</li>
<li>
<p><em>atomicWithInt</em> - returning <em>int</em></p>
</li>
<li>
<p><em>atomicWithLong</em> - returning <em>long</em></p>
</li>
<li>
<p><em>atomicWithBoolean</em> - returning <em>boolean</em></p>
</li>
<li>
<p><em>atomicWithDouble</em> - returning <em>double</em></p>
</li>
<li>
<p><em>atomicWithVoid</em> - no return value</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Multiverse</strong>, by default, uses an optimistic locking strategy and automatically rolls back and retries colliding
transactions.</p>
</div>
<div class="paragraph">
<p>Developers should refrain from irreversible actions (e.g. writing to the console,
sending e-mails, launching a missile, etc.) in their transactional code.  To increase flexibility, the
default <strong>Multiverse</strong> settings can be customized through custom <em>atomic blocks</em> .</p>
</div>
</div>
<div class="sect2">
<h3 id="_customizing_the_transactional_properties">Customizing the Transactional Properties</h3>
<div class="paragraph">
<p>Frequently it&#8217;s desirable to specify different values for some of the transaction properties
(e.g. read-only transactions, locking strategy, isolation level, etc.).  The <em>createAtomicBlock</em> method will
create a new <em>AtomicBlock</em> configured with the supplied values:</p>
</div>
<div class="listingblock">
<div class="title">Create an <strong>AtomicBlock</strong> with Custom Parameters</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.stm.GParsStm</span>
<span class="keyword">import</span> <span class="include">org.multiverse.api.AtomicBlock</span>
<span class="keyword">import</span> <span class="include">org.multiverse.api.PropagationLevel</span>

<span class="directive">final</span> TxnExecutor block = GParsStm.createTxnExecutor(<span class="key">maxRetries</span>: <span class="integer">3000</span>, <span class="key">familyName</span>: <span class="string"><span class="delimiter">'</span><span class="content">Custom</span><span class="delimiter">'</span></span>, <span class="key">PropagationLevel</span>: PropagationLevel.Requires, <span class="key">interruptible</span>: <span class="predefined-constant">false</span>)
<span class="keyword">assert</span> GParsStm.atomicWithBoolean(block) {
    <span class="predefined-constant">true</span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The customized <em>AtomicBlock</em> can then be used to create transactions using the specified settings.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<em>AtomicBlock</em> instances are thread-safe and can be freely reused among threads and transactions
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_using_the_em_transaction_em_object">Using the <em>Transaction</em> Object</h3>
<div class="paragraph">
<p>Atomic closures use the current <em>Transaction</em> as a parameter. The <em>Txn</em> object handle for a transaction can be used to manually control the transaction.
This is illustrated in the example below, where we use the <em>retry()</em> method to block the current transaction until the counter reaches the desired value:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.stm.GParsStm</span>
<span class="keyword">import</span> <span class="include">org.multiverse.api.PropagationLevel</span>
<span class="keyword">import</span> <span class="include">org.multiverse.api.TxnExecutor</span>

<span class="keyword">import</span> <span class="include">static</span> <span class="include">org.multiverse.api.StmUtils.newTxnInteger</span>

<span class="directive">final</span> TxnExecutor block = GParsStm.createTxnExecutor(<span class="key">maxRetries</span>: <span class="integer">3000</span>, <span class="key">familyName</span>: <span class="string"><span class="delimiter">'</span><span class="content">Custom</span><span class="delimiter">'</span></span>, <span class="key">PropagationLevel</span>: PropagationLevel.Requires, <span class="key">interruptible</span>: <span class="predefined-constant">false</span>)

<span class="keyword">def</span> counter = newTxnInteger(<span class="integer">0</span>)
<span class="directive">final</span> <span class="type">int</span> max = <span class="integer">100</span>

<span class="predefined-type">Thread</span>.start {
    <span class="keyword">while</span> (counter.atomicGet() &lt; max) {
        counter.atomicIncrementAndGet(<span class="integer">1</span>)
        sleep <span class="integer">10</span>
    }
}

<span class="keyword">assert</span> max + <span class="integer">1</span> == GParsStm.atomicWithInt(block) { tx -&gt;
    <span class="keyword">if</span> (counter.get() == max) <span class="keyword">return</span> counter.get() + <span class="integer">1</span>
    tx.retry()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_data_structures">Data Structures</h3>
<div class="paragraph">
<p>You might have noticed in previous examples that we use dedicated data structures to hold values.
The fact is that normal <strong>Java</strong> classes do not support transactions and thus cannot be used directly,
since <strong>Multiverse</strong> would not be able to share them safely among concurrent transactions, commit them nor roll them back.</p>
</div>
<hr>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
normal <strong>Java</strong> classes do not support transactions
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p>We need to use data that knows about transactions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>TxnIntRef</em></p>
</li>
<li>
<p><em>TxnLongRef</em></p>
</li>
<li>
<p><em>TxnBooleanRef</em></p>
</li>
<li>
<p><em>TxnDoubleRef</em></p>
</li>
<li>
<p><em>TxnRef</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You typically create these through the factory methods of the <em>org.multiverse.api.StmUtils</em> class.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_more_information">More Information</h3>
<div class="paragraph">
<p>We decided not to duplicate the information that was already available on the <strong>Multiverse</strong> website.</p>
</div>
<div class="paragraph">
<p>Unfortunately with the closure of Codehaus, that website is longer available. You may try to gather more information from the <a href="https://github.com/pveentjer/Multiverse">Multiverse source code</a>.</p>
</div>
<div class="paragraph">
<p>As we are unclear about the future of the <strong>Multiverse</strong> project, we will consider using a different <strong>STM</strong> implementation in a future <strong>GPars 2.0</strong>.</p>
</div>
<hr>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../images/divider.png" alt="divider" width="436">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_user_guide_to_strong_gae_strong">User Guide To <strong>GAE</strong></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_google_app_engine_integration">Google App Engine Integration</h3>
<div class="paragraph">
<p><strong>GPars</strong> can be run on the <a href="https://developers.google.com/appengine/">Google App Engine (<strong>GAE</strong>)</a>.  It can be made
part of <strong>Groovy</strong> and <strong>Java</strong> <em>GAE applications</em> as well as a plugged into <strong>Gaelyk</strong>.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="https://developers.google.com/appengine/">Google App Engine</a> is known as <strong>GAE</strong>
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p>The small <a href="https://github.com/musketyr/gpars-appengine">GPars App Engine integration library</a> provides all the necessary infrastructure to hook <strong>GAE</strong> services into <strong>GPars</strong>.
Although you&#8217;ll be running on <strong>GAE</strong> threads and leveraging <strong>GAE</strong> timer services, the high-level abstractions remain the same.
With a few restrictions you can still use <strong>GPars</strong> <em>actors, dataflow, agents, parallel collections</em> and other handy concepts.</p>
</div>
<div class="paragraph">
<p>Please refer to the <a href="https://github.com/musketyr/gpars-appengine">GPars App Engine library</a> for details on how to proceed with <strong>GPars</strong> on <strong>GAE</strong>.</p>
</div>
<hr>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../images/divider.png" alt="divider" width="436">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_user_guide_to_strong_remoting_strong">User Guide To <strong>Remoting</strong></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Concepts like <em>Actors</em>, <em>Dataflows</em> and <em>Agents</em> are not restricted just to a single VM. They provide an abstraction layer for concurrent programming that allows us to separate logic from low level synchronization code.
These concepts can be easly extend to multiple nodes in a network.</p>
</div>
<div class="paragraph">
<p>The following notes describe <strong>Remoting</strong> in <strong>GPars</strong>.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Remoting for <strong>GPars</strong> was a <em>Google Summer of Code 2014</em> project.
</td>
</tr>
</table>
</div>
<hr>
<div class="sect2">
<h3 id="_introduction_3">Introduction</h3>
<div class="paragraph">
<p>To use <em>Actors</em>, <em>Dataflows</em> or <em>Agent</em> remotely, a new remote proxy object was introduced with the <em>Remote</em> prefix.</p>
</div>
<div class="paragraph">
<p>The proxy object usually has an identical interface to it&#8217;s local counterpart. This allows us to use it in place of local counterpart.
Under the covers, a proxy object just sends messages over the wire to an original instance.</p>
</div>
<div class="paragraph">
<p>To transport messages across the network, the <a href="http://netty.io">Netty</a> library was used.</p>
</div>
<div class="paragraph">
<p>To create a proxy-object, the instance serialization mechanism was used (more in <strong>remote-serialization</strong> below).</p>
</div>
<div class="paragraph">
<p>The general approach to using remotes is as follows (details below):</p>
</div>
<div class="paragraph">
<p>At <em>host A</em>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create remoting context and start a server to handle incoming requests.</p>
</li>
<li>
<p>Publish an instance under a specified <em>name</em></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>At <em>host B</em>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create remoting context</p>
</li>
<li>
<p>Ask for an instance with specified <em>name</em> from <em>hostA:port</em>. A promise object is returned.</p>
</li>
<li>
<p>Get a proxy object from the promise.</p>
</li>
</ol>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
At this point, a new connection is created for each request
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_remote_serialization">Remote Serialization</h3>
<div class="paragraph">
<p>The following mechanism was used to create proxy objects:</p>
</div>
<div class="paragraph">
<p><em>object</em> &#8592;(serialization)&#8594; <em>handle</em> ---- [network] ---- <em>handle</em> &#8592;(serialization)&#8594; <em>proxy-object</em></p>
</div>
<div class="paragraph">
<p>One of the main advantages of this mechanism is that sending proxy-object references back is deserialized back to the original instance.</p>
</div>
<div class="paragraph">
<p>As all messages are seralized before sending over a wire, they must implement the <em>Serializable</em> interface.</p>
</div>
<div class="paragraph">
<p>This is a consequence of using built-in <strong>Java</strong> serialization mechanism and <strong>Netty</strong> <em>ObjectDecoder/ObjectEncoder</em>.
On the other hand, it gives us the flexibility to send any custom object as a message to an <strong>Actor</strong> or to use <strong>DataflowVariable</strong>(s) of any type.</p>
</div>
</div>
<div class="sect2">
<h3 id="_dataflows">Dataflows</h3>
<div class="paragraph">
<p>In order to use remoting for <em>Dataflows</em>, a context (<em>RemoteDataflows</em> class) has to be created. Within this context, <em>Dataflows</em> can be published and retrieved from remote hosts.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> remoteDataflows = RemoteDataflows.create()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In all subsections we assume that a context has already been created as shown above.
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p>After creating a context, if we want to allow other hosts to retrieve published <em>Dataflows</em>, we need to start a server.
We need to provide an address and port to listen on (say, like: <em>localhost</em>:11222, or 10.0.0.123:11333).</p>
</div>
<div class="listingblock">
<div class="title">Start A Remote Server</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>remoteDataflows.startServer HOST PORT</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>To stop the server, we have a <em>stopServer()</em> method. Note that both <em>start</em> and <em>stop</em> methods are asynchronous, and they don&#8217;t block; the server is started/stopped in the background.</p>
</div>
<div class="paragraph">
<p>Multiple execution of these methods or executing them in wrong order will raise an exception.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To only retrieve instances from remote hosts, starting a server is not necessary.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_dataflowvariable">DataflowVariable</h3>
<div class="paragraph">
<p>The <strong>DataflowVariable</strong> is a core part of <em>Dataflows</em> subsystem that gains remoting abilities. Other structures(?) and subsystems depend on it.</p>
</div>
<div class="paragraph">
<p>Publishing a variable within context is done simply by:</p>
</div>
<div class="listingblock">
<div class="title">Publishing a Context</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> variable = <span class="keyword">new</span> DataflowVariable()
remoteDataflows.publish variable <span class="string"><span class="delimiter">&quot;</span><span class="content">my-first-variable</span><span class="delimiter">&quot;</span></span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This registers the variable under a given name, so when a request for a variable with name <em>my-first-variable</em> arrives, the variable can be sent to the remote host.</p>
</div>
<div class="paragraph">
<p>It&#8217;s important to remember that publishing another variable under the same name, will override the provious one and subsequent requests will send the newly published one.</p>
</div>
<div class="paragraph">
<p>Variable retrieval is done by:</p>
</div>
<div class="listingblock">
<div class="title">Variable Retrieval</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> remoteVariablePromise = remoteDataflows.getVariable HOST, PORT, <span class="string"><span class="delimiter">&quot;</span><span class="content">my-first-variable</span><span class="delimiter">&quot;</span></span>
<span class="keyword">def</span> remoteVariable = remoteVariablePromise.get()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>getVariable</em> method is non-blocking and returns a promise object that will eventually hold a proxy object to that variable.
This proxy has the same interface as a <strong>DataflowVariable</strong> and can be used seemlessly as a regular variable.</p>
</div>
<div class="paragraph">
<p>To explore a full example see our: <em>groovyx.gpars.samples.remote.dataflow.variable</em> code</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_dataflowbroadcast">DataflowBroadcast</h3>
<div class="paragraph">
<p>It&#8217;s possible to subscribe to a <strong>DataflowBroadcast</strong> on a remote host. To do this, we had to have published it first (assuming the context already exists):</p>
</div>
<div class="listingblock">
<div class="title">A DataflowBroadcast Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> stream = <span class="keyword">new</span> DataflowBroadcast()
remoteDataflows.publish stream <span class="string"><span class="delimiter">&quot;</span><span class="content">my-first-broadcast</span><span class="delimiter">&quot;</span></span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then on the other host, it can be retrieved:</p>
</div>
<div class="listingblock">
<div class="title">A Retrieval Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> readChannelPromise = remoteDataflows.getReadChannel HOST, PORT, <span class="string"><span class="delimiter">&quot;</span><span class="content">my-first-broadcast</span><span class="delimiter">&quot;</span></span>
<span class="keyword">def</span> readChannel = readChannelPromise.get()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The proxy object has the same interface as a <strong>ReadChannel</strong> and can be used in the same fashion as a <strong>ReadChannel</strong> of a regular <strong>DataflowBroadcast</strong>.</p>
</div>
<div class="paragraph">
<p>To explore a full example, please see: <em>groovyx.gpars.samples.remote.dataflow.broadcast</em></p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_dataflowqueue">DataflowQueue</h3>
<div class="paragraph">
<p>The <strong>DataflowQueue</strong> feature received similar functionality, and is published like this :</p>
</div>
<div class="listingblock">
<div class="title">A Publish Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> queue = <span class="keyword">new</span> DataflowQueue()
remoteDataflows.publish queue, <span class="string"><span class="delimiter">&quot;</span><span class="content">my-first-queue</span><span class="delimiter">&quot;</span></span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>and in similar way, we can retrieved it from the remote host:</p>
</div>
<div class="listingblock">
<div class="title">Retrieval from Remote Sources</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> queuePromise = remoteDataflows.getQueue HOST, PORT, <span class="string"><span class="delimiter">&quot;</span><span class="content">my-first-queue</span><span class="delimiter">&quot;</span></span>
<span class="keyword">def</span> queue = queuePromise.get()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>New items can be pushed into the queue of the remote proxy. Such elements are sent over-the-wire to the original instance and pushed into it.</p>
</div>
<div class="paragraph">
<p>Retrieval commands send a request for an element to the <strong>original</strong> instance.</p>
</div>
<div class="paragraph">
<p>Conceptually, the remote proxy is an <em>interface</em> - it just sends requests to an original instance.</p>
</div>
<div class="paragraph">
<p>To explore a full example see: <em>groovyx.gpars.samples.remote.dataflow.queue</em> or <em>groovyx.gpars.samples.remote.dataflow.queuebalancer</em></p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_actors_3">Actors</h3>
<div class="paragraph">
<p>The <code>Remote Actors</code> subsystem is designed in a similar way.</p>
</div>
<div class="paragraph">
<p>To start a <em>RemoteActors</em> class, a context must be created. Then within this context, an <em>Actors</em> instance can be published or retrieved from a remote host.</p>
</div>
<div class="listingblock">
<div class="title">Remote Creation</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> remoteActors = RemoteActors.create()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Publishing :</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> actor = ...
remoteActors.publish actor, <span class="string"><span class="delimiter">&quot;</span><span class="content">actor-name</span><span class="delimiter">&quot;</span></span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Retrieval :</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> actorPromise = remoteActors.get HOST, PORT, <span class="string"><span class="delimiter">&quot;</span><span class="content">actor-name</span><span class="delimiter">&quot;</span></span>
<span class="keyword">def</span> remoteActor = actorPromise.get()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s possible to join a remote <strong>Actor</strong>, but this will block until the original <strong>Actor</strong> ends its work. Sending replies and the <em>sendAndWait</em> method are supported as well.</p>
</div>
<div class="paragraph">
<p>One can send any object as a message to an <strong>Actor</strong>, but keep in mind it has to be <strong class="blue">Serializable</strong>.</p>
</div>
<div class="paragraph">
<p>See example: <em>groovyx.gpars.samples.remote.actor</em></p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_remote_actor_names">Remote Actor Names</h3>
<div class="paragraph">
<p>A <em>RemoteActors</em> class context may be identified by a name. To create one with a name use:</p>
</div>
<div class="listingblock">
<div class="title">Create A Named Context</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> remoteActors = RemoteActors.create <span class="string"><span class="delimiter">&quot;</span><span class="content">test-group-1</span><span class="delimiter">&quot;</span></span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Actors</em> published within this context may be accessed by providing a special <strong>Actor</strong> URL.</p>
</div>
<div class="paragraph">
<p>For example: publishing an <strong>actor</strong> under the name  of <span class="blue">actor</span> within this context makes it accessible under the URL "test-group-1/actor".</p>
</div>
<div class="listingblock">
<div class="title">A Named Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> actor = remoteActors.get <span class="string"><span class="delimiter">&quot;</span><span class="content">test-group-1/actor</span><span class="delimiter">&quot;</span></span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The host and port of an instance holding this actor is determined automatically.</p>
</div>
<div class="paragraph">
<p>Invoking the <em>get</em> method will send a broadcast query to <em>255.255.255.255</em> with a search for an actor within a context with that specific name.
A matching instance responds to that query with necessary information like host and port.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Allowed Actor and Context Names</div>
<div class="paragraph">
<p>As the URL can contain "\\" (backslash) as a separator between context and actor name, we cannot use backslashes in an actor&#8217;s name, but a context name can contain any UTF characters.</p>
</div>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_agents_2">Agents</h3>
<div class="paragraph">
<p>A <code>Remote Agent</code> system is designed in similar fashion.</p>
</div>
<div class="paragraph">
<p>First, a <em>RemoteAgents</em> class context must be created. Within this context, <em>Agents</em> can be published or retrieved from remote hosts.</p>
</div>
<div class="listingblock">
<div class="title">A Remote Create Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> remoteAgents = RemoteAgents.create()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Publishing :</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> agent = ...
remoteAgents.publish agent, <span class="string"><span class="delimiter">&quot;</span><span class="content">agent-name</span><span class="delimiter">&quot;</span></span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Retrieval :</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> agentPromise = remoteAgents.get HOST, PORT, <span class="string"><span class="delimiter">&quot;</span><span class="content">agent-name</span><span class="delimiter">&quot;</span></span>
<span class="keyword">def</span> remoteAgent = agentPromise.get()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are two ways to execute closures used to update the state of a remote <em>Agent</em> instance:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>remote</em> - closure is serialized and sent to original instance and executed in that context</p>
</li>
<li>
<p><em>local</em> - current state is retrieved and closure is executed where the update originated, then updated value is sent to original instance. Concurrent changes to <em>Agent</em> wait until this process ends.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By default, a remote <em>Agent</em> uses a <em>remote</em> execution policy, but we can change it if necessary :</p>
</div>
<div class="listingblock">
<div class="title">Changing Policy to LOCAL</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> agentPromise = remoteAgents.get HOST, PORT, <span class="string"><span class="delimiter">&quot;</span><span class="content">agent</span><span class="delimiter">&quot;</span></span>
<span class="keyword">def</span> remoteAgent =  agentPromise.get()
remoteAgent.executionPolicy = AgentClosureExecutionPolicy.LOCAL</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../images/divider.png" alt="divider" width="436">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_general_strong_gpars_strong_tips">General <strong>GPars</strong> Tips</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_grouping_2">Grouping</h3>
<div class="paragraph">
<p>High-level concurrency concepts, like <strong>Agents, Actors</strong> or <strong>Dataflow</strong> tasks and operators can be grouped around shared thread pools.
The <em>PGroup</em> class and its sub-classes represent convenient <strong>GPars</strong> wrappers around thread pools.
Objects created using the group&#8217;s factory methods will share the group&#8217;s thread pool.</p>
</div>
<div class="listingblock">
<div class="title">A <strong>xxxPGroup</strong> Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> group1 = <span class="keyword">new</span> DefaultPGroup()
<span class="keyword">def</span> group2 = <span class="keyword">new</span> NonDaemonPGroup()

group1.with {
    task {...}
    task {...}
    <span class="keyword">def</span> op = operator(...) {...}
    <span class="keyword">def</span> actor = actor{...}
    <span class="keyword">def</span> anotherActor = group2.actor{...}  <span class="comment">//will belong to group2</span>
    <span class="keyword">def</span> agent = safe(<span class="integer">0</span>)
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Groups For Thread Pools</div>
<div class="paragraph">
<p>When customizing the thread pools for groups, consider using the existing <strong>GPars</strong> implementations - the <em>DefaultPool</em> or <em>ResizeablePool</em> classes.
Or you may wish to create your own implementation of the <em>groovyx.gpars.scheduler.Pool</em> interface to pass to the <em>DefaultPGroup</em> or <em>NonDaemonPGroup</em> constructors.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_java_api">Java API</h3>
<div class="paragraph">
<p>Much of <strong>GPars</strong> functionality can be used from <strong>Java</strong> just as well as from <strong>Groovy</strong>. Checkout the <code>Java API - Using <strong>GPars</strong> from Java</code> section of this <code>User Guide</code>.
Then experiment with the Maven-based stand-alone Java demo applications.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Take <strong>GPars</strong> with you wherever you go!
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_performance_2">Performance</h3>
<div class="paragraph">
<p>Your code in <strong>Groovy</strong> can be just as fast as code written in <strong>Java</strong>, <strong>Scala</strong> or any other programing language.
This should not be surprising, since <strong>GPars</strong> is technically a solid tasty Java-made cake with a Groovy DSL frosting on it.</p>
</div>
<div class="paragraph">
<p>Unlike <strong>Java</strong>, however, with <strong>GPars</strong>, as well as with other DSL-friendly languages, you are very likely to experience a useful code speed-up for free.
This speed-up comes from a better and cleaner design of your application.</p>
</div>
<div class="paragraph">
<p>Coding with a concurrency DSL will give you a smaller code-base with code using the concurrency primitives as language constructs.
So it&#8217;s much easier to build robust concurrent applications, identify potential bottle-necks or errors and then eliminate them.</p>
</div>
<div class="paragraph">
<p>While this whole <code>User Guide</code> is describing how to use <strong>Groovy</strong> and <strong>GPars</strong> to create beautiful and robust concurrent code,
we wanted to use some of these tips to highlight a few places where some code tuning or minor design compromises could give you interesting performance gains.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_parallel_collections_3">Parallel Collections</h3>
<div class="paragraph">
<p>Methods like parallel collection processing, like <em>eachParallel()</em> , <em>collectParallel()</em> and such-like, use <em>Parallel Array</em> , an efficient tree-like data structure behind the scenes.
This data structure has to be built from the original collection each time you call any of the parallel collection methods.
Thus when chaining parallel method calls, you might consider using the <em>map/reduce</em> API instead or alternatively, use the <em>ParallelArray</em> API directly to avoid the <em>Parallel Array</em> creation overhead.</p>
</div>
<div class="listingblock">
<div class="title">A Sample of Parallel Finds</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.GParsPool</span>;
GParsPool.withPool {
    people.findAllParallel{<span class="local-variable">it</span>.isMale()}.collectParallel{<span class="local-variable">it</span>.name}.any{<span class="local-variable">it</span> == <span class="string"><span class="delimiter">'</span><span class="content">Joe</span><span class="delimiter">'</span></span>}
    people.parallel.filter{<span class="local-variable">it</span>.isMale()}.map{<span class="local-variable">it</span>.name}.filter{<span class="local-variable">it</span> == <span class="string"><span class="delimiter">'</span><span class="content">Joe</span><span class="delimiter">'</span></span>}.size() &gt; <span class="integer">0</span>
    people.parallelArray.withFilter({<span class="local-variable">it</span>.isMale()} <span class="keyword">as</span> <span class="predefined-type">Predicate</span>).withMapping({<span class="local-variable">it</span>.name} <span class="keyword">as</span> Mapper).any{<span class="local-variable">it</span> == <span class="string"><span class="delimiter">'</span><span class="content">Joe</span><span class="delimiter">'</span></span>} != <span class="predefined-constant">null</span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>In many scenarios, changing the pool size from the default value can give you performance benefits. Especially if your tasks perform IO operations, such as file or database access, networking, etc.
So increasing the number of threads in the pool is likely to help performance.</p>
</div>
<div class="listingblock">
<div class="title">Bump PoolSize To Boost Performance</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.GParsPool</span>;
GParsPool.withPool(<span class="integer">50</span>) {
    ...
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the closures you provide to the parallel collection processing methods are executed frequently, and concurrently, you may further slightly benefit from turning them into Java.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_actors_4">Actors</h3>
<div class="paragraph">
<p><strong>GPars</strong> actors are fast. <em>DynamicDispatchActors</em> and <em>ReactiveActors</em> are about twice as fast as the <em>DefaultActors</em>,  since they don&#8217;t have to maintain an implicit state between subsequent message arrivals.
The <em>DefaultActors</em> are, in fact, on a par in performance with actors from <strong>Scala</strong> , which you rarely hear of as being slow.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If top performance is what you&#8217;re looking for then identify patterns in your code !
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p>If top performance is what you&#8217;re looking for, a good start is to identify the following patterns in your actor code:</p>
</div>
<div class="listingblock">
<div class="title">A Pattern To Look For</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td>
  <td class="code"><pre>actor {
    loop {
        react {msg -&gt;
            <span class="keyword">switch</span>(msg) {
                <span class="keyword">case</span> <span class="predefined-type">String</span>:...
                case <span class="predefined-type">Integer</span>:...
            }
        }
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">A Better Replacement : <em>DynamicDispatchActor</em> :</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>messageHandler {
    when{<span class="predefined-type">String</span> msg -&gt; ...}
    when{<span class="predefined-type">Integer</span> msg -&gt; ...}
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>loop</em> and <em>react</em> methods are rather costly to call.</p>
</div>
<div class="paragraph">
<p>Defining a <em>DynamicDispatchActor</em> or <em>ReactiveActor</em> as classes instead of using the <em>messageHandler</em> and
<em>reactor</em> factory methods will also give you some more speed:</p>
</div>
<div class="listingblock">
<div class="title">A Dynamic Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre><span class="type">class</span> <span class="class">MyHandler</span> <span class="directive">extends</span> DynamicDispatchActor {
    <span class="directive">public</span> <span class="type">void</span> handleMessage(<span class="predefined-type">String</span> msg) {
        ...
    }

    <span class="directive">public</span> <span class="type">void</span> handleMessage(<span class="predefined-type">Integer</span> msg) {
        ...
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, convert that <em>MyHandler</em> class to Java to squeeze the last bit of performance from <strong>GPars</strong>.</p>
</div>
<hr>
<div class="sect3">
<h4 id="_pool_adjustment">Pool Adjustment</h4>
<div class="paragraph">
<p><strong>GPars</strong> allows you to group actors around thread pools, giving you the freedom to organize actors any way you like.
It&#8217;s always worthwhile to experiment with the actor pool size and type.</p>
</div>
<div class="paragraph">
<p><em>FJPool</em> usually gives better characteristics than <em>DefaultPool</em>, but seems to be more sensitive to the number of threads in the pool.
Sometimes, using a <em>ResizeablePool</em> or <em>ResizeableFJPool</em> can help performance by automatic eliminating unneeded threads.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> attackerGroup = <span class="keyword">new</span> DefaultPGroup(<span class="keyword">new</span> ResizeableFJPool(<span class="integer">10</span>))
<span class="keyword">def</span> defenderGroup = <span class="keyword">new</span> DefaultPGroup(<span class="keyword">new</span> DefaultPool(<span class="integer">5</span>))

<span class="keyword">def</span> attacker = attackerGroup.actor {...}
<span class="keyword">def</span> defender = defenderGroup.messageHandler {...}
...</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="__strong_agents_strong"><strong>Agents</strong></h3>
<div class="paragraph">
<p><strong>GPars Agents</strong> are even a bit faster in processing messages than <strong>actors</strong>.
The advice to group <strong>agents</strong> wisely around thread pools, and then tune the pool sizes and types, applies to <strong>agents</strong> as well as <strong>actors</strong>.
With <strong>agents</strong>, you may also benefit from submitting Java-written closures as messages.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Share Your Experience</div>
<div class="paragraph">
<p>The more we hear about <strong>GPars</strong> uses in the wild, the better we can adapt it for the future. Let us know how you use <strong>GPars</strong> and how it performs.
Send us your benchmarks, performance comparisons or profiling reports to help us tune <strong>GPars</strong> for you. See <a href="../User_Voices.html">this page for more details.</a></p>
</div>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_hosted_environments">Hosted Environments</h3>
<div class="paragraph">
<p>Hosted environments, such as <em>Google App Engine</em>, can impose additional restrictions on threading.
For <strong>GPars</strong> to better  integrate with these environments, the default thread factory and timer factory can be customized.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Hosted environments like <em>Google App Engine</em> impose restrictions on threading
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p>The <strong>GPars_Config</strong> class provides static initialization methods allowing third parties to register their own
implementations of the <em>PoolFactory</em> and <em>TimerFactory</em> interfaces. These can then be used to create default pools and timers for <strong>Actors</strong>, <strong>Dataflow</strong> and <strong>PGroups</strong>.</p>
</div>
<div class="listingblock">
<div class="title">Some Static Methods To Initialize Objects</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">GParsConfig</span> {
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">volatile</span> PoolFactory poolFactory;
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">volatile</span> TimerFactory timerFactory;

    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> setPoolFactory(<span class="directive">final</span> PoolFactory pool)

    <span class="directive">public</span> <span class="directive">static</span> PoolFactory getPoolFactory()

    <span class="directive">public</span> <span class="directive">static</span> Pool retrieveDefaultPool()

    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> setTimerFactory(<span class="directive">final</span> TimerFactory timerFactory)

    <span class="directive">public</span> <span class="directive">static</span> TimerFactory getTimerFactory()

    <span class="directive">public</span> <span class="directive">static</span> GeneralTimer retrieveDefaultTimer(<span class="directive">final</span> <span class="predefined-type">String</span> name, <span class="directive">final</span> <span class="type">boolean</span> daemon)

    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> shutdown()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Custom factories should be registered immediately after application startup in order for <strong>Actors</strong> and <strong>Dataflow</strong> to be able to use them for their default groups.</p>
</div>
<hr>
<div class="sect3">
<h4 id="_shutdown">Shutdown</h4>
<div class="paragraph">
<p>The <em>GParsConfig.shutdown()</em> method can be used in managed environments to properly shutdown all
asynchronously running timers and free up the memory from all thread-local variables.</p>
</div>
<div class="paragraph">
<p>After a call to this method, the <strong>GPars</strong> library can no longer provide the declared services.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compatibility">Compatibility</h3>
<div class="paragraph">
<p>Some further compatibility issues can occur when running <strong>GPars</strong> in a hosted environment.</p>
</div>
<div class="paragraph">
<p>The most noticeable one is probably the lack of <strong>ForkJoinThreadPool</strong> support in <strong>GAE</strong>. Mechanisms like <strong>Fork/Join</strong> and <strong>GParsPool</strong> may not be available on some services as a result.
However, <strong>GParsExecutorsPool, Dataflow, Actors, Agents</strong> and <strong>STM</strong> should work normally even when using managed non-Java SE thread pools.</p>
</div>
<hr>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../images/divider.png" alt="divider" width="436">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_user_guide_to_strong_the_conclusion_strong">User Guide To <strong>The Conclusion</strong></h2>
<div class="sectionbody">
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This was quite a wild ride, wasn&#8217;t it?
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p>Now, after reading this <strong>User Guide</strong>, you&#8217;re certainly ready to build fast, robust, reliable and concurrent applications.</p>
</div>
<div class="paragraph">
<p>You&#8217;ve seen that there are many concepts you can choose from and each has its own areas of applicability. The ability to pick the right concept to apply is key to being a successful developer.</p>
</div>
<div class="paragraph">
<p>If you feel you can do this with <strong>GPars</strong>, the mission of this <strong>User Guide</strong> has been accomplished.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Now, go ahead, use <strong>GPars</strong> and have fun!
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 2.0<br>
Last updated 2017-01-09 15:48:17 +01:00
</div>
</div>
</body>
</html>