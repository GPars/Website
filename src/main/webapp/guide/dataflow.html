<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.2">
<meta name="description" content="GPars is a multi-paradigm concurrency framework offering several mutually cooperating high-level concurrency abstractions.">
<meta name="author" content="The Whole GPars Team &lt;https://groups.google.com/forum/#!forum/gpars-users&gt;">
<title>User Guide to Dataflow</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.2.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>User Guide to Dataflow</h1>
<div class="details">
<span id="author" class="author">The Whole GPars Team &lt;https://groups.google.com/forum/#!forum/gpars-users&gt;</span><br>
<span id="revnumber">version 1.0,</span>
<span id="revdate">2015-11-01</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Document Index</div>
<ul class="sectlevel1">
<li><a href="#_introduction">Introduction</a>
<ul class="sectlevel2">
<li><a href="#_implementation_detail">Implementation Detail</a></li>
<li><a href="#_benefits">Benefits</a></li>
</ul>
</li>
<li><a href="#_concepts">Concepts</a>
<ul class="sectlevel2">
<li><a href="#_dataflow_programming">Dataflow Programming</a></li>
<li><a href="#_principles">Principles</a></li>
<li><a href="#_dataflow_queues_and_broadcasts">Dataflow Queues and Broadcasts</a></li>
<li><a href="#_dataflowstream">DataflowStream</a></li>
<li><a href="#_bind_handlers">Bind Handlers</a></li>
<li><a href="#_bind_handlers_grouping">Bind Handlers Grouping</a></li>
<li><a href="#_bind_handler_chaining">Bind Handler Chaining</a></li>
<li><a href="#_lazy_strong_dataflow_strong_tasks_and_variables">Lazy <strong>Dataflow</strong> Tasks and Variables</a></li>
<li><a href="#_dataflow_expressions">Dataflow Expressions</a></li>
<li><a href="#_bind_error_notification">Bind Error Notification</a></li>
<li><a href="#_further_reading">Further Reading</a></li>
</ul>
</li>
<li><a href="#_tasks">Tasks</a>
<ul class="sectlevel2">
<li><a href="#_a_simple_mashup_example">A Simple Mashup Example</a></li>
<li><a href="#_grouping_tasks">Grouping Tasks</a></li>
<li><a href="#_a_mashup_variant_with_methods">A Mashup Variant With Methods</a></li>
<li><a href="#_a_physical_calculation_example">A Physical Calculation Example</a></li>
<li><a href="#_deterministic_deadlocks">Deterministic Deadlocks</a></li>
<li><a href="#__strong_dataflows_strong_map"><strong>Dataflows</strong> Map</a></li>
<li><a href="#_returning_values_from_a_task">Returning Values From A Task</a></li>
<li><a href="#_joining_tasks">Joining Tasks</a></li>
</ul>
</li>
<li><a href="#_selects">Selects</a></li>
<li><a href="#_guards">Guards</a>
<ul class="sectlevel2">
<li><a href="#_priority_select">Priority Select</a></li>
<li><a href="#_collecting_results_of_asynchronous_computations">Collecting Results of Asynchronous Computations</a></li>
<li><a href="#_timeouts">Timeouts</a></li>
<li><a href="#_cancellations">Cancellations</a></li>
</ul>
</li>
<li><a href="#_operators">Operators</a>
<ul class="sectlevel2">
<li><a href="#_concepts_2">Concepts</a></li>
<li><a href="#_constructing_operators">Constructing Operators</a></li>
<li><a href="#_holding_state_in_operators">Holding State in Operators</a></li>
<li><a href="#_parallelize_operators">Parallelize Operators</a></li>
<li><a href="#_selectors">Selectors</a></li>
</ul>
</li>
<li><a href="#_shutting_down_dataflow_networks">Shutting Down Dataflow Networks</a>
<ul class="sectlevel2">
<li><a href="#_emergency_shutdown">Emergency Shutdown</a></li>
<li><a href="#_poisonpill">PoisonPill</a></li>
<li><a href="#_immediate_poison_pill">Immediate Poison Pill</a></li>
<li><a href="#_poison_with_counting">Poison With Counting</a></li>
<li><a href="#_poison_strategies">Poison Strategies</a></li>
<li><a href="#_termination_tips_and_tricks">Termination Tips and Tricks</a></li>
<li><a href="#_keeping_poisonpill_inside_a_given_network">Keeping PoisonPill Inside a Given Network</a></li>
<li><a href="#_graceful_shutdown">Graceful Shutdown</a></li>
</ul>
</li>
<li><a href="#_application_frameworks">Application Frameworks</a>
<ul class="sectlevel2">
<li><a href="#_building_flow_frameworks_on_top_of_strong_gpars_dataflow_strong">Building Flow Frameworks on Top of <strong>GPars Dataflow</strong></a></li>
</ul>
</li>
<li><a href="#_pipeline_dsl">Pipeline DSL</a>
<ul class="sectlevel2">
<li><a href="#_a_dsl_for_building_operators_pipelines">A DSL for Building Operators Pipelines</a></li>
<li><a href="#_overriding_the_default_strong_pgroup_strong">Overriding the Default <strong>PGroup</strong></a></li>
<li><a href="#_the_pipeline_builder">The Pipeline Builder</a></li>
<li><a href="#_passing_construction_parameters_through_the_pipeline_dsl">Passing Construction Parameters Through the Pipeline DSL</a></li>
</ul>
</li>
<li><a href="#_implementation">Implementation</a>
<ul class="sectlevel2">
<li><a href="#_combining_strong_actors_strong_and_code_dataflow_concurrency_code">Combining <strong>Actors</strong> and <code>Dataflow Concurrency</code></a></li>
<li><a href="#_using_plain_strong_java_strong_threads">Using Plain <strong>Java</strong> Threads</a></li>
</ul>
</li>
<li><a href="#_synchronous_variables_and_channels">Synchronous Variables and Channels</a>
<ul class="sectlevel2">
<li><a href="#_synchronous_dataflow_queue">Synchronous Dataflow Queue</a></li>
<li><a href="#_synchronous_dataflow_broadcast">Synchronous Dataflow Broadcast</a></li>
<li><a href="#_synchronous_dataflow_variable">Synchronous Dataflow Variable</a></li>
</ul>
</li>
<li><a href="#_kanban_flow">Kanban Flow</a>
<ul class="sectlevel2">
<li><a href="#_kanbanflow">KanbanFlow</a></li>
</ul>
</li>
<li><a href="#_classic_examples">Classic Examples</a>
<ul class="sectlevel2">
<li><a href="#_the_sieve_of_eratosthenes_implementation_using_code_dataflow_tasks_code">The Sieve of Eratosthenes Implementation using <code>Dataflow Tasks</code></a></li>
<li><a href="#_the_sieve_of_eratosthenes_using_both_code_dataflow_tasks_code_and_code_operators_code">The Sieve of Eratosthenes using both <code>Dataflow Tasks</code> and <code>Operators</code></a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><strong>Dataflow</strong> concurrency offers an alternative concurrency model, which is inherently safe and robust.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Check out this small example written in <strong>Groovy</strong> using <strong>GPars</strong> to sum results of calculations performed by three concurrently run tasks:</p>
</div>
<div class="listingblock">
<div class="title">A Simple Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

<span class="directive">final</span> <span class="keyword">def</span> x = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> y = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> z = <span class="keyword">new</span> DataflowVariable()

task {
    z &lt;&lt; x.val + y.val
}

task {
    x &lt;&lt; <span class="integer">10</span>
}

task {
    y &lt;&lt; <span class="integer">5</span>
}

println <span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="inline"><span class="inline-delimiter">${</span>z.val<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Or the same algorithm rewritten using the <em>Dataflows</em> class.</p>
</div>
<div class="listingblock">
<div class="title">A <em>Dataflows</em> Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

<span class="directive">final</span> <span class="keyword">def</span> df = <span class="keyword">new</span> Dataflows()

task {
    df.z = df.x + df.y
}

task {
    df.x = <span class="integer">10</span>
}

task {
    df.y = <span class="integer">5</span>
}

println <span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="inline"><span class="inline-delimiter">${</span>df.z<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>We start three logical tasks, which can run in parallel and perform their particular activities. The tasks
need to exchange data and they do so using <code>Dataflow Variables</code>.  Think of <code>Dataflow Variables</code> as one-shot
channels safely and reliably transferring data from producers to their consumers.</p>
</div>
<div class="paragraph">
<p>The <code>Dataflow Variables</code> have pretty straightforward semantics. When a task needs to read a value from a
<code>DataflowVariable</code> (through the val property), it will block until the value has been set by another task or
thread (using the <strong class="red">'&lt;&lt;'</strong> operator). Each <code>Dataflow Variable</code> can be set <strong>only once</strong> in its lifetime.</p>
</div>
<div class="paragraph">
<p>Notice that you don&#8217;t have to bother with ordering and synchronizing the tasks or threads and their access to shared variables.
The values are magically transferred among tasks at the right time without your intervention.
The data flow seamlessly among tasks / threads without your intervention or care.</p>
</div>
<hr>
<div class="sect2">
<h3 id="_implementation_detail">Implementation Detail</h3>
<div class="paragraph">
<p>The three tasks in the example <strong class="blue">do not necessarily need to be mapped to three physical threads</strong>. Tasks represent so-called "green" or "logical" threads and can be mapped under the covers to any number of physical threads.
The actual mapping depends on the scheduler, but the outcome of dataflow algorithms doesn&#8217;t depend on the actual scheduling.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Re-binding Is Possible</div>
<div class="paragraph">
<p>The <em>bind</em> operation of <code>dataflow variables</code> silently accepts re-binding to a value, which is equal to an already bound value. We can call the <em>bindUnique</em> method to reject equal values on already-bound variables.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_benefits">Benefits</h3>
<div class="paragraph">
<p>Here&#8217;s what you gain by using <code>Dataflow Concurrency</code> (by <a href="http://www.jonasboner.com">Jonas Bonér</a>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No race-conditions</p>
</li>
<li>
<p>No live-locks</p>
</li>
<li>
<p>Deterministic deadlocks</p>
</li>
<li>
<p>Completely deterministic programs</p>
</li>
<li>
<p>BEAUTIFUL code.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This doesn&#8217;t sound bad, does it?</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_concepts">Concepts</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_dataflow_programming">Dataflow Programming</h3>
<hr>
<div class="sect3">
<h4 id="_quoting_wikipedia">Quoting Wikipedia</h4>
<div class="paragraph">
<p>Operations (in <code>Dataflow</code> programs) consist of "black boxes" with inputs and outputs, all of which are always explicitly defined.
They run as soon as all of their inputs become valid, as opposed to when the program encounters them.
Whereas a traditional program essentially consists of a series of statements saying "do this, now do this", a <code>dataflow</code> program is more like a series of workers on an assembly line,
who will do their assigned task as soon as the materials arrive.</p>
</div>
<div class="paragraph">
<p>This is why dataflow languages are inherently parallel: the operations have no hidden state to keep track of, and the operations are all "ready" at the same time.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_principles">Principles</h3>
<div class="paragraph">
<p>With <code>Dataflow Concurrency</code>, you can safely share variables across tasks. These variable (in <strong>Groovy</strong> instances of the <code>DataflowVariable</code> class) can only be assigned (using the <strong class="red">'&lt;&lt;'</strong> operator) a value  once in their lifetime.
The values of the variables, on the other hand, can be read multiple times (in <strong>Groovy</strong> through the <code>val</code> property), even before the value has been assigned. In such cases, the reading task is suspended until the value is set by another task.
So you can simply write your code for each task sequentially using <code>Dataflow Variables</code> and the underlying mechanics will make sure you get all the values you need in a thread-safe manner.</p>
</div>
<div class="paragraph">
<p>In brief, you generally perform three operations with <code>Dataflow variables</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create a <code>dataflow variable</code></p>
</li>
<li>
<p>Wait for the variable to be bound (read it)</p>
</li>
<li>
<p>Bind the variable (write to it)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And these are the three essential rules your programs have to follow:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When the program encounters an unbound variable it waits for a value.</p>
</li>
<li>
<p>It&#8217;s not possible to change the value of a dataflow variable once it&#8217;s bound.</p>
</li>
<li>
<p><code>Dataflow variables</code> makes it easy to create concurrent stream agents.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_dataflow_queues_and_broadcasts">Dataflow Queues and Broadcasts</h3>
<div class="paragraph">
<p>Before you check our samples of <strong>Dataflow Variables</strong>, <strong>Tasks</strong> and <strong>Operators</strong>, you should learn a bit about streams and queues to have a full picture of <code>Dataflow Concurrency</code>.
Except for <code>dataflow variables</code>, there are also the concepts of <em>DataflowQueues</em> and <em>DataflowBroadcast</em> that you can leverage in your code.</p>
</div>
<div class="paragraph">
<p>You may think of them as thread-safe buffers or queues for message transfer among concurrent tasks or threads. Check out a typical producer-consumer demo:</p>
</div>
<div class="listingblock">
<div class="title">A Producer-Consumer Demo</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

<span class="keyword">def</span> words = [<span class="string"><span class="delimiter">'</span><span class="content">Groovy</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">fantastic</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">concurrency</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">fun</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">enjoy</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">safe</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">GPars</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">data</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">flow</span><span class="delimiter">'</span></span>]
<span class="directive">final</span> <span class="keyword">def</span> buffer = <span class="keyword">new</span> DataflowQueue()

task {
    <span class="keyword">for</span> (word <span class="keyword">in</span> words) {
        buffer &lt;&lt; word.toUpperCase()  <span class="comment">//add to the buffer</span>
    }
}

task {
    <span class="keyword">while</span>(<span class="predefined-constant">true</span>) println buffer.val  <span class="comment">//read from the buffer in a loop</span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Both <em>DataflowBroadcasts</em> and <em>DataflowQueues</em> , just like <code>DataflowVariables</code> , implement the <code>DataflowChannel</code> interface with common methods allowing us to write to them and read values from them.</p>
</div>
<div class="paragraph">
<p>The ability to treat both types identically through the <em>DataflowChannel</em> interface comes in handy once you start using them to wire <em>tasks</em> , <em>operators</em> or <em>selectors</em> together.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">DataflowChannels Combine Two Interfaces</div>
<div class="paragraph">
<p>The <em>DataflowChannel</em> interface combines two interfaces, each serving its purpose:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>DataflowReadChannel holds all the methods necessary for reading values from a channel - <strong>getVal()</strong>, <strong>getValAsync()</strong>, <strong>whenBound()</strong>, etc.</p>
</li>
<li>
<p>DataflowWriteChannel holds all the methods necessary for writing values into a channel - <strong>bind()</strong>, <strong class="red">'&lt;&lt;'</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You may prefer using these dedicated interfaces instead of the general <em>DataflowChannel</em> interface, to better express your intended usage.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Please refer to the API doc for more details on the channel interfaces.</p>
</div>
<hr>
<div class="sect3">
<h4 id="_point_to_point_communication">Point-to-point Communication</h4>
<div class="paragraph">
<p>The <em>DataflowQueue</em> class can be viewed as a point-to-point (1 to 1, many to 1) communication channel. It allows one or more producers send messages to one reader.  If multiple readers read from the same
<em>DataflowQueue</em> , they will each consume different messages. Or to put it a different way, each message is consumed by exactly one reader.  You can easily imagine a simple load-balancing scheme built around a shared
<em>DataflowQueue</em> with readers being added dynamically when the consumer part of your algorithm needs to scale up.  This is also a useful default choice when connecting tasks or operators.</p>
</div>
</div>
<div class="sect3">
<h4 id="_publish_subscribe_communication">Publish-subscribe Communication</h4>
<div class="paragraph">
<p>The <em>DataflowBroadcast</em> class offers a publish-subscribe (1 to many, many to many) communication model. One or more producers write messages, while all registered readers will receive all the messages. Each message
is thus consumed by all readers with a valid subscription at the point when the message is written to the channel. The readers subscribe by calling the <em>createReadChannel()</em> method.</p>
</div>
<div class="listingblock">
<div class="title">A Pub-Sub Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
</pre></td>
  <td class="code"><pre>DataflowWriteChannel broadcastStream = <span class="keyword">new</span> DataflowBroadcast()
DataflowReadChannel stream1 = broadcastStream.createReadChannel()
DataflowReadChannel stream2 = broadcastStream.createReadChannel()

broadcastStream &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Message1</span><span class="delimiter">'</span></span>
broadcastStream &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Message2</span><span class="delimiter">'</span></span>
broadcastStream &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Message3</span><span class="delimiter">'</span></span>

<span class="keyword">assert</span> stream1.val == stream2.val
<span class="keyword">assert</span> stream1.val == stream2.val
<span class="keyword">assert</span> stream1.val == stream2.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Under the covers, <em>DataflowBroadcast</em> uses the <em>DataflowStream</em> class to implement the message delivery.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_dataflowstream">DataflowStream</h3>
<div class="paragraph">
<p>The <em>DataflowStream</em> class represents a deterministic dataflow channel. It&#8217;s built around the concept of a functional queue and so provides a lock-free thread-safe implementation for message passing.
Essentially, you may think of <em>DataflowStream</em> mechanisms as a 1-to-many communication channel, since when a reader consumes a messages, other readers will still be able to read the same message.
Also, all messages arrive to all readers in the same order.  Since the <em>DataflowStream</em> is implemented as a functional queue, its API requires users to traverse the values in the stream themselves.
On the other hand, <em>DataflowStream</em> offers handy methods for value filtering or transformation together with interesting performance characteristics.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">The Semantics of The <em>DataflowStream</em> is Different From The <em>DataflowChannel</em> Interface</div>
<div class="paragraph">
<p>The <em>DataflowStream</em> class, unlike the other communication elements, does not implement the <em>DataflowChannel</em> interface, since the semantics of its use is different.
Use <em>DataflowStreamReadAdapter</em> and <em>DataflowStreamWriteAdapter</em> classes to wrap instances of the <em>DataflowChannel</em> class in a <em>DataflowReadChannel</em> or <em>DataflowWriteChannel</em> implementations.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">A Sample of DataflowStream Usage</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
39
<strong>40</strong>
41
42
43
44
45
46
47
48
49
<strong>50</strong>
51
52
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.stream.DataflowStream</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.scheduler.ResizeablePool</span>

<span class="comment">/**
 * Demonstrates concurrent implementation of the Sieve of Eratosthenes using dataflow tasks
 *
 * In principle, the algorithm consists of a concurrently run chained filters,
 * each of which detects whether the current number can be divided by a single prime number.
 * (generate nums 1, 2, 3, 4, 5, ...) -&gt; (filter by mod 2) -&gt; (filter by mod 3) -&gt; (filter by mod 5) -&gt; (filter by mod 7) -&gt; (filter by mod 11) -&gt; (caution! Primes falling out here)
 * The chain is built (grows) on the fly, whenever a new prime is found
 */</span>

<span class="comment">/**
 * We need a resizeable thread pool, since tasks consume threads while waiting, blocked for values from the DataflowQueue.val
 */</span>
group = <span class="keyword">new</span> DefaultPGroup(<span class="keyword">new</span> ResizeablePool(<span class="predefined-constant">true</span>))

<span class="directive">final</span> <span class="type">int</span> requestedPrimeNumberCount = <span class="integer">100</span>

<span class="comment">/**
 * Generating candidate numbers
 */</span>
<span class="directive">final</span> DataflowStream candidates = <span class="keyword">new</span> DataflowStream()
group.task {
    candidates.generate(<span class="integer">2</span>, {<span class="local-variable">it</span> + <span class="integer">1</span>}, {<span class="local-variable">it</span> &lt; <span class="integer">1000</span>})
}

<span class="comment">/**
 * Chain a new filter for a particular prime number to the end of the Sieve
 * @param inChannel The current end channel to consume
 * @param prime The prime number to divide future prime candidates with
 * @return A new channel ending the whole chain
 */</span>
<span class="keyword">def</span> <span class="function">filter</span>(DataflowStream inChannel, <span class="type">int</span> prime) {
    inChannel.filter { number -&gt;
        group.task {
            number % prime != <span class="integer">0</span>
        }
    }
}

<span class="comment">/**
 * Consume Sieve output and add additional filters for all found primes
 */</span>
<span class="keyword">def</span> currentOutput = candidates
requestedPrimeNumberCount.times {

    <span class="type">int</span> prime = currentOutput.first
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Found: </span><span class="inline"><span class="inline-delimiter">$</span>prime</span><span class="delimiter">&quot;</span></span>
    currentOutput = filter(currentOutput, prime)
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>For convenience and for the ability to use <em>DataflowStream</em> objects with other dataflow constructs, like e.g. operators, you can wrap it with <em>DataflowReadAdapter</em> for read access or <em>DataflowWriteAdapter</em> for write access.</p>
</div>
<div class="paragraph">
<p>The <em>DataflowStream</em> class is designed for single-threaded producers and consumers. If multiple threads are supposed to read or write values to the stream, their access to the stream must be serialized externally or adapters should be used.</p>
</div>
<div class="sect3">
<h4 id="_dataflowstream_adapters">DataflowStream Adapters</h4>
<div class="paragraph">
<p>The <em>DataflowStream</em> API as well as the semantics of its use are very different from the one defined by <em>Dataflow(Read/Write)Channel</em>. Adapters have to be used in order to allow <em>DataflowStreams</em> to work with other dataflow elements.
The <em>DataflowStreamReadAdapter</em> class will wrap a <em>DataflowStream</em> with the necessary methods to read values, while the <em>DataflowStreamWriteAdapter</em> class provides write methods around the wrapped <em>DataflowStream</em> method.</p>
</div>
</div>
<div class="sect3">
<h4 id="_thread_safety">Thread Safety</h4>
<div class="paragraph">
<p>It&#8217;s important to mention that the <em>DataflowStreamWriteAdapter</em> is thread safe. It allows multiple threads to add values to the wrapped <em>DataflowStream</em> through the adapter.
On the other hand, the <em>DataflowStreamReadAdapter</em> is designed to be used by a single thread.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <em>DataflowStreamWriteAdapter</em> is thread safe
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p>To minimize overhead and stay in-line with <em>DataflowStream</em> semantics, the <em>DataflowStreamReadAdapter</em> class is not thread-safe and should only be used from within a single thread.</p>
</div>
<div class="paragraph">
<p>If multiple threads need to read from a <em>DataflowStream</em>, they should create their own wrapping of <em>DataflowStreamReadAdapter</em> .</p>
</div>
<div class="paragraph">
<p>Thanks to the adapters, <em>DataflowStream</em> can be used for communications between operators or selectors, as these expect <em>Dataflow(Read/Write)Channels</em> .</p>
</div>
<div class="listingblock">
<div class="title">DataflowStreamAdapters Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.stream.DataflowStream</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.stream.DataflowStreamReadAdapter</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.stream.DataflowStreamWriteAdapter</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.selector</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.operator</span>

<span class="comment">/**
 * Demonstrates the use of DataflowStreamAdapters to allow dataflow operators to use DataflowStreams
 */</span>

<span class="directive">final</span> DataflowStream a = <span class="keyword">new</span> DataflowStream()
<span class="directive">final</span> DataflowStream b = <span class="keyword">new</span> DataflowStream()
<span class="keyword">def</span> aw = <span class="keyword">new</span> DataflowStreamWriteAdapter(a)
<span class="keyword">def</span> bw = <span class="keyword">new</span> DataflowStreamWriteAdapter(b)
<span class="keyword">def</span> ar = <span class="keyword">new</span> DataflowStreamReadAdapter(a)
<span class="keyword">def</span> br = <span class="keyword">new</span> DataflowStreamReadAdapter(b)

<span class="keyword">def</span> result = <span class="keyword">new</span> DataflowQueue()

<span class="keyword">def</span> op1 = operator(ar, bw) {
    bindOutput <span class="local-variable">it</span>
}
<span class="keyword">def</span> op2 = selector([br], [result]) {
    result &lt;&lt; <span class="local-variable">it</span>
}

aw &lt;&lt; <span class="integer">1</span>
aw &lt;&lt; <span class="integer">2</span>
aw &lt;&lt; <span class="integer">3</span>
<span class="keyword">assert</span>([<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>] == [result.val, result.val, result.val])
op1.stop()
op2.stop()
op1.join()
op2.join()
</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Also the ability to select a value from multiple <em>DataflowChannels</em> can only be used through an adapter around a <em>DataflowStream</em>.</p>
</div>
<div class="listingblock">
<div class="title">A DataflowStream Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
39
<strong>40</strong>
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.Select</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.stream.DataflowStream</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.stream.DataflowStreamReadAdapter</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.stream.DataflowStreamWriteAdapter</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.select</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

<span class="comment">/**
 * Demonstrates the use of DataflowStreamAdapters to allow dataflow select to select on DataflowStreams
 */</span>

<span class="directive">final</span> DataflowStream a = <span class="keyword">new</span> DataflowStream()
<span class="directive">final</span> DataflowStream b = <span class="keyword">new</span> DataflowStream()

<span class="keyword">def</span> aw = <span class="keyword">new</span> DataflowStreamWriteAdapter(a)
<span class="keyword">def</span> bw = <span class="keyword">new</span> DataflowStreamWriteAdapter(b)
<span class="keyword">def</span> ar = <span class="keyword">new</span> DataflowStreamReadAdapter(a)
<span class="keyword">def</span> br = <span class="keyword">new</span> DataflowStreamReadAdapter(b)

<span class="directive">final</span> Select&lt;?&gt; select = select(ar, br)
task {
    aw &lt;&lt; <span class="integer">1</span>
    aw &lt;&lt; <span class="integer">2</span>
    aw &lt;&lt; <span class="integer">3</span>
}

<span class="keyword">assert</span> <span class="integer">1</span> == select().value
<span class="keyword">assert</span> <span class="integer">2</span> == select().value
<span class="keyword">assert</span> <span class="integer">3</span> == select().value

task {
    bw &lt;&lt; <span class="integer">4</span>
    aw &lt;&lt; <span class="integer">5</span>
    bw &lt;&lt; <span class="integer">6</span>
}

<span class="keyword">def</span> result = (<span class="integer">1</span>..<span class="integer">3</span>).collect{select()}.sort{<span class="local-variable">it</span>.value}

<span class="keyword">assert</span> result*.value == [<span class="integer">4</span>, <span class="integer">5</span>, <span class="integer">6</span>]
<span class="keyword">assert</span> result*.index == [<span class="integer">1</span>, <span class="integer">0</span>, <span class="integer">1</span>]</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you don&#8217;t need any of the functional queue <em>DataflowStream-special</em> functionality, like generation, filtering or mapping, you might consider using the <em>DataflowBroadcast</em> class instead.</p>
</div>
<div class="paragraph">
<p>This class offers the <em>publish-subscribe</em> communication model through the <em>DataflowChannel</em> interface.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_bind_handlers">Bind Handlers</h3>
<div class="listingblock">
<div class="title">What A Bind</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> a = <span class="keyword">new</span> DataflowVariable()

a &gt;&gt; {println <span class="string"><span class="delimiter">&quot;</span><span class="content">The variable has just been bound to </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>}

a.whenBound {println <span class="string"><span class="delimiter">&quot;</span><span class="content">Just to confirm that the variable has been really set to </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>}
...</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Bind handlers</code> can be registered on all dataflow channels (variables, queues or broadcasts) either using the <strong class="red">'&gt;&gt;'</strong> operator and/or the <em>then()</em> or the <em>whenBound()</em> methods.
They will be run only after a value is bound to the variable.</p>
</div>
<div class="paragraph">
<p><code>Dataflow queues</code> and <code>broadcasts</code> also support a <em>wheneverBound</em> method to register a closure or a message handler to run each time a value is bound to them.</p>
</div>
<div class="listingblock">
<div class="title">A DataflowQueue().wheneverBound Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> queue = <span class="keyword">new</span> DataflowQueue()
queue.wheneverBound {println <span class="string"><span class="delimiter">&quot;</span><span class="content">A value </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="content"> arrived to the queue</span><span class="delimiter">&quot;</span></span>}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Obviously, nothing prevents you from having more than a single handler for a single promise: They will all trigger in parallel once the <strong>promise</strong> has a concrete value:</p>
</div>
<div class="listingblock">
<div class="title">A <code>wheneverBound</code> Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre>Promise bookingPromise = task {
    <span class="directive">final</span> data = collectData()
    <span class="keyword">return</span> broker.makeBooking(data)
}

bookingPromise.whenBound {booking -&gt; printAgenda booking}
bookingPromise.whenBound {booking -&gt; sendMeAnEmailTo booking}
bookingPromise.whenBound {booking -&gt; updateTheCalendar booking}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Parallel Speculations Anyone ?</div>
<div class="paragraph">
<p>Dataflow variables and broadcasts are one of several possible ways to implement <em>Parallel Speculations</em> . For details, please check out <em>Parallel Speculations</em> in the <em>Parallel Collections</em> section of the <strong>User Guide</strong>.</p>
</div>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_bind_handlers_grouping">Bind Handlers Grouping</h3>
<div class="paragraph">
<p>When you need to wait for multiple <code>DataflowVariables Promises</code> to be bound, we can benefit from calling the <em>whenAllBound()</em> function. It&#8217;s available on the <em>Dataflow</em> class as well as on <em>PGroup</em> instances.</p>
</div>
<div class="listingblock">
<div class="title">whenAllBound() Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
</pre></td>
  <td class="code"><pre>    <span class="directive">final</span> group = <span class="keyword">new</span> NonDaemonPGroup()

    <span class="comment">//Calling asynchronous services and receiving back promises for the reservations</span>
    Promise flightReservation = flightBookingService(<span class="string"><span class="delimiter">'</span><span class="content">PAR &lt;-&gt; BRU</span><span class="delimiter">'</span></span>)
    Promise hotelReservation = hotelBookingService(<span class="string"><span class="delimiter">'</span><span class="content">BRU:Feb 24 20015 - Feb 29 2015</span><span class="delimiter">'</span></span>)
    Promise taxiReservation = taxiBookingService(<span class="string"><span class="delimiter">'</span><span class="content">BRU:Feb 24 2015 10:31</span><span class="delimiter">'</span></span>)

    <span class="comment">//when all reservations have been made, we need to build an agenda for our trip</span>
    Promise agenda = group.whenAllBound(flightReservation, hotelReservation, taxiReservation) {flight, hotel, taxi -&gt;
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Agenda: </span><span class="inline"><span class="inline-delimiter">$</span>flight</span><span class="content"> | </span><span class="inline"><span class="inline-delimiter">$</span>hotel</span><span class="content"> | </span><span class="inline"><span class="inline-delimiter">$</span>taxi</span><span class="delimiter">&quot;</span></span>
    }

    <span class="comment">//since this is a demo, we only print the agenda and block when it's ready</span>
    println agenda.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you don&#8217;t know the number of parameters the <em>whenAllBound()</em> handler needs, then use a closure with one argument of type <em>List</em>:</p>
</div>
<div class="listingblock">
<div class="title">whenAllBound() Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
</pre></td>
  <td class="code"><pre>Promise module1 = task {
    compile(module1Sources)
}
Promise module2 = task {
    compile(module2Sources)
}

<span class="comment">//We don't know the number of modules that will be jarred together, so use a List</span>
<span class="directive">final</span> jarCompiledModules = {<span class="predefined-type">List</span> modules -&gt; ...}

whenAllBound([module1, module2], jarCompiledModules)</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_bind_handler_chaining">Bind Handler Chaining</h3>
<div class="paragraph">
<p>All dataflow channels also support the <em>then()</em> method to register a callback handler to invoke when a value becomes available. Unlike <em>whenBound()</em>, the <em>then()</em> method allows us to use chaining, giving us the option to transfer resulting values between functions asynchronously.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong>Groovy</strong> allows us to leave out some of the <em>dots</em> in the <em>then()</em> method chains.
</td>
</tr>
</table>
</div>
<hr>
<div class="listingblock">
<div class="title">A Pointless Sample - No Need To Join The Dots !</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre><span class="directive">final</span> DataflowVariable variable = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> DataflowVariable result = <span class="keyword">new</span> DataflowVariable()

variable.then {<span class="local-variable">it</span> * <span class="integer">2</span>} then {<span class="local-variable">it</span> + <span class="integer">1</span>} then {result &lt;&lt; <span class="local-variable">it</span>}
variable &lt;&lt; <span class="integer">4</span>
<span class="keyword">assert</span> <span class="integer">9</span> == result.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">This could be nicely combined with <em>Asynchronous functions</em></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
</pre></td>
  <td class="code"><pre><span class="directive">final</span> DataflowVariable variable = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> DataflowVariable result = <span class="keyword">new</span> DataflowVariable()

<span class="directive">final</span> doubler = {<span class="local-variable">it</span> * <span class="integer">2</span>}
<span class="directive">final</span> adder = {<span class="local-variable">it</span> + <span class="integer">1</span>}

variable.then doubler then adder then {result &lt;&lt; <span class="local-variable">it</span>}

<span class="predefined-type">Thread</span>.start {variable &lt;&lt; <span class="integer">4</span>}

<span class="keyword">assert</span> <span class="integer">9</span> == result.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">or <em>ActiveObjects</em></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
</pre></td>
  <td class="code"><pre><span class="annotation">@ActiveObject</span>
<span class="type">class</span> <span class="class">ActiveDemoCalculator</span> {
    <span class="annotation">@ActiveMethod</span>
    <span class="keyword">def</span> <span class="function">doubler</span>(<span class="type">int</span> value) {
        value * <span class="integer">2</span>
    }

    <span class="annotation">@ActiveMethod</span>
    <span class="keyword">def</span> <span class="function">adder</span>(<span class="type">int</span> value) {
        value + <span class="integer">1</span>
    }
}

<span class="directive">final</span> DataflowVariable result = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> calculator = <span class="keyword">new</span> ActiveDemoCalculator();

calculator.doubler(<span class="integer">4</span>).then {calculator.adder <span class="local-variable">it</span>}.then {result &lt;&lt; <span class="local-variable">it</span>}

<span class="keyword">assert</span> <span class="integer">9</span> == result.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Motivation for Chaining Promises</div>
<div class="paragraph">
<p>Chaining can save quite some code when calling other asynchronous services from within <em>whenBound()</em> handlers.</p>
</div>
<div class="paragraph">
<p>Asynchronous services, such as <em>Asynchronous Functions</em> or <em>Active Methods</em>, return <strong>Promises</strong> for their results. To obtain the actual results, your handlers would have to block to wait for the value to be bound. This locks the current thread in an unproductive state.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">An Unproductive Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>variable.whenBound {value -&gt;
    Promise promise = asyncFunction(value)
    println promise.get()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>or, alternatively, it could register another (nested) <em>whenBound()</em> handler, which would result in unnecessarily complex code.</p>
</div>
<div class="listingblock">
<div class="title">An Unnecessarily Complex Nested Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>variable.whenBound {value -&gt;
    asyncFunction(value).whenBound {
        println <span class="local-variable">it</span>
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>For an illustration, compare the following two code snippets. One is using <em>whenBound()</em> and one using <em>then()</em> chaining. They&#8217;re both equivalent in terms of functionality and behavior.</p>
</div>
<div class="listingblock">
<div class="title">A <em>whenBound()</em> Sample Plus a <em>then()</em> Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
</pre></td>
  <td class="code"><pre><span class="directive">final</span> DataflowVariable variable = <span class="keyword">new</span> DataflowVariable()

<span class="directive">final</span> doubler = {<span class="local-variable">it</span> * <span class="integer">2</span>}
<span class="directive">final</span> inc = {<span class="local-variable">it</span> + <span class="integer">1</span>}

<span class="comment">//Using whenBound()</span>
variable.whenBound {value -&gt;
    task {
        doubler(value)
    }.whenBound {doubledValue -&gt;
        task {
            inc(doubledValue)
        }.whenBound {incrementedValue -&gt;
            println incrementedValue
        }
    }
}

<span class="comment">//Using then() chaining</span>
variable.then doubler then inc then <span class="local-variable">this</span>.&amp;println

<span class="predefined-type">Thread</span>.start {variable &lt;&lt; <span class="integer">4</span>}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Chaining Promises solves both of these issues elegantly:</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>variable &gt;&gt; asyncFunction &gt;&gt; {println <span class="local-variable">it</span>}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>RightShift</em> <em class="red">'&gt;&gt;'</em> operator has been overloaded to call <em>then()</em> method and, therefore, can be chained the same way:</p>
</div>
<div class="listingblock">
<div class="title">A Chaining Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
</pre></td>
  <td class="code"><pre><span class="directive">final</span> DataflowVariable variable = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> DataflowVariable result = <span class="keyword">new</span> DataflowVariable()

<span class="directive">final</span> doubler = {<span class="local-variable">it</span> * <span class="integer">2</span>}
<span class="directive">final</span> adder = {<span class="local-variable">it</span> + <span class="integer">1</span>}

variable &gt;&gt; doubler &gt;&gt; adder &gt;&gt; {result &lt;&lt; <span class="local-variable">it</span>}

<span class="predefined-type">Thread</span>.start {variable &lt;&lt; <span class="integer">4</span>}

<span class="keyword">assert</span> <span class="integer">9</span> == result.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="sect3">
<h4 id="_error_handling_for_promise_chaining">Error Handling for Promise Chaining</h4>
<div class="paragraph">
<p>Asynchronous operations may obviously throw exceptions. It&#8217;s important to be able to handle them easily and with little effort.
<strong>GPars</strong> <strong>romise</strong> objects can implicitly propagate exceptions from asynchronous calculations across <strong>promise</strong> chains.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Promises</strong> propagate result values as well as exceptions. The blocking <em>get()</em> method re-throws any exception that was bound to the <strong>Promise</strong> so the caller can handle it.</p>
</li>
<li>
<p>For <code>asynchronous notifications</code> - the <em>whenBound()</em> handler closure - gets the exception passed in as an argument.</p>
</li>
<li>
<p>The <em>then()</em> method accepts two arguments - a <strong>value handler</strong> and an optional <strong>error handler</strong>. These will  be invoked depending on whether the result is a regular value or an exception.
If no errorHandler is  specified, the exception is re-thrown to the <strong>Promise</strong> returned by <em>then()</em> .</p>
</li>
<li>
<p>Exactly the same behavior for <em>then()</em> methods holds true for the <em>whenAllBound()</em> method, which listens on multiple <strong>Promises</strong> to get bound.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">A Sample of Error Handling</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
</pre></td>
  <td class="code"><pre>Promise&lt;<span class="predefined-type">Integer</span>&gt; initial = <span class="keyword">new</span> DataflowVariable&lt;<span class="predefined-type">Integer</span>&gt;()
Promise&lt;<span class="predefined-type">String</span>&gt; result = initial.then {<span class="local-variable">it</span> * <span class="integer">2</span>} then {<span class="integer">100</span> / <span class="local-variable">it</span>}  <span class="comment">// Will throw exception for 0</span>
.then {println <span class="string"><span class="delimiter">&quot;</span><span class="content">Log the value </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="content"> as it passes by</span><span class="delimiter">&quot;</span></span>; <span class="keyword">return</span> <span class="local-variable">it</span>}  <span class="comment">// No error handler is defined,</span>
                                                                <span class="comment">// so exceptions are ignored</span>
                                                                <span class="comment">// and silently re-thrown to the next handler in chain</span>
.then({<span class="string"><span class="delimiter">&quot;</span><span class="content">The result for </span><span class="inline"><span class="inline-delimiter">$</span>num</span><span class="content"> is </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>}, {<span class="string"><span class="delimiter">&quot;</span><span class="content">Error detected for </span><span class="inline"><span class="inline-delimiter">$</span>num</span><span class="content">: </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>}) <span class="comment">// Here the exception is caught</span>

initial &lt;&lt; <span class="integer">0</span>

println result.get()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>ErrorHandler</strong> is a closure that accepts instances of <em>Throwable</em> as its' only (optional) argument. It returns a value that should be bound to the result of the <em>then()</em> method call, i.e. the returned <strong>Promise</strong>.
If an exception is thrown from within an error handler, it&#8217;s bound to the resulting <strong>Promise</strong> as an error.</p>
</div>
<div class="listingblock">
<div class="title">Re-throwing Potential Exceptions</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>promise.then({<span class="local-variable">it</span>+<span class="integer">1</span>})                  <span class="comment">// Implicitly re-throws potential exceptions bound to promise</span>
promise.then({<span class="local-variable">it</span>+<span class="integer">1</span>}, {e -&gt; <span class="keyword">throw</span> e})  <span class="comment">// Explicitly re-throws potential exceptions bound to promise</span>

promise.then({<span class="local-variable">it</span>+<span class="integer">1</span>}, {e -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>(<span class="string"><span class="delimiter">'</span><span class="content">Error occurred</span><span class="delimiter">'</span></span>, e})
<span class="comment">// Explicitly re-throws a new exception wrapping a potential exception bound to a *Promise*</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_where_do_you_want_this_exception">Where Do You Want This Exception ?</h4>
<div class="paragraph">
<p>Exception handling in <strong>Java</strong> has try-catch statements. The behavior of <strong>GPars</strong> <strong>Promise</strong> objects gives an asynchronous invocation freedom to handle exceptions at anywhere it&#8217;s most convenient.
You can freely ignore exceptions in your code if you want to, then just assume things work. Even so, remember that exceptions are not accidentally swallowed.</p>
</div>
<div class="listingblock">
<div class="title">A Exceptional Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre>task {
    <span class="string"><span class="delimiter">'</span><span class="content">gpars.org</span><span class="delimiter">'</span></span>.toURL().text  <span class="comment">//should throw MalformedURLException</span>
}

.then {page -&gt; page.toUpperCase()}
.then {page -&gt; page.contains(<span class="string"><span class="delimiter">'</span><span class="content">GROOVY</span><span class="delimiter">'</span></span>)}
.then({mentionsGroovy -&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">Groovy found: </span><span class="inline"><span class="inline-delimiter">$</span>mentionsGroovy</span><span class="delimiter">&quot;</span></span>}, {error -&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">Error: </span><span class="inline"><span class="inline-delimiter">$</span>error</span><span class="delimiter">&quot;</span></span>}).join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="sect4">
<h5 id="_handling_concrete_exception_types">Handling Concrete Exception Types</h5>
<div class="paragraph">
<p>You may also be more specific about the handled exception types like this :</p>
</div>
<div class="listingblock">
<div class="title">A Specific Exception Handling Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>url.then(download)
    .then(calculateHash, {<span class="exception">MalformedURLException</span> e -&gt; <span class="keyword">return</span> <span class="integer">0</span>}) <span class="comment">// &lt;- specific !</span>
    .then(formatResult)
    .then(printResult, printError)
    .then(sendNotificationEmail);</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_customer_site_exception_handling">Customer-site Exception Handling</h5>
<div class="paragraph">
<p>You may wish to leave an exception completely un-handled, then let clients (consumers) handle it:</p>
</div>
<div class="listingblock">
<div class="title">A Delayed Exception Handling Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>Promise&lt;<span class="predefined-type">Object</span>&gt; result = url.then(download).then(calculateHash).then(formatResult).then(printResult);
<span class="keyword">try</span> {
    result.get()
} <span class="keyword">catch</span> (<span class="exception">Exception</span> e) {
    <span class="comment">//handle exceptions here</span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="_putting_it_all_together">Putting It All Together</h4>
<div class="paragraph">
<p>By combining <em>whenAllBound()</em> and <em>then</em> (or <strong class="red">'&gt;&gt;'</strong>) methods, we can easily manage large asynchronous scenarios in a convenient way:</p>
</div>
<div class="listingblock">
<div class="title">A Large Asynchronous Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
</pre></td>
  <td class="code"><pre>withPool {

    Closure download = {<span class="predefined-type">String</span> url -&gt;
        sleep <span class="integer">3000</span>  <span class="comment">//Simulate a web read</span>
        <span class="string"><span class="delimiter">'</span><span class="content">web content</span><span class="delimiter">'</span></span>
    }.asyncFun()

    Closure loadFile = {<span class="predefined-type">String</span> fileName -&gt;
        <span class="string"><span class="delimiter">'</span><span class="content">file content</span><span class="delimiter">'</span></span>  <span class="comment">//simulate a local file read</span>
    }.asyncFun()

    Closure hash = {s -&gt; s.hashCode()}

    Closure compare = {<span class="type">int</span> first, <span class="type">int</span> second -&gt;
        first == second
    }

    Closure errorHandler = {println <span class="string"><span class="delimiter">&quot;</span><span class="content">Error detected: </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>}

    <span class="keyword">def</span> all = whenAllBound([
                  download(<span class="string"><span class="delimiter">'</span><span class="content">http://www.gpars.org</span><span class="delimiter">'</span></span>) &gt;&gt; hash,
                  loadFile(<span class="string"><span class="delimiter">'</span><span class="content">/coolStuff/gpars/website/index.html</span><span class="delimiter">'</span></span>) &gt;&gt; hash
              ], compare).then({println <span class="local-variable">it</span>}, errorHandler)
    all.join()  <span class="comment">//optionally block until the calculation is all done</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that only the initial action (function) needs to be asynchronous. The functions further down the pipeline will be invoked asynchronously by your <strong>Promise</strong>, even if they are synchronous.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_implementing_the_strong_fork_join_strong_pattern_with_strong_promises_strong">Implementing the <strong>Fork/join</strong> Pattern With <strong>Promises</strong></h4>
<div class="paragraph">
<p><strong>Promises</strong> are very flexible and can be used as an implementation vehicle for many different scenarios.
Here&#8217;s one handy additional capability of a <strong>Promise</strong>.</p>
</div>
<div class="paragraph">
<p>The _thenForkAndJoin() method triggers one or several activities once the current <strong>Promise</strong> becomes bound and returns a completed <strong>Promise</strong> object, bound only after all the activities finish.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see how this fits into the picture:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>then()</em> - permits activity chaining, so that one activity is performed after another</p>
</li>
<li>
<p><em>whenAllBound()</em> - allows joining multiple activities; a new activity is started only after they all finish</p>
</li>
<li>
<p><em>task()</em> - allows us to create (fork) multiple asynchronous activities</p>
</li>
<li>
<p><em>thenForkAndJoin()</em> - a short-hand syntax for forking several activities and joining on them</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So with <em>thenForkAndJoin()</em> you simply create multiple activities that should be triggered by a shared (triggering) <strong>Promise</strong>.</p>
</div>
<div class="listingblock">
<div class="title">A Sample of  Multiple Activities</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>promise.thenForkAndJoin(task1, task2, task3).then{...}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Once all the activities return a result, they&#8217;re collected into a list and bound into the <strong>Promise</strong> returned by <em>thenForkAndJoin()</em> .</p>
</div>
<div class="listingblock">
<div class="title">A thenForkAndJoin() Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>task {
    <span class="integer">2</span>
}.thenForkAndJoin({ <span class="local-variable">it</span> ** <span class="integer">2</span> }, { <span class="local-variable">it</span>**<span class="integer">3</span> }, { <span class="local-variable">it</span>**<span class="integer">4</span> }, { <span class="local-variable">it</span>**<span class="integer">5</span> }).then({ println <span class="local-variable">it</span>}).join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_lazy_strong_dataflow_strong_tasks_and_variables">Lazy <strong>Dataflow</strong> Tasks and Variables</h3>
<div class="paragraph">
<p>Sometimes you may need to combine the qualities of <code>Dataflow Variables</code> with a lazy initialization.</p>
</div>
<div class="listingblock">
<div class="title">A Lazy Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>Closure&lt;<span class="predefined-type">String</span>&gt; download = {url -&gt;
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Downloading</span><span class="delimiter">&quot;</span></span>
    url.toURL().text
}

<span class="keyword">def</span> pageContent = <span class="keyword">new</span> LazyDataflowVariable(download.curry(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://gpars.org</span><span class="delimiter">&quot;</span></span>))</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Instances of <em>LazyDataflowVariable</em> have an initializer declared at construction time. An instance is only triggered when someone asks for its value, either through the blocking <em>get()</em> method or using any of the non-blocking callback methods, such as <em>then()</em> .  Since <em>LazyDataflowVariables</em> preserve all the goodness of ordinary <em>DataflowVariables</em> , you can chain them together easily with other <em>lazy</em> or <em>ordinary</em> <code>Dataflow Variables</code>.</p>
</div>
<hr>
<div class="sect3">
<h4 id="_a_bigger_example">A Bigger Example</h4>
<div class="paragraph">
<p>This discussion deserves a more practical example. So, taking inspiration from <a href="http://blog.jcoglan.com/2013/03/30/callbacks-are-imperative-promises-are-functional-nodes-biggest-missed-opportunity/">this long post</a>,
the following piece of code demonstrates how to  use <em>LazyDataflowVariables</em> to lazily and asynchronously load mutually dependent components into memory.  The component modules will be loaded in the order of their dependencies and concurrently, if possible.</p>
</div>
<div class="paragraph">
<p>Each module will only be loaded once, irrespective of the number of modules that depend on it.  Thanks to <code>laziness</code>, only the modules that are transitively needed will be loaded.  Our example uses a simple "diamond" dependency scheme:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>D depends on B and C</p>
</li>
<li>
<p>C depends on A</p>
</li>
<li>
<p>B depends on A</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When loading D, A will get loaded first. B and C will be loaded concurrently once A has been loaded. D will start loading once both B and C have been loaded.</p>
</div>
<div class="listingblock">
<div class="title">A Diamond Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
39
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> moduleA = <span class="keyword">new</span> LazyDataflowVariable({-&gt;
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Loading moduleA into memory</span><span class="delimiter">&quot;</span></span>
    sleep <span class="integer">3000</span>
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Loaded moduleA into memory</span><span class="delimiter">&quot;</span></span>
    <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">moduleA</span><span class="delimiter">&quot;</span></span>
})

<span class="keyword">def</span> moduleB = <span class="keyword">new</span> LazyDataflowVariable({-&gt;
    moduleA.then {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">-&gt;Loading moduleB into memory, since moduleA is ready</span><span class="delimiter">&quot;</span></span>
        sleep <span class="integer">3000</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">  Loaded moduleB into memory</span><span class="delimiter">&quot;</span></span>
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">moduleB</span><span class="delimiter">&quot;</span></span>
    }
})

<span class="keyword">def</span> moduleC = <span class="keyword">new</span> LazyDataflowVariable({-&gt;
    moduleA.then {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">-&gt;Loading moduleC into memory, since moduleA is ready</span><span class="delimiter">&quot;</span></span>
        sleep <span class="integer">3000</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">  Loaded moduleC into memory</span><span class="delimiter">&quot;</span></span>
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">moduleC</span><span class="delimiter">&quot;</span></span>
    }
})

<span class="keyword">def</span> moduleD = <span class="keyword">new</span> LazyDataflowVariable({-&gt;
    whenAllBound(moduleB, moduleC) { b, c -&gt;
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">--&gt;Loading moduleD into memory, since moduleB and moduleC are ready</span><span class="delimiter">&quot;</span></span>
        sleep <span class="integer">3000</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">   Loaded moduleD into memory</span><span class="delimiter">&quot;</span></span>
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">moduleD</span><span class="delimiter">&quot;</span></span>
    }
})

println <span class="string"><span class="delimiter">&quot;</span><span class="content">Nothing loaded so far</span><span class="delimiter">&quot;</span></span>
println <span class="string"><span class="delimiter">&quot;</span><span class="content">===================================================================</span><span class="delimiter">&quot;</span></span>
println <span class="string"><span class="delimiter">&quot;</span><span class="content">Load module: </span><span class="delimiter">&quot;</span></span> + moduleD.get()
println <span class="string"><span class="delimiter">&quot;</span><span class="content">===================================================================</span><span class="delimiter">&quot;</span></span>
println <span class="string"><span class="delimiter">&quot;</span><span class="content">All requested modules loaded</span><span class="delimiter">&quot;</span></span></pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_making_tasks_lazy">Making Tasks Lazy</h4>
<div class="paragraph">
<p>The <em>lazyTask()</em> method is available alongside the <em>task()</em> method to give the us a task-oriented abstraction for delayed activities.
A <strong>Lazy Task</strong> returns an instance of a <em>LazyDataflowVariable</em> (like a <strong>Promise</strong> ) with the initializer set by the provided closure.
As soon as someone asks for the value, the task will start asynchronously and eventually deliver a value into the <em>LazyDataflowVariable</em> .</p>
</div>
<div class="listingblock">
<div class="title">A Lazy Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.Dataflow</span>

<span class="keyword">def</span> pageContent = Dataflow.lazyTask {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Downloading</span><span class="delimiter">&quot;</span></span>
        <span class="string"><span class="delimiter">&quot;</span><span class="content">http://gpars.org</span><span class="delimiter">&quot;</span></span>.toURL().text
    }

println <span class="string"><span class="delimiter">&quot;</span><span class="content">No-one has asked for the value just yet. Bound = </span><span class="inline"><span class="inline-delimiter">${</span>pageContent.bound<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
sleep <span class="integer">1000</span>
println <span class="string"><span class="delimiter">&quot;</span><span class="content">Now going to ask for a value</span><span class="delimiter">&quot;</span></span>
println pageContent.get().size()
println <span class="string"><span class="delimiter">&quot;</span><span class="content">Repetitive requests will receive the already calculated value. No additional downloading.</span><span class="delimiter">&quot;</span></span>
println pageContent.get().size()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_dataflow_expressions">Dataflow Expressions</h3>
<div class="paragraph">
<p>Look at the magic below:</p>
</div>
<div class="listingblock">
<div class="title">A Dataflow Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> initialDistance = <span class="keyword">new</span> DataflowVariable()
<span class="keyword">def</span> acceleration = <span class="keyword">new</span> DataflowVariable()
<span class="keyword">def</span> time = <span class="keyword">new</span> DataflowVariable()

task {
    initialDistance &lt;&lt; <span class="integer">100</span>
    acceleration &lt;&lt; <span class="integer">2</span>
    time &lt;&lt; <span class="integer">10</span>
}

<span class="keyword">def</span> result = initialDistance + acceleration*<span class="float">0.5</span>*time**<span class="integer">2</span>
println <span class="string"><span class="delimiter">'</span><span class="content">Total distance </span><span class="delimiter">'</span></span> + result.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>We use <strong>DataflowVariables</strong> that represent several parameters to a mathematical equation calculating total distance of an accelerating object.
In the equation itself, however, we use the <strong>DataflowVariable</strong> directly. We do not refer to the values they represent and yet we are able to do the math correctly. This shows that <strong>DataflowVariables</strong> can be very flexible.</p>
</div>
<div class="paragraph">
<p>For example, you can call methods on them and these methods are dispatched to the bound values:</p>
</div>
<div class="listingblock">
<div class="title">A <strong>DataflowVariable</strong> Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> name = <span class="keyword">new</span> DataflowVariable()
task {
    name &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">  adam   </span><span class="delimiter">'</span></span>
}
println name.toUpperCase().trim().val</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can pass other <strong>DataflowVariables</strong> as arguments to such methods and the real values will be passed automatically instead:</p>
</div>
<div class="listingblock">
<div class="title">Another <strong>DataflowVariable</strong> as An Argument Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> title = <span class="keyword">new</span> DataflowVariable()
<span class="keyword">def</span> searchPhrase = <span class="keyword">new</span> DataflowVariable()
task {
    title &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content"> Groovy in Action 2nd edition   </span><span class="delimiter">'</span></span>
}

task {
    searchPhrase &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">2nd</span><span class="delimiter">'</span></span>
}

println title.trim().contains(searchPhrase).val</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And you can also query properties of the bound value using directly the <strong>DataflowVariable</strong>:</p>
</div>
<div class="listingblock">
<div class="title">A <strong>DataflowVariable</strong> Sample To Query Book Title Properties</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> book = <span class="keyword">new</span> DataflowVariable()
<span class="keyword">def</span> searchPhrase = <span class="keyword">new</span> DataflowVariable()
task {
    book &lt;&lt; [
             <span class="key">title</span>:<span class="string"><span class="delimiter">'</span><span class="content">Groovy in Action 2nd edition   </span><span class="delimiter">'</span></span>,
             <span class="key">author</span>:<span class="string"><span class="delimiter">'</span><span class="content">Dierk Koenig</span><span class="delimiter">'</span></span>,
             <span class="key">publisher</span>:<span class="string"><span class="delimiter">'</span><span class="content">Manning</span><span class="delimiter">'</span></span>]
}

task {
    searchPhrase &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">2nd</span><span class="delimiter">'</span></span>
}

book.title.trim().contains(searchPhrase).whenBound {println <span class="local-variable">it</span>}  <span class="comment">//Asynchronous waiting</span>

println book.title.trim().contains(searchPhrase).val  <span class="comment">//Synchronous waiting</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Please note that the result is still a <strong>DataflowVariable</strong> (<code>DataflowExpression</code> to be precise), from which you can get the real value from both synchronously and asynchronously.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_bind_error_notification">Bind Error Notification</h3>
<div class="paragraph">
<p><em>DataflowVariables</em> offer the ability to send notifications to registered listeners whenever a bind operation fails.
The <em>getBindErrorManager()</em> method allows listeners to be added and removed.  The listeners are notified in case of a failed attempt to bind a value (through <code>bind()</code>, <code>bindSafely()</code>, <code>bindUnique()</code> or <code>leftShift()</code> ) or an error (through <strong>bindError()</strong>).</p>
</div>
<div class="listingblock">
<div class="title">Reporting  Bind Operation FailED</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
</pre></td>
  <td class="code"><pre>        <span class="directive">final</span> DataflowVariable variable = <span class="keyword">new</span> DataflowVariable()

        variable.getBindErrorManager().addBindErrorListener(<span class="keyword">new</span> BindErrorListener() {
            <span class="annotation">@Override</span>
            <span class="type">void</span> onBindError(<span class="directive">final</span> <span class="predefined-type">Object</span> oldValue, <span class="directive">final</span> <span class="predefined-type">Object</span> failedValue, <span class="directive">final</span> <span class="type">boolean</span> uniqueBind) {
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">Bind failed!</span><span class="delimiter">&quot;</span></span>
            }

            <span class="annotation">@Override</span>
            <span class="type">void</span> onBindError(<span class="directive">final</span> <span class="predefined-type">Object</span> oldValue, <span class="directive">final</span> <span class="predefined-type">Throwable</span> failedError) {
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">Binding an error failed!</span><span class="delimiter">&quot;</span></span>
            }

            <span class="annotation">@Override</span>
            <span class="directive">public</span> <span class="type">void</span> onBindError(<span class="directive">final</span> <span class="predefined-type">Throwable</span> oldError, <span class="directive">final</span> <span class="predefined-type">Object</span> failedValue, <span class="directive">final</span> <span class="type">boolean</span> uniqueBind) {
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">Bind failed!</span><span class="delimiter">&quot;</span></span>
            }

            <span class="annotation">@Override</span>
            <span class="directive">public</span> <span class="type">void</span> onBindError(<span class="directive">final</span> <span class="predefined-type">Throwable</span> oldError, <span class="directive">final</span> <span class="predefined-type">Throwable</span> failedError) {
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">Binding an error failed!</span><span class="delimiter">&quot;</span></span>
            }

        })</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This lets us customize responses to any attempt to bind an already bound <strong>Dataflow Variable</strong>. For example, using <em>bindSafely()</em>, you do not receive bind exceptions back to the caller, but rather, a registered <em>BindErrorListener</em> is notified.</p>
</div>
</div>
<div class="sect2">
<h3 id="_further_reading">Further Reading</h3>
<div class="ulist">
<ul>
<li>
<p><a href="http://github.com/jboner/scala-dataflow/tree/f9a38992f5abed4df0b12f6a5293f703aa04dc33/src">Scala Dataflow library</a> by Jonas Bonér</p>
</li>
<li>
<p><a href="http://jonasboner.com/talks/state_youre_doing_it_wrong/html/all.html">JVM concurrency presentation slides</a> by Jonas Bonér</p>
</li>
<li>
<p><a href="http://github.com/larrytheliquid/dataflow/tree/master">Dataflow Concurrency library for Ruby</a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tasks">Tasks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <strong>Dataflow Task</strong> give us an easy-to-grasp abstraction of mutually-independent logical tasks or threads. These can run concurrently and exchange data solely through <code>Dataflow Variables</code>, <code>Queues</code>, <code>Broadcasts</code> and <code>Streams</code>. A <strong>Dataflow Task</strong> with it&#8217;s easy-to-express mutual dependencies and inherently sequential body could also be used as a practical implementation of a UML <em>Activity Diagrams</em> .</p>
</div>
<div class="paragraph">
<p>Check out the examples.</p>
</div>
<div class="sect2">
<h3 id="_a_simple_mashup_example">A Simple Mashup Example</h3>
<div class="paragraph">
<p>In this example, we&#8217;re downloading the front pages of three popular web sites, each in their own task, while in a separate task we&#8217;re filtering out sites talking about <strong>Groovy</strong> today and forming the output. The output task synchronizes automatically with the three download tasks on the three Dataflow variables through which the content of each website is passed to the output task.</p>
</div>
<div class="listingblock">
<div class="title">What Wonderful A Mashup !</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
39
<strong>40</strong>
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsPool.withPool</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowVariable</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>


<span class="comment">/**
 * A simple mashup sample, downloads content of three websites
 * and checks how many of them refer to Groovy.
 */</span>

<span class="keyword">def</span> dzone = <span class="keyword">new</span> DataflowVariable()
<span class="keyword">def</span> jroller = <span class="keyword">new</span> DataflowVariable()
<span class="keyword">def</span> theserverside = <span class="keyword">new</span> DataflowVariable()

task {
    println <span class="string"><span class="delimiter">'</span><span class="content">Started downloading from DZone</span><span class="delimiter">'</span></span>
    dzone &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">http://www.dzone.com</span><span class="delimiter">'</span></span>.toURL().text
    println <span class="string"><span class="delimiter">'</span><span class="content">Done downloading from DZone</span><span class="delimiter">'</span></span>
}

task {
    println <span class="string"><span class="delimiter">'</span><span class="content">Started downloading from JRoller</span><span class="delimiter">'</span></span>
    jroller &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">http://www.jroller.com</span><span class="delimiter">'</span></span>.toURL().text
    println <span class="string"><span class="delimiter">'</span><span class="content">Done downloading from JRoller</span><span class="delimiter">'</span></span>
}

task {
    println <span class="string"><span class="delimiter">'</span><span class="content">Started downloading from TheServerSide</span><span class="delimiter">'</span></span>
    theserverside &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">http://www.theserverside.com</span><span class="delimiter">'</span></span>.toURL().text
    println <span class="string"><span class="delimiter">'</span><span class="content">Done downloading from TheServerSide</span><span class="delimiter">'</span></span>
}

task {
    withPool {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Number of Groovy sites today: </span><span class="delimiter">&quot;</span></span> +
                ([dzone, jroller, theserverside].findAllParallel {
                    <span class="local-variable">it</span>.val.toUpperCase().contains <span class="string"><span class="delimiter">'</span><span class="content">GROOVY</span><span class="delimiter">'</span></span>
                }).size()
    }
}.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_grouping_tasks">Grouping Tasks</h3>
<div class="paragraph">
<p>Dataflow tasks can be organized into groups for performance fine-tuning. Groups provide a handy <em>task()</em> factory method to create tasks attached to these groups.
Using groups allows us to organize tasks or operators around different thread pools (wrapped inside the group).  While the Dataflow.task() command schedules the task on a default thread pool <code>(java.util.concurrent.Executor, fixed size=#cpu+1, daemon threads)</code>,
we might prefer defining our own thread pool(s) to run these tasks.</p>
</div>
<div class="listingblock">
<div class="title">A Personal Thread Pool Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>

<span class="keyword">def</span> group = <span class="keyword">new</span> DefaultPGroup()

group.with {
    task {
        ...
    }

    task {
        ...
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Custom Thread Pools for <strong>Dataflow</strong></div>
<div class="paragraph">
<p>The default thread pool for dataflow tasks has daemon threads. This means our application will exit as soon as the main thread finishes and <strong>won&#8217;t</strong> wait for all tasks to complete!</p>
</div>
<div class="paragraph">
<p>When grouping tasks, make sure the custom thread pools either :</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>use daemon threads ( achieved by using <strong>DefaultPGroup</strong> )</p>
</li>
<li>
<p>provide a thread factory to a thread pool constructor</p>
</li>
<li>
<p>or in case the thread pools use non-daemon threads, ( from the <strong>NonDaemonPGroup</strong> group class ), we must shutdown the group or the thread pool explicitly by calling its <strong>shutdown()</strong> method, otherwise our application will not exit.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>We can selectively override the default group used for tasks, operators, callbacks and other dataflow elements inside a code block using the <em>Dataflow.usingGroup()</em> method:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre>Dataflow.usingGroup(group) {
    task {
        <span class="string"><span class="delimiter">'</span><span class="content">http://gpars.codehaus.org</span><span class="delimiter">'</span></span>.toURL().text  <span class="comment">//should throw MalformedURLException</span>
    }
    .then {page -&gt; page.toUpperCase()}
    .then {page -&gt; page.contains(<span class="string"><span class="delimiter">'</span><span class="content">GROOVY</span><span class="delimiter">'</span></span>)}
    .then({mentionsGroovy -&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">Groovy found: </span><span class="inline"><span class="inline-delimiter">$</span>mentionsGroovy</span><span class="delimiter">&quot;</span></span>}, {error -&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">Error: </span><span class="inline"><span class="inline-delimiter">$</span>error</span><span class="delimiter">&quot;</span></span>}).join()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can always override the default group by being specific:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre>Dataflow.usingGroup(group) {
    anotherGroup.task {
        <span class="string"><span class="delimiter">'</span><span class="content">http://gpars.codehaus.org</span><span class="delimiter">'</span></span>.toURL().text  <span class="comment">//should throw MalformedURLException</span>
    }
    .then(anotherGroup) {page -&gt; page.toUpperCase()}
    .then(anotherGroup) {page -&gt; page.contains(<span class="string"><span class="delimiter">'</span><span class="content">GROOVY</span><span class="delimiter">'</span></span>)}.then(anotherGroup) {println Dataflow.retrieveCurrentDFPGroup();<span class="local-variable">it</span>}
    .then(anotherGroup, {mentionsGroovy -&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">Groovy found: </span><span class="inline"><span class="inline-delimiter">$</span>mentionsGroovy</span><span class="delimiter">&quot;</span></span>}, {error -&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">Error: </span><span class="inline"><span class="inline-delimiter">$</span>error</span><span class="delimiter">&quot;</span></span>}).join()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_a_mashup_variant_with_methods">A Mashup Variant With Methods</h3>
<div class="paragraph">
<p>To avoid giving you wrong impression about structuring the Dataflow code, here&#8217;s a rewrite of the mashup
example, with a <em>downloadPage()</em> method performing the actual download in a separate task and returning a
DataflowVariable instance, so that the main application thread could eventually get hold of the downloaded
content.  Dataflow variables can obviously be passed around as parameters or return values.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
</pre></td>
  <td class="code"><pre><span class="keyword">package</span> groovyx.gpars.samples.dataflow

<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.GParsExecutorsPool.withPool</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowVariable</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>


<span class="comment">/**
 * A simple mashup sample, downloads content of three websites and checks how many of them refer to Groovy.
 */</span>
<span class="directive">final</span> <span class="predefined-type">List</span> urls = [<span class="string"><span class="delimiter">'</span><span class="content">http://www.dzone.com</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">http://www.jroller.com</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">http://www.theserverside.com</span><span class="delimiter">'</span></span>]

task {
    <span class="keyword">def</span> pages = urls.collect { downloadPage(<span class="local-variable">it</span>) }
    withPool {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Number of Groovy sites today: </span><span class="delimiter">&quot;</span></span> +
                (pages.findAllParallel {
                    <span class="local-variable">it</span>.val.toUpperCase().contains <span class="string"><span class="delimiter">'</span><span class="content">GROOVY</span><span class="delimiter">'</span></span>
                }).size()
    }
}.join()

<span class="keyword">def</span> <span class="function">downloadPage</span>(<span class="keyword">def</span> url) {
    <span class="keyword">def</span> page = <span class="keyword">new</span> DataflowVariable()
    task {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Started downloading from </span><span class="inline"><span class="inline-delimiter">$</span>url</span><span class="delimiter">&quot;</span></span>
        page &lt;&lt; url.toURL().text
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Done downloading from </span><span class="inline"><span class="inline-delimiter">$</span>url</span><span class="delimiter">&quot;</span></span>
    }
    <span class="keyword">return</span> page
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_a_physical_calculation_example">A Physical Calculation Example</h3>
<div class="paragraph">
<p>Dataflow programs naturally scale with the number of processors. Up to a certain level, the more processors you have the faster the program runs.
Check out, for example, the following script, which calculates parameters of a simple physical experiment and prints out the results.
Each task performs its part of the calculation and may depend on values calculated by some other tasks and its' results might be needed by some of the other tasks.
With <code>Dataflow Concurrency</code> you can split the work between tasks or reorder the tasks themselves as you like and the dataflow mechanics will ensure the calculation is accomplished correctly.</p>
</div>
<div class="listingblock">
<div class="title">A DataflowVariable Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
39
<strong>40</strong>
41
42
43
44
45
46
47
48
49
<strong>50</strong>
51
52
53
54
55
56
57
58
59
<strong>60</strong>
61
62
63
64
65
66
67
68
69
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowVariable</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

<span class="directive">final</span> <span class="keyword">def</span> mass = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> radius = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> volume = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> density = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> acceleration = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> time = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> velocity = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> decelerationForce = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> deceleration = <span class="keyword">new</span> DataflowVariable()
<span class="directive">final</span> <span class="keyword">def</span> distance = <span class="keyword">new</span> DataflowVariable()

<span class="keyword">def</span> t = task {
    println <span class="string"><span class="delimiter">&quot;&quot;&quot;</span><span class="content">

Calculating distance required to stop a moving ball.
....................................................
The ball has a radius of </span><span class="inline"><span class="inline-delimiter">${</span>radius.val<span class="inline-delimiter">}</span></span><span class="content"> meters and is made of a material with </span><span class="inline"><span class="inline-delimiter">${</span>density.val<span class="inline-delimiter">}</span></span><span class="content"> kg/m3 density,
which means that the ball has a volume of </span><span class="inline"><span class="inline-delimiter">${</span>volume.val<span class="inline-delimiter">}</span></span><span class="content"> m3 and a mass of </span><span class="inline"><span class="inline-delimiter">${</span>mass.val<span class="inline-delimiter">}</span></span><span class="content"> kg.
The ball has been accelerating with </span><span class="inline"><span class="inline-delimiter">${</span>acceleration.val<span class="inline-delimiter">}</span></span><span class="content"> m/s2 from 0 for </span><span class="inline"><span class="inline-delimiter">${</span>time.val<span class="inline-delimiter">}</span></span><span class="content"> seconds and so reached a velocity of </span><span class="inline"><span class="inline-delimiter">${</span>velocity.val<span class="inline-delimiter">}</span></span><span class="content"> m/s.

Given our ability to push the ball backwards with a force of </span><span class="inline"><span class="inline-delimiter">${</span>decelerationForce.val<span class="inline-delimiter">}</span></span><span class="content"> N (Newton), we can cause a deceleration
of </span><span class="inline"><span class="inline-delimiter">${</span>deceleration.val<span class="inline-delimiter">}</span></span><span class="content"> m/s2 and so stop the ball at a distance of </span><span class="inline"><span class="inline-delimiter">${</span>distance.val<span class="inline-delimiter">}</span></span><span class="content"> m.
...................................................

This example has been calculated asynchronously in multiple tasks using *GPars* Dataflow concurrency in Groovy.
Author: </span><span class="inline"><span class="inline-delimiter">${</span>author.val<span class="inline-delimiter">}</span></span><span class="content">
</span><span class="delimiter">&quot;&quot;&quot;</span></span>

    <span class="predefined-type">System</span>.exit <span class="integer">0</span>
}

task {
    mass &lt;&lt; volume.val * density.val
}

task {
    volume &lt;&lt; <span class="predefined-type">Math</span>.PI * (radius.val ** <span class="integer">3</span>)
}

task {
    radius &lt;&lt; <span class="float">2.5</span>
    density &lt;&lt;         <span class="float">998.2071</span>  <span class="comment">//water</span>
    acceleration &lt;&lt; <span class="float">9.80665</span> <span class="comment">//free fall</span>
    decelerationForce &lt;&lt; <span class="integer">900</span>
}

task {
    println <span class="string"><span class="delimiter">'</span><span class="content">Enter your name:</span><span class="delimiter">'</span></span>
    <span class="keyword">def</span> name = <span class="keyword">new</span> <span class="predefined-type">InputStreamReader</span>(<span class="predefined-type">System</span>.in).readLine()
    author &lt;&lt; (name?.trim()?.size()&gt;<span class="integer">0</span> ? name : <span class="string"><span class="delimiter">'</span><span class="content">anonymous</span><span class="delimiter">'</span></span>)
}

task {
    time &lt;&lt; <span class="integer">10</span>
    velocity &lt;&lt; acceleration.val * time.val
}

task {
    deceleration &lt;&lt; decelerationForce.val / mass.val
}

task {
    distance &lt;&lt; deceleration.val * ((velocity.val/deceleration.val) ** <span class="integer">2</span>) * <span class="float">0.5</span>
}

t.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
I did my best to make all the physical calculations right. Feel free to change the values and see how long a distance you need to stop the rolling ball.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_deterministic_deadlocks">Deterministic Deadlocks</h3>
<div class="paragraph">
<p>If you happen to introduce a deadlock in your dependencies, the deadlock will occur each time you run the code. No randomness is allowed.
That&#8217;s one of the benefits of <code>Dataflow Concurrency</code>.  Irrespective of the actual thread scheduling scheme, if you don&#8217;t get a deadlock in tests,
you won&#8217;t get them in production.</p>
</div>
<div class="listingblock">
<div class="title">A Deterministic Deadlock Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre>task {
    println a.val
    b &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Hi there</span><span class="delimiter">'</span></span>
}

task {
    println b.val
    a &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Hello man</span><span class="delimiter">'</span></span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="__strong_dataflows_strong_map"><strong>Dataflows</strong> Map</h3>
<div class="paragraph">
<p>As a handy shortcut the <em>Dataflows</em> class can help you reduce the amount of code you need to leverage <code>Dataflow Variables</code>.</p>
</div>
<div class="listingblock">
<div class="title">A Convenience Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> df = <span class="keyword">new</span> Dataflows()
df.x = <span class="string"><span class="delimiter">'</span><span class="content">value1</span><span class="delimiter">'</span></span>

<span class="keyword">assert</span> df.x == <span class="string"><span class="delimiter">'</span><span class="content">value1</span><span class="delimiter">'</span></span>

Dataflow.task {df.y = <span class="string"><span class="delimiter">'</span><span class="content">value2}</span></span><span class="error">
</span>
<span class="keyword">assert</span> df.y == <span class="string"><span class="delimiter">'</span><span class="content">value2</span><span class="delimiter">'</span></span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Think of <strong>Dataflows</strong> as a map with <code>Dataflow Variables</code> as keys storing their bound values as appropriate map values.
The semantics of reading a value (e.g. df.x) and binding a value (e.g. df.x = 'value') are identical to the semantics of plain <code>Dataflow Variables</code> (x.val and x &lt;&lt; 'value' respectively).</p>
</div>
<hr>
<div class="sect3">
<h4 id="_mixing_em_dataflows_em_and_strong_groovy_strong_em_with_em_blocks">Mixing <em>Dataflows</em> and <strong>Groovy</strong> <em>with</em> blocks</h4>
<div class="paragraph">
<p>When inside a <em>with</em> block of a <strong>Dataflows</strong> instance, the <code>Dataflow Variables</code> stored inside the <strong>Dataflows</strong> instance can be accessed directly without the need to prefix them with the <strong>Dataflows</strong> instance identifier.</p>
</div>
<div class="listingblock">
<div class="title">A <em>with</em> block Makes Coding Easier</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre><span class="keyword">new</span> Dataflows().with {
    x = <span class="string"><span class="delimiter">'</span><span class="content">value1</span><span class="delimiter">'</span></span>
    <span class="keyword">assert</span> x == <span class="string"><span class="delimiter">'</span><span class="content">value1</span><span class="delimiter">'</span></span>

    Dataflow.task {y = <span class="string"><span class="delimiter">'</span><span class="content">value2}</span></span><span class="error">
</span>
    <span class="keyword">assert</span> y == <span class="string"><span class="delimiter">'</span><span class="content">value2</span><span class="delimiter">'</span></span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_returning_values_from_a_task">Returning Values From A Task</h3>
<div class="paragraph">
<p>Typically, <strong>Dataflow</strong> tasks communicate through <code>Dataflow Variables</code>. On top of that, tasks can also return values, again through a <code>Dataflow Variable</code>.
When you invoke the <em>task()</em> factory method, you get back an instance of a  <strong>Promise</strong> (implemented as <code>DataflowVariable</code>), through which you can listen for the task&#8217;s return value,
just like when using any other <strong>Promise</strong> or <code>DataflowVariable</code>.</p>
</div>
<div class="listingblock">
<div class="title">A Task Returns A Value Using a <strong>Promise</strong></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
</pre></td>
  <td class="code"><pre>    <span class="directive">final</span> Promise t1 = task {
        <span class="keyword">return</span> <span class="integer">10</span>
    }
    <span class="directive">final</span> Promise t2 = task {
        <span class="keyword">return</span> <span class="integer">20</span>
    }

    <span class="keyword">def</span> results = [t1, t2]*.val

    println <span class="string"><span class="delimiter">'</span><span class="content">Both sub-tasks finished and returned values: </span><span class="delimiter">'</span></span> + results</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The value can also be obtained without blocking the caller using the <em>whenBound()</em> method.
</td>
</tr>
</table>
</div>
<hr>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> task = task {
    println <span class="string"><span class="delimiter">'</span><span class="content">The task is running and calculating the return value</span><span class="delimiter">'</span></span>
    <span class="integer">30</span>        <span class="comment">// the value to be returned</span>
}
task &gt;&gt; {value -&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">The task finished and returned </span><span class="inline"><span class="inline-delimiter">$</span>value</span><span class="delimiter">&quot;</span></span>}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_joining_tasks">Joining Tasks</h3>
<div class="paragraph">
<p>Using the <em>join()</em> operation on the resulting <code>Dataflow Variable</code> of a task, you can block until the task finishes.</p>
</div>
<div class="listingblock">
<div class="title">A Bloacking Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
</pre></td>
  <td class="code"><pre> task {
     <span class="directive">final</span> Promise t1 = task {
         println <span class="string"><span class="delimiter">'</span><span class="content">First sub-task running.</span><span class="delimiter">'</span></span>
     }
     <span class="directive">final</span> Promise t2 = task {
         println <span class="string"><span class="delimiter">'</span><span class="content">Second sub-task running</span><span class="delimiter">'</span></span>
     }
     [t1, t2]*.join()
     println <span class="string"><span class="delimiter">'</span><span class="content">Both sub-tasks finished</span><span class="delimiter">'</span></span>
 }.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_selects">Selects</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Frequently, a value needs to be obtained from one of several dataflow channels (such as variables, queues, broadcasts or streams). The <em>Select</em> class is suitable for these scenarios.</p>
</div>
<div class="paragraph">
<p><em>Select</em> can scan several dataflow channels and pick one channel from all the input channels, with a value that&#8217;s ready to be read. The value from that chosen channel is read and returned
to the caller together with the index of the originating channel.  Picking the channel is either random, or based on channel priority, in which case, channels with a lower position index in the <em>Select</em> constructor have higher priority.</p>
</div>
<div class="listingblock">
<div class="title">Selecting A Value From Multiple Channels</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowVariable</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.select</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

<span class="comment">/**
 * Shows a basic use of Select, which monitors a set of input channels for values and makes these values
 * available on its output irrespective of their original input channel.
 * Note that dataflow variables and queues can be combined for Select.
 *
 * You might also consider checking out the prioritySelect method, which prioritizes values by the index of their input channel
 */</span>
<span class="keyword">def</span> a = <span class="keyword">new</span> DataflowVariable()
<span class="keyword">def</span> b = <span class="keyword">new</span> DataflowVariable()
<span class="keyword">def</span> c = <span class="keyword">new</span> DataflowQueue()

task {
    sleep <span class="integer">3000</span>
    a &lt;&lt; <span class="integer">10</span>
}

task {
    sleep <span class="integer">1000</span>
    b &lt;&lt; <span class="integer">20</span>
}

task {
    sleep <span class="integer">5000</span>
    c &lt;&lt; <span class="integer">30</span>
}

<span class="keyword">def</span> select = select([a, b, c])

println <span class="string"><span class="delimiter">&quot;</span><span class="content">The fastest result is </span><span class="inline"><span class="inline-delimiter">${</span>select().value<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">A <em>select()</em> Method Returns What ?</div>
<div class="paragraph">
<p>Note that the return type from <em>select()</em> is <em>SelectResult</em> , holding the value as well as the original channel index.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>There are several ways to read values from a <strong>Select</strong>:</p>
</div>
<div class="listingblock">
<div class="title">How Do I <strong>Select</strong> Thee ? Let Me Count The Ways !</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> sel = select(a, b, c, d)
<span class="keyword">def</span> result = sel.select()                                       <span class="comment">//Random selection</span>
<span class="keyword">def</span> result = sel()                                              <span class="comment">//Random selection (a short-hand variant)</span>
<span class="keyword">def</span> result = sel.select([<span class="predefined-constant">true</span>, <span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>])              <span class="comment">//Random selection with guards specified</span>
<span class="keyword">def</span> result = sel([<span class="predefined-constant">true</span>, <span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>])                     <span class="comment">//Random selection with guards specified (a short-hand variant)</span>

<span class="keyword">def</span> result = sel.prioritySelect()                               <span class="comment">//Priority selection</span>
<span class="keyword">def</span> result = sel.prioritySelect([<span class="predefined-constant">true</span>, <span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>])      <span class="comment">//Priority selection with guards specifies</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, the <em>Select</em> method blocks processing of the caller until a value is available to be read. The alternative <em>selectToPromise()</em> and <em>prioritySelectToPromise()</em>
methods give us a way to obtain a <strong>Promise</strong> of a  value that can be selected later. Through the returned <strong>Promise</strong>, you can register a callback to invoke asynchronously whenever the next value is selected.</p>
</div>
<div class="listingblock">
<div class="title">Random And Priority Seletions</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> sel = select(a, b, c, d)

Promise result = sel.selectToPromise()                                       <span class="comment">//Random selection</span>
Promise result = sel.selectToPromise([<span class="predefined-constant">true</span>, <span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>])              <span class="comment">//Random selection with guards specified</span>

Promise result = sel.prioritySelectToPromise()                               <span class="comment">//Priority selection</span>
Promise result = sel.prioritySelectToPromise([<span class="predefined-constant">true</span>, <span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>])      <span class="comment">//Priority selection with guards specifies</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Another Way ?</div>
<p>Alternatively, the <em>Select</em> method can have it&#8217;s value sent to a declared <em>MessageStream</em> (e.g. an <strong>Actor</strong>) without blocking the caller.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> handler = actor {...}
<span class="keyword">def</span> sel = select(a, b, c, d)

sel.select(handler)                                         <span class="comment">//Random selection</span>
sel(handler)                                                <span class="comment">//Random selection (a short-hand variant)</span>
sel.select(handler, [<span class="predefined-constant">true</span>, <span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>])              <span class="comment">//Random selection with guards specified</span>
sel(handler, [<span class="predefined-constant">true</span>, <span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>])                     <span class="comment">//Random selection with guards specified (a short-hand variant)</span>

sel.prioritySelect(handler)                                 <span class="comment">//Priority selection</span>
sel.prioritySelect(handler, [<span class="predefined-constant">true</span>, <span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>])      <span class="comment">//Priority selection with guards specifies</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_guards">Guards</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Guards</strong> let the caller omit some input channels from the selection. <strong>Guards</strong> are specified as a List of boolean flags passed to the <em>select()</em> or <em>prioritySelect()</em> methods.</p>
</div>
<div class="listingblock">
<div class="title">A Useful Filter Tool</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> sel = select(leaders, seniors, experts, juniors)
<span class="keyword">def</span> teamLead = sel([<span class="predefined-constant">true</span>, <span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>, <span class="predefined-constant">false</span>]).value        <span class="comment">//Only 'leaders' and 'seniors' qualify for becoming a teamLead here</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>A typical use for <strong>Guards</strong> is to make <strong>Selects</strong> flexible enough to adapt to changes in user state.</p>
</div>
<div class="listingblock">
<div class="title">Guards Enable/Disable Channels During Value Selection</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.select</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

<span class="comment">/**
 * Demonstrates the ability to enable/disable channels during a value selection on a Select by providing boolean guards.
 */</span>
<span class="directive">final</span> DataflowQueue operations = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowQueue numbers = <span class="keyword">new</span> DataflowQueue()

<span class="keyword">def</span> t = task {
    <span class="directive">final</span> <span class="keyword">def</span> select = select(operations, numbers)
    <span class="integer">3</span>.times {
        <span class="keyword">def</span> instruction = select([<span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>]).value
        <span class="keyword">def</span> num1 = select([<span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>]).value
        <span class="keyword">def</span> num2 = select([<span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>]).value
        <span class="directive">final</span> <span class="keyword">def</span> formula = <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>num1</span><span class="content"> </span><span class="inline"><span class="inline-delimiter">$</span>instruction</span><span class="content"> </span><span class="inline"><span class="inline-delimiter">$</span>num2</span><span class="delimiter">&quot;</span></span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>formula</span><span class="content"> = </span><span class="inline"><span class="inline-delimiter">${</span><span class="keyword">new</span> GroovyShell().evaluate(formula)<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
    }
}

task {
    operations &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">+</span><span class="delimiter">'</span></span>
    operations &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">+</span><span class="delimiter">'</span></span>
    operations &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">*</span><span class="delimiter">'</span></span>
}

task {
    numbers &lt;&lt; <span class="integer">10</span>
    numbers &lt;&lt; <span class="integer">20</span>
    numbers &lt;&lt; <span class="integer">30</span>
    numbers &lt;&lt; <span class="integer">40</span>
    numbers &lt;&lt; <span class="integer">50</span>
    numbers &lt;&lt; <span class="integer">60</span>
}

t.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="sect2">
<h3 id="_priority_select">Priority Select</h3>
<div class="paragraph">
<p>When certain channels should have precedence over others when selecting, the <strong>prioritySelect</strong> methods should be used instead.</p>
</div>
<div class="listingblock">
<div class="title">A <strong>prioritySelect</strong> Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
39
<strong>40</strong>
41
</pre></td>
  <td class="code"><pre><span class="comment">/**
 * Here's a simply usecase for Priority Select. It monitors a set of input channels for values and makes these values
 * available on its output irrespective of their original input channel.
 *
 * Note that dataflow variables, queues and broadcasts can be combined for Select.
 *
 * Unlike plain select method call, the prioritySelect call gives precedence to input channels with lower index.
 * Available messages from high priority channels will be served before messages from lower-priority channels.
 * Messages received through a single input channel will have their mutual order preserved.
 *
 */</span>
<span class="keyword">def</span> critical = <span class="keyword">new</span> DataflowVariable()
<span class="keyword">def</span> ordinary = <span class="keyword">new</span> DataflowQueue()
<span class="keyword">def</span> whoCares = <span class="keyword">new</span> DataflowQueue()

task {
    ordinary &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">All working fine</span><span class="delimiter">'</span></span>
    whoCares &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">I feel a bit tired</span><span class="delimiter">'</span></span>
    ordinary &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">We are on target</span><span class="delimiter">'</span></span>
}

task {
    ordinary &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">I have just started my work. Busy. Will come back later...</span><span class="delimiter">'</span></span>
    sleep <span class="integer">5000</span>
    ordinary &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">I am done for now</span><span class="delimiter">'</span></span>
}

task {
    whoCares &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Huh, what is that noise</span><span class="delimiter">'</span></span>
    ordinary &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Here I am to do some clean-up work</span><span class="delimiter">'</span></span>
    whoCares &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">I wonder whether unplugging this cable will eliminate that nasty sound.</span><span class="delimiter">'</span></span>
    critical &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">The server room runs on UPS!</span><span class="delimiter">'</span></span>
    whoCares &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">The sound has disappeared</span><span class="delimiter">'</span></span>
}

<span class="keyword">def</span> select = select([critical, ordinary, whoCares])

println <span class="string"><span class="delimiter">'</span><span class="content">Starting to monitor our IT department</span><span class="delimiter">'</span></span>

sleep <span class="integer">3000</span>
<span class="integer">10</span>.times {println <span class="string"><span class="delimiter">&quot;</span><span class="content">Received: </span><span class="inline"><span class="inline-delimiter">${</span>select.prioritySelect().value<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_collecting_results_of_asynchronous_computations">Collecting Results of Asynchronous Computations</h3>
<div class="paragraph">
<p>No matter whether they are <strong>dataflow tasks</strong> , <strong>active objects' methods</strong> or <strong>asynchronous functions</strong>, asynchronous activities always return a <strong>Promise</strong>.
<strong>Promises</strong> implement the <em>SelectableChannel</em> interface and so can be passed in <em>selects</em> for selection together with other <strong>Promises</strong> as well as <em>read channels</em> .</p>
</div>
<div class="paragraph">
<p>Similarly to <strong>Java</strong>'s <em>CompletionService</em> , our <strong>GPars</strong> <em>Select</em> method enables you to obtain results of asynchronous activities as soon as each becomes available.
Also, we can use a <em>Select</em> to give us the first/fastest result from the first of several computations running in parallel.</p>
</div>
<div class="listingblock">
<div class="title">How To Pick The Fastest Result</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.Promise</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.Select</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>
<span class="comment">/**
 * Demonstrates the use of dataflow tasks and selects to pick the fastest result of concurrently run calculations.
 */</span>

<span class="directive">final</span> group = <span class="keyword">new</span> DefaultPGroup()
group.with {
    Promise p1 = task {
        sleep(<span class="integer">1000</span>)
        <span class="integer">10</span> * <span class="integer">10</span> + <span class="integer">1</span>
    }
    Promise p2 = task {
        sleep(<span class="integer">1000</span>)
        <span class="integer">5</span> * <span class="integer">20</span> + <span class="integer">2</span>
    }
    Promise p3 = task {
        sleep(<span class="integer">1000</span>)
        <span class="integer">1</span> * <span class="integer">100</span> + <span class="integer">3</span>
    }

    <span class="directive">final</span> alt = <span class="keyword">new</span> Select(group, p1, p2, p3)

    <span class="keyword">def</span> result = alt.select()
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="delimiter">&quot;</span></span> + result
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_timeouts">Timeouts</h3>
<div class="paragraph">
<p>The <em>Select.createTimeout()</em> method will create a <strong>DataflowVariable</strong> bound to a value after a declared time period.
This can be leveraged in <em>Selects</em> so that they unblock(resume processing) after a desired delay, if none of the other channels delivers a value before that time.
Simply pass a <strong>timeout channel</strong> as another input channel to the <em>Select</em> .</p>
</div>
<div class="listingblock">
<div class="title">A <strong>Timeout Channel</strong> Helps Pick The Fastest Answer</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.Promise</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.Select</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>
<span class="comment">/**
 * Demonstrates the use of dataflow tasks and selects to pick the fastest result of concurrently run calculations.
 */</span>

<span class="directive">final</span> group = <span class="keyword">new</span> DefaultPGroup()
group.with {
    Promise p1 = task {
        sleep(<span class="integer">1000</span>)
        <span class="integer">10</span> * <span class="integer">10</span> + <span class="integer">1</span>
    }
    Promise p2 = task {
        sleep(<span class="integer">1000</span>)
        <span class="integer">5</span> * <span class="integer">20</span> + <span class="integer">2</span>
    }
    Promise p3 = task {
        sleep(<span class="integer">1000</span>)
        <span class="integer">1</span> * <span class="integer">100</span> + <span class="integer">3</span>
    }

    <span class="directive">final</span> timeoutChannel = Select.createTimeout(<span class="integer">500</span>)

    <span class="directive">final</span> alt = <span class="keyword">new</span> Select(group, p1, p2, p3, timeoutChannel)

    <span class="keyword">def</span> result = alt.select()
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="delimiter">&quot;</span></span> + result
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_cancellations">Cancellations</h3>
<div class="paragraph">
<p>Ok, so we have our answer. What bout the other tasks that continue to work on their answer? If we need to cancel those other tasks once an answer was found or maybe a timeout expired,
then the best way is to set a flag that our tasks periodically monitor.</p>
</div>
<hr>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Intentionally, There&#8217;s no cancellation machinery built into <em>DataflowVariables</em> or <em>Tasks</em>
</td>
</tr>
</table>
</div>
<hr>
<div class="listingblock">
<div class="title">A Sample To Pick The Fastest Answer And Cancel The Others</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.Promise</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.Select</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>

<span class="keyword">import</span> <span class="include">java.util.concurrent.atomic.AtomicBoolean</span>

<span class="comment">/**
 * Demonstrates the use of dataflow tasks and selects to pick the fastest result of concurrently run calculations.
 * It shows a waY to cancel the slower tasks once a result is known
 */</span>

<span class="directive">final</span> group = <span class="keyword">new</span> DefaultPGroup()
<span class="directive">final</span> done = <span class="keyword">new</span> <span class="predefined-type">AtomicBoolean</span>()

group.with {
    Promise p1 = task {
        sleep(<span class="integer">1000</span>)
        <span class="keyword">if</span> (done.get()) <span class="keyword">return</span>
        <span class="integer">10</span> * <span class="integer">10</span> + <span class="integer">1</span>
    }
    Promise p2 = task {
        sleep(<span class="integer">1000</span>)
        <span class="keyword">if</span> (done.get()) <span class="keyword">return</span>
        <span class="integer">5</span> * <span class="integer">20</span> + <span class="integer">2</span>
    }
    Promise p3 = task {
        sleep(<span class="integer">1000</span>)
        <span class="keyword">if</span> (done.get()) <span class="keyword">return</span>
        <span class="integer">1</span> * <span class="integer">100</span> + <span class="integer">3</span>
    }

    <span class="directive">final</span> alt = <span class="keyword">new</span> Select(group, p1, p2, p3, Select.createTimeout(<span class="integer">500</span>))

    <span class="keyword">def</span> result = alt.select()
    done.set(<span class="predefined-constant">true</span>)

    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="delimiter">&quot;</span></span> + result
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_operators">Operators</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>Dataflow Operators</code> and <code>Selectors</code> provide a full <strong>Dataflow</strong> implementation with all the usual ceremony.</p>
</div>
<div class="sect2">
<h3 id="_concepts_2">Concepts</h3>
<div class="paragraph">
<p>Full <code>Dataflow Concurrency</code> builds on the concept of channels connecting operators and selectors. These objects consume values coming through input channels,
transform them into new values and output the new values into their output channels.</p>
</div>
<div class="paragraph">
<p><em>Operators</em> wait for <strong>every</strong> input channel to have a value before starting to process them but <em>Selectors</em> only wait for the first available value on <strong>any</strong> of its' input channels.</p>
</div>
<div class="listingblock">
<div class="title">An Operator Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>operator(<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d]) {x, y, z -&gt;
    ...
    bindOutput <span class="integer">0</span>, x + y + z
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">A Sample Cache</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
39
<strong>40</strong>
41
42
43
44
45
</pre></td>
  <td class="code"><pre><span class="comment">/**
 * CACHE
 *
 * Caches sites' contents. Accepts requests for url content, outputs the content. Outputs requests for download
 * if the site is not in cache yet.
 */</span>
operator(<span class="key">inputs</span>: [urlRequests], <span class="key">outputs</span>: [downloadRequests, sites]) {request -&gt;

    <span class="keyword">if</span> (!request.content) {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">[Cache] Retrieving </span><span class="inline"><span class="inline-delimiter">${</span>request.site<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>

        <span class="keyword">def</span> content = cache[request.site]

        <span class="keyword">if</span> (content) {
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">[Cache] Found in cache</span><span class="delimiter">&quot;</span></span>
            bindOutput <span class="integer">1</span>, [<span class="key">site</span>: request.site, <span class="key">word</span>:request.word, <span class="key">content</span>: content]
        } <span class="keyword">else</span> {
            <span class="keyword">def</span> downloads = pendingDownloads[request.site]
            <span class="keyword">if</span> (downloads != <span class="predefined-constant">null</span>) {
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">[Cache] Awaiting download</span><span class="delimiter">&quot;</span></span>
                downloads &lt;&lt; request
            } <span class="keyword">else</span> {
                pendingDownloads[request.site] = <span class="type">[]</span>
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">[Cache] Asking for download</span><span class="delimiter">&quot;</span></span>
                bindOutput <span class="integer">0</span>, request
            }
        }

    } <span class="keyword">else</span> {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">[Cache] Caching </span><span class="inline"><span class="inline-delimiter">${</span>request.site<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>

        cache[request.site] = request.content
        bindOutput <span class="integer">1</span>, request

        <span class="keyword">def</span> downloads = pendingDownloads[request.site]

        <span class="keyword">if</span> (downloads != <span class="predefined-constant">null</span>) {
            <span class="keyword">for</span> (downloadRequest <span class="keyword">in</span> downloads) {
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">[Cache] Waking up</span><span class="delimiter">&quot;</span></span>
                bindOutput <span class="integer">1</span>, [<span class="key">site</span>: downloadRequest.site, <span class="key">word</span>:downloadRequest.word, <span class="key">content</span>: request.content]
            }
            pendingDownloads.remove(request.site)
        }
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Exception Handling Explained</div>
<div class="paragraph">
<p>Standard error handling prints an error message to the standard error output and terminates the operator in case an uncaught exception is thrown from withing the operator&#8217;s body.
To alter the behavior, you can register your own event listener. See the <em>Operator Lifecycle</em> section for more details.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">Exception Handling Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> listener = <span class="keyword">new</span> DataflowEventAdapter() {

    <span class="annotation">@Override</span>
    <span class="type">boolean</span> onException(<span class="directive">final</span> DataflowProcessor processor, <span class="directive">final</span> <span class="predefined-type">Throwable</span> e) {
        logChannel &lt;&lt; e
        <span class="keyword">return</span> <span class="predefined-constant">false</span>   <span class="comment">//Indicate whether to terminate the operator or not</span>
    }
}

op = group.operator(<span class="key">inputs</span>: [a, b], <span class="key">outputs</span>: [c], <span class="key">listeners</span>: [listener]) {x, y -&gt;
    ...
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="sect3">
<h4 id="_types_of_operators">Types of Operators</h4>
<div class="paragraph">
<p>There are specialized versions of operator methods for specific purposes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>operator - the basic general-purpose operator</p>
</li>
<li>
<p>selector - operator triggered by a value being available on any input channel</p>
</li>
<li>
<p>prioritySelector - a selector that prefers delivering messages from lower-indexed input channels over higher-indexed ones</p>
</li>
<li>
<p>splitter - a single-input operator copying its input values to all of its output channels</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_wiring_operators_together">Wiring Operators Together</h5>
<div class="paragraph">
<p>Operators are typically combined into networks, like when some operators consume output produced by other operators.</p>
</div>
<div class="listingblock">
<div class="title">Using Several Operators</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>operator(<span class="key">inputs</span>:[a, b], <span class="key">outputs</span>:[c, d]) {...}
splitter(c, [e, f])
selector(<span class="key">inputs</span>:[e, d]: <span class="key">outputs</span>:<span class="type">[]</span>) {...}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>You may alternatively refer to output channels through operators themselves:</p>
</div>
<div class="listingblock">
<div class="title">A More Complex Operator Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> op1 = operator(<span class="key">inputs</span>:[a, b], <span class="key">outputs</span>:[c, d]) {...}
<span class="keyword">def</span> sp1 = splitter(op1.outputs[<span class="integer">0</span>], [e, f])                            <span class="comment">//takes the first output of op1</span>

selector(<span class="key">inputs</span>:[sp1.outputs[<span class="integer">0</span>], op1.outputs[<span class="integer">1</span>]]: <span class="key">outputs</span>:<span class="type">[]</span>) {...}   <span class="comment">//takes the first output of sp1 and the second output of op1</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="_grouping_operators">Grouping Operators</h4>
<div class="paragraph">
<p><strong>Dataflow</strong> operators can be organized into groups for performance fine-tuning. Groups provide a handy <em>operator()</em> factory method to create tasks attached to the groups.</p>
</div>
<div class="listingblock">
<div class="title">For Performance Fine-tuning ? Use <strong>Groups</strong></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>

<span class="keyword">def</span> group = <span class="keyword">new</span> DefaultPGroup()

group.with {
    operator(<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d]) {x, y, z -&gt;
        ...
        bindOutput <span class="integer">0</span>, x + y + z
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Custom Thread Pools For <strong>Dataflow</strong></div>
<div class="paragraph">
<p>The default thread pool for dataflow operators contains daemon threads, which means your application will exit as soon as the main thread finishes and won&#8217;t wait for all tasks to complete.</p>
</div>
<div class="paragraph">
<p>When grouping operators, make sure your custom thread pools use either daemon threads, too, which can be achieved by using DefaultPGroup or by providing your own thread factory to a thread pool constructor, or in case your thread
pools use non-daemon threads, such as when using the NonDaemonPGroup group class, make sure you shutdown the group or the thread pool explicitly by calling its shutdown() method, otherwise your applications will not exit.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>You may selectively override the default group used for tasks, operators, callbacks and other dataflow
elements inside a code block using the <em>Dataflow.usingGroup()</em> method:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>Dataflow.usingGroup(group) {
    operator(<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d]) {x, y, z -&gt;
        ...
        bindOutput <span class="integer">0</span>, x + y + z
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can always override the default group by being specific:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>Dataflow.usingGroup(group) {
    anotherGroup.operator(<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d]) {x, y, z -&gt;
        ...
        bindOutput <span class="integer">0</span>, x + y + z
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_constructing_operators">Constructing Operators</h3>
<div class="paragraph">
<p>The construction properties of an operator, such as <em>inputs</em>, <em>outputs</em>, <em>stateObject</em> or <em>maxForks</em> cannot
be modified once the operator has been build.  You may find the <em>groovyx.gpars.dataflow.ProcessingNode</em>
class helpful when gradually collecting channels and values into lists before you finally build an operator.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.Dataflow</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.ProcessingNode.node</span>

<span class="comment">/**
 * Shows how to build operators using the ProcessingNode class
 */</span>

<span class="directive">final</span> DataflowQueue aValues = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowQueue bValues = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowQueue results = <span class="keyword">new</span> DataflowQueue()

<span class="comment">//Create a config and gradually set the required properties - channels, code, etc.</span>
<span class="keyword">def</span> adderConfig = node {valueA, valueB -&gt;
    bindOutput valueA + valueB
}
adderConfig.inputs &lt;&lt; aValues
adderConfig.inputs &lt;&lt; bValues
adderConfig.outputs &lt;&lt; results

<span class="comment">//Build the operator</span>
<span class="directive">final</span> adder = adderConfig.operator(Dataflow.DATA_FLOW_GROUP)

<span class="comment">//Now the operator is running and processing the data</span>
aValues &lt;&lt; <span class="integer">10</span>
aValues &lt;&lt; <span class="integer">20</span>
bValues &lt;&lt; <span class="integer">1</span>
bValues &lt;&lt; <span class="integer">2</span>

<span class="keyword">assert</span> [<span class="integer">11</span>, <span class="integer">22</span>] == (<span class="integer">1</span>..<span class="integer">2</span>).collect {
    results.val
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_holding_state_in_operators">Holding State in Operators</h3>
<div class="paragraph">
<p>Although operators can frequently do without keeping state between subsequent invocations, <strong>GPars</strong> allows
operators to maintain state, if desired by the developer. One obvious way is to leverage the <strong>Groovy</strong> closure
capabilities to close-over their context:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="type">int</span> counter = <span class="integer">0</span>
operator(<span class="key">inputs</span>: [a], <span class="key">outputs</span>: [b]) {value -&gt;
    counter += <span class="integer">1</span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Another way, which allows you to avoid declaring the state object outside of the operator definition, is to pass the state object
into the operator as a <em>stateObject</em> parameter at construction time:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>operator(<span class="key">inputs</span>: [a], <span class="key">outputs</span>: [b], <span class="key">stateObject</span>: [<span class="key">counter</span>: <span class="integer">0</span>]) {value -&gt;
    stateObject.counter += <span class="integer">1</span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_parallelize_operators">Parallelize Operators</h3>
<div class="paragraph">
<p>By default an operator&#8217;s body is processed by a single thread at a time. While this is a safe setting
allowing the operator&#8217;s body to be written in a non-thread-safe manner, once an operator becomes "hot" and
data start to accumulate in the operator&#8217;s input queues, you might consider allowing multiple threads to run
the operator&#8217;s body concurrently. Bear in mind that in such a case you need to avoid or protect shared
resources from multi-threaded access.  To enable multiple threads to run the operator&#8217;s body concurrently,
pass an extra <em>maxForks</em> parameter when creating an operator:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> op = operator(<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d, e], <span class="key">maxForks</span>: <span class="integer">2</span>) {x, y, z -&gt;
    bindOutput <span class="integer">0</span>, x + y + z
    bindOutput <span class="integer">1</span>, x * y * z
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of the <em>maxForks</em> parameter indicates the maximum of threads running the operator
concurrently. Only positive numbers are allowed with value 1 being the default.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Thread Starvation</div>
<div class="paragraph">
<p>Please always make sure the <strong>group</strong> serving the operator holds enough threads to support all requested
forks.  Using groups allows you to organize tasks or operators around different thread pools (wrapped inside
the group).  While the Dataflow.task() command schedules the task on a default thread pool
(java.util.concurrent.Executor, fixed size=#cpu+1, daemon threads), you may prefer being able to define your
own thread pool(s) to run your tasks.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> group = <span class="keyword">new</span> DefaultPGroup(<span class="integer">10</span>)
group.operator((<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d, e], <span class="key">maxForks</span>: <span class="integer">5</span>) {x, y, z -&gt; ...}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The default group uses a resizeable thread pool as so will never run out of threads.</p>
</div>
<hr>
<div class="sect3">
<h4 id="_synchronizing_outputs">Synchronizing Outputs</h4>
<div class="paragraph">
<p>When enabling internal parallelization of an operator by setting the value for <em>maxForks</em> to a value greater
than 1 it is important to remember that without explicit or implicit synchronization in the operators' body
race-conditions may occur.  Especially bear in mind that values written to multiple output channels are not
guarantied to be written atomically in the same order to all the channels</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre>operator(<span class="key">inputs</span>:[inputChannel], <span class="key">outputs</span>:[a, b], <span class="key">maxForks</span>:<span class="integer">5</span>) {msg -&gt;
    bindOutput <span class="integer">0</span>, msg
    bindOutput <span class="integer">1</span>, msg
}
inputChannel &lt;&lt; <span class="integer">1</span>
inputChannel &lt;&lt; <span class="integer">2</span>
inputChannel &lt;&lt; <span class="integer">3</span>
inputChannel &lt;&lt; <span class="integer">4</span>
inputChannel &lt;&lt; <span class="integer">5</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>May result in output channels having the values mixed-up something like:</pre>
</div>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre>a -&gt; <span class="integer">1</span>, <span class="integer">3</span>, <span class="integer">2</span>, <span class="integer">4</span>, <span class="integer">5</span>
b -&gt; <span class="integer">2</span>, <span class="integer">1</span>, <span class="integer">3</span>, <span class="integer">5</span>, <span class="integer">4</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Explicit synchronization is one way to get correctly bound all output channels and protect operator not-thread local state:</pre>
</div>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> lock = <span class="keyword">new</span> <span class="predefined-type">Object</span>()
operator(<span class="key">inputs</span>:[inputChannel], <span class="key">outputs</span>:[a, b], <span class="key">maxForks</span>:<span class="integer">5</span>) {msg -&gt;
    doStuffThatIsThreadSafe()

    <span class="directive">synchronized</span>(lock) {
        doSomethingThatMustNotBeAccessedByMultipleThreadsAtTheSameTime()
        bindOutput <span class="integer">0</span>, msg
        bindOutput <span class="integer">1</span>, <span class="integer">2</span>*msg
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Obviously you need to weight the pros and cons here, since synchronization may defeat the purpose of setting
<em>maxForks</em> to a value greater than 1.</p>
</div>
<div class="paragraph">
<p>To set values of all the operator&#8217;s output channels in one atomic step, you may also consider calling either
the <em>bindAllOutputsAtomically</em> method, passing in a single value to write to all output channels or the
<em>bindAllOutputsAtomically</em> method, which takes a multiple values, each of which will be written to the
output channel with the same position index.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>operator(<span class="key">inputs</span>:[inputChannel], <span class="key">outputs</span>:[a, b], <span class="key">maxForks</span>:<span class="integer">5</span>) {msg -&gt;
    doStuffThatIsThreadSafe()
        bindAllOutputValuesAtomically msg, <span class="integer">2</span>*msg
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Which Bind Do I Use ?</div>
<div class="literalblock">
<div class="content">
<pre>Using the _bindAllOutputs_ or the _bindAllOutputValues_ methods will not guarantee atomicity of writes across al the output channels when using internal parallelism.</pre>
</div>
</div>
<div class="paragraph">
<p>If preserving the order of messages in multiple output channels is not an issue, <em>bindAllOutputs</em> as well as <em>bindAllOutputValues</em> will provide better performance over the atomic variants.</p>
</div>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_operator_lifecycle">Operator Lifecycle</h4>
<div class="paragraph">
<p>Dataflow operators and selectors fire several events during their lifecycle, which allows the interested
parties to obtain notifications and potential alter operator&#8217;s behavior. The <em>DataflowEventListener</em>
interface offers a couple of callback methods:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
39
<strong>40</strong>
41
42
43
44
45
46
47
48
49
<strong>50</strong>
51
52
53
54
55
56
57
58
59
<strong>60</strong>
61
62
63
64
65
66
67
68
69
<strong>70</strong>
71
72
73
74
75
76
77
78
79
<strong>80</strong>
81
82
83
84
85
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">interface</span> DataflowEventListener {
    <span class="comment">/**
     * Invoked immediately after the operator starts by a pooled thread before the first message is obtained
     *
     * @param processor The reporting dataflow operator/selector
     */</span>
    <span class="type">void</span> afterStart(DataflowProcessor processor);

    <span class="comment">/**
     * Invoked immediately after the operator terminates
     *
     * @param processor The reporting dataflow operator/selector
     */</span>
    <span class="type">void</span> afterStop(DataflowProcessor processor);

    <span class="comment">/**
     * Invoked if an exception occurs.
     * If any of the listeners returns true, the operator will terminate.
     * Exceptions outside of the operator's body or listeners' messageSentOut() handlers will terminate the operator irrespective of the listeners' votes.
     *
     * @param processor The reporting dataflow operator/selector
     * @param e         The thrown exception
     * @return True, if the operator should terminate in response to the exception, false otherwise.
     */</span>
    <span class="type">boolean</span> onException(DataflowProcessor processor, <span class="predefined-type">Throwable</span> e);

    <span class="comment">/**
     * Invoked when a message becomes available in an input channel.
     *
     * @param processor The reporting dataflow operator/selector
     * @param channel   The input channel holding the message
     * @param index     The index of the input channel within the operator
     * @param message   The incoming message
     * @return The original message or a message that should be used instead
     */</span>
    <span class="predefined-type">Object</span> messageArrived(DataflowProcessor processor, DataflowReadChannel&lt;<span class="predefined-type">Object</span>&gt; channel, <span class="type">int</span> index, <span class="predefined-type">Object</span> message);

    <span class="comment">/**
     * Invoked when a control message (instances of ControlMessage) becomes available in an input channel.
     *
     * @param processor The reporting dataflow operator/selector
     * @param channel   The input channel holding the message
     * @param index     The index of the input channel within the operator
     * @param message   The incoming message
     * @return The original message or a message that should be used instead
     */</span>
    <span class="predefined-type">Object</span> controlMessageArrived(DataflowProcessor processor, DataflowReadChannel&lt;<span class="predefined-type">Object</span>&gt; channel, <span class="type">int</span> index, <span class="predefined-type">Object</span> message);

    <span class="comment">/**
     * Invoked when a message is being bound to an output channel.
     *
     * @param processor The reporting dataflow operator/selector
     * @param channel   The output channel to send the message to
     * @param index     The index of the output channel within the operator
     * @param message   The message to send
     * @return The original message or a message that should be used instead
     */</span>
    <span class="predefined-type">Object</span> messageSentOut(DataflowProcessor processor, DataflowWriteChannel&lt;<span class="predefined-type">Object</span>&gt; channel, <span class="type">int</span> index, <span class="predefined-type">Object</span> message);

    <span class="comment">/**
     * Invoked when all messages required to trigger the operator become available in the input channels.
     *
     * @param processor The reporting dataflow operator/selector
     * @param messages  The incoming messages
     * @return The original list of messages or a modified/new list of messages that should be used instead
     */</span>
    <span class="predefined-type">List</span>&lt;<span class="predefined-type">Object</span>&gt; beforeRun(DataflowProcessor processor, <span class="predefined-type">List</span>&lt;<span class="predefined-type">Object</span>&gt; messages);

    <span class="comment">/**
     * Invoked when the operator completes a single run
     *
     * @param processor The reporting dataflow operator/selector
     * @param messages  The incoming messages that have been processed
     */</span>
    <span class="type">void</span> afterRun(DataflowProcessor processor, <span class="predefined-type">List</span>&lt;<span class="predefined-type">Object</span>&gt; messages);

    <span class="comment">/**
     * Invoked when the fireCustomEvent() method is triggered manually on a dataflow operator/selector
     *
     * @param processor The reporting dataflow operator/selector
     * @param data      The custom piece of data provided as part of the event
     * @return A value to return from the fireCustomEvent() method to the caller (event initiator)
     */</span>
    <span class="predefined-type">Object</span> customEvent(DataflowProcessor processor, <span class="predefined-type">Object</span> data);
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>A default implementation is provided through the <em>DataflowEventAdapter</em> class.</p>
</div>
<div class="paragraph">
<p>Listeners provide a way to handle exceptions, when they occur inside operators. A listener may typically log such exceptions,
notify a supervising entity, generate an alternative output or perform any steps required to recover from the situation.
If there&#8217;s no listener registered or if any of the listeners returns <em>true</em> the operator will terminate, preserving the contract of <em>afterStop()</em> .
Exceptions that occur outside the actual operator&#8217;s body, i.e. at the parameter preparation phase before the body is triggered
or at the clean-up and channel subscription phase, after the body finishes, always lead to operator termination.</p>
</div>
<div class="paragraph">
<p>The <em>fireCustomEvent()</em> method available on operators and selectors may be used to communicate back and forth between operator&#8217;s body
and the interested listeners:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
</pre></td>
  <td class="code"><pre><span class="directive">final</span> listener = <span class="keyword">new</span> DataflowEventAdapter() {
    <span class="annotation">@Override</span>
    <span class="predefined-type">Object</span> customEvent(DataflowProcessor processor, <span class="predefined-type">Object</span> data) {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Log: Getting quite high on the scale </span><span class="inline"><span class="inline-delimiter">$</span>data</span><span class="delimiter">&quot;</span></span>
        <span class="keyword">return</span> <span class="integer">100</span>  <span class="comment">//The value to use instead</span>
    }
}

op = group.operator(<span class="key">inputs</span>: [a, b], <span class="key">outputs</span>: [c], <span class="key">listeners</span>: [listener]) {x, y -&gt;
    <span class="directive">final</span> sum = x + y
    <span class="keyword">if</span> (sum &gt; <span class="integer">100</span>) bindOutput(fireCustomEvent(sum))  <span class="comment">//Reporting that the sum is too high, binding the lowered value that comes back</span>
    <span class="keyword">else</span> bindOutput sum
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_selectors">Selectors</h3>
<div class="paragraph">
<p>Selector&#8217;s body should be a closure consuming either one or two arguments.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>selector (inputs : [a, b, c], outputs : [d, e]) {value -&gt;
    ....
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The two-argument closure will get a value plus an index of the input channel, the value of which is
currently being processed.  This allows the selector to distinguish between values coming through different
input channels.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>selector (inputs : [a, b, c], outputs : [d, e]) {value, index -&gt;
    ....
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="sect3">
<h4 id="_priority_selector">Priority Selector</h4>
<div class="paragraph">
<p>When priorities need to be preserved among input channels, a <em>DataflowPrioritySelector</em> should be used.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>prioritySelector(inputs : [a, b, c], outputs : [d, e]) {value, index -&gt;
    ...
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The priority selector will always prefer values from channels with lower position index over values coming
through the channels with higher position index.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_join_selector">Join Selector</h4>
<div class="paragraph">
<p>A selector without a body closure specified will copy all incoming values to all of its output channels.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> join = selector (inputs : [programmers, analysis, managers], outputs : [employees, colleagues])</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_internal_parallelism">Internal Parallelism</h4>
<div class="paragraph">
<p>The <em>maxForks</em> attribute allowing for internal selectors parallelism is also available.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>selector (inputs : [a, b, c], outputs : [d, e], maxForks : <span class="integer">5</span>) {value -&gt;
    ....
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_guards_2">Guards</h4>
<div class="paragraph">
<p>Just like <em>Selects</em> , <em>Selectors</em> also allow the users to temporarily include/exclude individual input
channels from selection.  The <em>guards</em> input property can be used to set the initial mask on all input
channels and the <em>setGuards</em> and <em>setGuard</em> methods are then available in the selector&#8217;s body.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
39
<strong>40</strong>
41
42
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.selector</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

<span class="comment">/**
 * Demonstrates the ability to enable/disable channels during a value selection on a select by providing boolean guards.
 */</span>
<span class="directive">final</span> DataflowQueue operations = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowQueue numbers = <span class="keyword">new</span> DataflowQueue()

<span class="keyword">def</span> instruction
<span class="keyword">def</span> nums = <span class="type">[]</span>

selector(<span class="key">inputs</span>: [operations, numbers], <span class="key">outputs</span>: <span class="type">[]</span>, <span class="key">guards</span>: [<span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>]) {value, index -&gt;   <span class="comment">//initial guards is set here</span>
    <span class="keyword">if</span> (index == <span class="integer">0</span>) {
        instruction = value
        setGuard(<span class="integer">0</span>, <span class="predefined-constant">false</span>)  <span class="comment">//setGuard() used here</span>
        setGuard(<span class="integer">1</span>, <span class="predefined-constant">true</span>)
    }
    <span class="keyword">else</span> nums &lt;&lt; value
    <span class="keyword">if</span> (nums.size() == <span class="integer">2</span>) {
        setGuards([<span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>])                                    <span class="comment">//setGuards() used here</span>
        <span class="directive">final</span> <span class="keyword">def</span> formula = <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>nums[<span class="integer">0</span>]<span class="inline-delimiter">}</span></span><span class="content"> </span><span class="inline"><span class="inline-delimiter">$</span>instruction</span><span class="content"> </span><span class="inline"><span class="inline-delimiter">${</span>nums[<span class="integer">1</span>]<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>formula</span><span class="content"> = </span><span class="inline"><span class="inline-delimiter">${</span><span class="keyword">new</span> GroovyShell().evaluate(formula)<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
        nums.clear()
    }
}

task {
    operations &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">+</span><span class="delimiter">'</span></span>
    operations &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">+</span><span class="delimiter">'</span></span>
    operations &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">*</span><span class="delimiter">'</span></span>
}

task {
    numbers &lt;&lt; <span class="integer">10</span>
    numbers &lt;&lt; <span class="integer">20</span>
    numbers &lt;&lt; <span class="integer">30</span>
    numbers &lt;&lt; <span class="integer">40</span>
    numbers &lt;&lt; <span class="integer">50</span>
    numbers &lt;&lt; <span class="integer">60</span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Warning</div>
<div class="paragraph">
<p>Avoid combining <em>guards</em> and <em>maxForks</em> greater than 1. Although the <em>Selector</em> is thread-safe and won&#8217;t be damaged in any way, the guards are likely not to be set the way you expect. The multiple threads running the selector&#8217;s body concurrently will tend to over-write each-other&#8217;s settings to the <em>guards</em> property.</p>
</div>
</div>
</div>
<hr>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_shutting_down_dataflow_networks">Shutting Down Dataflow Networks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Shutting down a network of dataflow processors (operators and selectors) may sometimes be a non-trivial
task, especially if you need a generic mechanism that will not leave any messages unprocessed.</p>
</div>
<div class="paragraph">
<p>Dataflow operators and selectors can be terminated in three ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>by calling the terminate() method on all operators that need to be terminated</p>
</li>
<li>
<p>by sending a poisson message</p>
</li>
<li>
<p>by setting up a network of activity monitors that will shutdown the network after all messages have been processed</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Check out the details on the ways that <strong>GPars</strong> provides.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Shutting down the thread pool</div>
<div class="paragraph">
<p>If you use a custom <em>PGroup</em> to maintain a thread pool for your dataflow network, you should not forget to
shutdown the pool once the network is terminated.  Otherwise the thread pool will consume system resources
and, in case of using non-daemon threads, it will prevent JVM from exit.</p>
</div>
</div>
</div>
<hr>
<div class="sect2">
<h3 id="_emergency_shutdown">Emergency Shutdown</h3>
<div class="paragraph">
<p>You can call <em>terminate()</em> on any operator/selector to immediately shut it down. Provided you keep track of
all your processors, perhaps by adding them to a list, the fastest way to stop the network would be:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>allMyProcessors*.terminate()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This should, however, be treated as an emergency exit, since no guarantees can be given regarding messages
processed nor finished work.  Operators will simply terminate instantly leaving work unfinished and
abandoning messages in the input channels.  Certainly, the lifecycle event listeners hooked to the
operators/selectors will have their <em>afterStop()</em> event handlers invoked in order to, for example, release
resources or output a note into the log.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> op1 = operator(<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d, e]) {x, y, z -&gt; }

<span class="keyword">def</span> op2 = selector(<span class="key">inputs</span>: [d], <span class="key">outputs</span>: [f, out]) { }

<span class="keyword">def</span> op3 = prioritySelector(<span class="key">inputs</span>: [e, f], <span class="key">outputs</span>: [b]) {value, index -&gt; }

[op1, op2, op3]*.terminate()  <span class="comment">//Terminate all operators by calling the terminate() method on them</span>
op1.join()
op2.join()
op3.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Shutting down the whole JVM through <em>System.exit()</em> will obviously shutdown the dataflow network, however, no lifecycle listeners will be invoked.
</td>
</tr>
</table>
</div>
<hr>
<div class="sect3">
<h4 id="_stopping_operators_gently">Stopping Operators Gently</h4>
<div class="paragraph">
<p>Operators handle incoming messages repeatedly. The only safe moment for stopping an operator without the
risk of loosing any messages is right after the operator has finished processing messages and is just about
to look for more messages in its incoming pipes.  This is exactly what the <em>terminateAfterNextRun()</em> method
does. It will schedule the operator for shutdown after the next set of messages gets handled.</p>
</div>
<div class="paragraph">
<p>The unprocessed messages will stay in the input channels, which allows you to handle them later, perhaps
with a different operator/selector or in some other way. Using <em>terminateAfterNextRun()</em> you will not loose
any input messages.  This may be particularly handy when you use a group of operators/selectors to
load-balance messages coming from a channel.  Once the work-load decreases, the terminateAfterNextRun()
method may be used to safely reduce the pool of load-balancing operators.</p>
</div>
<div class="sect4">
<h5 id="_detecting_shutdown">Detecting shutdown</h5>
<div class="paragraph">
<p>Operators and electors offer a handy <em>join()</em> method for those who need to block until the operator terminates.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>allMyProcessors*.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the easies way to wait until the whole dataflow network shuts down, irrespective of the shutdown method used.</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_poisonpill">PoisonPill</h3>
<div class="paragraph">
<p><em>PoisonPill</em> is a common term for a strategy that uses special-purpose messages to stop entities that
receive it.  <strong>GPars</strong> offers the <em>PoisonPill</em> class, which has exactly such effect or operators and
selectors. Since <em>PoisonPill</em> is a <em>ControlMessage</em>, it is invisible to operator&#8217;s body and custom code does
not need to handle it in any way.  <em>DataflowEventListeners</em> may react to <em>ControlMessages</em> through the
<em>controlMessageArrived()</em> handler method.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> op1 = operator(<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d, e]) {x, y, z -&gt; }

<span class="keyword">def</span> op2 = selector(<span class="key">inputs</span>: [d], <span class="key">outputs</span>: [f, out]) { }

<span class="keyword">def</span> op3 = prioritySelector(<span class="key">inputs</span>: [e, f], <span class="key">outputs</span>: [b]) {value, index -&gt; }

a &lt;&lt; PoisonPill.instance  <span class="comment">//Send the poisson</span>

op1.join()
op2.join()
op3.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>After receiving a poisson an operator terminates, right after it finishes the current calculation and makes
sure the poisson is sent to all its output channels, so that the poisson can spread to the connected
operators.  Also, although operators typically wait for all inputs to have a value, in case of
<em>PoisonPills</em>, the operator will terminate immediately as soon as a <em>PoisonPill</em> appears on any of its
inputs. The values already obtained from the other channels will be lost. It can be considered an error in
the design of the network, if these messages were supposed to be processed.  They would need a proper value
as their peer and not a PoisonPill in order to be processes normally.</p>
</div>
<div class="paragraph">
<p>Selectors, on the other hand, will patiently wait for <em>PoisonPill</em> to be received from all their input
channels before sending it on the the output channels.  This behavior prevents networks containing
<strong>feed-back loops involving selectors</strong> from being shutdown using <em>PoisonPill</em> .  A selector would never
receive a <em>PoisonPill</em> from the channel that comes back from behind the selector. A different shutdown
strategy should be used for such networks.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Operators and Selectors Should Only Terminate Themselves</div>
<div class="paragraph">
<p>Given the potential variety of operator networks and their asynchronous nature, a good termination strategy is that
operators and selectors should only ever terminate themselves.
All ways of terminating them from outside (either by calling the terminate() method or by sending poisson down the stream)
may result in messages being lost somewhere in the pipes, when the reading operators terminate before they fully handle
the messages waiting in their input channels.</p>
</div>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_immediate_poison_pill">Immediate Poison Pill</h3>
<div class="paragraph">
<p>Especially for selectors to shutdown immediately after receiving a poison pill, a notion of <strong>immediate
poison pill</strong> has been introduced.  Since normal, non-immediate poison pills merely close the input channel
leaving the selector alive until at least one input channel remains open, the immediate poison pill closes
the selector instantly. Obviously, unprocessed messages from the other selector&#8217;s input channels will not be
handled by the selector, once it reads an immediate poison pill.</p>
</div>
<div class="paragraph">
<p>With immediate poison pill you can safely shutdown networks with selectors involved in feedback loops.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> op1 = selector(<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d, e]) {value, index -&gt; }
<span class="keyword">def</span> op2 = selector(<span class="key">inputs</span>: [d], <span class="key">outputs</span>: [f, out]) { }
<span class="keyword">def</span> op3 = prioritySelector(<span class="key">inputs</span>: [e, f], <span class="key">outputs</span>: [b]) {value, index -&gt; }

a &lt;&lt; PoisonPill.immediateInstance

[op1, op2, op3]*.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_poison_with_counting">Poison With Counting</h3>
<div class="paragraph">
<p>When sending a poison pill down the operator network you may need to be notified when all the operators or a
specified number of them have been stopped. The <em>CountingPoisonPill</em> class serves exactly this purpose:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
</pre></td>
  <td class="code"><pre>operator(<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d, e]) {x, y, z -&gt; }
selector(<span class="key">inputs</span>: [d], <span class="key">outputs</span>: [f, out]) { }
prioritySelector(<span class="key">inputs</span>: [e, f], <span class="key">outputs</span>: [b]) {value, index -&gt; }

<span class="comment">//Send the poisson indicating the number of operators than need to be terminated before we can continue</span>
<span class="directive">final</span> pill = <span class="keyword">new</span> CountingPoisonPill(<span class="integer">3</span>)
a &lt;&lt; pill

<span class="comment">//Wait for all operators to terminate</span>
pill.join()
<span class="comment">//At least 3 operators should be terminated by now</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>termination</em> property of the <em>CountingPoisonPill</em> class is a regular <em>Promise&lt;Boolean&gt;</em> and so has a lot of handy properties.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
</pre></td>
  <td class="code"><pre><span class="comment">//Send the poisson indicating the number of operators than need to be terminated before we can continue</span>
<span class="directive">final</span> pill = <span class="keyword">new</span> CountingPoisonPill(<span class="integer">3</span>)
pill.termination.whenBound {println <span class="string"><span class="delimiter">&quot;</span><span class="content">Reporting asynchronously that the network has been stopped</span><span class="delimiter">&quot;</span></span>}
a &lt;&lt; pill

<span class="keyword">if</span> (pill.termination.bound) println <span class="string"><span class="delimiter">&quot;</span><span class="content">Wow, that was quick. We are done already!</span><span class="delimiter">&quot;</span></span>
<span class="keyword">else</span> println <span class="string"><span class="delimiter">&quot;</span><span class="content">Things are being slow today. The network is still running.</span><span class="delimiter">&quot;</span></span>

<span class="comment">//Wait for all operators to terminate</span>
<span class="keyword">assert</span> pill.termination.get()
<span class="comment">//At least 3 operators should be terminated by now</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>An immediate variant of <em>CountingPoisonPill</em> is also available - <em>ImmediateCountingPoisonPill</em> .</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> op1 = selector(<span class="key">inputs</span>: [a, b, c], <span class="key">outputs</span>: [d, e]) {value, index -&gt; }
<span class="keyword">def</span> op2 = selector(<span class="key">inputs</span>: [d], <span class="key">outputs</span>: [f, out]) { }
<span class="keyword">def</span> op3 = prioritySelector(<span class="key">inputs</span>: [e, f], <span class="key">outputs</span>: [b]) {value, index -&gt; }

<span class="directive">final</span> pill = <span class="keyword">new</span> ImmediateCountingPoisonPill(<span class="integer">3</span>)
a &lt;&lt; pill
pill.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>ImmediateCountingPoisonPill</em> will safely and instantly shutdown dataflow networks even with selectors
involved in feedback loops, which normal non-immediate poison pill would not be able to.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_poison_strategies">Poison Strategies</h3>
<div class="paragraph">
<p>To correctly shutdown a network using <em>PoisonPill</em> you must identify the appropriate set of channels to send
<em>PoisonPill</em> to.  <em>PoisonPill</em> will spread in the network the usual way through the channels and processors
down the stream. Typically the right channels to send <em>PoisonPill</em> to will be those that serve as <strong>data
sources</strong> for the network.  This may be difficult to achieve for general cases or for complex networks. On
the other hand, for networks with a prevalent direction of message flow <em>PoisonPill</em> provides a very
straightforward way to shutdown the whole network gracefully.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Load-balancing Prevents Poison Shutdown</div>
<div class="paragraph">
<p>Load-balancing architectures, which use multiple operators reading messages off a shared channel (queue),
will also prevent poison shutdown to work properly, since only one of the reading operators will get to read
the poison message.  You may consider using <strong>forked operators</strong> instead, by setting the <em>maxForks</em> property
to a value greater than 1.  Another alternative is to manually split the message stream into multiple
channels, each of which would be consumed by one of the original operators.</p>
</div>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_termination_tips_and_tricks">Termination Tips and Tricks</h3>
<div class="paragraph">
<p>Notice that <strong>GPars</strong> <em>tasks</em> return a <em>DataflowVariable</em>, which gets bound to a value as soon as the task
finishes.  The 'terminator' operator below leverages the fact that <em>DataflowVariables</em> are implementations
of the <em>DataflowReadChannel</em> interface and thus can be consumed by operators. As soon as both tasks finish,
the operator will send a <em>PoisonPill</em> down the <em>q</em> channel to stop the consumer as soon as it processes all
data.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.NonDaemonPGroup</span>


<span class="keyword">def</span> group = <span class="keyword">new</span> NonDaemonPGroup()

<span class="directive">final</span> DataflowQueue q = <span class="keyword">new</span> DataflowQueue()

<span class="comment">// final destination</span>
<span class="keyword">def</span> customs = group.operator(<span class="key">inputs</span>: [q], <span class="key">outputs</span>: <span class="type">[]</span>) { value -&gt;
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Customs received </span><span class="inline"><span class="inline-delimiter">$</span>value</span><span class="delimiter">&quot;</span></span>
}

<span class="comment">// big producer</span>
<span class="keyword">def</span> green = group.task {
    (<span class="integer">1</span>..<span class="integer">100</span>).each {
        q &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">green channel </span><span class="delimiter">'</span></span> + <span class="local-variable">it</span>
        sleep <span class="integer">10</span>
    }
}

<span class="comment">// little producer</span>
<span class="keyword">def</span> red = group.task {
    (<span class="integer">1</span>..<span class="integer">10</span>).each {
        q &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">red channel </span><span class="delimiter">'</span></span> + <span class="local-variable">it</span>
        sleep <span class="integer">15</span>
    }
}

<span class="keyword">def</span> terminator = group.operator(<span class="key">inputs</span>: [green, red], <span class="key">outputs</span>: <span class="type">[]</span>) { t1, t2 -&gt;
    q &lt;&lt; PoisonPill.instance
}

customs.join()
group.shutdown()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_keeping_poisonpill_inside_a_given_network">Keeping PoisonPill Inside a Given Network</h3>
<div class="paragraph">
<p>If your network passed values through channels to entities outside of it, you may need to stop the
<em>PoisonPill</em> messages on the network boundaries. This can be easily achieved by putting a single-input
single-output filtering operator on each such channel.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>operator(networkLeavingChannel, otherNetworkEnteringChannel) {value -&gt;
    <span class="keyword">if</span> (!(value instanceOf PoisonPill)) bindOutput <span class="local-variable">it</span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>Pipeline</em> DSL may be also helpful here:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>networkLeavingChannel.filter { !(<span class="local-variable">it</span> instanceOf PoisonPill) } into otherNetworkEnteringChannel</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Check out the <em>Pipeline DSL</em> section to find out more on pipelines.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_graceful_shutdown">Graceful Shutdown</h3>
<div class="paragraph">
<p><strong>GPars</strong> provides a generic way to shutdown a dataflow network. Unlike the previously mentioned mechanisms this
approach will keep the network running until all the messages get handled and than gracefully shuts all
operators down letting you know when this happens.  You have to pay a modest performance penalty,
though. This is unavoidable since we need to keep track of what&#8217;s happening inside the network.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
39
<strong>40</strong>
41
42
43
44
45
46
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowBroadcast</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.operator.component.GracefulShutdownListener</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.operator.component.GracefulShutdownMonitor</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.PGroup</span>

PGroup group = <span class="keyword">new</span> DefaultPGroup(<span class="integer">10</span>)
<span class="directive">final</span> a = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> b = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> c = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> d = <span class="keyword">new</span> DataflowQueue&lt;<span class="predefined-type">Object</span>&gt;()
<span class="directive">final</span> e = <span class="keyword">new</span> DataflowBroadcast&lt;<span class="predefined-type">Object</span>&gt;()
<span class="directive">final</span> f = <span class="keyword">new</span> DataflowQueue&lt;<span class="predefined-type">Object</span>&gt;()
<span class="directive">final</span> result = <span class="keyword">new</span> DataflowQueue&lt;<span class="predefined-type">Object</span>&gt;()

<span class="directive">final</span> monitor = <span class="keyword">new</span> GracefulShutdownMonitor(<span class="integer">100</span>);

<span class="keyword">def</span> op1 = group.operator(<span class="key">inputs</span>: [a, b], <span class="key">outputs</span>: [c], <span class="key">listeners</span>: [<span class="keyword">new</span> GracefulShutdownListener(monitor)]) {x, y -&gt;
    sleep <span class="integer">5</span>
    bindOutput x + y
}
<span class="keyword">def</span> op2 = group.operator(<span class="key">inputs</span>: [c], <span class="key">outputs</span>: [d, e], <span class="key">listeners</span>: [<span class="keyword">new</span> GracefulShutdownListener(monitor)]) {x -&gt;
    sleep <span class="integer">10</span>
    bindAllOutputs <span class="integer">2</span>*x
}
<span class="keyword">def</span> op3 = group.operator(<span class="key">inputs</span>: [d], <span class="key">outputs</span>: [f], <span class="key">listeners</span>: [<span class="keyword">new</span> GracefulShutdownListener(monitor)]) {x -&gt;
    sleep <span class="integer">5</span>
    bindOutput x + <span class="integer">40</span>
}
<span class="keyword">def</span> op4 = group.operator(<span class="key">inputs</span>: [e.createReadChannel(), f], <span class="key">outputs</span>: [result], <span class="key">listeners</span>: [<span class="keyword">new</span> GracefulShutdownListener(monitor)]) {x, y -&gt;
    sleep <span class="integer">5</span>
    bindOutput x + y
}

<span class="integer">100</span>.times{a &lt;&lt; <span class="integer">10</span>}
<span class="integer">100</span>.times{b &lt;&lt; <span class="integer">20</span>}

<span class="directive">final</span> shutdownPromise = monitor.shutdownNetwork()

<span class="integer">100</span>.times{<span class="keyword">assert</span> <span class="integer">160</span> == result.val}

shutdownPromise.get()
[op1, op2, op3, op4]*.join()

group.shutdown()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>First, we need an instance of <em>GracefulShutdownMonitor</em> , which will orchestrate the shutdown process. It
relies on instances of <em>GracefulShutdownListener</em> attached to all operators/selectors. These listeners
observe their respective processors together with their input channels and report to the shared
<em>GracefulShutdownMonitor</em>.  Once <em>shutdownNetwork()</em> is called on <em>GracefulShutdownMonitor</em> , it will
periodically check for reported activities, query the state of operators as well as the number of messages
in their input channels.</p>
</div>
<div class="paragraph">
<p>Please make sure that no new messages enter the dataflow network after the shutdown has been initiated,
since this may cause the network to never terminate.  The shutdown process should only be started after all
data producers have ceased sending additional messages to the monitored network.</p>
</div>
<div class="paragraph">
<p>The <em>shutdownNetwork()</em> method returns a <strong>Promise</strong> so that you can do the usual set of tricks with it -
block waiting for the network to terminate using the <em>get()</em> method, register a callback using the
<em>whenBound()</em> method or make it trigger a whole set of activities through the <em>then()</em> method.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Limitations of Graceful Sshutdown</div>
<div class="ulist">
<ul>
<li>
<p>For <em>GracefulShutdownListener</em> to work correctly, its <em>messageArrived()</em> event handler must see the
original value that has arrived through the input channel. Since some event listeners may alter the
messages as they pass through the listeners it is advisable to add the <em>GracefulShutdownListener</em> first to
the list of listeners on each dataflow processor.</p>
</li>
<li>
<p>Also, graceful shutdown will not work for those rare operators that have listeners, which turn control
messages into plain value messages in the <em>controlMessageArrived()</em> event handler.</p>
</li>
<li>
<p>Third and last, load-balancing architectures, which use multiple operators reading messages off a shared
channel (queue), will also prevent graceful shutdown to work properly. You may consider using <strong>forked
operators</strong> instead, by setting the <em>maxForks</em> property to a value greater than 1. Another alternative is
to manually split the message stream into multiple channels, each of which would be consumed by one of the
original operators.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_application_frameworks">Application Frameworks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Dataflow Operators and Selectors can be successfully used to build high-level domain-specific frameworks for
problems that naturally fit the flow model.</p>
</div>
<div class="sect2">
<h3 id="_building_flow_frameworks_on_top_of_strong_gpars_dataflow_strong">Building Flow Frameworks on Top of <strong>GPars Dataflow</strong></h3>
<div class="paragraph">
<p><strong>GPars</strong> dataflow can be viewed as bottom-line language-level infrastructure. Operators, selectors, channels
and event listeners can be very useful at language level to combine, for example, with <strong>actors</strong> or parallel
collections.  Whenever a need comes for asynchronous handling of events that come through one of more
channels, a dataflow operator or a small dataflow network could be a very good fit. Unlike tasks, operators
are lightweight and release threads when there&#8217;s no message to process. Unlike <strong>actors</strong>, operators are
addressed indirectly through channels and may easily combine messages from multiple channels into one
action.</p>
</div>
<div class="paragraph">
<p>Alternatively, operators can be looked at as continuous functions, which instantly and repeatedly transform
their input values into output.  We believe that a concurrency-friendly general-purpose programming language
should provide this type of abstraction.</p>
</div>
<div class="paragraph">
<p>At the same time, dataflow elements can be easily used as building blocks for constructing domain-specific
workflow-like frameworks.  These frameworks can offer higher-level abstractions specialized to a single
problem domain, which would be inappropriate for a general-purpose language-level library. Each of the
higher-level concepts is then mapped to (potentially several) <strong>GPars</strong> concepts.</p>
</div>
<div class="paragraph">
<p>For example, a network solving data-mining problems may consist of several data sources, data cleaning
nodes, categorization nodes, reporting nodes and others. Image processing network, on the other hand, may
need nodes specialized in image compression and format transformation. Similarly, networks for data
encryption, mp3 encoding, work-flow management as well as many other domains that would benefit from
dataflow-based solutions, will differ in many aspects - the type of nodes in the network, the type and
frequency of events, the load-balancing scheme, potential constraints on branching, the need for
visualization, debugging and logging, the way users define the networks and interact with them as well as
many others.</p>
</div>
<div class="paragraph">
<p>The higher-level application-specific frameworks should put effort into providing abstractions best suited
for the given domain and hide <strong>GPars</strong> complexities. For example, the visual graph of the network that the user
manipulates on the screen should typically not show all the channels that participate in the
network. Debugging or logging channels, which rarely contribute to the core of the solution, are among the
first good candidates to consider for exclusion. Also channels and lifecycle-event listeners, which
orchestrate aspects such as load balancing or graceful shutdown, will probably be not exposed to the user,
although they will be part of the generated and executed network. Similarly, a single channel in the
domain-specific model will in reality translate into multiple channels perhaps with one or more
logging/transforming/filtering operators connecting them together. The function associated with a node will
most likely be wrapped with some additional infrastructural code to form the operator&#8217;s body.</p>
</div>
<div class="paragraph">
<p><strong>GPars</strong> gives you the underlying components that the end user may be abstracted away completely by the
application-specific framework.  This keeps <strong>GPars</strong> domain-agnostic and universal, yet useful at the
implementation level.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pipeline_dsl">Pipeline DSL</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_dsl_for_building_operators_pipelines">A DSL for Building Operators Pipelines</h3>
<div class="paragraph">
<p>Building dataflow networks can be further simplified. <strong>GPars</strong> offers handy shortcuts for the common scenario
of building (mostly linear) pipelines of operators.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> toUpperCase = {s -&gt; s.toUpperCase()}

<span class="directive">final</span> encrypt = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowReadChannel encrypted = encrypt | toUpperCase | {<span class="local-variable">it</span>.reverse()} | {<span class="string"><span class="delimiter">'</span><span class="content">###encrypted###</span><span class="delimiter">'</span></span> + <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">###</span><span class="delimiter">'</span></span>}

encrypt &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">I need to keep this message secret!</span><span class="delimiter">&quot;</span></span>
encrypt &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">GPars can build linear operator pipelines really easily</span><span class="delimiter">&quot;</span></span>

println encrypted.val
println encrypted.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This saves you from directly creating, wiring and manipulating all the channels and operators that are to
form the pipeline.  The <em>pipe</em> operator lets you hook an output of one function/operator/process to the
input of another one. Just like chaining system processes on the command line.</p>
</div>
<div class="paragraph">
<p>The <em>pipe</em> operator is a handy shorthand for a more generic <em>chainWith()</em> method:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> toUpperCase = {s -&gt; s.toUpperCase()}

<span class="directive">final</span> encrypt = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowReadChannel encrypted = encrypt.chainWith toUpperCase chainWith {<span class="local-variable">it</span>.reverse()} chainWith {<span class="string"><span class="delimiter">'</span><span class="content">###encrypted###</span><span class="delimiter">'</span></span> + <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">###</span><span class="delimiter">'</span></span>}

encrypt &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">I need to keep this message secret!</span><span class="delimiter">&quot;</span></span>
encrypt &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">GPars can build linear operator pipelines really easily</span><span class="delimiter">&quot;</span></span>

println encrypted.val
println encrypted.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
<div class="sect3">
<h4 id="_combining_pipelines_with_straight_operators">Combining Pipelines with Straight Operators</h4>
<div class="paragraph">
<p>Since each operator pipeline has an entry and an exit channel, pipelines can be wired into more complex
operator networks.  Only your imagination can limit your ability to mix pipelines with channels and
operators in the same network definitions.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> toUpperCase = {s -&gt; s.toUpperCase()}
<span class="keyword">def</span> save = {text -&gt;
    <span class="comment">//Just pretending to be saving the text to disk, database or whatever</span>
    println <span class="string"><span class="delimiter">'</span><span class="content">Saving </span><span class="delimiter">'</span></span> + text
}

<span class="directive">final</span> toEncrypt = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowReadChannel encrypted = toEncrypt.chainWith toUpperCase chainWith {<span class="local-variable">it</span>.reverse()} chainWith {<span class="string"><span class="delimiter">'</span><span class="content">###encrypted###</span><span class="delimiter">'</span></span> + <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content">###</span><span class="delimiter">'</span></span>}

<span class="directive">final</span> DataflowQueue fork1 = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowQueue fork2 = <span class="keyword">new</span> DataflowQueue()
splitter(encrypted, [fork1, fork2])  <span class="comment">//Split the data flow</span>

fork1.chainWith save  <span class="comment">//Hook in the save operation</span>

<span class="comment">//Hook in a sneaky decryption pipeline</span>
<span class="directive">final</span> DataflowReadChannel decrypted = fork2.chainWith {<span class="local-variable">it</span>[<span class="integer">15</span>..-<span class="integer">4</span>]} chainWith {<span class="local-variable">it</span>.reverse()} chainWith {<span class="local-variable">it</span>.toLowerCase()}
      .chainWith {<span class="string"><span class="delimiter">'</span><span class="content">Groovy leaks! Check out a decrypted secret message: </span><span class="delimiter">'</span></span> + <span class="local-variable">it</span>}

toEncrypt &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">I need to keep this message secret!</span><span class="delimiter">&quot;</span></span>
toEncrypt &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">GPars can build operator pipelines really easy</span><span class="delimiter">&quot;</span></span>

println decrypted.val
println decrypted.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Type of Channel Preservation</div>
<div class="paragraph">
<p>The type of the channel is preserved across the whole pipeline. E.g. if you start chaining off a synchronous
 channel, all the channels in the pipeline will be synchronous. In that case, obviously, the whole chain blocks, including the writer who writes into the channel at head, until someone reads data off the tail of the pipeline.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
</pre></td>
  <td class="code"><pre><span class="directive">final</span> SyncDataflowQueue queue = <span class="keyword">new</span> SyncDataflowQueue()
<span class="directive">final</span> result = queue.chainWith {<span class="local-variable">it</span> * <span class="integer">2</span>}.chainWith {<span class="local-variable">it</span> + <span class="integer">1</span>} chainWith {<span class="local-variable">it</span> * <span class="integer">100</span>}

<span class="predefined-type">Thread</span>.start {
    <span class="integer">5</span>.times {
        println result.val
    }
}

queue &lt;&lt; <span class="integer">1</span>
queue &lt;&lt; <span class="integer">2</span>
queue &lt;&lt; <span class="integer">3</span>
queue &lt;&lt; <span class="integer">4</span>
queue &lt;&lt; <span class="integer">5</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_joining_pipelines">Joining Pipelines</h4>
<div class="paragraph">
<p>Two pipelines (or channels) can be connected using the <em>into()</em> method:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
</pre></td>
  <td class="code"><pre><span class="directive">final</span> encrypt = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowWriteChannel messagesToSave = <span class="keyword">new</span> DataflowQueue()
encrypt.chainWith toUpperCase chainWith {<span class="local-variable">it</span>.reverse()} into messagesToSave

task {
    encrypt &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">I need to keep this message secret!</span><span class="delimiter">&quot;</span></span>
    encrypt &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">GPars can build operator pipelines really easy</span><span class="delimiter">&quot;</span></span>
}

task {
    <span class="integer">2</span>.times {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Saving </span><span class="delimiter">&quot;</span></span> + messagesToSave.val
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The output of the <em>encryption</em> pipeline is directly connected to the input of the <em>saving</em> pipeline (a
single channel in out case).</p>
</div>
</div>
<div class="sect3">
<h4 id="_forking_the_strong_dataflow_strong">Forking the <strong>Dataflow</strong></h4>
<div class="paragraph">
<p>When a need comes to copy the output of a pipeline/channel into more than one following pipeline/channel, the <em>split()</em> method will help you:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre><span class="directive">final</span> encrypt = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowWriteChannel messagesToSave = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowWriteChannel messagesToLog = <span class="keyword">new</span> DataflowQueue()

encrypt.chainWith toUpperCase chainWith {<span class="local-variable">it</span>.reverse()}.split(messagesToSave, messagesToLog)</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_tapping_into_a_pipeline">Tapping into a Pipeline</h4>
<div class="paragraph">
<p>Like <em>split()</em> the <em>tap()</em> method allows you to fork the data flow into multiple channels. Tapping, however,
is slightly more convenient in some scenarios, since it treats one of the two new forks as the successor of
the pipeline.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>queue.chainWith {<span class="local-variable">it</span> * <span class="integer">2</span>}.tap(logChannel).chainWith{<span class="local-variable">it</span> + <span class="integer">1</span>}.tap(logChannel).into(PrintChannel)</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_merging_channels">Merging Channels</h4>
<div class="paragraph">
<p>Merging allows you to join multiple read channels as inputs for a single dataflow operator. The function
passed as the second argument needs to accept as many arguments as there are channels being merged - each
will hold a value of the corresponding channel.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>maleChannel.merge(femaleChannel) {m, f -&gt; m.marry(f)}.into(mortgageCandidatesChannel)</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_separation">Separation</h4>
<div class="paragraph">
<p><em>Separation</em> is the opposite operation to <em>merge</em>. The supplied closure returns a list of values, each of
which will be output into an output channel with the corresponding position index.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>queue1.separate([queue2, queue3, queue4]) {a -&gt; [a-<span class="integer">1</span>, a, a+<span class="integer">1</span>]}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_choices">Choices</h4>
<div class="paragraph">
<p>The <em>binaryChoice()</em> and <em>choice()</em> methods allow you to send a value to one out of two (or many) output
channels, as indicated by the return value from a closure.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre>queue1.binaryChoice(queue2, queue3) {a -&gt; a &gt; <span class="integer">0</span>}
queue1.choice([queue2, queue3, queue4]) {a -&gt; a % <span class="integer">3</span>}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_filtering">Filtering</h4>
<div class="paragraph">
<p>The <em>filter()</em> method allows to filter data in the pipeline using boolean predicates.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
</pre></td>
  <td class="code"><pre>        <span class="directive">final</span> DataflowQueue queue1 = <span class="keyword">new</span> DataflowQueue()
        <span class="directive">final</span> DataflowQueue queue2 = <span class="keyword">new</span> DataflowQueue()

        <span class="directive">final</span> odd = {num -&gt; num % <span class="integer">2</span> != <span class="integer">0</span> }

        queue1.filter(odd) into queue2
        (<span class="integer">1</span>..<span class="integer">5</span>).each {queue1 &lt;&lt; <span class="local-variable">it</span>}
        <span class="keyword">assert</span> <span class="integer">1</span> == queue2.val
        <span class="keyword">assert</span> <span class="integer">3</span> == queue2.val
        <span class="keyword">assert</span> <span class="integer">5</span> == queue2.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_null_values">Null Values</h4>
<div class="paragraph">
<p>If a chained function returns a <em>null</em> value, it is normally passed along the pipeline as a valid value. To
indicate to the operator that no value should be passed further down the pipeline, a <em>NullObject.nullObject</em>
instance must be returned.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
</pre></td>
  <td class="code"><pre>        <span class="directive">final</span> DataflowQueue queue1 = <span class="keyword">new</span> DataflowQueue()
        <span class="directive">final</span> DataflowQueue queue2 = <span class="keyword">new</span> DataflowQueue()

        <span class="directive">final</span> odd = {num -&gt;
            <span class="keyword">if</span> (num == <span class="integer">5</span>) <span class="keyword">return</span> <span class="predefined-constant">null</span>  <span class="comment">//null values are normally passed on</span>
            <span class="keyword">if</span> (num % <span class="integer">2</span> != <span class="integer">0</span>) <span class="keyword">return</span> num
            <span class="keyword">else</span> <span class="keyword">return</span> NullObject.nullObject  <span class="comment">//this value gets blocked</span>
        }

        queue1.chainWith odd into queue2
        (<span class="integer">1</span>..<span class="integer">5</span>).each {queue1 &lt;&lt; <span class="local-variable">it</span>}
        <span class="keyword">assert</span> <span class="integer">1</span> == queue2.val
        <span class="keyword">assert</span> <span class="integer">3</span> == queue2.val
        <span class="keyword">assert</span> <span class="predefined-constant">null</span> == queue2.val</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_customizing_thread_pools">Customizing Thread Pools</h4>
<div class="paragraph">
<p>All of the Pipeline DSL methods allow for custom thread pools or <em>PGroups</em> to be specified:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
39
<strong>40</strong>
41
42
43
</pre></td>
  <td class="code"><pre>channel | {<span class="local-variable">it</span> * <span class="integer">2</span>}

channel.chainWith(closure)
channel.chainWith(pool) {<span class="local-variable">it</span> * <span class="integer">2</span>}
channel.chainWith(group) {<span class="local-variable">it</span> * <span class="integer">2</span>}

channel.into(otherChannel)
channel.into(pool, otherChannel)
channel.into(group, otherChannel)

channel.split(otherChannel1, otherChannel2)
channel.split(otherChannels)
channel.split(pool, otherChannel1, otherChannel2)
channel.split(pool, otherChannels)
channel.split(group, otherChannel1, otherChannel2)
channel.split(group, otherChannels)

channel.tap(otherChannel)
channel.tap(pool, otherChannel)
channel.tap(group, otherChannel)

channel.merge(otherChannel)
channel.merge(otherChannels)
channel.merge(pool, otherChannel)
channel.merge(pool, otherChannels)
channel.merge(group, otherChannel)
channel.merge(group, otherChannels)

channel.filter( otherChannel)
channel.filter(pool, otherChannel)
channel.filter(group, otherChannel)

channel.binaryChoice( trueBranch, falseBranch)
channel.binaryChoice(pool, trueBranch, falseBranch)
channel.binaryChoice(group, trueBranch, falseBranch)

channel.choice( branches)
channel.choice(pool, branches)
channel.choice(group, branches)

channel.separate( outputs)
channel.separate(pool, outputs)
channel.separate(group, outputs)
</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_overriding_the_default_strong_pgroup_strong">Overriding the Default <strong>PGroup</strong></h3>
<div class="paragraph">
<p>To avoid the necessity to specify PGroup for each Pipeline DSL method separately you may override the value
of the default Dataflow PGroup.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>Dataflow.usingGroup(group) {
    channel.choice(branches)
}
<span class="comment">//Is identical to</span>
channel.choice(group, branches)</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>Dataflow.usingGroup()</em> method resets the value of the default dataflow PGroup for the given code block
to the value specified.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_the_pipeline_builder">The Pipeline Builder</h3>
<div class="paragraph">
<p>The <em>Pipeline</em> class offers an intuitive builder for operator pipelines. The greatest benefit of using the
<em>Pipeline</em> class compared to chaining the channels directly is the ease with which a custom thread
pool/group can be applied to all the operators along the constructed chain.  The available methods and
overloaded operators are identical to the ones available on channels directly.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The greatest benefit of using the <em>Pipeline</em> class is easy usage
</td>
</tr>
</table>
</div>
<hr>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.operator.Pipeline</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.scheduler.DefaultPool</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.scheduler.Pool</span>

<span class="directive">final</span> DataflowQueue queue = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowQueue result1 = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> DataflowQueue result2 = <span class="keyword">new</span> DataflowQueue()
<span class="directive">final</span> Pool pool = <span class="keyword">new</span> DefaultPool(<span class="predefined-constant">false</span>, <span class="integer">2</span>)

<span class="directive">final</span> negate = {-<span class="local-variable">it</span>}

<span class="directive">final</span> Pipeline pipeline = <span class="keyword">new</span> Pipeline(pool, queue)

pipeline | {<span class="local-variable">it</span> * <span class="integer">2</span>} | {<span class="local-variable">it</span> + <span class="integer">1</span>} | negate
pipeline.split(result1, result2)

queue &lt;&lt; <span class="integer">1</span>
queue &lt;&lt; <span class="integer">2</span>
queue &lt;&lt; <span class="integer">3</span>

<span class="keyword">assert</span> -<span class="integer">3</span> == result1.val
<span class="keyword">assert</span> -<span class="integer">5</span> == result1.val
<span class="keyword">assert</span> -<span class="integer">7</span> == result1.val

<span class="keyword">assert</span> -<span class="integer">3</span> == result2.val
<span class="keyword">assert</span> -<span class="integer">5</span> == result2.val
<span class="keyword">assert</span> -<span class="integer">7</span> == result2.val

pool.shutdown()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_passing_construction_parameters_through_the_pipeline_dsl">Passing Construction Parameters Through the Pipeline DSL</h3>
<div class="paragraph">
<p>You are likely to frequently need the ability to pass additional initialization parameters to the operators,
such as the listeners to attach or the value for <em>maxForks</em>. Just like when building operators directly, the
Pipeline DSL methods accept an optional map of parameters to pass in.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="keyword">new</span> Pipeline(group, queue1).merge([<span class="key">maxForks</span>: <span class="integer">4</span>, <span class="key">listeners</span>: [listener]], queue2) {a, b -&gt; a + b}.into queue3</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation">Implementation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Dataflow Concurrency in <strong>GPars</strong> builds on the same principles as the <strong>Actor</strong> support. All of the dataflow
tasks share a thread pool and so the number threads created through <em>Dataflow.task()</em> factory method don&#8217;t
need to correspond to the number of physical threads required from the system.  The <em>PGroup.task()</em> factory
method can be used to attach the created task to a group. Since each group defines its own thread pool, you
can easily organize tasks around different thread pools just like you do with <strong>actors</strong>.</p>
</div>
<div class="sect2">
<h3 id="_combining_strong_actors_strong_and_code_dataflow_concurrency_code">Combining <strong>Actors</strong> and <code>Dataflow Concurrency</code></h3>
<div class="paragraph">
<p>The good news is that you can combine <strong>actors</strong> and <code>Dataflow Concurrency</code> in any way you feel fit for your
particular problem at hands. You can freely you use Dataflow Variables from <strong>Actors</strong>.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
</pre></td>
  <td class="code"><pre><span class="directive">final</span> DataflowVariable a = <span class="keyword">new</span> DataflowVariable()

<span class="directive">final</span> Actor doubler = Actors.actor {
    react {message-&gt;
        a &lt;&lt; <span class="integer">2</span> * message
    }
}

<span class="directive">final</span> Actor fakingDoubler = actor {
    react {
        doubler.send <span class="local-variable">it</span>  <span class="comment">//send a number to the doubler</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Result </span><span class="inline"><span class="inline-delimiter">${</span>a.val<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>  <span class="comment">//wait for the result to be bound to 'a'</span>
    }
}

fakingDoubler &lt;&lt; <span class="integer">10</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example you see the "fakingDoubler" using both messages and a <em>DataflowVariable</em> to communicate with
the <em>doubler</em> <strong>Actor</strong>.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_using_plain_strong_java_strong_threads">Using Plain <strong>Java</strong> Threads</h3>
<div class="paragraph">
<p>The <em>DataflowVariable</em> as well as the <em>DataflowQueue</em> classes can obviously be used from any thread of your
application, not only from the tasks created by <em>Dataflow.task()</em> . Consider the following example:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowVariable</span>

<span class="directive">final</span> DataflowVariable a = <span class="keyword">new</span> DataflowVariable&lt;<span class="predefined-type">String</span>&gt;()
<span class="directive">final</span> DataflowVariable b = <span class="keyword">new</span> DataflowVariable&lt;<span class="predefined-type">String</span>&gt;()

<span class="predefined-type">Thread</span>.start {
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Received: </span><span class="inline"><span class="inline-delimiter">$</span>a</span><span class="content">.val</span><span class="delimiter">&quot;</span></span>
    <span class="predefined-type">Thread</span>.sleep <span class="integer">2000</span>
    b &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Thank you</span><span class="delimiter">'</span></span>
}

<span class="predefined-type">Thread</span>.start {
    <span class="predefined-type">Thread</span>.sleep <span class="integer">2000</span>
    a &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">An important message from the second thread</span><span class="delimiter">'</span></span>
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Reply: </span><span class="inline"><span class="inline-delimiter">$</span>b</span><span class="content">.val</span><span class="delimiter">&quot;</span></span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re creating two plain <em>java.lang.Thread</em> instances, which exchange data using the two data flow
variables. Obviously, neither the <strong>Actor</strong> lifecycle methods, nor the send/react functionality or thread
pooling take effect in such scenarios.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_synchronous_variables_and_channels">Synchronous Variables and Channels</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When using asynchronous dataflow channels, apart from the fact that readers have to wait for a value to be
available for consumption, the communicating parties remain completely independent. Writers don&#8217;t wait for
their messages to get consumed. Readers obtain values immediately as they come and ask.  Synchronous
channels, on the other hand, can synchronize writers with the readers as well as multiple readers among
themselves.  This is particularly useful when you need to increase the level of determinism. The
writer-to-reader partial ordering imposed by asynchronous communication is complemented with
reader-to-writer partial ordering, when using synchronous communication.  In other words, you are guaranteed
that whatever the reader did before reading a value from a synchronous channel preceded whatever the writer
did after writing the value.  Also, with synchronous communication writers can never get too far ahead of
readers, which simplifies reasoning about the system and reduces the need to manage data production speed in
order to avoid system overload.</p>
</div>
<div class="sect2">
<h3 id="_synchronous_dataflow_queue">Synchronous Dataflow Queue</h3>
<div class="paragraph">
<p>The <em>SyncDataflowQueue</em> class should be used for point-to-point (1:1 or n:1) communication. Each message
written to the queue will be consumed by exactly one reader. Writers are blocked until their message is
consumed, readers are blocked until there&#8217;s a value available for them to read.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.SyncDataflowQueue</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.NonDaemonPGroup</span>

<span class="comment">/**
 * Shows how synchronous dataflow queues can be used to throttle fast producer when serving data to a slow consumer.
 * Unlike when using asynchronous channels, synchronous channels block both the writer and the readers until all parties are ready to exchange messages.
 */</span>

<span class="keyword">def</span> group = <span class="keyword">new</span> NonDaemonPGroup()

<span class="directive">final</span> SyncDataflowQueue channel = <span class="keyword">new</span> SyncDataflowQueue()

<span class="keyword">def</span> producer = group.task {
    (<span class="integer">1</span>..<span class="integer">30</span>).each {
        channel &lt;&lt; <span class="local-variable">it</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Just sent </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>
    }
    channel &lt;&lt; -<span class="integer">1</span>
}

<span class="keyword">def</span> consumer = group.task {
    <span class="keyword">while</span> (<span class="predefined-constant">true</span>) {
        sleep <span class="integer">500</span>  <span class="comment">//simulating a slow consumer</span>
        <span class="directive">final</span> <span class="predefined-type">Object</span> msg = channel.val
        <span class="keyword">if</span> (msg == -<span class="integer">1</span>) <span class="keyword">return</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Received </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>
    }
}

consumer.join()

group.shutdown()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_synchronous_dataflow_broadcast">Synchronous Dataflow Broadcast</h3>
<div class="paragraph">
<p>The <em>SyncDataflowBroadcast</em> class should be used for publish-subscribe (1:n or n:m) communication. Each
message written to the broadcast will be consumed by all subscribed readers. Writers are blocked until their
message is consumed by all readers, readers are blocked until there&#8217;s a value available for them to read and
all the other subscribed readers ask for the message as well.  With <em>SyncDataflowBroadcast</em> you get all
readers processing the same message at the same time and waiting for one-another before getting the
next one.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
39
<strong>40</strong>
41
42
43
44
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.SyncDataflowBroadcast</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.NonDaemonPGroup</span>

<span class="comment">/**
 * Shows how synchronous dataflow broadcasts can be used to throttle fast producer when serving data to slow consumers.
 * Unlike when using asynchronous channels, synchronous channels block both the writer and the readers until all parties are ready to exchange messages.
 */</span>

<span class="keyword">def</span> group = <span class="keyword">new</span> NonDaemonPGroup()

<span class="directive">final</span> SyncDataflowBroadcast channel = <span class="keyword">new</span> SyncDataflowBroadcast()

<span class="keyword">def</span> subscription1 = channel.createReadChannel()
<span class="keyword">def</span> fastConsumer = group.task {
    <span class="keyword">while</span> (<span class="predefined-constant">true</span>) {
        sleep <span class="integer">10</span>  <span class="comment">//simulating a fast consumer</span>
        <span class="directive">final</span> <span class="predefined-type">Object</span> msg = subscription1.val
        <span class="keyword">if</span> (msg == -<span class="integer">1</span>) <span class="keyword">return</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Fast consumer received </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>
    }
}

<span class="keyword">def</span> subscription2 = channel.createReadChannel()
<span class="keyword">def</span> slowConsumer = group.task {
    <span class="keyword">while</span> (<span class="predefined-constant">true</span>) {
        sleep <span class="integer">500</span>  <span class="comment">//simulating a slow consumer</span>
        <span class="directive">final</span> <span class="predefined-type">Object</span> msg = subscription2.val
        <span class="keyword">if</span> (msg == -<span class="integer">1</span>) <span class="keyword">return</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Slow consumer received </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>
    }
}

<span class="keyword">def</span> producer = group.task {
    (<span class="integer">1</span>..<span class="integer">30</span>).each {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Sending </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>
        channel &lt;&lt; <span class="local-variable">it</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Sent </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>
    }
    channel &lt;&lt; -<span class="integer">1</span>
}

[fastConsumer, slowConsumer]*.join()

group.shutdown()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_synchronous_dataflow_variable">Synchronous Dataflow Variable</h3>
<div class="paragraph">
<p>Unlike <em>DataflowVariable</em>, which is asynchronous and only blocks the readers until a value is bound to the
variable, the <em>SyncDataflowVariable</em> class provides a one-shot data exchange mechanism that blocks the
writer and all readers until a specified number of waiting parties is reached.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.SyncDataflowVariable</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.NonDaemonPGroup</span>

<span class="directive">final</span> NonDaemonPGroup group = <span class="keyword">new</span> NonDaemonPGroup()

<span class="directive">final</span> SyncDataflowVariable value = <span class="keyword">new</span> SyncDataflowVariable(<span class="integer">2</span>)  <span class="comment">//two readers required to exchange the message</span>

<span class="keyword">def</span> writer = group.task {
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Writer about to write a value</span><span class="delimiter">&quot;</span></span>
    value &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Hello</span><span class="delimiter">'</span></span>
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Writer has written the value</span><span class="delimiter">&quot;</span></span>
}

<span class="keyword">def</span> reader = group.task {
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Reader about to read a value</span><span class="delimiter">&quot;</span></span>
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Reader has read the value: </span><span class="inline"><span class="inline-delimiter">${</span>value.val<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
}

<span class="keyword">def</span> slowReader = group.task {
    sleep <span class="integer">5000</span>
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Slow reader about to read a value</span><span class="delimiter">&quot;</span></span>
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Slow reader has read the value: </span><span class="inline"><span class="inline-delimiter">${</span>value.val<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
}

[reader, slowReader]*.join()

group.shutdown()</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_kanban_flow">Kanban Flow</h2>
<div class="sectionbody">
<div class="paragraph">
<p>APIs:
[KanbanFlow|api:groovyx.gpars.dataflow.KanbanFlow] |
[KanbanLink|api:groovyx.gpars.dataflow.KanbanLink] |
[KanbanTray|api:groovyx.gpars.dataflow.KanbanTray] |</p>
</div>
<div class="sect2 gpars dataflow ProcessingNode">
<h3 id="_kanbanflow">KanbanFlow</h3>
<div class="paragraph">
<p>A <em>KanbanFlow</em> is a composed object that uses dataflow abstractions to define dependencies between multiple
concurrent producer and consumer operators.</p>
</div>
<div class="paragraph">
<p>Each link between a producer and a consumer is defined by a <em>KanbanLink</em>.</p>
</div>
<div class="paragraph">
<p>Inside each KanbanLink, the communication between producer and consumer follows the KanbanFlow pattern as
described in <a href="http://people.canoo.com/mittie/kanbanflow.html">The KanbanFlow Pattern</a>.  They use objects of
type <em>KanbanTray</em> to send products downstream and signal requests for further products back to the producer.</p>
</div>
<div class="paragraph">
<p>The figure below shows a <em>KanbanLink</em> with one producer, one consumer and five trays numbered 0 to 4. Tray
number 0 has been used to take a product from producer to consumer, has been emptied by the consumer and is
now sent back to the producer&#8217;s input queue. Trays 1 and 2 wait carry products waiting for consumption,
trays 3 and 4 wait to be used by producers.</p>
</div>
<div class="paragraph">
<p>A <em>KanbanFlow</em> object links producers to consumers thus creating <em>KanbanLink</em> objects.  In the course of
this activity, a second link may be constructed where the producer is the same object that acted as the
consumer in a formerly created link such that the two links become connected to build a chain.</p>
</div>
<div class="paragraph">
<p>Here is an example of a <em>KanbanFlow</em> with only one link, e.g. one producer and one consumer.  The producer
always sends the number 1 downstream and the consumer prints this number.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.ProcessingNode.node</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.KanbanFlow</span>

<span class="keyword">def</span> producer = node { down -&gt; down <span class="integer">1</span> }
<span class="keyword">def</span> consumer = node { up   -&gt; println up.take() }

<span class="keyword">new</span> KanbanFlow().with {
    link producer to consumer
    start()
    <span class="comment">// run for a while</span>
    stop()
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>For putting a product into a tray and sending the tray downstream, one can either use the @send()@ method,
the @&lt;&lt;@ operator, or use the tray as a method object.  The following lines are equivalent:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>node { down -&gt; down.send <span class="integer">1</span> }
node { down -&gt; down &lt;&lt; <span class="integer">1</span> }
node { down -&gt; down <span class="integer">1</span> }</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>When a product is taken from the input tray with the @take()@ method, the empty tray is automatically
released.</p>
</div>
<hr>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
You should call @take()@ only once!
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p>If you prefer to not using an empty tray for sending products downstream (as typically the case when a
<em>ProcessingNode</em> acts as a filter), you must release the tray in order to keep it in play. Otherwise, the
number of trays in the system decreases. You can release a tray either by calling the @release()@ method or
by using the @~@ operator (think "shake it off").  The following lines are equivalent:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre>node { down -&gt; down.release() }
node { down -&gt; ~down }</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Trays are automatically released, if you call any of the @take()@ or @send()@ methods.</p>
</div>
</div>
</div>
<hr>
<div class="sect3">
<h4 id="_various_linking_structures">Various Linking Structures</h4>
<div class="paragraph">
<p>In addition to a linear chains, a <em>KanbanFlow</em> can also link a single producer to multiple consumers (tree)
or multiple producers to a single consumer (collector) or any combination of the above that results in a
directed acyclic graph (DAG).</p>
</div>
<div class="paragraph">
<p>The <em>KanbanFlowTest</em> class has many examples for such structures, including scenarios where a single
producer delegates work to multiple consumers with:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a <strong>work-stealing</strong> strategy where all consumers get their pick from the downstream,</p>
</li>
<li>
<p>a <strong>master-slave</strong> strategy where a producer chooses from the available consumers, and</p>
</li>
<li>
<p>a <strong>broadcast</strong> strategy where a producer sends all products to all consumers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cycles are forbidden by default but when enabled, they can be used as so-called generators. A producer can
even be his own consumer that increases a product value in every cycle. The generator itself remains
state-free since the value is only stored as a product riding on a tray.  Such a generator can be used for
e.g. lazy sequences or as a the "heartbeat" of a subsequent flow.</p>
</div>
<div class="paragraph">
<p>The approach of generator "loops" can equally be applied to collectors, where a collector does not maintain
any internal state but sends a collection onto itself, adding products at each call.</p>
</div>
<div class="paragraph">
<p>Generally speaking, a <em>ProcessingNode</em> can link to itself for exporting state to the tray/product that it
sends to itself. Access to the product is then <strong>thread-safe by design</strong>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_composing_kanbanflows">Composing KanbanFlows</h4>
<div class="paragraph">
<p>Just as <em>KanbanLink</em> objects can be chained together to form a <em>KanbanFlow</em>, flows themselves can be
composed again to form new greater flows from existing smaller ones.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> firstFlow = <span class="keyword">new</span> KanbanFlow()
<span class="keyword">def</span> producer  = node(counter)
<span class="keyword">def</span> consumer  = node(repeater)
firstFlow.link(producer).to(consumer)

<span class="keyword">def</span> secondFlow = <span class="keyword">new</span> KanbanFlow()
<span class="keyword">def</span> producer2  = node(repeater)
<span class="keyword">def</span> consumer2  = node(reporter)
secondFlow.link(producer2).to(consumer2)

flow = firstFlow + secondFlow

flow.start()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_customizing_concurrency_characteristics">Customizing Concurrency Characteristics</h4>
<div class="paragraph">
<p>The amount of concurrency in a kanban system is determined by the number of trays (sometimes called <strong>WIP</strong> =
work in progress). With no trays in the streams, the system does nothing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>With one tray only, the system is confined to sequential execution.</p>
</li>
<li>
<p>With more trays, concurrency begins.</p>
</li>
<li>
<p>With more trays than available processing units, the system begins to waste resources.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The number of trays can be controlled in various ways. They are typically set when starting the flow.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>flow.start(<span class="integer">0</span>) <span class="comment">// start without trays</span>
flow.start(<span class="integer">1</span>) <span class="comment">// start with one tray per link in the flow</span>
flow.start()  <span class="comment">// start with the optimal number of trays</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition to the trays, the <em>KanbanFlow</em> may also be constrained by its underlying <em>ThreadPool</em>. A pool of
size 1 for example will not allow much concurrency.</p>
</div>
<div class="paragraph">
<p><em>KanbanFlows</em> use a default pool that is dimensioned by the number of available cores. This can be
customized by setting the @pooledGroup@ property.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_tests">Tests</h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/GPars/GPars/blob/master/src/test/groovy/groovyx/gpars/dataflow/KanbanFlowTest.groovy">Kanban Flow Test in <strong>Groovy</strong></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_demos">Demos</h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/GPars/GPars/blob/master/src/test/groovy/groovyx/gpars/samples/dataflow/kanban/DemoKanbanFlow.groovy">Demo Kanban Flow</a></p>
</li>
<li>
<p><a href="https://github.com/GPars/GPars/blob/master/src/test/groovy/groovyx/gpars/samples/dataflow/kanban/DemoKanbanFlowBroadcast.groovy">Demo Kanban Flow Broadcast</a></p>
</li>
<li>
<p><a href="https://github.com/GPars/GPars/blob/master/src/test/groovy/groovyx/gpars/samples/dataflow/kanban/DemoKanbanFlowCycle.groovy">Demo Kanban Flow Cycle</a></p>
</li>
<li>
<p><a href="https://github.com/GPars/GPars/blob/master/src/test/groovy/groovyx/gpars/samples/dataflow/kanban/DemoKanbanLazyPrimeSequenceLoops.groovy">Demo Kanban Lazy Prime Sequence Loops</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_classic_examples">Classic Examples</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_the_sieve_of_eratosthenes_implementation_using_code_dataflow_tasks_code">The Sieve of Eratosthenes Implementation using <code>Dataflow Tasks</code></h3>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
39
<strong>40</strong>
41
42
43
44
45
46
47
48
49
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

<span class="comment">/**
 * Demonstrates concurrent implementation of the Sieve of Eratosthenes using dataflow tasks
 */</span>

<span class="directive">final</span> <span class="type">int</span> requestedPrimeNumberCount = <span class="integer">1000</span>

<span class="directive">final</span> DataflowQueue initialChannel = <span class="keyword">new</span> DataflowQueue()

<span class="comment">/**
 * Generating candidate numbers
 */</span>
task {
    (<span class="integer">2</span>..<span class="integer">10000</span>).each {
        initialChannel &lt;&lt; <span class="local-variable">it</span>
    }
}

<span class="comment">/**
 * Chain a new filter for a particular prime number to the end of the Sieve
 * @param inChannel The current end channel to consume
 * @param prime The prime number to divide future prime candidates with
 * @return A new channel ending the whole chain
 */</span>
<span class="keyword">def</span> <span class="function">filter</span>(inChannel, <span class="type">int</span> prime) {
    <span class="keyword">def</span> outChannel = <span class="keyword">new</span> DataflowQueue()

    task {
        <span class="keyword">while</span> (<span class="predefined-constant">true</span>) {
            <span class="keyword">def</span> number = inChannel.val
            <span class="keyword">if</span> (number % prime != <span class="integer">0</span>) {
                outChannel &lt;&lt; number
            }
        }
    }
    <span class="keyword">return</span> outChannel
}

<span class="comment">/**
 * Consume Sieve output and add additional filters for all found primes
 */</span>
<span class="keyword">def</span> currentOutput = initialChannel
requestedPrimeNumberCount.times {
    <span class="type">int</span> prime = currentOutput.val
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Found: </span><span class="inline"><span class="inline-delimiter">$</span>prime</span><span class="delimiter">&quot;</span></span>
    currentOutput = filter(currentOutput, prime)
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_sieve_of_eratosthenes_using_both_code_dataflow_tasks_code_and_code_operators_code">The Sieve of Eratosthenes using both <code>Dataflow Tasks</code> and <code>Operators</code></h3>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
39
<strong>40</strong>
41
42
43
44
45
46
47
</pre></td>
  <td class="code"><pre>       <span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowQueue</span>
       <span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.operator</span>
       <span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.dataflow.Dataflow.task</span>

       <span class="comment">/**
        * Demonstrates concurrent implementation of the Sieve of Eratosthenes using dataflow tasks and operators
        */</span>

       <span class="directive">final</span> <span class="type">int</span> requestedPrimeNumberCount = <span class="integer">100</span>

       <span class="directive">final</span> DataflowQueue initialChannel = <span class="keyword">new</span> DataflowQueue()

       <span class="comment">/**
        * Generating candidate numbers
        */</span>
       task {
           (<span class="integer">2</span>..<span class="integer">1000</span>).each {
               initialChannel &lt;&lt; <span class="local-variable">it</span>
           }
       }

       <span class="comment">/**
        * Chain a new filter for a particular prime number to the end of the Sieve
        * @param inChannel The current end channel to consume
        * @param prime The prime number to divide future prime candidates with
        * @return A new channel ending the whole chain
        */</span>
       <span class="keyword">def</span> <span class="function">filter</span>(inChannel, <span class="type">int</span> prime) {
           <span class="keyword">def</span> outChannel = <span class="keyword">new</span> DataflowQueue()

           operator([<span class="key">inputs</span>: [inChannel], <span class="key">outputs</span>: [outChannel]]) {
               <span class="keyword">if</span> (<span class="local-variable">it</span> % prime != <span class="integer">0</span>) {
                   bindOutput <span class="local-variable">it</span>
               }
           }
           <span class="keyword">return</span> outChannel
       }

       <span class="comment">/**
        * Consume Sieve output and add additional filters for all found primes
        */</span>
       <span class="keyword">def</span> currentOutput = initialChannel
       requestedPrimeNumberCount.times {
           <span class="type">int</span> prime = currentOutput.val
           println <span class="string"><span class="delimiter">&quot;</span><span class="content">Found: </span><span class="inline"><span class="inline-delimiter">$</span>prime</span><span class="delimiter">&quot;</span></span>
           currentOutput = filter(currentOutput, prime)
       }</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.0<br>
Last updated 2015-10-31 14:10:18 CET
</div>
</div>
</body>
</html>