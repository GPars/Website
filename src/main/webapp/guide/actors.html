<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.2">
<meta name="description" content="GPars is a multi-paradigm concurrency framework offering several mutually cooperating high-level concurrency abstractions.">
<meta name="author" content="The Whole GPars Team &lt;https://groups.google.com/forum/#!forum/gpars-users&gt;">
<title>User Guide To Actors</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.2.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>User Guide To Actors</h1>
<div class="details">
<span id="author" class="author">The Whole GPars Team &lt;https://groups.google.com/forum/#!forum/gpars-users&gt;</span><br>
<span id="revnumber">version 1.0,</span>
<span id="revdate">2015-11-01</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Document Index</div>
<ul class="sectlevel1">
<li><a href="#_types_of_actors">Types of Actors</a></li>
<li><a href="#_actor_threading_model">Actor Threading Model</a></li>
<li><a href="#_usage_of_actors">Usage of Actors</a>
<ul class="sectlevel2">
<li><a href="#_sending_messages">Sending Messages</a></li>
<li><a href="#_receiving_messages">Receiving Messages</a></li>
<li><a href="#_sending_replies">Sending Replies</a></li>
<li><a href="#_creating_actors">Creating Actors</a></li>
<li><a href="#_undelivered_messages">Undelivered Messages</a></li>
<li><a href="#_joining_actors">Joining Actors</a></li>
<li><a href="#_custom_schedulers">Custom schedulers</a></li>
</ul>
</li>
<li><a href="#_actors_principles">Actors Principles</a>
<ul class="sectlevel2">
<li><a href="#_creating_an_asynchronous_service">Creating an asynchronous service</a></li>
<li><a href="#_actors_guarantee_thread_safety_for_non_thread_safe_code">Actors guarantee thread-safety for non-thread-safe code</a></li>
<li><a href="#_simple_calculator">Simple calculator</a></li>
</ul>
</li>
<li><a href="#_stateless_actors">Stateless Actors</a>
<ul class="sectlevel2">
<li><a href="#_dynamic_dispatch_actor">Dynamic Dispatch Actor</a></li>
<li><a href="#_static_dispatch_actor">Static Dispatch Actor</a></li>
<li><a href="#_reactive_actor">Reactive Actor</a></li>
</ul>
</li>
<li><a href="#_tips_and_tricks">Tips and Tricks</a>
<ul class="sectlevel2">
<li><a href="#_structuring_actor_s_code">Structuring Actor&#8217;s Code</a></li>
<li><a href="#_event_driven_loops">Event-Driven Loops</a></li>
<li><a href="#_enhancing_the_actor_s_metaclass">Enhancing The Actor&#8217;s MetaClass</a></li>
<li><a href="#_using_groovy_closures">Using Groovy Closures</a></li>
</ul>
</li>
<li><a href="#_active_objects">Active Objects</a>
<ul class="sectlevel2">
<li><a href="#_actors_with_a_friendly_facade">Actors with a friendly facade</a></li>
</ul>
</li>
<li><a href="#_classic_examples">Classic Examples</a>
<ul class="sectlevel2">
<li><a href="#_a_few_examples_of_actors_usage">A Few Examples of Actors usage</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><strong>Actors</strong> offer a message passing-based concurrency model: programs are collections of independent active
objects that exchange messages and have no mutable shared state.</p>
</div>
<div class="paragraph">
<p><strong>Actors</strong> can help us avoid issues such as deadlock, live-lock and starvation, which are common problems for shared memory based approaches.</p>
</div>
<div class="paragraph">
<p><strong>Actors</strong> are a way of leveraging the multi-core nature of today&#8217;s hardware without all the problems traditionally associated with shared-memory
multi-threading, which is why programming languages such as <strong>Erlang</strong> and <strong>Scala</strong> have taken up this model.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The actor support in GPars was originally inspired by the Actors library in Scala, but has since gone
well beyond what Scala offers as standard.
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p>A nice article summarizing the key <a href="http://ruben.savanne.be/articles/concurrency-in-erlang-scala">concepts
behind actors</a> has been written by <em>Ruben Vermeersch</em>.</p>
</div>
<div class="paragraph">
<p><strong>Actors</strong> always guarantee that <strong>at most one thread processes the actor&#8217;s body</strong> at any one time and also, under the covers, that the memory is synchronized
each time a thread is assigned to an actor so the actor&#8217;s state <strong>can be safely modified</strong> by code in the body <strong>without any other extra (synchronization or locking) effort</strong> .</p>
</div>
<div class="paragraph">
<p>Ideally actor&#8217;s code should <strong>never be invoked</strong> directly from outside so all the code of the actor class can only be executed by the thread
handling the last received message and hence all the actor&#8217;s code is <strong>implicitly thread-safe</strong> .</p>
</div>
<div class="paragraph">
<p>If any of the actor&#8217;s methods are allowed to be called by other objects directly, the thread-safety guarantee for the actor&#8217;s code and state are <strong>no longer valid</strong> .</p>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_types_of_actors">Types of Actors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In general, you can find two types of actors in the wild&#8201;&#8212;&#8201;ones that hold <strong>implicit state</strong> and ones that don&#8217;t.</p>
</div>
<div class="paragraph">
<p><strong>GPars</strong> gives you both options.</p>
</div>
<div class="paragraph">
<p><strong>Stateless</strong> actors, represented in <strong>GPars</strong> by the <em>DynamicDispatchActor</em> and the <em>ReactiveActor</em> classes, keep no track of what messages have arrived
previously.  You may think of these as flat message handlers, which process messages as they come. Any state-based behavior has to be implemented by the user.</p>
</div>
<div class="paragraph">
<p>The <strong>stateful</strong> actors, represented in <strong>GPars</strong> by the <em>DefaultActor</em> class (and previously also by the <em>AbstractPooledActor</em> class), allow us to handle implicit state directly.
After receiving a message, the actor moves into a new state with different ways to handle future messages.</p>
</div>
<div class="paragraph">
<p>To give you an example, a freshly started actor may only accept some types of messages, e.g. encrypted messages for decryption, only after it has received the encryption keys.
The stateful actors allow to encode such dependencies directly in the structure of the message-handling code.  Implicit state management, however, comes at a slight performance cost,
mainly due to the lack of continuations support on JVM.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_actor_threading_model">Actor Threading Model</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Since actors are detached from the system threads, a larg3 number of actors can share a relatively small thread pool.</p>
</div>
<div class="paragraph">
<p>This can go as far as having many concurrent actors share a single pooled thread while avoiding some of the threading limitations of the JVM.</p>
</div>
<div class="paragraph">
<p>In general, while the JVM can only give you a limited number of threads (typically around a couple of thousands), the number of actors is only
limited by the available memory. If an actor has no work to do, it doesn&#8217;t consume any threads.</p>
</div>
<div class="paragraph">
<p>Actor code is processed in chunks separated by quiet periods of waiting for new events (messages).  This can be naturally modeled through <em>continuations</em>.</p>
</div>
<div class="paragraph">
<p>As JVM doesn&#8217;t support continuations directly, they have to be simulated in the actors frameworks, which has slight impact on organization of the actors' code.
However, the benefits in most cases outweigh the difficulties.</p>
</div>
<hr>
<div class="listingblock">
<div class="title">An Actors Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
39
<strong>40</strong>
41
42
43
44
45
46
47
48
49
<strong>50</strong>
51
52
53
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.actor.Actor</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.actor.DefaultActor</span>

<span class="type">class</span> <span class="class">GameMaster</span> <span class="directive">extends</span> DefaultActor {
    <span class="type">int</span> secretNum

    <span class="type">void</span> afterStart() {
        secretNum = <span class="keyword">new</span> <span class="predefined-type">Random</span>().nextInt(<span class="integer">10</span>)
    }

    <span class="type">void</span> act() {
        loop {
            react { <span class="type">int</span> num -&gt;
                <span class="keyword">if</span> (num &gt; secretNum) {
                    reply <span class="string"><span class="delimiter">'</span><span class="content">too large</span><span class="delimiter">'</span></span>
                }
                <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; secretNum) {
                    reply <span class="string"><span class="delimiter">'</span><span class="content">too small</span><span class="delimiter">'</span></span>
                }
                <span class="keyword">else</span> {
                    reply <span class="string"><span class="delimiter">'</span><span class="content">you win</span><span class="delimiter">'</span></span>
                    terminate()
                }
            }
        }
    }
}

<span class="type">class</span> <span class="class">Player</span> <span class="directive">extends</span> DefaultActor {
    <span class="predefined-type">String</span> name
    Actor server
    <span class="type">int</span> myNum

    <span class="type">void</span> act() {
        loop {
            myNum = <span class="keyword">new</span> <span class="predefined-type">Random</span>().nextInt(<span class="integer">10</span>)
            server.send myNum
            react {
                <span class="keyword">switch</span> (<span class="local-variable">it</span>) {
                  <span class="keyword">case</span> <span class="string"><span class="delimiter">'</span><span class="content">too large</span><span class="delimiter">'</span></span>: println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: </span><span class="inline"><span class="inline-delimiter">$</span>myNum</span><span class="content"> was too large</span><span class="delimiter">&quot;</span></span>; <span class="keyword">break</span>
                  <span class="keyword">case</span> <span class="string"><span class="delimiter">'</span><span class="content">too small</span><span class="delimiter">'</span></span>: println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: </span><span class="inline"><span class="inline-delimiter">$</span>myNum</span><span class="content"> was too small</span><span class="delimiter">&quot;</span></span>; <span class="keyword">break</span>
                  <span class="keyword">case</span> <span class="string"><span class="delimiter">'</span><span class="content">you win</span><span class="delimiter">'</span></span>: println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: I won </span><span class="inline"><span class="inline-delimiter">$</span>myNum</span><span class="delimiter">&quot;</span></span>; terminate(); <span class="keyword">break</span>
                }
            }
        }
    }
}

<span class="keyword">def</span> master = <span class="keyword">new</span> GameMaster().start()
<span class="keyword">def</span> player = <span class="keyword">new</span> Player(<span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">Player</span><span class="delimiter">'</span></span>, <span class="key">server</span>: master).start()

<span class="comment">// This forces the main thread to wait until both actors have terminated.</span>
[master, player]*.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>example by <em>Jordi Campos i Miralles, Departament de Matemàtica Aplicada i Anàlisi, MAiA Facultat de
Matemàtiques, Universitat de Barcelona</em></p>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_usage_of_actors">Usage of Actors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>GPars provides consistent Actor APIs and DSLs. Actors in principal perform three specific operations&#8201;&#8212;&#8201;send
messages, receive messages and create new actors. Although not specifically enforced by GPars messages
should be immutable or at least follow the <strong>hands-off</strong> policy when the sender never touches the messages
after the message has been sent off.</p>
</div>
<div class="sect2">
<h3 id="_sending_messages">Sending Messages</h3>
<div class="paragraph">
<p>Messages can be sent to actors using the <em>send</em> method.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> passiveActor = Actors.actor{
    loop {
        react { msg -&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">Received: </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>; }
    }
}
passiveActor.send <span class="string"><span class="delimiter">'</span><span class="content">Message 1</span><span class="delimiter">'</span></span>
passiveActor &lt;&lt; <span class="string"><span class="delimiter">'</span><span class="content">Message 2</span><span class="delimiter">'</span></span>    <span class="comment">//using the &lt;&lt; operator</span>
passiveActor <span class="string"><span class="delimiter">'</span><span class="content">Message 3</span><span class="delimiter">'</span></span>       <span class="comment">//using the implicit call() method</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, the <em>&lt;&lt;</em> operator or the implicit <em>call</em> method can be used. A family of <em>sendAndWait</em>
methods is available to block the caller until a reply from the actor is available.  The <em>reply</em> is returned
from the <em>sendAndWait</em> method as a return value.  The <em>sendAndWait</em> methods may also return after a
timeout expires or in case of termination of the called actor.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> replyingActor = Actors.actor{
    loop {
        react { msg -&gt;
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">Received: </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>;
            reply <span class="string"><span class="delimiter">&quot;</span><span class="content">I've got </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>
        }
    }
}

<span class="keyword">def</span> reply1 = replyingActor.sendAndWait(<span class="string"><span class="delimiter">'</span><span class="content">Message 4</span><span class="delimiter">'</span></span>)

<span class="keyword">def</span> reply2 = replyingActor.sendAndWait(<span class="string"><span class="delimiter">'</span><span class="content">Message 5</span><span class="delimiter">'</span></span>, <span class="integer">10</span>, <span class="predefined-type">TimeUnit</span>.SECONDS)

use (TimeCategory) {
    <span class="keyword">def</span> reply3 = replyingActor.sendAndWait(<span class="string"><span class="delimiter">'</span><span class="content">Message 6</span><span class="delimiter">'</span></span>, <span class="integer">10</span>.seconds)
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>sendAndContinue</em> method allows the caller to continue its processing while the supplied closure is
waiting for a reply from the actor.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre>friend.sendAndContinue <span class="string"><span class="delimiter">'</span><span class="content">I need money!</span><span class="delimiter">'</span></span>, {money -&gt; pocket money}
println <span class="string"><span class="delimiter">'</span><span class="content">I can continue while my friend is collecting money for me</span><span class="delimiter">'</span></span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>sendAndPromise</em> method returns a <strong>Promise</strong> (aka Future) to the final reply and so allows the caller
to continue its processing while the actor is handling the submitted message.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>Promise loan = friend.sendAndPromise <span class="string"><span class="delimiter">'</span><span class="content">I need money!</span><span class="delimiter">'</span></span>
println <span class="string"><span class="delimiter">'</span><span class="content">I can continue while my friend is collecting money for me</span><span class="delimiter">'</span></span>
loan.whenBound {money -&gt; pocket money}  <span class="comment">// Asynchronous waiting for a reply.</span>
println <span class="string"><span class="delimiter">&quot;</span><span class="content">Received </span><span class="inline"><span class="inline-delimiter">${</span>loan.get()<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>  <span class="comment">// Synchronous waiting for a reply.</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>All <em>send</em> , <em>sendAndWait</em> or <em>sendAndContinue</em> methods will throw an exception if invoked on a non-active actor.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_receiving_messages">Receiving Messages</h3>
<div class="sect3">
<h4 id="_non_blocking_message_retrieval">Non-blocking Message Retrieval</h4>
<div class="paragraph">
<p>Calling the <em>react</em> method, optionally with a timeout parameter, from within the actor&#8217;s code will consume
the next message from the actor&#8217;s inbox, potentially waiting, if there is no message to be processed
immediately.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>println <span class="string"><span class="delimiter">'</span><span class="content">Waiting for a gift</span><span class="delimiter">'</span></span>
react {gift -&gt;
    <span class="keyword">if</span> (mySpouse.likes gift) reply <span class="string"><span class="delimiter">'</span><span class="content">Thank you!</span><span class="delimiter">'</span></span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Under the covers the supplied closure is not invoked directly, but scheduled for processing by any thread in
the thread pool once a message is available. After scheduling the current thread will then be detached from
the actor and freed to process any other actor, which has received a message already.</p>
</div>
<div class="paragraph">
<p>To allow detaching actors from the threads the <em>react</em> method demands the code to be written in a special
<strong>continuation style</strong>.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
</pre></td>
  <td class="code"><pre>Actors.actor {
    loop {
        println <span class="string"><span class="delimiter">'</span><span class="content">Waiting for a gift</span><span class="delimiter">'</span></span>
        react {gift -&gt;
            <span class="keyword">if</span> (mySpouse.likes gift) reply <span class="string"><span class="delimiter">'</span><span class="content">Thank you!</span><span class="delimiter">'</span></span>
            <span class="keyword">else</span> {
                reply <span class="string"><span class="delimiter">'</span><span class="content">Try again, please</span><span class="delimiter">'</span></span>
                react {anotherGift -&gt;
                    <span class="keyword">if</span> (myChildren.like gift) reply <span class="string"><span class="delimiter">'</span><span class="content">Thank you!</span><span class="delimiter">'</span></span>
                }
                println <span class="string"><span class="delimiter">'</span><span class="content">Never reached</span><span class="delimiter">'</span></span>
            }
        }
        println <span class="string"><span class="delimiter">'</span><span class="content">Never reached</span><span class="delimiter">'</span></span>
    }
    println <span class="string"><span class="delimiter">'</span><span class="content">Never reached</span><span class="delimiter">'</span></span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>react</em> method has a special semantics to allow actors to be detached from threads when no messages
are available in their mailbox.  Essentially, <em>react</em> schedules the supplied code (closure) to be executed
upon next message arrival and returns.  The closure supplied to the <em>react</em> methods is the code where the
computation should <strong>continue</strong> . Thus <strong>continuation style</strong> .</p>
</div>
<div class="paragraph">
<p>Since actors have to preserve the guarantee that at most one thread is active within the actor&#8217;s body, the
next message cannot be handled before the current message processing finishes. Typically, there shouldn&#8217;t be
a need to put code after calls to <em>react</em>.  Some actor implementations even enforce this. However, GPars
does not for performance reasons.  The <em>loop</em> method allows iteration within the actor body. Unlike typical
looping constructs, like <em>for</em> or <em>while</em> loops, <em>loop</em> cooperates with nested <em>react</em> blocks and will
ensure looping across subsequent message retrievals.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sending_replies">Sending Replies</h3>
<div class="paragraph">
<p>The <em>reply</em> and <em>replyIfExists</em> methods are not only defined on the actors themselves, but for
<em>AbstractPooledActor</em> (not available in <em>DefaultActor</em> , <em>DynamicDispatchActor</em> nor <em>ReactiveActor</em> classes)
also on the processed messages themselves upon their reception, which is particularly handy when handling
multiple messages in a single call. In such cases <em>reply()</em> invoked on the actor sends a reply to authors of
all the currently processed message (the last one), whereas <em>reply()</em> called on messages sends a reply to
the author of the particular message only.</p>
</div>
<div class="paragraph">
<p>DemoMultiMessage.groovy - See demos here.</p>
</div>
<div class="sect3">
<h4 id="_the_sender_property">The Sender Property</h4>
<div class="paragraph">
<p>Messages upon retrieval offer the sender property to identify the originator of the message. The property is
available inside the Actor&#8217;s closure:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>react {tweet -&gt;
    <span class="keyword">if</span> (isSpam(tweet)) ignoreTweetsFrom sender
    sender.send <span class="string"><span class="delimiter">'</span><span class="content">Never write to me again!</span><span class="delimiter">'</span></span>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_forwarding">Forwarding</h4>
<div class="paragraph">
<p>When sending a message, a different actor can be specified as the sender so that potential replies to the
message will be forwarded to the specified actor and not to the actual originator.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> decryptor = Actors.actor {
    react {message -&gt;
        reply message.reverse()
<span class="comment">//        sender.send message.reverse()    //An alternative way to send replies</span>
    }
}

<span class="keyword">def</span> console = Actors.actor {  <span class="comment">//This actor will print out decrypted messages, since the replies are forwarded to it</span>
    react {
        println <span class="string"><span class="delimiter">'</span><span class="content">Decrypted message: </span><span class="delimiter">'</span></span> + <span class="local-variable">it</span>
    }
}

decryptor.send <span class="string"><span class="delimiter">'</span><span class="content">lellarap si yvoorG</span><span class="delimiter">'</span></span>, console  <span class="comment">//Specify an actor to send replies to</span>
console.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creating_actors">Creating Actors</h3>
<div class="paragraph">
<p>Actors share a <strong>pool</strong> of threads, which are dynamically assigned to actors when the actors need to <strong>react</strong>
to messages sent to them. The threads are returned to back the pool once a message has been processed and
the actor is idle waiting for some more messages to arrive.</p>
</div>
<div class="paragraph">
<p>For example, this is how you create an actor that prints out all messages that it receives.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> console = Actors.actor {
    loop {
        react {
            println <span class="local-variable">it</span>
        }
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice the <em>loop()</em> method call, which ensures that the actor doesn&#8217;t stop after having processed the first
message.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example with a decryptor service, which can decrypt submitted messages and send the decrypted
messages back to the originators.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
</pre></td>
  <td class="code"><pre><span class="directive">final</span> <span class="keyword">def</span> decryptor = Actors.actor {
    loop {
        react {<span class="predefined-type">String</span> message -&gt;
            <span class="keyword">if</span> (<span class="string"><span class="delimiter">'</span><span class="content">stopService</span><span class="delimiter">'</span></span> == message) {
                println <span class="string"><span class="delimiter">'</span><span class="content">Stopping decryptor</span><span class="delimiter">'</span></span>
                stop()
            }
            <span class="keyword">else</span> reply message.reverse()
        }
    }
}

Actors.actor {
    decryptor.send <span class="string"><span class="delimiter">'</span><span class="content">lellarap si yvoorG</span><span class="delimiter">'</span></span>
    react {
        println <span class="string"><span class="delimiter">'</span><span class="content">Decrypted message: </span><span class="delimiter">'</span></span> + <span class="local-variable">it</span>
        decryptor.send <span class="string"><span class="delimiter">'</span><span class="content">stopService</span><span class="delimiter">'</span></span>
    }
}.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of an actor that waits for up to 30 seconds to receive a reply to its message.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> friend = Actors.actor {
    react {
        <span class="comment">//this doesn't reply -&gt; caller won't receive any answer in time</span>
        println <span class="local-variable">it</span>
        <span class="comment">//reply 'Hello' //uncomment this to answer conversation</span>
        react {
            println <span class="local-variable">it</span>
        }
    }
}

<span class="keyword">def</span> me = Actors.actor {
    friend.send(<span class="string"><span class="delimiter">'</span><span class="content">Hi</span><span class="delimiter">'</span></span>)
    <span class="comment">//wait for answer 1sec</span>
    react(<span class="integer">1000</span>) {msg -&gt;
        <span class="keyword">if</span> (msg == Actor.TIMEOUT) {
            friend.send(<span class="string"><span class="delimiter">'</span><span class="content">I see, busy as usual. Never mind.</span><span class="delimiter">'</span></span>)
            stop()
        } <span class="keyword">else</span> {
            <span class="comment">//continue conversation</span>
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">Thank you for </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>
        }
    }
}

me.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_undelivered_messages">Undelivered Messages</h3>
<div class="paragraph">
<p>Sometimes messages cannot be delivered to the target actor. When special action needs to be taken for
undelivered messages, at actor termination all unprocessed messages from its queue have their
<em>onDeliveryError()</em> method called. The <em>onDeliveryError()</em> method or closure defined on the message can, for
example, send a notification back to the original sender of the message.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
</pre></td>
  <td class="code"><pre><span class="directive">final</span> DefaultActor me
me = Actors.actor {
    <span class="keyword">def</span> message = <span class="integer">1</span>

    message.metaClass.onDeliveryError = {-&gt;
        <span class="comment">//send message back to the caller</span>
        me &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Could not deliver </span><span class="inline"><span class="inline-delimiter">$</span>delegate</span><span class="delimiter">&quot;</span></span>
    }

    <span class="keyword">def</span> actor = Actors.actor {
        react {
            <span class="comment">//wait 2sec in order next call in demo can be emitted</span>
            <span class="predefined-type">Thread</span>.sleep(<span class="integer">2000</span>)
            <span class="comment">//stop actor after first message</span>
            stop()
        }
    }

    actor &lt;&lt; message
    actor &lt;&lt; message

    react {
        <span class="comment">//print whatever comes back</span>
        println <span class="local-variable">it</span>
    }

}

me.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively the <em>onDeliveryError()</em> method can be specified on the sender itself. The method can be added
both dynamically</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
</pre></td>
  <td class="code"><pre><span class="directive">final</span> DefaultActor me
me = Actors.actor {
    <span class="keyword">def</span> message1 = <span class="integer">1</span>
    <span class="keyword">def</span> message2 = <span class="integer">2</span>

    <span class="keyword">def</span> actor = Actors.actor {
        react {
            <span class="comment">//wait 2sec in order next call in demo can be emitted</span>
            <span class="predefined-type">Thread</span>.sleep(<span class="integer">2000</span>)
            <span class="comment">//stop actor after first message</span>
            stop()
        }
    }

    me.metaClass.onDeliveryError = {msg -&gt;
        <span class="comment">//callback on actor inaccessibility</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Could not deliver message </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>
    }

    actor &lt;&lt; message1
    actor &lt;&lt; message2

    actor.join()

}

me.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>and statically in actor definition:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre><span class="type">class</span> <span class="class">MyActor</span> <span class="directive">extends</span> DefaultActor {
    <span class="directive">public</span> <span class="type">void</span> onDeliveryError(msg) {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Could not deliver message </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>
    }
    ...
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_joining_actors">Joining Actors</h3>
<div class="paragraph">
<p>Actors provide a <em>join()</em> method to allow callers to wait for the actor to terminate. A variant accepting a
timeout is also available. The Groovy <em>spread-dot</em> operator comes in handy when joining multiple actors at a
time.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> master = <span class="keyword">new</span> GameMaster().start()
<span class="keyword">def</span> player = <span class="keyword">new</span> Player(<span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">Player</span><span class="delimiter">'</span></span>, <span class="key">server</span>: master).start()

[master, player]*.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_conditional_and_counting_loops">Conditional and Counting Loops</h4>
<div class="paragraph">
<p>The <em>loop()</em> method allows for either a condition or a number of iterations to be specified, optionally
accompanied with a closure to invoke once the loop finishes - <em>After Loop Termination Code Handler</em> .</p>
</div>
<div class="paragraph">
<p>The following actor will loop three times to receive 3 messages and then prints out the maximum of the
received messages.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
</pre></td>
  <td class="code"><pre><span class="directive">final</span> Actor actor = Actors.actor {
    <span class="keyword">def</span> candidates = <span class="type">[]</span>
    <span class="keyword">def</span> printResult = {-&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">The best offer is </span><span class="inline"><span class="inline-delimiter">${</span>candidates.max()<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>}

    loop(<span class="integer">3</span>, printResult) {
        react {
            candidates &lt;&lt; <span class="local-variable">it</span>
        }
    }
}

actor <span class="integer">10</span>
actor <span class="integer">30</span>
actor <span class="integer">20</span>
actor.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The following actor will receive messages until a value greater then 30 arrives.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
</pre></td>
  <td class="code"><pre><span class="directive">final</span> Actor actor = Actors.actor {
    <span class="keyword">def</span> candidates = <span class="type">[]</span>
    <span class="directive">final</span> Closure printResult = {-&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">Reached best offer - </span><span class="inline"><span class="inline-delimiter">${</span>candidates.max()<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>}

    loop({-&gt; candidates.max() &lt; <span class="integer">30</span>}, printResult) {
        react {
            candidates &lt;&lt; <span class="local-variable">it</span>
        }
    }
}

actor <span class="integer">10</span>
actor <span class="integer">20</span>
actor <span class="integer">25</span>
actor <span class="integer">31</span>
actor <span class="integer">20</span>
actor.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The <code>After Loop Termination Code Handler</code> can use an actor&#8217;s <em>react{}</em> but not <em>loop()</em> .
</td>
</tr>
</table>
</div>
<hr>
<div class="sidebarblock">
<div class="content">
<div class="title">Fair Vs Non-fair Actor Behavior</div>
<div class="paragraph">
<p><em>DefaultActor</em> can be set to behave in a fair or non-fair (default) manner. Depending on the strategy
chosen, the actor either makes the thread available to other actors sharing the same parallel group (fair),
or keeps the thread fot itself until the message queue gets empty (non-fair). Generally, non-fair actors
perform 2 - 3 times better than fair ones.</p>
</div>
<div class="paragraph">
<p>Use either the <em>fairActor()</em> factory method or the actor&#8217;s makeFair() method.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_custom_schedulers">Custom schedulers</h3>
<div class="paragraph">
<p>Actors leverage the standard JDK concurrency library by default.  To provide a custom thread scheduler use
the appropriate constructor parameter when creating a parallel group (PGroup class). The supplied scheduler
will orchestrate threads in the group&#8217;s thread pool.</p>
</div>
<div class="paragraph">
<p>Please also see the numerous Actor Demos.</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_actors_principles">Actors Principles</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Actors share a <strong>pool</strong> of threads, which are dynamically assigned to actors when the actors need to <strong>react</strong>
to messages sent to them.  The threads are returned back to the pool once a message has been processed and
the actor is idle waiting for some more messages to arrive.  Actors become detached from the underlying
threads and so a relatively small thread pool can serve potentially unlimited number of actors.  Virtually
unlimited scalability in number of actors is the main advantage of <em>event-based actors</em> , which are detached
from the underlying physical threads.</p>
</div>
<div class="paragraph">
<p>Here are some examples of how to use actors. This is how you create an actor that prints out all messages
that it receives.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.actor.Actors.actor</span>

<span class="keyword">def</span> console = actor {
    loop {
        react {
            println <span class="local-variable">it</span>
        }
    }</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice the <em>loop()</em> method call, which ensures that the actor doesn&#8217;t stop after having processed the first
message.</p>
</div>
<div class="paragraph">
<p>As an alternative you can extend the <em>DefaultActor</em> class and override the <em>act()</em> method. Once you
instantiate the actor, you need to start it so that it attaches itself to the thread pool and can start
accepting messages.  The <em>actor()</em> factory method will take care of starting the actor.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
</pre></td>
  <td class="code"><pre><span class="type">class</span> <span class="class">CustomActor</span> <span class="directive">extends</span> DefaultActor {
    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> act() {
        loop {
            react {
                println <span class="local-variable">it</span>
            }
        }
    }
}

<span class="keyword">def</span> console=<span class="keyword">new</span> CustomActor()
console.start()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Messages can be sent to the actor using multiple methods</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>console.send(<span class="string"><span class="delimiter">'</span><span class="content">Message</span><span class="delimiter">'</span></span>)
console <span class="string"><span class="delimiter">'</span><span class="content">Message</span><span class="delimiter">'</span></span>
console.sendAndWait <span class="string"><span class="delimiter">'</span><span class="content">Message</span><span class="delimiter">'</span></span>                                                     <span class="comment">//Wait for a reply</span>
console.sendAndContinue <span class="string"><span class="delimiter">'</span><span class="content">Message</span><span class="delimiter">'</span></span>, {reply -&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">I received reply: </span><span class="inline"><span class="inline-delimiter">$</span>reply</span><span class="delimiter">&quot;</span></span>}  <span class="comment">//Forward the reply to a function</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_creating_an_asynchronous_service">Creating an asynchronous service</h3>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.actor.Actors.actor</span>

<span class="directive">final</span> <span class="keyword">def</span> decryptor = actor {
    loop {
        react {<span class="predefined-type">String</span> message-&gt;
            reply message.reverse()
        }
    }
}

<span class="keyword">def</span> console = actor {
    decryptor.send <span class="string"><span class="delimiter">'</span><span class="content">lellarap si yvoorG</span><span class="delimiter">'</span></span>
    react {
        println <span class="string"><span class="delimiter">'</span><span class="content">Decrypted message: </span><span class="delimiter">'</span></span> + <span class="local-variable">it</span>
    }
}

console.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, you create new actors with the <em>actor()</em> method passing in the actor&#8217;s body as a closure
parameter. Inside the actor&#8217;s body you can use <em>loop()</em> to iterate, <em>react()</em> to receive messages and
<em>reply()</em> to send a message to the actor, which has sent the currently processed message. The sender of the
current message is also available through the actor&#8217;s <em>sender</em> property.  When the decryptor actor doesn&#8217;t
find a message in its message queue at the time when <em>react()</em> is called, the <em>react()</em> method gives up the
thread and returns it back to the thread pool for other actors to pick it up.  Only after a new message
arrives to the actor&#8217;s message queue, the closure of the <em>react()</em> method gets scheduled for processing with
the pool.  Event-based actors internally simulate continuations - actor&#8217;s work is split into sequentially
run chunks, which get invoked once a message is available in the inbox. Each chunk for a single actor can be
performed by a different thread from the thread pool.</p>
</div>
<div class="paragraph">
<p>Groovy flexible syntax with closures allows our library to offer multiple ways to define actors.  For
instance, here&#8217;s an example of an actor that waits for up to 30 seconds to receive a reply to its message.
Actors allow time DSL defined by org.codehaus.groovy.runtime.TimeCategory class to be used for timeout
specification to the <em>react()</em> method, provided the user wraps the call within a <em>TimeCategory</em> use block.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> friend = Actors.actor {
    react {
        <span class="comment">//this doesn't reply -&gt; caller won't receive any answer in time</span>
        println <span class="local-variable">it</span>
        <span class="comment">//reply 'Hello' //uncomment this to answer conversation</span>
        react {
            println <span class="local-variable">it</span>
        }
    }
}

<span class="keyword">def</span> me = Actors.actor {
    friend.send(<span class="string"><span class="delimiter">'</span><span class="content">Hi</span><span class="delimiter">'</span></span>)
    <span class="comment">//wait for answer 1sec</span>
    react(<span class="integer">1000</span>) {msg -&gt;
        <span class="keyword">if</span> (msg == Actor.TIMEOUT) {
            friend.send(<span class="string"><span class="delimiter">'</span><span class="content">I see, busy as usual. Never mind.</span><span class="delimiter">'</span></span>)
            stop()
        } <span class="keyword">else</span> {
            <span class="comment">//continue conversation</span>
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">Thank you for </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>
        }
    }
}

me.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>When a timeout expires when waiting for a message, the Actor.TIMEOUT message arrives instead. Also the
<em>onTimeout()</em> handler is invoked, if present on the actor:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> friend = Actors.actor {
    react {
        <span class="comment">//this doesn't reply -&gt; caller won't receive any answer in time</span>
        println <span class="local-variable">it</span>
        <span class="comment">//reply 'Hello' //uncomment this to answer conversation</span>
        react {
            println <span class="local-variable">it</span>
        }
    }
}

<span class="keyword">def</span> me = Actors.actor {
    friend.send(<span class="string"><span class="delimiter">'</span><span class="content">Hi</span><span class="delimiter">'</span></span>)

    delegate.metaClass.onTimeout = {-&gt;
        friend.send(<span class="string"><span class="delimiter">'</span><span class="content">I see, busy as usual. Never mind.</span><span class="delimiter">'</span></span>)
        stop()
    }

    <span class="comment">//wait for answer 1sec</span>
    react(<span class="integer">1000</span>) {msg -&gt;
        <span class="keyword">if</span> (msg != Actor.TIMEOUT) {
            <span class="comment">//continue conversation</span>
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">Thank you for </span><span class="inline"><span class="inline-delimiter">$</span>msg</span><span class="delimiter">&quot;</span></span>
        }
    }
}

me.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice the possibility to use Groovy meta-programming to define actor&#8217;s lifecycle notification methods
(e.g. <em>onTimeout()</em> ) dynamically.  Obviously, the lifecycle methods can be defined the usual way when you
decide to define a new class for your actor.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre><span class="type">class</span> <span class="class">MyActor</span> <span class="directive">extends</span> DefaultActor {
    <span class="directive">public</span> <span class="type">void</span> onTimeout() {
        ...
    }

    <span class="directive">protected</span> <span class="type">void</span> act() {
       ...
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_actors_guarantee_thread_safety_for_non_thread_safe_code">Actors guarantee thread-safety for non-thread-safe code</h3>
<div class="paragraph">
<p>Actors guarantee that always at most one thread processes the actor&#8217;s body at a time and also under the
covers the memory gets synchronized each time a thread gets assigned to an actor so the actor&#8217;s state <strong>can
be safely modified</strong> by code in the body <strong>without any other extra (synchronization or locking) effort</strong> .</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
</pre></td>
  <td class="code"><pre><span class="type">class</span> <span class="class">MyCounterActor</span> <span class="directive">extends</span> DefaultActor {
    <span class="directive">private</span> <span class="predefined-type">Integer</span> counter = <span class="integer">0</span>

    <span class="directive">protected</span> <span class="type">void</span> act() {
        loop {
            react {
                counter++
            }
        }
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Ideally actor&#8217;s code should <strong>never be invoked</strong> directly from outside so all the code of the actor class can
only be executed by the thread handling the last received message and so all the actor&#8217;s code is <strong>implicitly
thread-safe</strong> .  If any of the actor&#8217;s methods is allowed to be called by other objects directly, the
thread-safety guarantee for the actor&#8217;s code and state are <strong>no longer valid</strong> .</p>
</div>
</div>
<div class="sect2">
<h3 id="_simple_calculator">Simple calculator</h3>
<div class="paragraph">
<p>A little bit more realistic example of an event-driven actor that receives two numeric messages, sums them
up and sends the result to the console actor.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>

<span class="comment">//not necessary, just showing that a single-threaded pool can still handle multiple actors</span>
<span class="keyword">def</span> group = <span class="keyword">new</span> DefaultPGroup(<span class="integer">1</span>);

<span class="directive">final</span> <span class="keyword">def</span> console = group.actor {
    loop {
        react {
            println <span class="string"><span class="delimiter">'</span><span class="content">Result: </span><span class="delimiter">'</span></span> + <span class="local-variable">it</span>
        }
    }
}

<span class="directive">final</span> <span class="keyword">def</span> calculator = group.actor {
    react {a -&gt;
        react {b -&gt;
            console.send(a + b)
        }
    }
}

calculator.send <span class="integer">2</span>
calculator.send <span class="integer">3</span>

calculator.join()
group.shutdown()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that event-driven actors require special care regarding the <em>react()</em> method. Since <em>event_driven
actors</em> need to split the code into independent chunks assignable to different threads sequentially and
<strong>continuations</strong> are not natively supported on JVM, the chunks are created artificially. The <em>react()</em> method
creates the next message handler.  As soon as the current message handler finishes, the next message handler
(continuation) gets scheduled.</p>
</div>
<div class="sect3">
<h4 id="_concurrent_merge_sort_example">Concurrent Merge Sort Example</h4>
<div class="paragraph">
<p>For comparison I&#8217;m also including a more involved example performing a concurrent merge sort of a list of
integers using actors. You can see that thanks to flexibility of Groovy we came pretty close to the Scala
model, although I still miss Scala pattern matching for message handling.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
39
<strong>40</strong>
41
42
43
44
45
46
47
48
49
<strong>50</strong>
51
52
53
54
55
56
57
58
59
<strong>60</strong>
61
62
63
64
65
66
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">groovyx.gpars.actor.Actors.actor</span>

Closure createMessageHandler(<span class="keyword">def</span> parentActor) {
    <span class="keyword">return</span> {
        react {<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; message -&gt;
            <span class="keyword">assert</span> message != <span class="predefined-constant">null</span>
            <span class="keyword">switch</span> (message.size()) {
                <span class="keyword">case</span> <span class="integer">0</span>..<span class="integer">1</span>:
                    parentActor.send(message)
                    <span class="keyword">break</span>
                <span class="keyword">case</span> <span class="integer">2</span>:
                    <span class="keyword">if</span> (message[<span class="integer">0</span>] &lt;= message[<span class="integer">1</span>]) parentActor.send(message)
                    <span class="keyword">else</span> parentActor.send(message[-<span class="integer">1</span>..<span class="integer">0</span>])
                    <span class="keyword">break</span>
                <span class="keyword">default</span>:
                    <span class="keyword">def</span> splitList = split(message)

                    <span class="keyword">def</span> child1 = actor(createMessageHandler(delegate))
                    <span class="keyword">def</span> child2 = actor(createMessageHandler(delegate))
                    child1.send(splitList[<span class="integer">0</span>])
                    child2.send(splitList[<span class="integer">1</span>])

                    react {message1 -&gt;
                        react {message2 -&gt;
                            parentActor.send merge(message1, message2)
                        }
                    }
            }
        }
    }
}

<span class="keyword">def</span> console = <span class="keyword">new</span> DefaultPGroup(<span class="integer">1</span>).actor {
    react {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Sorted array:</span><span class="char">\t</span><span class="inline"><span class="inline-delimiter">${</span><span class="local-variable">it</span><span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
        <span class="predefined-type">System</span>.exit <span class="integer">0</span>
    }
}

<span class="keyword">def</span> sorter = actor(createMessageHandler(console))
sorter.send([<span class="integer">1</span>, <span class="integer">5</span>, <span class="integer">2</span>, <span class="integer">4</span>, <span class="integer">3</span>, <span class="integer">8</span>, <span class="integer">6</span>, <span class="integer">7</span>, <span class="integer">3</span>, <span class="integer">9</span>, <span class="integer">5</span>, <span class="integer">3</span>])
console.join()

<span class="keyword">def</span> <span class="function">split</span>(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; list) {
    <span class="type">int</span> listSize = list.size()
    <span class="type">int</span> middleIndex = listSize / <span class="integer">2</span>
    <span class="keyword">def</span> list1 = list[<span class="integer">0</span>..&lt;middleIndex]
    <span class="keyword">def</span> list2 = list[middleIndex..listSize - <span class="integer">1</span>]
    <span class="keyword">return</span> [list1, list2]
}

<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; merge(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; a, <span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; b) {
    <span class="type">int</span> i = <span class="integer">0</span>, j = <span class="integer">0</span>
    <span class="directive">final</span> <span class="type">int</span> newSize = a.size() + b.size()
    <span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; result = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Integer</span>&gt;(newSize)

    <span class="keyword">while</span> ((i &lt; a.size()) &amp;&amp; (j &lt; b.size())) {
        <span class="keyword">if</span> (a[i] &lt;= b[j]) result &lt;&lt; a[i++]
        <span class="keyword">else</span> result &lt;&lt; b[j++]
    }

    <span class="keyword">if</span> (i &lt; a.size()) result.addAll(a[i..-<span class="integer">1</span>])
    <span class="keyword">else</span> result.addAll(b[j..-<span class="integer">1</span>])
    <span class="keyword">return</span> result
}
</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since <em>actors</em> reuse threads from a pool, the script will work with virtually <strong>any size of a thread pool</strong>,
no matter how many actors are created along the way.</p>
</div>
</div>
<div class="sect3">
<h4 id="_actor_lifecycle_methods">Actor Lifecycle Methods</h4>
<div class="paragraph">
<p>Each Actor can define lifecycle observing methods, which will be called whenever a certain lifecycle event
occurs.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>afterStart() - called right after the actor has been started.</p>
</li>
<li>
<p>afterStop(List undeliveredMessages) - called right after the actor is stopped, passing in all the unprocessed messages from the queue.</p>
</li>
<li>
<p>onInterrupt(InterruptedException e) - called when the actor&#8217;s thread gets interrupted. Thread interruption will result in the stopping the actor in any case.</p>
</li>
<li>
<p>onTimeout() - called when no messages are sent to the actor within the timeout specified for the currently blocking react method.</p>
</li>
<li>
<p>onException(Throwable e) - called when an exception occurs in the actor&#8217;s event handler. Actor will stop after return from this method.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can either define the methods statically in your Actor class or add them dynamically to the actor&#8217;s metaclass:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
</pre></td>
  <td class="code"><pre><span class="type">class</span> <span class="class">MyActor</span> <span class="directive">extends</span> DefaultActor {
    <span class="directive">public</span> <span class="type">void</span> afterStart() {
        ...
    }
    <span class="directive">public</span> <span class="type">void</span> onTimeout() {
        ...
    }

    <span class="directive">protected</span> <span class="type">void</span> act() {
       ...
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Another Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> myActor = actor {
    delegate.metaClass.onException = {
        log.error(<span class="string"><span class="delimiter">'</span><span class="content">Exception occurred</span><span class="delimiter">'</span></span>, <span class="local-variable">it</span>)
    }

...
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Performance Tips</div>
<div class="paragraph">
<p>To help performance, you may consider using the <em>silentStart()</em> method instead of <em>start()</em> when starting a <em>DynamicDispatchActor</em> or a <em>ReactiveActor</em> .
Calling <em>silentStart()</em> will by-pass some of the start-up machinery and as a result will also avoid calling the <em>afterStart()</em> method.
Due to its stateful nature, <em>DefaultActor</em> cannot be started silently.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pool_management">Pool Management</h4>
<div class="paragraph">
<p><em>Actors</em> can be organized into groups and as a default there&#8217;s always an application-wide pooled actor group
available. And just like the <em>Actors</em> abstract factory can be used to create actors in the default group,
custom groups can be used as abstract factories to create new actors instances belonging to these groups.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> myGroup = <span class="keyword">new</span> DefaultPGroup()

<span class="keyword">def</span> actor1 = myGroup.actor {
...
}

<span class="keyword">def</span> actor2 = myGroup.actor {
...
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>parallelGroup</em> property of an actor points to the group it belongs to. It by default points to the
default actor group, which is <em>Actors.defaultActorPGroup</em> , and can only be changed before the actor is
started.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre><span class="type">class</span> <span class="class">MyActor</span> <span class="directive">extends</span> StaticDispatchActor&lt;<span class="predefined-type">Integer</span>&gt; {
    <span class="directive">private</span> <span class="directive">static</span> PGroup group = <span class="keyword">new</span> DefaultPGroup(<span class="integer">100</span>)

    MyActor(...) {
        <span class="local-variable">this</span>.parallelGroup = group
        ...
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The actors belonging to the same group share the <strong>underlying thread pool</strong> of that group. The pool by default
contains <strong>n + 1 threads</strong>, where <strong>n</strong> stands for the number of <strong>CPUs</strong> detected by the JVM. The <strong>pool size</strong> can
be set <strong>explicitly</strong> either by setting the <em>gpars.poolsize</em> system property or individually for each actor
group by specifying the appropriate constructor parameter.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> myGroup = <span class="keyword">new</span> DefaultPGroup(<span class="integer">10</span>)  <span class="comment">//the pool will contain 10 threads</span></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The thread pool can be manipulated through the appropriate <em>DefaultPGroup</em> class, which <strong>delegates</strong> to the
<em>Pool</em> interface of the thread pool. For example, the <em>resize()</em> method allows you to change the pool size
any time and the <em>resetDefaultSize()</em> sets it back to the default value. The <em>shutdown()</em> method can be
called when you need to safely finish all tasks, destroy the pool and stop all the threads in order to exit
JVM in an organized manner.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
</pre></td>
  <td class="code"><pre>... (n+<span class="integer">1</span> threads <span class="keyword">in</span> the <span class="keyword">default</span> pool after startup)

Actors.defaultActorPGroup.resize <span class="integer">1</span>  <span class="comment">//use one-thread pool</span>

... (<span class="integer">1</span> thread <span class="keyword">in</span> the pool)

Actors.defaultActorPGroup.resetDefaultSize()

... (n+<span class="integer">1</span> threads <span class="keyword">in</span> the pool)

Actors.defaultActorPGroup.shutdown()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>As an alternative to the <em>DefaultPGroup</em>, which creates a pool of daemon threads, the <em>NonDaemonPGroup</em>
class can be used when non-daemon threads are required.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> daemonGroup = <span class="keyword">new</span> DefaultPGroup()

<span class="keyword">def</span> actor1 = daemonGroup.actor {
...
}

<span class="keyword">def</span> nonDaemonGroup = <span class="keyword">new</span> NonDaemonPGroup()

<span class="keyword">def</span> actor2 = nonDaemonGroup.actor {
...
}

<span class="type">class</span> <span class="class">MyActor</span> {
    <span class="keyword">def</span> <span class="function">MyActor</span>() {
        <span class="local-variable">this</span>.parallelGroup = nonDaemonGroup
    }

    <span class="type">void</span> act() {...}
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Actors belonging to the same group share the <strong>underlying thread pool</strong>. With pooled actor groups you can
split your actors to leverage multiple thread pools of different sizes and so assign resources to different
components of your system and tune their performance.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> coreActors = <span class="keyword">new</span> NonDaemonPGroup(<span class="integer">5</span>)  <span class="comment">//5 non-daemon threads pool</span>
<span class="keyword">def</span> helperActors = <span class="keyword">new</span> DefaultPGroup(<span class="integer">1</span>)  <span class="comment">//1 daemon thread pool</span>

<span class="keyword">def</span> priceCalculator = coreActors.actor {
...
}

<span class="keyword">def</span> paymentProcessor = coreActors.actor {
...
}

<span class="keyword">def</span> emailNotifier = helperActors.actor {
...
}

<span class="keyword">def</span> cleanupActor = helperActors.actor {
...
}

<span class="comment">//increase size of the core actor group</span>
coreActors.resize <span class="integer">6</span>

<span class="comment">//shutdown the group's pool once you no longer need the group to release resources</span>
helperActors.shutdown()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Do not forget to shutdown custom pooled actor groups, once you no longer need them and their actors, to
preserve system resources.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_default_actor_group">The Default Actor Group</h4>
<div class="paragraph">
<p>Actors that didn&#8217;t have their parallelGroup property changed or that were created through any of the factory
methods on the <em>Actors</em> class share a common group <em>Actors.defaultActorPGroup</em> . This group uses a
<strong>resizeable thread pool</strong> with an upper limit of <strong>1000 threads</strong> .  This gives you the comfort of having the
pool automatically adjust to the demand of the actors. On the other hand, with a growing number of actors
the pool may become too big an inefficient.  It is advisable to group your actors into your own PGroups with
fixed size thread pools for all but trivial applications.</p>
</div>
</div>
<div class="sect3">
<h4 id="_common_trap_app_terminates_while_actors_do_not_receive_messages">Common Trap: App Terminates While Actors Do Not Receive Messages</h4>
<div class="paragraph">
<p>Most likely you&#8217;re using daemon threads and pools, which is the default setting, and your main thread
finishes. Calling <em>actor.join()</em> on any, some or all of your actors would block the main thread until the
actor terminates and thus keep all your actors running.  Alternatively use instances of <em>NonDaemonPGroup</em>
and assign some of your actors to these groups.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> nonDaemonGroup = <span class="keyword">new</span> NonDaemonPGroup()
<span class="keyword">def</span> myActor = nonDaemonGroup.actor {...}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>alternatively
.A Sample</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> nonDaemonGroup = <span class="keyword">new</span> NonDaemonPGroup()

<span class="type">class</span> <span class="class">MyActor</span> <span class="directive">extends</span> DefaultActor {
    <span class="keyword">def</span> <span class="function">MyActor</span>() {
        <span class="local-variable">this</span>.parallelGroup = nonDaemonGroup
    }

    <span class="type">void</span> act() {...}
}

<span class="keyword">def</span> myActor = <span class="keyword">new</span> MyActor()</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_blocking_actors">Blocking Actors</h4>
<div class="paragraph">
<p>Instead of event-driven continuation-styled actors, you may in some scenarios prefer using blocking actors.
Blocking actors hold a single pooled thread for their whole life-time including the time when waiting for
messages.  They avoid some of the thread management overhead, since they never fight for threads after
start, and also they let you write straight code without the necessity of continuation style, since they
only do blocking message reads via the <em>receive</em> method.  Obviously the number of blocking actors running
concurrently is limited by the number of threads available in the shared pool.  On the other hand, blocking
actors typically provide better performance compared to continuation-style actors, especially when the
actor&#8217;s message queue rarely gets empty.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> decryptor = blockingActor {
    <span class="keyword">while</span> (<span class="predefined-constant">true</span>) {
        receive {message -&gt;
            <span class="keyword">if</span> (message <span class="keyword">instanceof</span> <span class="predefined-type">String</span>) reply message.reverse()
            <span class="keyword">else</span> stop()
        }
    }
}

<span class="keyword">def</span> console = blockingActor {
    decryptor.send <span class="string"><span class="delimiter">'</span><span class="content">lellarap si yvoorG</span><span class="delimiter">'</span></span>
    println <span class="string"><span class="delimiter">'</span><span class="content">Decrypted message: </span><span class="delimiter">'</span></span> + receive()
    decryptor.send <span class="predefined-constant">false</span>
}

[decryptor, console]*.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Blocking actors increase the number of options to tune performance of your applications. They may in
particular be good candidates for high-traffic positions in your actor network.</p>
</div>
<hr>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_stateless_actors">Stateless Actors</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_dynamic_dispatch_actor">Dynamic Dispatch Actor</h3>
<div class="paragraph">
<p>The <em>DynamicDispatchActor</em> class is an actor allowing for an alternative structure of the message handling
code. In general <em>DynamicDispatchActor</em> repeatedly scans for messages and dispatches arrived messages to one
of the <em>onMessage(message)</em> methods defined on the actor. The <em>DynamicDispatchActor</em> leverages the Groovy
dynamic method dispatch mechanism under the covers.  Since, unlike <em>DefaultActor</em> descendants, a
<em>DynamicDispatchActor</em> not <em>ReactiveActor</em> (discussed below) do not need to implicitly remember actor&#8217;s
state between subsequent message receptions, they provide much better performance characteristics, generally
comparable to other actor frameworks, like e.g. Scala Actors.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.actor.Actors</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.actor.DynamicDispatchActor</span>

<span class="directive">final</span> <span class="type">class</span> <span class="class">MyActor</span> <span class="directive">extends</span> DynamicDispatchActor {

    <span class="type">void</span> onMessage(<span class="predefined-type">String</span> message) {
        println <span class="string"><span class="delimiter">'</span><span class="content">Received string</span><span class="delimiter">'</span></span>
    }

    <span class="type">void</span> onMessage(<span class="predefined-type">Integer</span> message) {
        println <span class="string"><span class="delimiter">'</span><span class="content">Received integer</span><span class="delimiter">'</span></span>
        reply <span class="string"><span class="delimiter">'</span><span class="content">Thanks!</span><span class="delimiter">'</span></span>
    }

    <span class="type">void</span> onMessage(<span class="predefined-type">Object</span> message) {
        println <span class="string"><span class="delimiter">'</span><span class="content">Received object</span><span class="delimiter">'</span></span>
        sender.send <span class="string"><span class="delimiter">'</span><span class="content">Thanks!</span><span class="delimiter">'</span></span>
    }

    <span class="type">void</span> onMessage(<span class="predefined-type">List</span> message) {
        println <span class="string"><span class="delimiter">'</span><span class="content">Received list</span><span class="delimiter">'</span></span>
        stop()
    }
}

<span class="directive">final</span> <span class="keyword">def</span> myActor = <span class="keyword">new</span> MyActor().start()

Actors.actor {
    myActor <span class="integer">1</span>
    myActor <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>
    myActor <span class="float">1.0</span>
    myActor(<span class="keyword">new</span> <span class="predefined-type">ArrayList</span>())
    myActor.join()
}.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>In some scenarios, typically when no implicit conversation-history-dependent state needs to be preserved for
the actor, the dynamic dispatch code structure may be more intuitive than the traditional one using nested
<em>loop</em> and <em>react</em> statements.</p>
</div>
<div class="paragraph">
<p>The <em>DynamicDispatchActor</em> class also provides a handy facility to add message handlers dynamically at actor
construction time or any time later using the <em>when</em> handlers, optionally wrapped inside a <em>become</em> method:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
</pre></td>
  <td class="code"><pre><span class="directive">final</span> Actor myActor = <span class="keyword">new</span> DynamicDispatchActor().become {
    when {<span class="predefined-type">String</span> msg -&gt; println <span class="string"><span class="delimiter">'</span><span class="content">A String</span><span class="delimiter">'</span></span>; reply <span class="string"><span class="delimiter">'</span><span class="content">Thanks</span><span class="delimiter">'</span></span>}
    when {<span class="predefined-type">Double</span> msg -&gt; println <span class="string"><span class="delimiter">'</span><span class="content">A Double</span><span class="delimiter">'</span></span>; reply <span class="string"><span class="delimiter">'</span><span class="content">Thanks</span><span class="delimiter">'</span></span>}
    when {msg -&gt; println <span class="string"><span class="delimiter">'</span><span class="content">A something ...</span><span class="delimiter">'</span></span>; reply <span class="string"><span class="delimiter">'</span><span class="content">What was that?</span><span class="delimiter">'</span></span>;stop()}
}
myActor.start()
Actors.actor {
    myActor <span class="string"><span class="delimiter">'</span><span class="content">Hello</span><span class="delimiter">'</span></span>
    myActor <span class="float">1.0d</span>
    myActor <span class="integer">10</span> <span class="keyword">as</span> <span class="predefined-type">BigDecimal</span>
    myActor.join()
}.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Obviously the two approaches can be combined:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
</pre></td>
  <td class="code"><pre><span class="directive">final</span> <span class="type">class</span> <span class="class">MyDDA</span> <span class="directive">extends</span> DynamicDispatchActor {

    <span class="type">void</span> onMessage(<span class="predefined-type">String</span> message) {
        println <span class="string"><span class="delimiter">'</span><span class="content">Received string</span><span class="delimiter">'</span></span>
    }

    <span class="type">void</span> onMessage(<span class="predefined-type">Integer</span> message) {
        println <span class="string"><span class="delimiter">'</span><span class="content">Received integer</span><span class="delimiter">'</span></span>
    }

    <span class="type">void</span> onMessage(<span class="predefined-type">Object</span> message) {
        println <span class="string"><span class="delimiter">'</span><span class="content">Received object</span><span class="delimiter">'</span></span>
    }

    <span class="type">void</span> onMessage(<span class="predefined-type">List</span> message) {
        println <span class="string"><span class="delimiter">'</span><span class="content">Received list</span><span class="delimiter">'</span></span>
        stop()
    }
}

<span class="directive">final</span> <span class="keyword">def</span> myActor = <span class="keyword">new</span> MyDDA().become {
    when {<span class="predefined-type">BigDecimal</span> num -&gt; println <span class="string"><span class="delimiter">'</span><span class="content">Received BigDecimal</span><span class="delimiter">'</span></span>}
    when {<span class="predefined-type">Float</span> num -&gt; println <span class="string"><span class="delimiter">'</span><span class="content">Got a float</span><span class="delimiter">'</span></span>}
}.start()

Actors.actor {
    myActor <span class="string"><span class="delimiter">'</span><span class="content">Hello</span><span class="delimiter">'</span></span>
    myActor <span class="float">1.0f</span>
    myActor <span class="integer">10</span> <span class="keyword">as</span> <span class="predefined-type">BigDecimal</span>
    myActor.send(<span class="type">[]</span>)
    myActor.join()
}.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The dynamic message handlers registered via <em>when</em> take precedence over the static <em>onMessage</em> handlers.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Fair or non-fair Behavior of DynamicDispatchActors</div>
<div class="paragraph">
<p><em>DynamicDispatchActor</em> can be set to behave in a fair on non-fair (default) manner. Depending on the
strategy chosen, the actor either makes the thread available to other actors sharing the same parallel group
(fair), or keeps the thread fot itself until the message queue gets empty (non-fair). Generally, non-fair
actors perform 2 - 3 times better than fair ones.</p>
</div>
<div class="paragraph">
<p>Use either the <em>fairMessageHandler()</em> factory method or the actor&#8217;s makeFair() method.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>    <span class="keyword">def</span> fairActor = Actors.fairMessageHandler {...}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_static_dispatch_actor">Static Dispatch Actor</h3>
<div class="paragraph">
<p>While <em>DynamicDispatchActor</em> dispatches messages based on their run-time type and so pays extra performance penalty for each message,
<em>StaticDispatchActor</em> avoids run-time message checks and dispatches the message solely based on the compile-time information.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
</pre></td>
  <td class="code"><pre><span class="directive">final</span> <span class="type">class</span> <span class="class">MyActor</span> <span class="directive">extends</span> StaticDispatchActor&lt;<span class="predefined-type">String</span>&gt; {
    <span class="type">void</span> onMessage(<span class="predefined-type">String</span> message) {
        println <span class="string"><span class="delimiter">'</span><span class="content">Received string </span><span class="delimiter">'</span></span> + message

        <span class="keyword">switch</span> (message) {
            <span class="keyword">case</span> <span class="string"><span class="delimiter">'</span><span class="content">hello</span><span class="delimiter">'</span></span>:
                reply <span class="string"><span class="delimiter">'</span><span class="content">Hi!</span><span class="delimiter">'</span></span>
                <span class="keyword">break</span>
            <span class="keyword">case</span> <span class="string"><span class="delimiter">'</span><span class="content">stop</span><span class="delimiter">'</span></span>:
                stop()
        }
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Instances of <em>StaticDispatchActor</em> have to override the <em>onMessage</em> method appropriate for the actor&#8217;s
declared type parameter.  The <em>onMessage(T message)</em> method is then invoked with every received message.</p>
</div>
<div class="paragraph">
<p>A shorter route towards both fair and non-fair static dispatch actors is available through the helper
factory methods:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
</pre></td>
  <td class="code"><pre><span class="directive">final</span> actor = staticMessageHandler {<span class="predefined-type">String</span> message -&gt;
    println <span class="string"><span class="delimiter">'</span><span class="content">Received string </span><span class="delimiter">'</span></span> + message

    <span class="keyword">switch</span> (message) {
        <span class="keyword">case</span> <span class="string"><span class="delimiter">'</span><span class="content">hello</span><span class="delimiter">'</span></span>:
            reply <span class="string"><span class="delimiter">'</span><span class="content">Hi!</span><span class="delimiter">'</span></span>
            <span class="keyword">break</span>
        <span class="keyword">case</span> <span class="string"><span class="delimiter">'</span><span class="content">stop</span><span class="delimiter">'</span></span>:
            stop()
    }
}

println <span class="string"><span class="delimiter">'</span><span class="content">Reply: </span><span class="delimiter">'</span></span> + actor.sendAndWait(<span class="string"><span class="delimiter">'</span><span class="content">hello</span><span class="delimiter">'</span></span>)
actor <span class="string"><span class="delimiter">'</span><span class="content">bye</span><span class="delimiter">'</span></span>
actor <span class="string"><span class="delimiter">'</span><span class="content">stop</span><span class="delimiter">'</span></span>
actor.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>When compared to the <em>DynamicDispatchActor</em>, the <em>StaticDispatchActor</em> class is limited to a single handler method.</p>
</div>
<div class="paragraph">
<p>This simplified creation without any <em>when</em> handlers, plus the considerable performance benefits,
should make <em>StaticDispatchActor</em> your default choice for straightforward message handlers, when
dispatching based on message run-time type is not necessary.</p>
</div>
<div class="paragraph">
<p>For example, <em>StaticDispatchActors</em> make dataflow operators four times faster than the <em>DynamicDispatchActor</em> .</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_reactive_actor">Reactive Actor</h3>
<div class="paragraph">
<p>The <em>ReactiveActor</em> class, constructed typically by calling <em>Actors.reactor()</em> or <em>DefaultPGroup.reactor()</em>,
allow for more event-driven like approach.</p>
</div>
<div class="paragraph">
<p>When a reactive actor receives a message, the supplied block of code, which makes up the reactive actor&#8217;s body, is run with the message as a parameter.
The result returned from the code is sent in reply.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
</pre></td>
  <td class="code"><pre><span class="directive">final</span> <span class="keyword">def</span> group = <span class="keyword">new</span> DefaultPGroup()

<span class="directive">final</span> <span class="keyword">def</span> doubler = group.reactor {
    <span class="integer">2</span> * <span class="local-variable">it</span>
}

group.actor {
    println <span class="string"><span class="delimiter">'</span><span class="content">Double of 10 = </span><span class="delimiter">'</span></span> + doubler.sendAndWait(<span class="integer">10</span>)
}

group.actor {
    println <span class="string"><span class="delimiter">'</span><span class="content">Double of 20 = </span><span class="delimiter">'</span></span> + doubler.sendAndWait(<span class="integer">20</span>)
}

group.actor {
    println <span class="string"><span class="delimiter">'</span><span class="content">Double of 30 = </span><span class="delimiter">'</span></span> + doubler.sendAndWait(<span class="integer">30</span>)
}

<span class="keyword">for</span>(i <span class="keyword">in</span> (<span class="integer">1</span>..<span class="integer">10</span>)) {
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Double of </span><span class="inline"><span class="inline-delimiter">$</span>i</span><span class="content"> = </span><span class="inline"><span class="inline-delimiter">${</span>doubler.sendAndWait(i)<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
}

doubler.stop()
doubler.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of an actor, which submits a batch of numbers to a <em>ReactiveActor</em> for processing and then
prints the results gradually as they arrive.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.actor.Actor</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.actor.Actors</span>

<span class="directive">final</span> <span class="keyword">def</span> doubler = Actors.reactor {
    <span class="integer">2</span> * <span class="local-variable">it</span>
}

Actor actor = Actors.actor {
    (<span class="integer">1</span>..<span class="integer">10</span>).each {doubler &lt;&lt; <span class="local-variable">it</span>}
    <span class="type">int</span> i = <span class="integer">0</span>
    loop {
        i += <span class="integer">1</span>
        <span class="keyword">if</span> (i &gt; <span class="integer">10</span>) stop()
        <span class="keyword">else</span> {
            react {message -&gt;
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">Double of </span><span class="inline"><span class="inline-delimiter">$</span>i</span><span class="content"> = </span><span class="inline"><span class="inline-delimiter">$</span>message</span><span class="delimiter">&quot;</span></span>
            }
        }
    }
}

actor.join()
doubler.stop()
doubler.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Essentially reactive actors provide a convenience shortcut for an actor that would wait for messages in a
loop, process them and send back the result. This is schematically how the reactive actor looks inside:</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
</pre></td>
  <td class="code"><pre><span class="directive">public</span> <span class="type">class</span> <span class="class">ReactiveActor</span> <span class="directive">extends</span> DefaultActor {
    Closure body

    <span class="type">void</span> act() {
        loop {
            react {message -&gt;
                reply body(message)
            }
        }
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Fair or Non-fair Behavior of ReactiveActors</div>
<div class="paragraph">
<p><em>ReactiveActor</em> can be set to behave in a fair or unfair (default) manner.</p>
</div>
<div class="paragraph">
<p>Depending on the strategy chosen, the actor either makes the thread available to other actors sharing the same parallel group (fair),
or keeps the thread for itself until the message queue is empty (non-fair). Generally, non-fair actors perform 2–3 times better than fair ones.</p>
</div>
<div class="paragraph">
<p>Use either the <em>fairReactor()</em> factory method or the actor&#8217;s makeFair() method.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre>    <span class="keyword">def</span> fairActor = Actors.fairReactor {...}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tips_and_tricks">Tips and Tricks</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_structuring_actor_s_code">Structuring Actor&#8217;s Code</h3>
<div class="paragraph">
<p>When extending the <em>DefaultActor</em> class, you can call any actor&#8217;s methods from within the <em>act()</em> method and
use the <em>react()</em> or <em>loop()</em> methods in them.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
</pre></td>
  <td class="code"><pre><span class="type">class</span> <span class="class">MyDemoActor</span> <span class="directive">extends</span> DefaultActor {

    <span class="directive">protected</span> <span class="type">void</span> act() {
        handleA()
    }

    <span class="directive">private</span> <span class="type">void</span> handleA() {
        react {a -&gt;
            handleB(a)
        }
    }

    <span class="directive">private</span> <span class="type">void</span> handleB(<span class="type">int</span> a) {
        react {b -&gt;
            println a + b
            reply a + b
        }
    }
}

<span class="directive">final</span> <span class="keyword">def</span> demoActor = <span class="keyword">new</span> MyDemoActor()
demoActor.start()

Actors.actor {
    demoActor <span class="integer">10</span>
    demoActor <span class="integer">20</span>
    react {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>
    }
}.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Bear in mind that the methods <em>handleA()</em> and <em>handleB()</em> in all our examples will only schedule the supplied message handlers to run as continuations of the current calculation in reaction to the next message arriving.</p>
</div>
<div class="paragraph">
<p>Alternatively, when using the <em>actor()</em> factory method, you can add event-handling code through the meta class as closures.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
</pre></td>
  <td class="code"><pre>Actor demoActor = Actors.actor {
    delegate.metaClass {
        handleA = {-&gt;
            react {a -&gt;
                 handleB(a)
            }
        }

        handleB = {a -&gt;
            react {b -&gt;
                println a + b
                reply a + b
            }
        }
    }

    handleA()
}

Actors.actor {
    demoActor <span class="integer">10</span>
    demoActor <span class="integer">20</span>
    react {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>
    }
}.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Closures, which have the actor set as their delegate can also be used to structure event-handling code.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
</pre></td>
  <td class="code"><pre>Closure handleB = {a -&gt;
    react {b -&gt;
        println a + b
        reply a + b
    }
}

Closure handleA = {-&gt;
    react {a -&gt;
        handleB(a)
    }
}

Actor demoActor = Actors.actor {
    handleA.delegate = delegate
    handleB.delegate = delegate

    handleA()
}

Actors.actor {
    demoActor <span class="integer">10</span>
    demoActor <span class="integer">20</span>
    react {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Result: </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>
    }
}.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_event_driven_loops">Event-Driven Loops</h3>
<div class="paragraph">
<p>When coding event-driven actors, please kepp in mind that calls to <em>react()</em> and <em>loop()</em> methods have slightly different semantics.</p>
</div>
<div class="paragraph">
<p>This becomes a bit of a challenge once you try to implement any types of loops in your actors.  On the other hand,
if you leverage the fact that <em>react()</em> only schedules a continuation and returns, you may call methods recursively without fear of stack overflow.
Look at the examples below which respectively use the three described techniques for structuring actor&#8217;s code.</p>
</div>
<div class="sect3">
<h4 id="_a_subclass_of_em_defaultactor_em">A Subclass Of <em>DefaultActor</em></h4>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
</pre></td>
  <td class="code"><pre><span class="type">class</span> <span class="class">MyLoopActor</span> <span class="directive">extends</span> DefaultActor {

    <span class="directive">protected</span> <span class="type">void</span> act() {
        outerLoop()
    }

    <span class="directive">private</span> <span class="type">void</span> outerLoop() {
        react {a -&gt;
            println <span class="string"><span class="delimiter">'</span><span class="content">Outer: </span><span class="delimiter">'</span></span> + a
            <span class="keyword">if</span> (a != <span class="integer">0</span>) innerLoop()
            <span class="keyword">else</span> println <span class="string"><span class="delimiter">'</span><span class="content">Done</span><span class="delimiter">'</span></span>
        }
    }

    <span class="directive">private</span> <span class="type">void</span> innerLoop() {
        react {b -&gt;
            println <span class="string"><span class="delimiter">'</span><span class="content">Inner </span><span class="delimiter">'</span></span> + b
            <span class="keyword">if</span> (b == <span class="integer">0</span>) outerLoop()
            <span class="keyword">else</span> innerLoop()
        }
    }
}

<span class="directive">final</span> <span class="keyword">def</span> actor = <span class="keyword">new</span> MyLoopActor().start()
actor <span class="integer">10</span>
actor <span class="integer">20</span>
actor <span class="integer">0</span>
actor <span class="integer">0</span>
actor.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_enhancing_the_actor_s_metaclass">Enhancing The Actor&#8217;s MetaClass</h3>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
</pre></td>
  <td class="code"><pre>Actor actor = Actors.actor {

  delegate.metaClass {
      outerLoop = {-&gt;
          react {a -&gt;
              println <span class="string"><span class="delimiter">'</span><span class="content">Outer: </span><span class="delimiter">'</span></span> + a
              <span class="keyword">if</span> (a!=<span class="integer">0</span>) innerLoop()
              <span class="keyword">else</span> println <span class="string"><span class="delimiter">'</span><span class="content">Done</span><span class="delimiter">'</span></span>
          }
      }

      innerLoop = {-&gt;
          react {b -&gt;
              println <span class="string"><span class="delimiter">'</span><span class="content">Inner </span><span class="delimiter">'</span></span> + b
              <span class="keyword">if</span> (b==<span class="integer">0</span>) outerLoop()
              <span class="keyword">else</span> innerLoop()
          }
      }
  }

  outerLoop()
}

actor <span class="integer">10</span>
actor <span class="integer">20</span>
actor <span class="integer">0</span>
actor <span class="integer">0</span>
actor.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_using_groovy_closures">Using Groovy Closures</h3>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
</pre></td>
  <td class="code"><pre>Closure innerLoop

Closure outerLoop = {-&gt;
    react {a -&gt;
        println <span class="string"><span class="delimiter">'</span><span class="content">Outer: </span><span class="delimiter">'</span></span> + a
        <span class="keyword">if</span> (a!=<span class="integer">0</span>) innerLoop()
        <span class="keyword">else</span> println <span class="string"><span class="delimiter">'</span><span class="content">Done</span><span class="delimiter">'</span></span>
    }
}

innerLoop = {-&gt;
    react {b -&gt;
        println <span class="string"><span class="delimiter">'</span><span class="content">Inner </span><span class="delimiter">'</span></span> + b
        <span class="keyword">if</span> (b==<span class="integer">0</span>) outerLoop()
        <span class="keyword">else</span> innerLoop()
    }
}

Actor actor = Actors.actor {
    outerLoop.delegate = delegate
    innerLoop.delegate = delegate

    outerLoop()
}

actor <span class="integer">10</span>
actor <span class="integer">20</span>
actor <span class="integer">0</span>
actor <span class="integer">0</span>
actor.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Plus don&#8217;t forget about the possibility to use the actor&#8217;s <em>loop()</em> method to create a loop that runs until the actor terminates.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
</pre></td>
  <td class="code"><pre><span class="type">class</span> <span class="class">MyLoopingActor</span> <span class="directive">extends</span> DefaultActor {

  <span class="directive">protected</span> <span class="type">void</span> act() {
      loop {
          outerLoop()
      }
  }

  <span class="directive">private</span> <span class="type">void</span> outerLoop() {
      react {a -&gt;
          println <span class="string"><span class="delimiter">'</span><span class="content">Outer: </span><span class="delimiter">'</span></span> + a
          <span class="keyword">if</span> (a!=<span class="integer">0</span>) innerLoop()
          <span class="keyword">else</span> println <span class="string"><span class="delimiter">'</span><span class="content">Done for now, but will loop again</span><span class="delimiter">'</span></span>
      }
  }

  <span class="directive">private</span> <span class="type">void</span> innerLoop() {
      react {b -&gt;
          println <span class="string"><span class="delimiter">'</span><span class="content">Inner </span><span class="delimiter">'</span></span> + b
          <span class="keyword">if</span> (b == <span class="integer">0</span>) outerLoop()
          <span class="keyword">else</span> innerLoop()
      }
  }
}

<span class="directive">final</span> <span class="keyword">def</span> actor = <span class="keyword">new</span> MyLoopingActor().start()
actor <span class="integer">10</span>
actor <span class="integer">20</span>
actor <span class="integer">0</span>
actor <span class="integer">0</span>
actor <span class="integer">10</span>
actor.stop()
actor.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_active_objects">Active Objects</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Active objects provide an OO facade on top of actors, allowing you to avoid dealing directly with the actor
machinery, having to match messages, wait for results and send replies.</p>
</div>
<div class="sect2">
<h3 id="_actors_with_a_friendly_facade">Actors with a friendly facade</h3>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.activeobject.ActiveObject</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.activeobject.ActiveMethod</span>

<span class="annotation">@ActiveObject</span>
<span class="type">class</span> <span class="class">Decryptor</span> {
    <span class="annotation">@ActiveMethod</span>
    <span class="keyword">def</span> <span class="function">decrypt</span>(<span class="predefined-type">String</span> encryptedText) {
        <span class="keyword">return</span> encryptedText.reverse()
    }

    <span class="annotation">@ActiveMethod</span>
    <span class="keyword">def</span> <span class="function">decrypt</span>(<span class="predefined-type">Integer</span> encryptedNumber) {
        <span class="keyword">return</span> -<span class="integer">1</span>*encryptedNumber + <span class="integer">142</span>
    }
}

<span class="directive">final</span> Decryptor decryptor = <span class="keyword">new</span> Decryptor()
<span class="keyword">def</span> part1 = decryptor.decrypt(<span class="string"><span class="delimiter">'</span><span class="content"> noitcA ni yvoorG</span><span class="delimiter">'</span></span>)
<span class="keyword">def</span> part2 = decryptor.decrypt(<span class="integer">140</span>)
<span class="keyword">def</span> part3 = decryptor.decrypt(<span class="string"><span class="delimiter">'</span><span class="content">noitide dn</span><span class="delimiter">'</span></span>)

print part1.get()
print part2.get()
println part3.get()</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>You mark active objects with the <em>@ActiveObject</em> annotation. This will ensure a hidden actor instance is
created for each instance of your class.  Now you can mark methods with the <em>@ActiveMethod</em> annotation
indicating that you want the method to be invoked asynchronously by the target object&#8217;s internal actor.  An
optional boolean <em>blocking</em> parameter to the <em>@ActiveMethod</em> annotation specifies, whether the caller should
block until a result is available or whether instead the caller should only receive a <em>promise</em> for a future
result in a form of a <em>DataflowVariable</em> and so the caller is not blocked waiting.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Blocking or Not ?</div>
<div class="paragraph">
<p>By default, all active methods are set to be <strong>non-blocking</strong> . However, methods that declare their return type explicitly,
must be configured as blocking, otherwise the compiler will report an error. Only <em>def</em>, <em>void</em> and <em>DataflowVariable</em> are permissible return types for non-blocking methods.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Under the covers, GPars will translate your method call to <strong>a message being sent to the internal
actor</strong> . The actor will eventually handle that message by invoking the desired method on behalf of the
caller and once finished a reply will be sent back to the caller.  Non-blocking methods return promises for
results, aka <em>DataflowVariables</em> .</p>
</div>
<div class="sect3">
<h4 id="_but_blocking_means_we_re_not_really_asynchronous_are_we">But Blocking Means We&#8217;re Not Really Asynchronous, Are We?</h4>
<div class="paragraph">
<p>Indeed, if you mark your active methods as <em>blocking</em> , the caller will be blocked waiting for the result,
just like when doing normal plain method invocation.  All we&#8217;ve achieved is being thread-safe inside the
Active object from concurrent access. Something the <em>synchronized</em> keyword could give you as well.  So it is
the <strong>non-blocking</strong> methods that should drive your decision towards using active objects. Blocking methods
will then provide the usual synchronous semantics yet give the consistency guarantees across concurrent
method invocations. The blocking methods are then still very useful when used in combination with
non-blocking ones.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.activeobject.ActiveMethod</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.activeobject.ActiveObject</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowVariable</span>

<span class="annotation">@ActiveObject</span>
<span class="type">class</span> <span class="class">Decryptor</span> {
    <span class="annotation">@ActiveMethod</span>(blocking=<span class="predefined-constant">true</span>)
    <span class="predefined-type">String</span> decrypt(<span class="predefined-type">String</span> encryptedText) {
        encryptedText.reverse()
    }

    <span class="annotation">@ActiveMethod</span>(blocking=<span class="predefined-constant">true</span>)
    <span class="predefined-type">Integer</span> decrypt(<span class="predefined-type">Integer</span> encryptedNumber) {
        -<span class="integer">1</span>*encryptedNumber + <span class="integer">142</span>
    }
}

<span class="directive">final</span> Decryptor decryptor = <span class="keyword">new</span> Decryptor()
print decryptor.decrypt(<span class="string"><span class="delimiter">'</span><span class="content"> noitcA ni yvoorG</span><span class="delimiter">'</span></span>)
print decryptor.decrypt(<span class="integer">140</span>)
println decryptor.decrypt(<span class="string"><span class="delimiter">'</span><span class="content">noitide dn</span><span class="delimiter">'</span></span>)</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_non_blocking_semantics">Non-Blocking Semantics</h4>
<div class="paragraph">
<p>Now calling the non-blocking active method will return as soon as the actor has been sent a message.  The
caller is now allowed to do whatever he likes, while the actor is taking care of the calculation.  The state
of the calculation can be polled using the <em>bound</em> property on the promise.  Calling the <em>get()</em> method on
the returned promise will block the caller until a value is available.  The call to <em>get()</em> will eventually
return a value or throw an exception, depending on the outcome of the actual calculation.</p>
</div>
<hr>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The <em>get()</em> method has a variant with a timeout parameter, to avoid the risk of waiting indefinitely.
</td>
</tr>
</table>
</div>
<hr>
<div class="sect4">
<h5 id="_annotation_rules">Annotation Rules</h5>
<div class="paragraph">
<p>There are a few rules to follow when annotating your objects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <em>ActiveMethod</em> annotations are only accepted in classes annotated as <em>ActiveObject</em></p>
</li>
<li>
<p>Only instance (non-static) methods can be annotated as <em>ActiveMethod</em></p>
</li>
<li>
<p>You can override active methods with non-active ones and vice versa</p>
</li>
<li>
<p>Subclasses of active objects can declare additional active methods, provided they are themselves annotated
as <em>ActiveObject</em></p>
</li>
<li>
<p>Combining concurrent use of active and non-active methods may result in race conditions. Ideally design
your active objects as completely encapsulated classes with all non-private methods marked as active</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_inheritance">Inheritance</h4>
<div class="paragraph">
<p>The <em>@ActiveObject</em> annotation can appear on any class in an inheritance hierarchy. The actor field will
only be created in top-most annotated class in the hierarchy, the subclasses will reuse the field.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.activeobject.ActiveObject</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.activeobject.ActiveMethod</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.dataflow.DataflowVariable</span>

<span class="annotation">@ActiveObject</span>
<span class="type">class</span> <span class="class">A</span> {
    <span class="annotation">@ActiveMethod</span>
    <span class="keyword">def</span> <span class="function">fooA</span>(value) {
        ...
    }
}

<span class="type">class</span> <span class="class">B</span> <span class="directive">extends</span> A {
}

<span class="annotation">@ActiveObject</span>
<span class="type">class</span> <span class="class">C</span> <span class="directive">extends</span> B {
    <span class="annotation">@ActiveMethod</span>
    <span class="keyword">def</span> <span class="function">fooC</span>(value1, value2) {
        ...
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>In our example the actor field will be generated into class <em>A</em> . Class <em>C</em> has to be annotated with
<em>@ActiveObject</em> since it holds the <em>@ActiveMethod</em> annotation on method <em>fooC()</em> , while class <em>B</em> does not
need the annotation, since none of its methods is active.</p>
</div>
</div>
<div class="sect3">
<h4 id="_groups">Groups</h4>
<div class="paragraph">
<p>Just like actors can be grouped around thread pools, active objects can be configured to use threads from
particular parallel groups.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="annotation">@ActiveObject</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">group1</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">MyActiveObject</span> {
    ...
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>value</em> parameter to the <em>@ActiveObject</em> annotation specifies a name of parallel group to bind the
internal actor to.  Only threads from the specified group will be used to run internal actors of instances
of the class.  The groups, however, need to be created and registered prior to creation of any of the active
object instances belonging to that group.  If not specified explicitly, an active object will use the
default actor group - <em>Actors.defaultActorPGroup</em> .</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="directive">final</span> DefaultPGroup group = <span class="keyword">new</span> DefaultPGroup(<span class="integer">10</span>)
ActiveObjectRegistry.instance.register(<span class="string"><span class="delimiter">&quot;</span><span class="content">group1</span><span class="delimiter">&quot;</span></span>, group)</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_alternative_names_for_the_internal_actor">Alternative Names For The Internal Actor</h4>
<div class="paragraph">
<p>You will probably only rarely run into name collisions with the default name for the active object&#8217;s
internal actor field.  May you need to change the default name <em>internalActiveObjectActor</em> , use the
<em>actorName</em> parameter to the <em>@ActiveObject</em> annotation.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre><span class="annotation">@ActiveObject</span>(actorName = <span class="string"><span class="delimiter">&quot;</span><span class="content">alternativeActorName</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">MyActiveObject</span> {
    ...
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Actor Naming Conventions</div>
<div class="paragraph">
<p>Alternative names for internal actors as well as their desired groups cannot be overriden in subclasses.</p>
</div>
<div class="paragraph">
<p>Make sure you only specify these values in the top-most active objects in your inheritance
hierarchy. Obviously, the top most active object is still allowed to subclass other classes, just none of
the predecessors must be an active object.</p>
</div>
</div>
</div>
<hr>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_classic_examples">Classic Examples</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_few_examples_of_actors_usage">A Few Examples of Actors usage</h3>
<div class="ulist">
<ul>
<li>
<p>The Sieve of Eratosthenes</p>
</li>
<li>
<p>Sleeping Barber</p>
</li>
<li>
<p>Dining Philosophers</p>
</li>
<li>
<p>Word Sort</p>
</li>
<li>
<p>Load Balancer</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_the_sieve_of_eratosthenes">The Sieve of Eratosthenes</h4>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Problem description</a></p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
39
<strong>40</strong>
41
42
43
44
45
46
47
48
49
<strong>50</strong>
51
52
53
54
55
56
57
58
59
<strong>60</strong>
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.actor.DynamicDispatchActor</span>

<span class="comment">/**
 * Demonstrates concurrent implementation of the Sieve of Eratosthenes using actors
 *
 * In principle, the algorithm consists of concurrently run chained filters,
 * each of which detects whether the current number can be divided by a single prime number.
 * (generate nums 1, 2, 3, 4, 5, ...) -&gt; (filter by mod 2) -&gt; (filter by mod 3) -&gt; (filter by mod 5) -&gt; (filter by mod 7) -&gt; (filter by mod 11) -&gt; (caution! Primes falling out here)
 * The chain is built (grows) on the fly, whenever a new prime is found.
 */</span>

<span class="type">int</span> requestedPrimeNumberBoundary = <span class="integer">1000</span>

<span class="directive">final</span> <span class="keyword">def</span> firstFilter = <span class="keyword">new</span> FilterActor(<span class="integer">2</span>).start()

<span class="comment">/**
 * Generating candidate numbers and sending them to the actor chain
 */</span>
(<span class="integer">2</span>..requestedPrimeNumberBoundary).each {
    firstFilter <span class="local-variable">it</span>
}
firstFilter.sendAndWait <span class="string"><span class="delimiter">'</span><span class="content">Poison</span><span class="delimiter">'</span></span>

<span class="comment">/**
 * Filter out numbers that can be divided by a single prime number
 */</span>
<span class="directive">final</span> <span class="type">class</span> <span class="class">FilterActor</span> <span class="directive">extends</span> DynamicDispatchActor {
    <span class="directive">private</span> <span class="directive">final</span> <span class="type">int</span> myPrime
    <span class="directive">private</span> <span class="keyword">def</span> follower

    <span class="keyword">def</span> <span class="function">FilterActor</span>(<span class="directive">final</span> myPrime) { <span class="local-variable">this</span>.myPrime = myPrime; }

    <span class="comment">/**
     * Try to divide the received number with the prime. If the number cannot be divided, send it along the chain.
     * If there's no-one to send it to, I'm the last in the chain, the number is a prime and so I will create and chain
     * a new actor responsible for filtering by this newly found prime number.
     */</span>
    <span class="keyword">def</span> <span class="function">onMessage</span>(<span class="type">int</span> value) {
        <span class="keyword">if</span> (value % myPrime != <span class="integer">0</span>) {
            <span class="keyword">if</span> (follower) follower value
            <span class="keyword">else</span> {
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">Found </span><span class="inline"><span class="inline-delimiter">$</span>value</span><span class="delimiter">&quot;</span></span>
                follower = <span class="keyword">new</span> FilterActor(value).start()
            }
        }
    }

    <span class="comment">/**
     * Stop the actor on poisson reception
     */</span>
    <span class="keyword">def</span> <span class="function">onMessage</span>(<span class="keyword">def</span> poisson) {
        <span class="keyword">if</span> (follower) {
            <span class="keyword">def</span> sender = sender
            follower.sendAndContinue(poisson, {<span class="local-variable">this</span>.stop(); sender?.send(<span class="string"><span class="delimiter">'</span><span class="content">Done</span><span class="delimiter">'</span></span>)})  <span class="comment">//Pass the poisson along and stop after a reply</span>
        } <span class="keyword">else</span> {  <span class="comment">//I am the last in the chain</span>
            stop()
            reply <span class="string"><span class="delimiter">'</span><span class="content">Done</span><span class="delimiter">'</span></span>
        }
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_sleeping_barber">Sleeping Barber</h4>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Sleeping_barber_problem">Problem description</a></p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
39
<strong>40</strong>
41
42
43
44
45
46
47
48
49
<strong>50</strong>
51
52
53
54
55
56
57
58
59
<strong>60</strong>
61
62
63
64
65
66
67
68
69
<strong>70</strong>
71
72
73
74
75
76
77
78
79
<strong>80</strong>
81
82
83
84
85
86
87
88
89
<strong>90</strong>
91
92
93
94
95
96
97
98
99
<strong>100</strong>
101
102
103
104
105
106
107
108
109
<strong>110</strong>
111
112
113
114
115
116
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.actor.DefaultActor</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.group.DefaultPGroup</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.actor.Actor</span>

<span class="directive">final</span> <span class="keyword">def</span> group = <span class="keyword">new</span> DefaultPGroup()

<span class="directive">final</span> <span class="keyword">def</span> barber = group.actor {
    <span class="directive">final</span> <span class="keyword">def</span> random = <span class="keyword">new</span> <span class="predefined-type">Random</span>()
    loop {
        react {message -&gt;
            <span class="keyword">switch</span> (message) {
                <span class="keyword">case</span> <span class="key">Enter</span>:
                    message.customer.send <span class="keyword">new</span> Start()
                    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Barber: Processing customer </span><span class="inline"><span class="inline-delimiter">${</span>message.customer.name<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
                    doTheWork(random)
                    message.customer.send <span class="keyword">new</span> Done()
                    reply <span class="keyword">new</span> Next()
                    <span class="keyword">break</span>
                <span class="keyword">case</span> <span class="key">Wait</span>:
                    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Barber: No customers. Going to have a sleep</span><span class="delimiter">&quot;</span></span>
                    <span class="keyword">break</span>
            }
        }
    }
}

<span class="directive">private</span> <span class="keyword">def</span> <span class="function">doTheWork</span>(<span class="predefined-type">Random</span> random) {
    <span class="predefined-type">Thread</span>.sleep(random.nextInt(<span class="integer">10</span>) * <span class="integer">1000</span>)
}

<span class="directive">final</span> Actor waitingRoom

waitingRoom = group.actor {
    <span class="directive">final</span> <span class="type">int</span> capacity = <span class="integer">5</span>
    <span class="directive">final</span> <span class="predefined-type">List</span>&lt;Customer&gt; waitingCustomers = <span class="type">[]</span>
    <span class="type">boolean</span> barberAsleep = <span class="predefined-constant">true</span>

    loop {
        react {message -&gt;
            <span class="keyword">switch</span> (message) {
                <span class="keyword">case</span> <span class="key">Enter</span>:
                    <span class="keyword">if</span> (waitingCustomers.size() == capacity) {
                        reply <span class="keyword">new</span> Full()
                    } <span class="keyword">else</span> {
                        waitingCustomers &lt;&lt; message.customer
                        <span class="keyword">if</span> (barberAsleep) {
                            <span class="keyword">assert</span> waitingCustomers.size() == <span class="integer">1</span>
                            barberAsleep = <span class="predefined-constant">false</span>
                            waitingRoom.send <span class="keyword">new</span> Next()
                        }
                        <span class="keyword">else</span> reply <span class="keyword">new</span> Wait()
                    }
                    <span class="keyword">break</span>
                <span class="keyword">case</span> <span class="key">Next</span>:
                    <span class="keyword">if</span> (waitingCustomers.size()&gt;<span class="integer">0</span>) {
                        <span class="keyword">def</span> customer = waitingCustomers.remove(<span class="integer">0</span>)
                        barber.send <span class="keyword">new</span> Enter(<span class="key">customer</span>:customer)
                    } <span class="keyword">else</span> {
                        barber.send <span class="keyword">new</span> Wait()
                        barberAsleep = <span class="predefined-constant">true</span>
                    }
            }
        }
    }

}

<span class="type">class</span> <span class="class">Customer</span> <span class="directive">extends</span> DefaultActor {
    <span class="predefined-type">String</span> name
    Actor localBarbers

    <span class="type">void</span> act() {
        localBarbers &lt;&lt; <span class="keyword">new</span> Enter(<span class="key">customer</span>:<span class="local-variable">this</span>)
        loop {
            react {message -&gt;
                <span class="keyword">switch</span> (message) {
                    <span class="keyword">case</span> <span class="key">Full</span>:
                        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Customer: </span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: The waiting room is full. I am leaving.</span><span class="delimiter">&quot;</span></span>
                        stop()
                        <span class="keyword">break</span>
                    <span class="keyword">case</span> <span class="key">Wait</span>:
                        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Customer: </span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: I will wait.</span><span class="delimiter">&quot;</span></span>
                        <span class="keyword">break</span>
                    <span class="keyword">case</span> <span class="key">Start</span>:
                        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Customer: </span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: I am now being served.</span><span class="delimiter">&quot;</span></span>
                        <span class="keyword">break</span>
                    <span class="keyword">case</span> <span class="key">Done</span>:
                        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Customer: </span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: I have been served.</span><span class="delimiter">&quot;</span></span>
                        stop();
                        <span class="keyword">break</span>

                }
            }
        }
    }
}

<span class="type">class</span> <span class="class">Enter</span> { Customer customer }
<span class="type">class</span> <span class="class">Full</span> {}
<span class="type">class</span> <span class="class">Wait</span> {}
<span class="type">class</span> <span class="class">Next</span> {}
<span class="type">class</span> <span class="class">Start</span> {}
<span class="type">class</span> <span class="class">Done</span> {}

<span class="keyword">def</span> customers = <span class="type">[]</span>
customers &lt;&lt; <span class="keyword">new</span> Customer(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Joe</span><span class="delimiter">'</span></span>, <span class="key">localBarbers</span>:waitingRoom).start()
customers &lt;&lt; <span class="keyword">new</span> Customer(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Dave</span><span class="delimiter">'</span></span>, <span class="key">localBarbers</span>:waitingRoom).start()
customers &lt;&lt; <span class="keyword">new</span> Customer(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Alice</span><span class="delimiter">'</span></span>, <span class="key">localBarbers</span>:waitingRoom).start()

sleep <span class="integer">15000</span>
customers &lt;&lt; <span class="keyword">new</span> Customer(<span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">James</span><span class="delimiter">'</span></span>, <span class="key">localBarbers</span>: waitingRoom).start()
sleep <span class="integer">5000</span>
customers*.join()
barber.stop()
waitingRoom.stop()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_dining_philosophers">Dining Philosophers</h4>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Dining_philosophers_problem">Problem description</a></p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
39
<strong>40</strong>
41
42
43
44
45
46
47
48
49
<strong>50</strong>
51
52
53
54
55
56
57
58
59
<strong>60</strong>
61
62
63
64
65
66
67
68
69
<strong>70</strong>
71
72
73
74
75
76
77
78
79
<strong>80</strong>
81
82
83
84
85
86
87
88
89
<strong>90</strong>
91
92
93
94
95
96
97
98
99
<strong>100</strong>
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.actor.DefaultActor</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.actor.Actors</span>

Actors.defaultActorPGroup.resize <span class="integer">5</span>

<span class="directive">final</span> <span class="type">class</span> <span class="class">Philosopher</span> <span class="directive">extends</span> DefaultActor {
    <span class="directive">private</span> <span class="predefined-type">Random</span> random = <span class="keyword">new</span> <span class="predefined-type">Random</span>()

    <span class="predefined-type">String</span> name
    <span class="keyword">def</span> forks = <span class="type">[]</span>

    <span class="type">void</span> act() {
        <span class="keyword">assert</span> <span class="integer">2</span> == forks.size()
        loop {
            think()
            forks*.send <span class="keyword">new</span> Take()
            <span class="keyword">def</span> messages = <span class="type">[]</span>
            react {a -&gt;
                messages &lt;&lt; [a, sender]
                react {b -&gt;
                    messages &lt;&lt; [b, sender]
                    <span class="keyword">if</span> ([a, b].any {Rejected.isCase <span class="local-variable">it</span>}) {
                        println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: </span><span class="char">\t</span><span class="content">Oops, can't get my forks! Giving up.</span><span class="delimiter">&quot;</span></span>
                        <span class="directive">final</span> <span class="keyword">def</span> accepted = messages.find {Accepted.isCase <span class="local-variable">it</span>[<span class="integer">0</span>]}
                        <span class="keyword">if</span> (accepted!=<span class="predefined-constant">null</span>) accepted[<span class="integer">1</span>].send <span class="keyword">new</span> Finished()
                    } <span class="keyword">else</span> {
                        eat()
                        reply <span class="keyword">new</span> Finished()
                    }
                }
            }
        }
    }

    <span class="type">void</span> think() {
        println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: </span><span class="char">\t</span><span class="content">I'm thinking</span><span class="delimiter">&quot;</span></span>
        <span class="predefined-type">Thread</span>.sleep random.nextInt(<span class="integer">5000</span>)
        println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: </span><span class="char">\t</span><span class="content">I'm done thinking</span><span class="delimiter">&quot;</span></span>
    }

    <span class="type">void</span> eat() {
        println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: </span><span class="char">\t</span><span class="content">I'm EATING</span><span class="delimiter">&quot;</span></span>
        <span class="predefined-type">Thread</span>.sleep random.nextInt(<span class="integer">2000</span>)
        println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="content">: </span><span class="char">\t</span><span class="content">I'm done EATING</span><span class="delimiter">&quot;</span></span>
    }
}

<span class="directive">final</span> <span class="type">class</span> <span class="class">Fork</span> <span class="directive">extends</span> DefaultActor {

    <span class="predefined-type">String</span> name
    <span class="type">boolean</span> available = <span class="predefined-constant">true</span>

    <span class="type">void</span> act() {
        loop {
            react {message -&gt;
                <span class="keyword">switch</span> (message) {
                    <span class="keyword">case</span> <span class="key">Take</span>:
                        <span class="keyword">if</span> (available) {
                            available = <span class="predefined-constant">false</span>
                            reply <span class="keyword">new</span> Accepted()
                        } <span class="keyword">else</span> reply <span class="keyword">new</span> Rejected()
                        <span class="keyword">break</span>
                    <span class="keyword">case</span> <span class="key">Finished</span>:
                        <span class="keyword">assert</span> !available
                        available = <span class="predefined-constant">true</span>
                        <span class="keyword">break</span>
                    <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Cannot process the message: </span><span class="inline"><span class="inline-delimiter">$</span>message</span><span class="delimiter">&quot;</span></span>)
                }
            }
        }
    }
}

<span class="directive">final</span> <span class="type">class</span> <span class="class">Take</span> {}
<span class="directive">final</span> <span class="type">class</span> <span class="class">Accepted</span> {}
<span class="directive">final</span> <span class="type">class</span> <span class="class">Rejected</span> {}
<span class="directive">final</span> <span class="type">class</span> <span class="class">Finished</span> {}

<span class="keyword">def</span> forks = [
        <span class="keyword">new</span> Fork(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Fork 1</span><span class="delimiter">'</span></span>),
        <span class="keyword">new</span> Fork(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Fork 2</span><span class="delimiter">'</span></span>),
        <span class="keyword">new</span> Fork(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Fork 3</span><span class="delimiter">'</span></span>),
        <span class="keyword">new</span> Fork(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Fork 4</span><span class="delimiter">'</span></span>),
        <span class="keyword">new</span> Fork(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Fork 5</span><span class="delimiter">'</span></span>)
]

<span class="keyword">def</span> philosophers = [
        <span class="keyword">new</span> Philosopher(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Joe</span><span class="delimiter">'</span></span>, <span class="key">forks</span>:[forks[<span class="integer">0</span>], forks[<span class="integer">1</span>]]),
        <span class="keyword">new</span> Philosopher(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Dave</span><span class="delimiter">'</span></span>, <span class="key">forks</span>:[forks[<span class="integer">1</span>], forks[<span class="integer">2</span>]]),
        <span class="keyword">new</span> Philosopher(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Alice</span><span class="delimiter">'</span></span>, <span class="key">forks</span>:[forks[<span class="integer">2</span>], forks[<span class="integer">3</span>]]),
        <span class="keyword">new</span> Philosopher(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">James</span><span class="delimiter">'</span></span>, <span class="key">forks</span>:[forks[<span class="integer">3</span>], forks[<span class="integer">4</span>]]),
        <span class="keyword">new</span> Philosopher(<span class="key">name</span>:<span class="string"><span class="delimiter">'</span><span class="content">Phil</span><span class="delimiter">'</span></span>, <span class="key">forks</span>:[forks[<span class="integer">4</span>], forks[<span class="integer">0</span>]]),
]

forks*.start()
philosophers*.start()

sleep <span class="integer">10000</span>
forks*.stop()
philosophers*.stop()</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_word_sort">Word Sort</h4>
<div class="paragraph">
<p>Given a folder name, the script will sort words in all files in the folder. The <em>SortMaster</em> actor creates a given number of <em>WordSortActors</em> ,
splits among them the files to sort words in and collects the results.</p>
</div>
<div class="paragraph">
<p><a href="http://fupeg.blogspot.com/2009/06/scala-concurrency.html">Inspired by Scala Concurrency blog post by Michael Galpin</a></p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
39
<strong>40</strong>
41
42
43
44
45
46
47
48
49
<strong>50</strong>
51
52
53
54
55
56
57
58
59
<strong>60</strong>
61
62
63
64
65
66
67
68
69
<strong>70</strong>
71
72
73
74
75
76
77
78
79
<strong>80</strong>
81
82
83
84
85
86
87
88
89
</pre></td>
  <td class="code"><pre><span class="comment">//Messages</span>
<span class="directive">private</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">FileToSort</span> { <span class="predefined-type">String</span> fileName }
<span class="directive">private</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">SortResult</span> { <span class="predefined-type">String</span> fileName; <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; words }

<span class="comment">//Worker actor</span>
<span class="type">class</span> <span class="class">WordSortActor</span> <span class="directive">extends</span> DefaultActor {

    <span class="directive">private</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; sortedWords(<span class="predefined-type">String</span> fileName) {
        parseFile(fileName).sort {<span class="local-variable">it</span>.toLowerCase()}
    }

    <span class="directive">private</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; parseFile(<span class="predefined-type">String</span> fileName) {
        <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; words = <span class="type">[]</span>
        <span class="keyword">new</span> <span class="predefined-type">File</span>(fileName).splitEachLine(<span class="string"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span>) {words.addAll(<span class="local-variable">it</span>)}
        <span class="keyword">return</span> words
    }

    <span class="type">void</span> act() {
        loop {
            react {message -&gt;
                <span class="keyword">switch</span> (message) {
                    <span class="keyword">case</span> <span class="key">FileToSort</span>:
                        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Sorting file=</span><span class="inline"><span class="inline-delimiter">${</span>message.fileName<span class="inline-delimiter">}</span></span><span class="content"> on thread </span><span class="inline"><span class="inline-delimiter">${</span><span class="predefined-type">Thread</span>.currentThread().name<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
                        reply <span class="keyword">new</span> SortResult(<span class="key">fileName</span>: message.fileName, <span class="key">words</span>: sortedWords(message.fileName))
                }
            }
        }
    }
}

<span class="comment">//Master actor</span>
<span class="directive">final</span> <span class="type">class</span> <span class="class">SortMaster</span> <span class="directive">extends</span> DefaultActor {

    <span class="predefined-type">String</span> docRoot = <span class="string"><span class="delimiter">'</span><span class="content">/</span><span class="delimiter">'</span></span>
    <span class="type">int</span> numActors = <span class="integer">1</span>

    <span class="predefined-type">List</span>&lt;<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt;&gt; sorted = <span class="type">[]</span>
    <span class="directive">private</span> <span class="predefined-type">CountDownLatch</span> startupLatch = <span class="keyword">new</span> <span class="predefined-type">CountDownLatch</span>(<span class="integer">1</span>)
    <span class="directive">private</span> <span class="predefined-type">CountDownLatch</span> doneLatch

    <span class="directive">private</span> <span class="type">void</span> beginSorting() {
        <span class="type">int</span> cnt = sendTasksToWorkers()
        doneLatch = <span class="keyword">new</span> <span class="predefined-type">CountDownLatch</span>(cnt)
    }

    <span class="directive">private</span> <span class="predefined-type">List</span> createWorkers() {
        <span class="keyword">return</span> (<span class="integer">1</span>..numActors).collect {<span class="keyword">new</span> WordSortActor().start()}
    }

    <span class="directive">private</span> <span class="type">int</span> sendTasksToWorkers() {
        <span class="predefined-type">List</span>&lt;Actor&gt; workers = createWorkers()
        <span class="type">int</span> cnt = <span class="integer">0</span>
        <span class="keyword">new</span> <span class="predefined-type">File</span>(docRoot).eachFile {
            workers[cnt % numActors] &lt;&lt; <span class="keyword">new</span> FileToSort(<span class="key">fileName</span>: <span class="local-variable">it</span>)
            cnt += <span class="integer">1</span>
        }
        <span class="keyword">return</span> cnt
    }

    <span class="directive">public</span> <span class="type">void</span> waitUntilDone() {
        startupLatch.await()
        doneLatch.await()
    }

    <span class="type">void</span> act() {
        beginSorting()
        startupLatch.countDown()
        loop {
            react {
                <span class="keyword">switch</span> (<span class="local-variable">it</span>) {
                    <span class="keyword">case</span> <span class="key">SortResult</span>:
                        sorted &lt;&lt; <span class="local-variable">it</span>.words
                        doneLatch.countDown()
                        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Received results for file=</span><span class="inline"><span class="inline-delimiter">${</span><span class="local-variable">it</span>.fileName<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
                }
            }
        }
    }
}

<span class="comment">//start the actors to sort words</span>
<span class="keyword">def</span> master = <span class="keyword">new</span> SortMaster(<span class="key">docRoot</span>: <span class="string"><span class="delimiter">'</span><span class="content">c:/tmp/Logs/</span><span class="delimiter">'</span></span>, <span class="key">numActors</span>: <span class="integer">5</span>).start()
master.waitUntilDone()
println <span class="string"><span class="delimiter">'</span><span class="content">Done</span><span class="delimiter">'</span></span>

<span class="predefined-type">File</span> file = <span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">c:/tmp/Logs/sorted_words.txt</span><span class="delimiter">&quot;</span></span>)
file.withPrintWriter { printer -&gt;
    master.sorted.each { printer.println <span class="local-variable">it</span> }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_load_balancer">Load Balancer</h4>
<div class="paragraph">
<p>Demonstrates work balancing among adaptable set of workers. The load balancer receives tasks and queues them
in a temporary task queue. When a worker finishes his assignment, it asks the load balancer for a new task.</p>
</div>
<div class="paragraph">
<p>If the load balancer doesn&#8217;t have any tasks available in the task queue, the worker is stopped.  If the
number of tasks in the task queue exceeds certain limit, a new worker is created to increase size of the
worker pool.</p>
</div>
<div class="listingblock">
<div class="title">A Sample</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
21
22
23
24
25
26
27
28
29
<strong>30</strong>
31
32
33
34
35
36
37
38
39
<strong>40</strong>
41
42
43
44
45
46
47
48
49
<strong>50</strong>
51
52
53
54
55
56
57
58
59
<strong>60</strong>
61
62
63
64
65
66
67
68
69
<strong>70</strong>
71
72
73
74
75
76
77
78
79
<strong>80</strong>
81
82
83
84
85
86
87
88
89
<strong>90</strong>
91
92
93
94
95
96
97
98
99
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">groovyx.gpars.actor.Actor</span>
<span class="keyword">import</span> <span class="include">groovyx.gpars.actor.DefaultActor</span>

<span class="comment">/**
 * Demonstrates work balancing among adaptable set of workers.
 * The load balancer receives tasks and queues them in a temporary task queue.
 * When a worker finishes his assignment, it asks the load balancer for a new task.
 * If the load balancer doesn't have any tasks available in the task queue, the worker is stopped.
 * If the number of tasks in the task queue exceeds certain limit, a new worker is created
 * to increase size of the worker pool.
 */</span>

<span class="directive">final</span> <span class="type">class</span> <span class="class">LoadBalancer</span> <span class="directive">extends</span> DefaultActor {
    <span class="type">int</span> workers = <span class="integer">0</span>
    <span class="predefined-type">List</span> taskQueue = <span class="type">[]</span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> QUEUE_SIZE_TRIGGER = <span class="integer">10</span>

    <span class="type">void</span> act() {
        loop {
            react { message -&gt;
                <span class="keyword">switch</span> (message) {
                    <span class="keyword">case</span> <span class="key">NeedMoreWork</span>:
                        <span class="keyword">if</span> (taskQueue.size() == <span class="integer">0</span>) {
                            println <span class="string"><span class="delimiter">'</span><span class="content">No more tasks in the task queue. Terminating the worker.</span><span class="delimiter">'</span></span>
                            reply DemoWorker.EXIT
                            workers -= <span class="integer">1</span>
                        } <span class="keyword">else</span> reply taskQueue.remove(<span class="integer">0</span>)
                        <span class="keyword">break</span>
                    <span class="keyword">case</span> <span class="key">WorkToDo</span>:
                        taskQueue &lt;&lt; message
                        <span class="keyword">if</span> ((workers == <span class="integer">0</span>) || (taskQueue.size() &gt;= QUEUE_SIZE_TRIGGER)) {
                            println <span class="string"><span class="delimiter">'</span><span class="content">Need more workers. Starting one.</span><span class="delimiter">'</span></span>
                            workers += <span class="integer">1</span>
                            <span class="keyword">new</span> DemoWorker(<span class="local-variable">this</span>).start()
                        }
                }
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">Active workers=</span><span class="inline"><span class="inline-delimiter">${</span>workers<span class="inline-delimiter">}</span></span><span class="char">\t</span><span class="content">Tasks in queue=</span><span class="inline"><span class="inline-delimiter">${</span>taskQueue.size()<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
            }
        }
    }
}

<span class="directive">final</span> <span class="type">class</span> <span class="class">DemoWorker</span> <span class="directive">extends</span> DefaultActor {
    <span class="directive">final</span> <span class="directive">static</span> <span class="predefined-type">Object</span> EXIT = <span class="keyword">new</span> <span class="predefined-type">Object</span>()
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">Random</span> random = <span class="keyword">new</span> <span class="predefined-type">Random</span>()

    Actor balancer

    <span class="keyword">def</span> <span class="function">DemoWorker</span>(balancer) {
        <span class="local-variable">this</span>.balancer = balancer
    }

    <span class="type">void</span> act() {
        loop {
            <span class="local-variable">this</span>.balancer &lt;&lt; <span class="keyword">new</span> NeedMoreWork()
            react {
                <span class="keyword">switch</span> (<span class="local-variable">it</span>) {
                    <span class="keyword">case</span> <span class="key">WorkToDo</span>:
                        processMessage(<span class="local-variable">it</span>)
                        <span class="keyword">break</span>
                    <span class="keyword">case</span> <span class="key">EXIT</span>: terminate()
                }
            }
        }

    }

    <span class="directive">private</span> <span class="type">void</span> processMessage(message) {
        <span class="directive">synchronized</span> (random) {
            <span class="predefined-type">Thread</span>.sleep random.nextInt(<span class="integer">5000</span>)
        }
    }
}
<span class="directive">final</span> <span class="type">class</span> <span class="class">WorkToDo</span> {}
<span class="directive">final</span> <span class="type">class</span> <span class="class">NeedMoreWork</span> {}

<span class="directive">final</span> Actor balancer = <span class="keyword">new</span> LoadBalancer().start()

<span class="comment">//produce tasks</span>
<span class="keyword">for</span> (i <span class="keyword">in</span> <span class="integer">1</span>..<span class="integer">20</span>) {
    <span class="predefined-type">Thread</span>.sleep <span class="integer">100</span>
    balancer &lt;&lt; <span class="keyword">new</span> WorkToDo()
}

<span class="comment">//produce tasks in a parallel thread</span>
<span class="predefined-type">Thread</span>.start {
    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="integer">1</span>..<span class="integer">10</span>) {
        <span class="predefined-type">Thread</span>.sleep <span class="integer">1000</span>
        balancer &lt;&lt; <span class="keyword">new</span> WorkToDo()
    }
}

<span class="predefined-type">Thread</span>.sleep <span class="integer">35000</span>  <span class="comment">//let the queues get empty</span>
balancer &lt;&lt; <span class="keyword">new</span> WorkToDo()
balancer &lt;&lt; <span class="keyword">new</span> WorkToDo()
<span class="predefined-type">Thread</span>.sleep <span class="integer">10000</span>

balancer.stop()
balancer.join()</pre></td>
</tr></table></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.0<br>
Last updated 2015-10-31 14:07:31 CET
</div>
</div>
</body>
</html>