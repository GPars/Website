<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
        <title>The GPars Framework 1.1.0</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <link rel="stylesheet" href="The%20GPars%20Framework%201.1.0_files/main.css" type="text/css" media="screen, print" title="Style" charset="utf-8">
        <link rel="stylesheet" href="The%20GPars%20Framework%201.1.0_files/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8">
    <script type="text/javascript">
function addJsClass(el) {
    var classes = document.body.className.split(" ");
    classes.push("js");
    document.body.className = classes.join(" ");
}
    </script>
    </head>

    <body class="body js" onload="addJsClass();">
        <div id="navigation">
            <ul>
                <li>
                    <div id="nav-summary" onmouseover="toggleNavSummary(false)" onmouseout="toggleNavSummary(true)">
                        <a href="http://gpars.org/1.1.0/guide/guide/index.html" class="button">Table of contents</a>
                        <div id="nav-summary-childs" style="display:none;">
                            
                            <div class="toc-item" style="margin-left:0"><a href="#introduction"><strong>1</strong><span>Introduction</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#gettingStarted"><strong>2</strong><span>Getting Started</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#dataParallelism"><strong>3</strong><span>Data Parallelism</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#GroovyCSP"><strong>4</strong><span>Groovy CSP</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#actors"><strong>5</strong><span>Actors</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#agents"><strong>6</strong><span>Agents</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#dataflow"><strong>7</strong><span>Dataflow</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#STM"><strong>8</strong><span>STM</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#GAE"><strong>9</strong><span>Google App Engine Integration</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#tips"><strong>10</strong><span>Tips</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#conclusion"><strong>11</strong><span>Conclusion</span></a></div>
                            
                        </div>
                    </div>
                </li>
                <li class="separator selected">
                    <a id="ref-button" onclick="localToggle(); return false;" href="#">Quick Reference</a>
                </li>
            </ul>
        </div>
        <div id="header">
            <div class="images clearfix">
                
                <span id="logo"><a href="http://gpars.codehaus.org/" target="_blank"><img alt="The GPars Framework" src="The%20GPars%20Framework%201.1.0_files/gpars-logo.png" border="0"></a></span>
                
                
            </div>
            <p>Groovy Parallel Systems</p>
        </div>


        <table id="colset" border="0" cellpadding="0" cellspacing="0">
            <tbody><tr>
                <td id="col1">
                    <div id="main" class="corner-all">

                        <span id="toggle-col1" class="toggle">(<a href="#" onclick="localToggle(); return false;">Quick Reference</a>)</span>

                        <div class="project">
                            <h1>The GPars Framework - Reference Documentation</h1>
                            <p><strong>Authors:</strong> The Whole GPars Gang</p>
                            <p><strong>Version:</strong> 1.1.0</p>
                            
                        </div>

                        
                        <div id="table-of-content">
                            <h2>Table of Contents</h2>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#introduction"><strong>1</strong><span>Introduction</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#introduction_enterGPars"><strong>1.1</strong><span>Enter GPars</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#introduction_credits"><strong>1.2</strong><span>Credits</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#gettingStarted"><strong>2</strong><span>Getting Started</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#gettingStarted_downloadingAndInstalling"><strong>2.1</strong><span>Downloading and Installing</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#gettingStarted_aHelloWorldExample"><strong>2.2</strong><span>A Hello World Example</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#gettingStarted_codeConventions"><strong>2.3</strong><span>Code conventions</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#gettingStarted_gettingSetUpInAnIDE"><strong>2.4</strong><span>Getting Set Up in an IDE</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#gettingStarted_applicabilityOfConcepts"><strong>2.5</strong><span>Applicability of Concepts</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#gettingStarted_what%27sNew"><strong>2.6</strong><span>What's New</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#gettingStarted_JavaAPI-usingGParsFromJava"><strong>2.7</strong><span>Java API - Using GPars from Java</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#dataParallelism"><strong>3</strong><span>Data Parallelism</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#dataParallelism_parallelCollections"><strong>3.1</strong><span>Parallel Collections</span></a></div>
                            
                            <div class="toc-item" style="margin-left:20px"><a href="#dataParallelism_parallelCollections_GParsPool"><strong>3.1.1</strong><span>GParsPool</span></a></div>
                            
                            <div class="toc-item" style="margin-left:20px"><a href="#dataParallelism_parallelCollections_GParsExecutorsPool"><strong>3.1.2</strong><span>GParsExecutorsPool</span></a></div>
                            
                            <div class="toc-item" style="margin-left:20px"><a href="#dataParallelism_parallelCollections_memoize"><strong>3.1.3</strong><span>Memoize</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#dataParallelism_map-reduce"><strong>3.2</strong><span>Map-Reduce</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#dataParallelism_parallelArrays"><strong>3.3</strong><span>Parallel Arrays</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#dataParallelism_asynchronousInvocation"><strong>3.4</strong><span>Asynchronous Invocation</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#dataParallelism_composableAsynchronousFunctions"><strong>3.5</strong><span>Composable Asynchronous Functions</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#dataParallelism_fork-join"><strong>3.6</strong><span>Fork-Join</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#dataParallelism_parallelSpeculations"><strong>3.7</strong><span>Parallel Speculations</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#GroovyCSP"><strong>4</strong><span>Groovy CSP</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#actors"><strong>5</strong><span>Actors</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#actors_actorsPrinciples"><strong>5.1</strong><span>Actors Principles</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#actors_statelessActors"><strong>5.2</strong><span>Stateless Actors</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#actors_tipsAndTricks"><strong>5.3</strong><span>Tips and Tricks</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#actors_activeObjects"><strong>5.4</strong><span>Active Objects</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#actors_classicExamples"><strong>5.5</strong><span>Classic Examples</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#agents"><strong>6</strong><span>Agents</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#dataflow"><strong>7</strong><span>Dataflow</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#dataflow_tasks"><strong>7.1</strong><span>Tasks</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#dataflow_selects"><strong>7.2</strong><span>Selects</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#dataflow_operators"><strong>7.3</strong><span>Operators</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#dataflow_operators_shutdown"><strong>7.4</strong><span>Shutting Down Dataflow Networks</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#dataflow_applications"><strong>7.5</strong><span>Application Frameworks</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#dataflow_pipelineDSL"><strong>7.6</strong><span>Pipeline DSL</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#dataflow_implementation"><strong>7.7</strong><span>Implementation</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#dataflow_synchronousVariablesAndChannels"><strong>7.8</strong><span>Synchronous Variables and Channels</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#dataflow_kanbanFlow"><strong>7.9</strong><span>Kanban Flow</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#dataflow_classicExamples"><strong>7.10</strong><span>Classic Examples</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#STM"><strong>8</strong><span>STM</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#GAE"><strong>9</strong><span>Google App Engine Integration</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#tips"><strong>10</strong><span>Tips</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#tips_performance"><strong>10.1</strong><span>Performance</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#tips_hostedEnvironment"><strong>10.2</strong><span>Integration into hosted environment</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#conclusion"><strong>11</strong><span>Conclusion</span></a></div>
                            
                            <div style="clear:both"></div>
                        </div>
                        
                        

<h1 id="introduction">1 Introduction</h1>
The world of mainstream computing is changing rapidly these days. If you open the hood and look under the
covers of your computer, you'll most likely see a dual-core processor there. Or a quad-core one, if you have
a high-end computer.  We all now run our software on multi-processor systems. The code we write today and
tomorrow will probably never run on a single processor system: parallel hardware has become standard.  Not
so with the software though, at least not yet. People still create single-threaded code, even though it will
not be able to leverage the full power of current and future hardware.  Some developers experiment with
low-level concurrency primitives, like threads, and locks or synchronized blocks.  However, it has become
obvious that the shared-memory multi-threading approach used at the application level causes more trouble
than it solves. Low-level concurrency handling is usually hard to get right, and it's not much fun either.
With such a radical change in hardware, software inevitably has to change dramatically too. Higher-level
concurrency and parallelism concepts like map/reduce, fork/join, actors and dataflow provide natural
abstractions for different types of problem domains while leveraging the multi-core hardware.



<h2 id="introduction_enterGPars">1.1 Enter GPars</h2>
Meet <a href="http://gpars.codehaus.org/" target="blank">GPars</a> - an open-source concurrency and parallelism library for Java and
Groovy that gives you a number of high-level abstractions for writing concurrent and parallel code in Groovy
(map/reduce, fork/join, asynchronous closures, actors, agents, dataflow concurrency and other concepts),
which can make your Java and Groovy code concurrent and/or parallel with little effort.  With GPars your
Java and/or Groovy code can easily utilize all the available processors on the target system. You can run
multiple calculations at the same time, request network resources in parallel, safely solve hierarchical
divide-and-conquer problems, perform functional style map/reduce or data parallel collection processing or
build your applications around the actor or dataflow model.<p class="paragraph">The project is open sourced under the <a href="http://gpars.codehaus.org/License" target="blank">Apache 2 License</a> . If you're
working on a commercial, open-source, educational or any other type of software project in Groovy, download
the binaries or integrate them from the Maven repository and get going. The way to writing highly concurrent
and/or parallel Java and Groovy code is wide open. Enjoy!



</p><h2 id="introduction_credits">1.2 Credits</h2>
This project could not have reached the point where it stands currently 
without all the great help and contribution of many individuals,
who have devoted their time, energy and expertise to make GPars a solid 
product. First, it is the people in the core team
who should be mentioned:
<ul class="star">
<li>Václav Pech</li>
<li>Dierk Koenig</li>
<li>Alex Tkachman</li>
<li>Russel Winder</li>
<li>Paul King</li>
<li>Jon Kerridge</li>
</ul><p class="paragraph">Over time, many people have contributed their ideas, provided useful feedback or helped GPars in one way or another.
There are many people in this group, too many to name them all, but let's list at least the most active:
</p><ul class="star">
<li>Hamlet d'Arcy</li>
<li>Hans Dockter</li>
<li>Guillaume Laforge</li>
<li>Robert Fischer</li>
<li>Johannes Link</li>
<li>Graeme Rocher</li>
<li>Alex Miller</li>
<li>Jeff Gortatowsky</li>
<li>Jiří Kropáček</li>
</ul><p class="paragraph">Many thanks to everyone!



</p><h1 id="gettingStarted">2 Getting Started</h1>
Let's set out a few assumptions before we get started:
<ol>
<li>You know and use Groovy and Java: otherwise you'd not be investing 
your valuable time studying a concurrency and parallelism library for 
Groovy and Java.</li>
<li>You definitely want to write your codes employing concurrency and parallelism using Groovy and Java.</li>
<li>If you are not using Groovy for your code, you are prepared to pay the inevitable verbosity tax of using Java.</li>
<li>You target multi-core hardware with your code.</li>
<li>You appreciate that in concurrent and parallel code things can 
happen at any time, in any order, and more likely with than one thing 
happening at once.</li>
</ol><p class="paragraph">With those assumptions in place, we get started.</p><p class="paragraph">It's becoming more and more obvious that dealing with concurrency and parallelism at the
thread/synchronized/lock level, as provided by the JVM, is far too low a level to be safe and comfortable.
Many high-level concepts, such as actors and dataflow have been around for quite some time: parallel
computers have been in use, at least in data centres if not on the desktop, long before multi-core chips hit
the hardware mainstream. Now then is the time to adopt these higher-level abstractions in the mainstream
software industry.  This is what <strong class="bold">GPars</strong> enables for the Groovy and Java languages, allowing Groovy and
Java programmers to use higher-level abstractions and therefore make developing concurrent and parallel
software easier and less error prone.</p><p class="paragraph">The concepts available in <strong class="bold">GPars</strong> can be categorized into three groups:
</p><ol>
<li> <em class="italic">Code-level helpers</em>  Constructs that can be 
applied to small parts of the code-base such as individual algorithms or
 data structures without any major changes in the overall project 
architecture</li>
<ol>
<li>Parallel Collections</li>
<li>Asynchronous Processing</li>
<li>Fork/Join (Divide/Conquer)</li>
</ol>
<li> <em class="italic">Architecture-level concepts</em>  Constructs that need to be taken into account when designing the project structure</li>
<ol>
<li>Actors</li>
<li>Communicating Sequential Processes (CSP)</li>
<li>Dataflow</li>
<li>Data Parallelism</li>
</ol>
<li> <em class="italic">Shared Mutable State Protection</em>  Although 
about 95% of current use of shared mutable state can be avoided using 
proper abstractions, good abstractions are still necessary for the 
remaining 5% use cases, when shared mutable state cannot be avoided</li>
<ol>
<li>Agents</li>
<li>Software Transactional Memory (not fully implemented in GPars as yet)</li>
</ol></ol><p class="paragraph">


</p><h2 id="gettingStarted_downloadingAndInstalling">2.1 Downloading and Installing</h2>
GPars is now distributed as standard with Groovy.  So if you have a Groovy installation, you should have
GPars already.  The exact version of GPars you have will, of course, depend of which version of Groovy.  If
you don't already have GPars, and you do have Groovy, then perhaps you should upgrade your Groovy!<p class="paragraph">If you do not have a Groovy installation, but get Groovy by using dependencies or just having the groovy-all
artifact, then you will need to get GPars.  Also if you want to use a version of GPars different from the
one with Groovy, or have an old GPars-less Groovy you cannot upgrade, you will need to get GPars.  The ways
of getting GPars are:
</p><ul class="star">
<li>Download the artifact from a repository and add it and all the transitive dependencies manually.</li>
<li>Specify a dependency in Gradle, Maven, or Ivy (or Gant, or Ant) build files.</li>
<li>Use Grapes (especially useful for Groovy scripts).</li>
</ul><p class="paragraph">If you're building a Grails or a Griffon application, you can use the appropriate plugins to fetch the jar
files for you.</p><p class="paragraph"></p><h3>The GPars Artifact</h3><p class="paragraph">As noted above GPars is now distributed as standard with Groovy.  If however, you have to manage this
dependency manually, the GPars artifact is in the main Maven repository and in the Codehaus main and
snapshots repositories.  The released versions are in the Maven and Codehaus main repositories,
the current development version (SNAPSHOT) is in the Codehaus snapshots repository.  To use from Gradle
or Grapes use the specification:
</p><div class="code"><pre><span class="java-quote">"org.codehaus.gpars:gpars:1.1.0"</span></pre></div>
for the release version, and:
<div class="code"><pre><span class="java-quote">"org.codehaus.gpars:gpars:1.2-SNAPSHOT"</span></pre></div>
for the development version.  You will likely need to add the Codehaus snapshots repository manually to the
search list in this latter case.  Using Maven the dependency is:
<div class="code"><pre>&lt;dependency&gt;
    &lt;groupId&gt;org.codehaus.gpars&lt;/groupId&gt;
    &lt;artifactId&gt;gpars&lt;/artifactId&gt;
    &lt;version&gt;1.1.0&lt;/version&gt;
&lt;/dependency&gt;</pre></div>
or version 1.2-SNAPSHOT if using the latest snapshot.<p class="paragraph"></p><h3>Transitive Dependencies</h3><p class="paragraph">GPars as a library depends on Groovy version equal or greater than 2.0. Also, the Fork/Join concurrency library namely <a href="http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166y.jar" target="blank">jsr166y</a>
(an artifact from the <a href="http://g.oswego.edu/dl/concurrency-interest/" target="blank">JSR-166 Project</a> ) must be on the
classpath the programs, which use GPars, to compile and execute.
Released versions of this artifact are in the main Maven and Codehaus repositories.  Development versions
of the artifact are available in the Codehaus snapshots repository.  Using Gradle or Grapes you would use
the following dependency specification:
</p><div class="code"><pre><span class="java-quote">"org.codehaus.jsr166-mirror:jsr166y:1.7.0"</span></pre></div>
For Maven, the specification would be:
<div class="code"><pre>&lt;dependency&gt;
    &lt;groupId&gt;org.codehaus.jsr166-mirror&lt;/groupId&gt;
    &lt;artifactId&gt;jsr166y&lt;/artifactId&gt;
    &lt;version&gt;1.7.0&lt;/version&gt;
&lt;/dependency&gt;</pre></div>
The development versions have version number 1.7.0.1-SNAPSHOT.<p class="paragraph">GPars defines this dependency in its own descriptor, so ideally all dependency management should be taken care of
automatically, if you use Gradle, Grails, Griffon, Maven, Ivy or other type of automatic dependency resolution tool.</p><p class="paragraph">Please visit the page <a href="http://gpars.codehaus.org/Integration" target="blank">Integration</a> on the GPars website for more details.



</p><h2 id="gettingStarted_aHelloWorldExample">2.2 A Hello World Example</h2>
Once you are setup, try the following Groovy script to test that your setup is functioning as it should.
<div class="code"><pre><span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.actor.Actors.actor<p class="paragraph">/**
 * A demo showing two cooperating actors. The decryptor decrypts received messages
 * and replies them back.  The console actor sends a message to decrypt, prints out
 * the reply and terminates both actors.  The main thread waits on both actors to
 * finish using the join() method to prevent premature exit, since both actors use
 * the <span class="java-keyword">default</span> actor group, which uses a daemon thread pool.
 * @author Dierk Koenig, Vaclav Pech
 */</p><p class="paragraph">def decryptor = actor {
    loop {
        react { message -&gt;
            <span class="java-keyword">if</span> (message <span class="java-keyword">instanceof</span> <span class="java-object">String</span>) reply message.reverse()
            <span class="java-keyword">else</span> stop()
        }
    }
}</p><p class="paragraph">def console = actor {
    decryptor.send 'lellarap si yvoorG'
    react {
        println 'Decrypted message: ' + it
        decryptor.send <span class="java-keyword">false</span>
    }
}</p><p class="paragraph">[decryptor, console]*.join()</p></pre></div>
You should get a message "Decrypted message: Groovy is parallel" printed out on the console when you run the code.<p class="paragraph"></p><blockquote class="note">
GPars has been designed primarily for use with the Groovy programming language.  Of course all Java and
Groovy programs are just bytecodes running on the JVM, so GPars can be used with Java source.  Despite being
aimed at Groovy code use, the solid technical foundation, plus the good performance characteristics, of GPars
make it an excellent library for Java programs. In fact most of GPars is written in Java, so there
is no performance penalty for Java applications using GPars.<p class="paragraph">For details please refer to the Java API section.
</p></blockquote><p class="paragraph">To quick-test using GPars via the Java API, you can compile and run the following Java code:
</p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.MessagingRunnable;
<span class="java-keyword">import</span> groovyx.gpars.actor.DynamicDispatchActor;<p class="paragraph"><span class="java-keyword">public</span> class StatelessActorDemo {
    <span class="java-keyword">public</span> <span class="java-keyword">static</span> void main(<span class="java-object">String</span>[] args) <span class="java-keyword">throws</span> InterruptedException {
        <span class="java-keyword">final</span> MyStatelessActor actor = <span class="java-keyword">new</span> MyStatelessActor();
        actor.start();
        actor.send(<span class="java-quote">"Hello"</span>);
        actor.sendAndWait(10);
        actor.sendAndContinue(10.0, <span class="java-keyword">new</span> MessagingRunnable&lt;<span class="java-object">String</span>&gt;() {
            @Override <span class="java-keyword">protected</span> void doRun(<span class="java-keyword">final</span> <span class="java-object">String</span> s) {
                <span class="java-object">System</span>.out.println(<span class="java-quote">"Received a reply "</span> + s);
            }
        });
    }
}</p><p class="paragraph">class MyStatelessActor <span class="java-keyword">extends</span> DynamicDispatchActor {
    <span class="java-keyword">public</span> void onMessage(<span class="java-keyword">final</span> <span class="java-object">String</span> msg) {
        <span class="java-object">System</span>.out.println(<span class="java-quote">"Received "</span> + msg);
        replyIfExists(<span class="java-quote">"Thank you"</span>);
    }</p><p class="paragraph">    <span class="java-keyword">public</span> void onMessage(<span class="java-keyword">final</span> <span class="java-object">Integer</span> msg) {
        <span class="java-object">System</span>.out.println(<span class="java-quote">"Received a number "</span> + msg);
        replyIfExists(<span class="java-quote">"Thank you"</span>);
    }</p><p class="paragraph">    <span class="java-keyword">public</span> void onMessage(<span class="java-keyword">final</span> <span class="java-object">Object</span> msg) {
        <span class="java-object">System</span>.out.println(<span class="java-quote">"Received an object "</span> + msg);
        replyIfExists(<span class="java-quote">"Thank you"</span>);
    }
}</p></pre></div>
Remember though that you will almost certainly have to add the Groovy artifact to the build as well as the
GPars artifact.  GPars may well work at Java speeds with Java applications, but it still has some
compilation dependencies on Groovy.



<h2 id="gettingStarted_codeConventions">2.3 Code conventions</h2>
We follow certain conventions in the code samples. Understanding these 
may help you read and comprehend GPars code samples better.
<ul class="star">
<li>The  <em class="italic">leftShift</em>  operator  <em class="italic">&lt;&lt;</em>  has been overloaded on actors, agents and dataflow expressions (both variables and streams) to mean  <em class="italic">send</em>  a message or  <em class="italic">assign</em>  a value.</li>
</ul><p class="paragraph"></p><div class="code"><pre>myActor &lt;&lt; 'message'<p class="paragraph">myAgent &lt;&lt; {account -&gt; account.add('5 USD')}</p><p class="paragraph">myDataflowVariable &lt;&lt; 120332</p></pre></div>
<ul class="star">
<li>On actors and agents the default  <em class="italic">call()</em>  method has been also overloaded to mean  <em class="italic">send</em>  . So sending a message to an actor or agent may look like a regular method call.</li>
</ul><p class="paragraph"></p><div class="code"><pre>myActor <span class="java-quote">"message"</span><p class="paragraph">myAgent {house -&gt; house.repair()}</p></pre></div>
<ul class="star">
<li>The  <em class="italic">rightShift</em>  operator  <em class="italic">&gt;&gt;</em>  in GPars has the  <em class="italic">when bound</em>  meaning. So</li>
</ul><p class="paragraph"> </p><div class="code"><pre>myDataflowVariable &gt;&gt; {value -&gt; doSomethingWith(value)}</pre></div>
 will schedule the closure to run only after  <em class="italic">myDataflowVariable</em>  is bound to a value, with the value as a parameter.<p class="paragraph">In samples we tend to statically import frequently used factory methods:
</p><ul class="star">
<li>GParsPool.withPool()</li>
<li>GParsPool.withExistingPool()</li>
<li>GParsExecutorsPool.withPool()</li>
<li>GParsExecutorsPool.withExistingPool()</li>
<li>Actors.actor()</li>
<li>Actors.reactor()</li>
<li>Actors.fairReactor()</li>
<li>Actors.messageHandler()</li>
<li>Actors.fairMessageHandler()</li>
<li>Agent.agent()</li>
<li>Agent.fairAgent()</li>
<li>Dataflow.task()</li>
<li>Dataflow.operator()</li>
</ul><p class="paragraph">It is more a matter of style preferences and 
personal taste, but we think static imports make the code more compact 
and readable.



</p><h2 id="gettingStarted_gettingSetUpInAnIDE">2.4 Getting Set Up in an IDE</h2>
Adding the GPars jar files to your project or defining the appropriate 
dependencies in pom.xml should be enough to get you started with GPars 
in your IDE.<p class="paragraph"></p><h3>GPars DSL recognition</h3><p class="paragraph"><strong class="bold">IntelliJ IDEA</strong> in both the free  <em class="italic">Community Edition</em>  and the commercial  <em class="italic">Ultimate Edition</em>  will recognize the GPars domain specific languages,
complete methods like  <em class="italic">eachParallel()</em>  ,  <em class="italic">reduce()</em>  or  <em class="italic">callAsync()</em>  and validate them. GPars uses the <a href="http://www.jetbrains.net/confluence/display/GRVY/Scripting+IDE+for+DSL+awareness" target="blank">GroovyDSL</a>
mechanism, which teaches IntelliJ IDEA the DSLs as soon as the GPars jar file is added to the project.


</p><h2 id="gettingStarted_applicabilityOfConcepts">2.5 Applicability of Concepts</h2>
GPars provides a lot of concepts to pick from. We're continuously 
building and updating a page that tries to help user choose the right 
abstraction for their tasks at hands.
Please, refer to the <a href="http://gpars.codehaus.org/Concepts+compared" target="blank">Concepts compared</a> page for details.<p class="paragraph">To briefly summarize the suggestions, below you can find the basic guide-lines:
</p><ol>
<li>You're looking at a collection, which needs to be <strong class="bold">iterated</strong> or processed using one of the many beautiful Groovy collections method, like  <em class="italic">each()</em>  ,  <em class="italic">collect()</em>  ,  <em class="italic">find()</em>  and such. Proposing that processing each element of the collection is independent of the other items, using GPars <strong class="bold">parallel collections</strong> can be recommended.</li>
<li>If you have a <strong class="bold">long-lasting calculation</strong> , which may safely run in the background, use the <strong class="bold">asynchronous invocation support</strong>
 in GPars. Since the GPars asynchronous functions can be composed, you 
can quickly parallelize complex functional calculations without having 
to mark independent calculations explicitly.</li>
<li>You need to <strong class="bold">parallelize</strong> an algorithm at hand. You can identify a set of <strong class="bold">tasks</strong>
 with their mutual dependencies. The tasks typically do not need to 
share data, but instead some tasks may need to wait for other tasks to 
finish before starting. You're ready to express these dependencies 
explicitly in code. With GPars <strong class="bold">dataflow tasks</strong>
 you create internally sequential tasks, each of which can run 
concurrently with the others. Dataflow variables and channels provide 
the tasks with the capability to express their dependencies and to 
exchange data safely.</li>
<li>You can't avoid using <strong class="bold">shared mutable state</strong>
 in your algorithm. Multiple threads will be accessing shared data and 
(some of them) modifying it. Traditional locking and synchronized 
approach feels too risky or unfamiliar. Go for <strong class="bold">agents</strong>, which will wrap your data and serialize all access to it.</li>
<li>You're building a system with high concurrency demands. Tweaking a 
data structure here or task there won't cut it. You need to build the 
architecture from the ground up with concurrency in mind. <strong class="bold">Message-passing</strong> might be the way to go.</li>
<ol>
<li><strong class="bold">Groovy CSP</strong> will give you highly deterministic and composable model for concurrent processes. The model is organized around the concept of <strong class="bold">calculations</strong> or <strong class="bold">processes</strong>, which run concurrently and communicate through synchronous channels.</li>
<li>If you're trying to solve a complex data-processing problem, consider GPars <strong class="bold">dataflow operators</strong>
 to build a data flow network. The concept is organized around 
event-driven transformations wired into pipelines using asynchronous 
channels.</li>
<li><strong class="bold">Actors</strong> and <strong class="bold">Active Objects</strong>
 will shine if you need to build a general-purpose, highly concurrent 
and scalable architecture following the object-oriented paradigm.</li>
</ol></ol><p class="paragraph"> Now you may have a better idea of what 
concepts to use on your current project. Go and check out more details 
on them in the User Guide.</p><p class="paragraph"></p><p class="paragraph">


</p><h2 id="gettingStarted_what'sNew">2.6 What's New</h2>
The new GPars 1.1.0 release introduces several enhancements and improvements on top of the previous release,
mainly in the dataflow area.<p class="paragraph">Check out the <a href="https://jira.codehaus.org/secure/ReleaseNote.jspa?projectId=12030&amp;version=17399" target="blank">JIRA release notes</a></p><p class="paragraph"></p><h3>Project changes</h3><p class="paragraph"></p><blockquote class="note">
See <a href="http://gpars.codehaus.org/Breaking+Changes" target="blank">the Breaking Changes listing</a> for the list of breaking changes.
</blockquote><p class="paragraph"></p><h3>Asynchronous functions</h3><p class="paragraph"></p><h3>Parallel collections</h3>
<ul class="star">
<li>Deprecated foldParallel, renamed to injectParallel</li>
</ul><p class="paragraph"></p><h3>Fork / Join</h3><p class="paragraph"></p><h3>Actors</h3><p class="paragraph"></p><h3>Dataflow</h3>
<ul class="star">
<li>LazyDataflowVariable added to allow for lazy asynchronous values</li>
<li>Timeout channels on Selects</li>
<li>Added a Promise-based API for value selection through the Select class</li>
<li>Enabled listening for bind errors on DataflowVariables</li>
<li>Minor API improvement affecting Promise and DataflowReadChannel</li>
</ul><p class="paragraph"></p><h3>Agent</h3>
<ul class="star">
<li>Protecting agent's blocking methods from being called from within commands</li>
</ul><p class="paragraph"></p><h3>Stm</h3>
<ul class="star">
<li>Updated to the latest 0.7.0 GA version of Multiverse</li>
</ul><p class="paragraph"></p><h3>Other</h3>
<ul class="star">
<li>Migrated to Groovy 2.0</li>
<li>Used @CompileStatic where appropriate</li>
</ul><p class="paragraph"></p><h3>Renaming hints</h3><p class="paragraph">


</p><h2 id="gettingStarted_JavaAPI-usingGParsFromJava">2.7 Java API - Using GPars from Java</h2>
Using GPars is very addictive, I guarantee. Once you get hooked you won't be able to code without it.
May the world force you to write code in Java, you will still be able to benefit from most of GPars features.<p class="paragraph"></p><h3>Java API specifics</h3><p class="paragraph">Some parts of GPars are irrelevant in Java and it is better to use the underlying Java libraries directly:
</p><ul class="star">
<li>Parallel Collection - use jsr-166y library's Parallel Array directly</li>
<li>Fork/Join - use jsr-166y library's Fork/Join support directly</li>
<li>Asynchronous functions - use Java executor services directly</li>
</ul><p class="paragraph">The other parts of GPars can be used from Java just like from Groovy, although most will miss the Groovy DSL capabilities.</p><p class="paragraph"></p><h3>GPars Closures in Java API</h3><p class="paragraph">To overcome the lack of closures as a language element in Java and to avoid forcing users to use Groovy closures directly
through the Java API, a few handy wrapper classes have been provided to help you define callbacks, actor body or dataflow tasks.
</p><ul class="star">
<li>groovyx.gpars.MessagingRunnable - used for single-argument callbacks or actor body</li>
<li>groovyx.gpars.ReactorMessagingRunnable - used for ReactiveActor body</li>
<li>groovyx.gpars.DataflowMessagingRunnable - used for dataflow operators' body</li>
</ul><p class="paragraph">These classes can be used in all places GPars API expects a Groovy closure.</p><p class="paragraph"></p><h3>Actors</h3><p class="paragraph">The  <em class="italic">DynamicDispatchActor</em>  as well as the  <em class="italic">ReactiveActor</em>  classes can be used just like in Groovy:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.MessagingRunnable;
 <span class="java-keyword">import</span> groovyx.gpars.actor.DynamicDispatchActor;<p class="paragraph"> <span class="java-keyword">public</span> class StatelessActorDemo {
     <span class="java-keyword">public</span> <span class="java-keyword">static</span> void main(<span class="java-object">String</span>[] args) <span class="java-keyword">throws</span> InterruptedException {
         <span class="java-keyword">final</span> MyStatelessActor actor = <span class="java-keyword">new</span> MyStatelessActor();
         actor.start();
         actor.send(<span class="java-quote">"Hello"</span>);
         actor.sendAndWait(10);
         actor.sendAndContinue(10.0, <span class="java-keyword">new</span> MessagingRunnable&lt;<span class="java-object">String</span>&gt;() {
             @Override <span class="java-keyword">protected</span> void doRun(<span class="java-keyword">final</span> <span class="java-object">String</span> s) {
                 <span class="java-object">System</span>.out.println(<span class="java-quote">"Received a reply "</span> + s);
             }
         });
     }
 }</p><p class="paragraph"> class MyStatelessActor <span class="java-keyword">extends</span> DynamicDispatchActor {
     <span class="java-keyword">public</span> void onMessage(<span class="java-keyword">final</span> <span class="java-object">String</span> msg) {
         <span class="java-object">System</span>.out.println(<span class="java-quote">"Received "</span> + msg);
         replyIfExists(<span class="java-quote">"Thank you"</span>);
     }</p><p class="paragraph">     <span class="java-keyword">public</span> void onMessage(<span class="java-keyword">final</span> <span class="java-object">Integer</span> msg) {
         <span class="java-object">System</span>.out.println(<span class="java-quote">"Received a number "</span> + msg);
         replyIfExists(<span class="java-quote">"Thank you"</span>);
     }</p><p class="paragraph">     <span class="java-keyword">public</span> void onMessage(<span class="java-keyword">final</span> <span class="java-object">Object</span> msg) {
         <span class="java-object">System</span>.out.println(<span class="java-quote">"Received an object "</span> + msg);
         replyIfExists(<span class="java-quote">"Thank you"</span>);
     }
 }</p></pre></div><p class="paragraph">Although there are not many 
differences between Groovy and Java GPars use, notice, the callbacks 
instantiating the MessagingRunnable class in place for a groovy closure.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovy.lang.Closure;
<span class="java-keyword">import</span> groovyx.gpars.ReactorMessagingRunnable;
<span class="java-keyword">import</span> groovyx.gpars.actor.Actor;
<span class="java-keyword">import</span> groovyx.gpars.actor.ReactiveActor;<p class="paragraph"><span class="java-keyword">public</span> class ReactorDemo {
    <span class="java-keyword">public</span> <span class="java-keyword">static</span> void main(<span class="java-keyword">final</span> <span class="java-object">String</span>[] args) <span class="java-keyword">throws</span> InterruptedException {
        <span class="java-keyword">final</span> Closure handler = <span class="java-keyword">new</span> ReactorMessagingRunnable&lt;<span class="java-object">Integer</span>, <span class="java-object">Integer</span>&gt;() {
            @Override <span class="java-keyword">protected</span> <span class="java-object">Integer</span> doRun(<span class="java-keyword">final</span> <span class="java-object">Integer</span> integer) {
                <span class="java-keyword">return</span> integer * 2;
            }
        };
        <span class="java-keyword">final</span> Actor actor = <span class="java-keyword">new</span> ReactiveActor(handler);
        actor.start();</p><p class="paragraph">        <span class="java-object">System</span>.out.println(<span class="java-quote">"Result: "</span> +  actor.sendAndWait(1));
        <span class="java-object">System</span>.out.println(<span class="java-quote">"Result: "</span> +  actor.sendAndWait(2));
        <span class="java-object">System</span>.out.println(<span class="java-quote">"Result: "</span> +  actor.sendAndWait(3));
    }
}</p></pre></div><p class="paragraph"></p><h3>Convenience factory methods</h3><p class="paragraph">Obviously, all the essential factory methods to build actors quickly are available where you'd expect them.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovy.lang.Closure;
<span class="java-keyword">import</span> groovyx.gpars.ReactorMessagingRunnable;
<span class="java-keyword">import</span> groovyx.gpars.actor.Actor;
<span class="java-keyword">import</span> groovyx.gpars.actor.Actors;<p class="paragraph"><span class="java-keyword">public</span> class ReactorDemo {
    <span class="java-keyword">public</span> <span class="java-keyword">static</span> void main(<span class="java-keyword">final</span> <span class="java-object">String</span>[] args) <span class="java-keyword">throws</span> InterruptedException {
        <span class="java-keyword">final</span> Closure handler = <span class="java-keyword">new</span> ReactorMessagingRunnable&lt;<span class="java-object">Integer</span>, <span class="java-object">Integer</span>&gt;() {
            @Override <span class="java-keyword">protected</span> <span class="java-object">Integer</span> doRun(<span class="java-keyword">final</span> <span class="java-object">Integer</span> integer) {
                <span class="java-keyword">return</span> integer * 2;
            }
        };
        <span class="java-keyword">final</span> Actor actor = Actors.reactor(handler);</p><p class="paragraph">        <span class="java-object">System</span>.out.println(<span class="java-quote">"Result: "</span> +  actor.sendAndWait(1));
        <span class="java-object">System</span>.out.println(<span class="java-quote">"Result: "</span> +  actor.sendAndWait(2));
        <span class="java-object">System</span>.out.println(<span class="java-quote">"Result: "</span> +  actor.sendAndWait(3));
    }
}</p></pre></div><p class="paragraph"></p><h3>Agents</h3><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.MessagingRunnable;
 <span class="java-keyword">import</span> groovyx.gpars.agent.Agent;<p class="paragraph"> <span class="java-keyword">public</span> class AgentDemo {
     <span class="java-keyword">public</span> <span class="java-keyword">static</span> void main(<span class="java-keyword">final</span> <span class="java-object">String</span>[] args) <span class="java-keyword">throws</span> InterruptedException {
         <span class="java-keyword">final</span> Agent counter = <span class="java-keyword">new</span> Agent&lt;<span class="java-object">Integer</span>&gt;(0);
         counter.send(10);
         <span class="java-object">System</span>.out.println(<span class="java-quote">"Current value: "</span> + counter.getVal());
         counter.send(<span class="java-keyword">new</span> MessagingRunnable&lt;<span class="java-object">Integer</span>&gt;() {
             @Override <span class="java-keyword">protected</span> void doRun(<span class="java-keyword">final</span> <span class="java-object">Integer</span> integer) {
                 counter.updateValue(integer + 1);
             }
         });
         <span class="java-object">System</span>.out.println(<span class="java-quote">"Current value: "</span> + counter.getVal());
     }
 }</p></pre></div><p class="paragraph"></p><h3>Dataflow Concurrency</h3><p class="paragraph">Both  <em class="italic">DataflowVariables</em>  and  <em class="italic">DataflowQueues</em>  can be used from Java without any hiccups. Just avoid the handy overloaded operators
and go straight to the methods, like  <em class="italic">bind</em>  ,  <em class="italic">whenBound</em> ,  <em class="italic">getVal</em>  and other.
You may also continue using dataflow  <em class="italic">tasks</em>  passing to them instances of  <em class="italic">Runnable</em>  or  <em class="italic">Callable</em>  just like groovy  <em class="italic">Closure</em>  .</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.MessagingRunnable;
<span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowVariable;
<span class="java-keyword">import</span> groovyx.gpars.group.DefaultPGroup;<p class="paragraph"><span class="java-keyword">import</span> java.util.concurrent.Callable;</p><p class="paragraph"><span class="java-keyword">public</span> class DataflowTaskDemo {
    <span class="java-keyword">public</span> <span class="java-keyword">static</span> void main(<span class="java-keyword">final</span> <span class="java-object">String</span>[] args) <span class="java-keyword">throws</span> InterruptedException {
        <span class="java-keyword">final</span> DefaultPGroup group = <span class="java-keyword">new</span> DefaultPGroup(10);</p><p class="paragraph">        <span class="java-keyword">final</span> DataflowVariable a = <span class="java-keyword">new</span> DataflowVariable();</p><p class="paragraph">        group.task(<span class="java-keyword">new</span> <span class="java-object">Runnable</span>() {
            <span class="java-keyword">public</span> void run() {
                a.bind(10);
            }
        });</p><p class="paragraph">        <span class="java-keyword">final</span> Promise result = group.task(<span class="java-keyword">new</span> Callable() {
            <span class="java-keyword">public</span> <span class="java-object">Object</span> call() <span class="java-keyword">throws</span> Exception {
                <span class="java-keyword">return</span> (<span class="java-object">Integer</span>)a.getVal() + 10;
            }
        });</p><p class="paragraph">        result.whenBound(<span class="java-keyword">new</span> MessagingRunnable&lt;<span class="java-object">Integer</span>&gt;() {
            @Override <span class="java-keyword">protected</span> void doRun(<span class="java-keyword">final</span> <span class="java-object">Integer</span> integer) {
                <span class="java-object">System</span>.out.println(<span class="java-quote">"arguments = "</span> + integer);
            }
        });</p><p class="paragraph">        <span class="java-object">System</span>.out.println(<span class="java-quote">"result = "</span> + result.getVal());
    }
}</p></pre></div><p class="paragraph"></p><h3>Dataflow operators</h3><p class="paragraph">The sample below should illustrate the main differences between Groovy and Java API for dataflow operators.
</p><ol>
<li>Use the convenience factory methods accepting list of channels to create operators or selectors</li>
<li>Use  <em class="italic">DataflowMessagingRunnable</em>  to specify the operator body</li>
<li>Call  <em class="italic">getOwningProcessor()</em>  to get hold of the operator from within the body in order to e.g. bind output values</li>
</ol><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.DataflowMessagingRunnable;
<span class="java-keyword">import</span> groovyx.gpars.dataflow.Dataflow;
<span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowQueue;
<span class="java-keyword">import</span> groovyx.gpars.dataflow.<span class="java-keyword">operator</span>.DataflowProcessor;<p class="paragraph"><span class="java-keyword">import</span> java.util.Arrays;
<span class="java-keyword">import</span> java.util.List;</p><p class="paragraph"><span class="java-keyword">public</span> class DataflowOperatorDemo {
    <span class="java-keyword">public</span> <span class="java-keyword">static</span> void main(<span class="java-keyword">final</span> <span class="java-object">String</span>[] args) <span class="java-keyword">throws</span> InterruptedException {
        <span class="java-keyword">final</span> DataflowQueue stream1 = <span class="java-keyword">new</span> DataflowQueue();
        <span class="java-keyword">final</span> DataflowQueue stream2 = <span class="java-keyword">new</span> DataflowQueue();
        <span class="java-keyword">final</span> DataflowQueue stream3 = <span class="java-keyword">new</span> DataflowQueue();
        <span class="java-keyword">final</span> DataflowQueue stream4 = <span class="java-keyword">new</span> DataflowQueue();</p><p class="paragraph">        <span class="java-keyword">final</span> DataflowProcessor op1 = Dataflow.selector(Arrays.asList(stream1), Arrays.asList(stream2), <span class="java-keyword">new</span> DataflowMessagingRunnable(1) {
            @Override <span class="java-keyword">protected</span> void doRun(<span class="java-keyword">final</span> <span class="java-object">Object</span>… objects) {
                getOwningProcessor().bindOutput(2*(<span class="java-object">Integer</span>)objects[0]);
            }
        });</p><p class="paragraph">        <span class="java-keyword">final</span> List secondOperatorInput = Arrays.asList(stream2, stream3);</p><p class="paragraph">        <span class="java-keyword">final</span> DataflowProcessor op2 = Dataflow.<span class="java-keyword">operator</span>(secondOperatorInput, Arrays.asList(stream4), <span class="java-keyword">new</span> DataflowMessagingRunnable(2) {
            @Override <span class="java-keyword">protected</span> void doRun(<span class="java-keyword">final</span> <span class="java-object">Object</span>… objects) {
                getOwningProcessor().bindOutput((<span class="java-object">Integer</span>) objects[0] + (<span class="java-object">Integer</span>) objects[1]);
            }
        });</p><p class="paragraph">        stream1.bind(1);
        stream1.bind(2);
        stream1.bind(3);
        stream3.bind(100);
        stream3.bind(100);
        stream3.bind(100);
        <span class="java-object">System</span>.out.println(<span class="java-quote">"Result: "</span> + stream4.getVal());
        <span class="java-object">System</span>.out.println(<span class="java-quote">"Result: "</span> + stream4.getVal());
        <span class="java-object">System</span>.out.println(<span class="java-quote">"Result: "</span> + stream4.getVal());
        op1.stop();
        op2.stop();
    }
}</p></pre></div><p class="paragraph"></p><h3>Performance</h3><p class="paragraph">In general, GPars overhead is identical irrespective of whether you use it from Groovy or Java and tends to be very low.
GPars actors, for example, can compete head-to-head with other JVM actor options, like Scala actors.</p><p class="paragraph">Since
 Groovy code in general runs slower than Java code, mainly due to 
dynamic method invocation, you might consider writing
your code in Java to improve performance. Typically numeric operations 
or frequent fine-grained method calls within a task or actor body
may benefit from a rewrite into Java.</p><p class="paragraph"></p><h3>Prerequisites</h3><p class="paragraph">All
 the GPars integration rules apply to Java projects just like they do to
 Groovy projects. You only need to include the groovy distribution jar 
file in your project and all is clear to march ahead.
You may also want to check out the sample Java Maven project to get tips
 on how to integrate GPars into a maven-based pure Java application - <a href="http://gpars.codehaus.org/Demos" target="blank">Sample Java Maven Project</a>



</p><h1 id="dataParallelism">3 Data Parallelism</h1>
Focusing on data instead of processes helps a great deal to create robust concurrent programs. You as a programmer
define your data together with functions that should be applied to it and then let the underlying machinery to process the data.
Typically a set of concurrent tasks will be created and then they will be submitted to a thread pool for processing.<p class="paragraph">In <strong class="bold">GPars</strong> the  <em class="italic">GParsPool</em>  and  <em class="italic">GParsExecutorsPool</em>  classes give you access to low-level data parallelism techniques.
While the  <em class="italic">GParsPool</em>  class relies on the jsr-166y Fork/Join framework and so offers greater functionality and better performance,
the  <em class="italic">GParsExecutorsPool</em>  uses good old Java executors and so is easier to setup in a managed or restricted environment.</p><p class="paragraph">There are three fundamental domains covered by the GPars low-level data parallelism:
</p><ol>
<li>Processing collections concurrently</li>
<li>Running functions (closures) asynchronously</li>
<li>Performing Fork/Join (Divide/Conquer) algorithms</li>
</ol><p class="paragraph">


</p><h2 id="dataParallelism_parallelCollections">3.1 Parallel Collections</h2>
Dealing with data frequently involves manipulating collections. Lists, 
arrays, sets, maps, iterators, strings and lot of other data types can 
be viewed as collections of items.
The common pattern to process such collections is to take elements 
sequentially, one-by-one, and make an action for each of the items in 
row.<p class="paragraph">Take, for example, the  <em class="italic">min()</em>  function, which is supposed to return the smallest element of a collection. When you call the  <em class="italic">min()</em>  method on a collection of numbers,
the caller thread will create an  <em class="italic">accumulator</em>  or  <em class="italic">so-far-the-smallest-value</em>
  initialized to the minimum value of the given type, let say to zero. 
And then the thread will iterate through the elements of the collection
and compare them with the value in the  <em class="italic">accumulator</em>  . Once all elements have been processed, the minimum value is stored in the  <em class="italic">accumulator</em>  .</p><p class="paragraph">This algorithm, however simple, is <strong class="bold">totally wrong</strong> on multi-core hardware. Running the  <em class="italic">min()</em>  function on a dual-core chip can leverage <strong class="bold">at most 50%</strong> of the computing power of the chip.
On a quad-core it would be only 25%. Correct, this algorithm effectively <strong class="bold">wastes 75% of the computing power</strong> of the chip.</p><p class="paragraph">Tree-like structures proved to be more appropriate for parallel processing. The  <em class="italic">min()</em>  function in our example doesn't need to iterate through all the elements in row and compare their values with the  <em class="italic">accumulator</em>  .
What it can do instead is relying on the multi-core nature of your hardware. A  <em class="italic">parallel_min()</em>
  function could, for example, compare pairs (or tuples of certain size)
 of neighboring values
in the collection and promote the smallest value from the tuple into a 
next round of comparison. Searching for minimum in different tuples can 
safely happen in parallel and so tuples in the same round
can be processed by different cores at the same time without races or 
contention among threads.</p><p class="paragraph"></p><h3>Meet Parallel Arrays</h3><p class="paragraph">The jsr-166y library brings a very convenient abstraction called <a href="http://groovy.dzone.com/articles/parallelize-your-arrays-with-j" target="blank">Parallel Arrays</a> . GPars leverages the Parallel Arrays implementation
 in several ways. The <strong class="bold">GParsPool</strong> and <strong class="bold">GParsExecutorsPool</strong> classes provide parallel variants of the common Groovy iteration methods like  <em class="italic">each()</em>  ,  <em class="italic">collect()</em>  ,  <em class="italic">findAll()</em>  and such.
 </p><div class="code"><pre>def selfPortraits = images.findAllParallel{it.contains me}.collectParallel {it.resize()}</pre></div>
 It also allows for a more functional style map/reduce collection processing.
 <div class="code"><pre>def smallestSelfPortrait = images.parallel.filter{it.contains me}.map{it.resize()}.min{it.sizeInMB}</pre></div>



<h2 id="dataParallelism_parallelCollections_GParsPool">3.1.1 GParsPool</h2>
Use of  <em class="italic">GParsPool</em>  - the JSR-166y based concurrent collection processor<p class="paragraph"></p><h2>Usage of GParsPool</h2><p class="paragraph">The  <em class="italic">GParsPool</em>  class enables a ParallelArray-based (from JSR-166y) concurrency DSL for collections and objects.</p><p class="paragraph">Examples of use:</p><p class="paragraph"></p><div class="code"><pre>//summarize numbers concurrently
 GParsPool.withPool {
     <span class="java-keyword">final</span> AtomicInteger result = <span class="java-keyword">new</span> AtomicInteger(0)
     [1, 2, 3, 4, 5].eachParallel {result.addAndGet(it)}
     assert 15 == result
 }<p class="paragraph"> //multiply numbers asynchronously
 GParsPool.withPool {
     <span class="java-keyword">final</span> List result = [1, 2, 3, 4, 5].collectParallel {it * 2}
     assert ([2, 4, 6, 8, 10].equals(result))
 }</p></pre></div>The passed-in closure takes an instance of a ForkJoinPool as a parameter, which can be then used freely inside the closure.
<div class="code"><pre>//check whether all elements within a collection meet certain criteria
 GParsPool.withPool(5) {ForkJoinPool pool -&gt;
     assert [1, 2, 3, 4, 5].everyParallel {it &gt; 0}
     assert ![1, 2, 3, 4, 5].everyParallel {it &gt; 1}
 }</pre></div>
The  <em class="italic">GParsPool.withPool()</em>  method takes optional parameters for number of threads in the created pool and an unhandled exception handler.
<div class="code"><pre>withPool(10) {...}
withPool(20, exceptionHandler) {...}</pre></div><p class="paragraph">The  <em class="italic">GParsPool.withExistingPool()</em>  takes an already existing ForkJoinPool instance to reuse.
The DSL is valid only within the associated block of code and only for the thread that has called the  <em class="italic">withPool()</em>  or  <em class="italic">withExistingPool()</em>  methods. The  <em class="italic">withPool()</em>
  method returns only after all the worker threads have finished their 
tasks and the pool has been destroyed, returning back the return value 
of the associated block of code. The  <em class="italic">withExistingPool()</em>  method doesn't wait for the pool threads to finish.</p><p class="paragraph">Alternatively, the  <em class="italic">GParsPool</em>  class can be statically imported  <em class="italic">import static groovyx.gpars.GParsPool.`*`</em>  , which will allow omitting the  <em class="italic">GParsPool</em>  class name.
</p><div class="code"><pre>withPool {
     assert [1, 2, 3, 4, 5].everyParallel {it &gt; 0}
     assert ![1, 2, 3, 4, 5].everyParallel {it &gt; 1}
 }</pre></div><p class="paragraph">The following methods are currently supported on all objects in Groovy:
</p><ul class="star">
<li>eachParallel()</li>
<li>eachWithIndexParallel()</li>
<li>collectParallel()</li>
<li>collectManyParallel()</li>
<li>findAllParallel()</li>
<li>findAnyParallel</li>
<li>findParallel()</li>
<li>everyParallel()</li>
<li>anyParallel()</li>
<li>grepParallel()</li>
<li>groupByParallel()</li>
<li>foldParallel()</li>
<li>minParallel()</li>
<li>maxParallel()</li>
<li>sumParallel()</li>
<li>splitParallel()</li>
<li>countParallel()</li>
<li>foldParallel()</li>
</ul><p class="paragraph"></p><h3>Meta-class enhancer</h3><p class="paragraph">As an alternative you can use the  <em class="italic">ParallelEnhancer</em>  class to enhance meta-classes of any classes or individual instances with the parallel methods.
</p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.ParallelEnhancer<p class="paragraph">def list = [1, 2, 3, 4, 5, 6, 7, 8, 9]
ParallelEnhancer.enhanceInstance(list)
println list.collectParallel {it * 2 }</p><p class="paragraph">def animals = ['dog', 'ant', 'cat', 'whale']
ParallelEnhancer.enhanceInstance animals
println (animals.anyParallel {it ==~ /ant/} ? 'Found an ant' : 'No ants found')
println (animals.everyParallel {it.contains('a')} ? 'All animals contain a' : 'Some animals can live without an a')</p></pre></div>
When using the  <em class="italic">ParallelEnhancer</em>  class, you're not restricted to a  <em class="italic">withPool()</em>  block with the use of the GParsPool DSLs. The enhanced classed or instances
remain enhanced till they get garbage collected.<p class="paragraph"></p><h3>Exception handling</h3><p class="paragraph">If
 an exception is thrown while processing any of the passed-in closures, 
the first exception gets re-thrown from the xxxParallel methods and the 
algorithm stops as soon as possible.</p><p class="paragraph"></p><blockquote class="note">
The exception handling mechanism of GParsPool builds on the one built 
into the Fork/Join framework. Since Fork/Join algorithms are by nature 
hierarchical,
once any part of the algorithm fails, there's usually little benefit 
from continuing the computation, since some branches of the algorithm 
will never return a result.<p class="paragraph">Bear in mind that the 
GParsPool implementation doesn't give any guarantees about its behavior 
after a first unhandled exception occurs,
beyond stopping the algorithm and re-throwing the first detected 
exception to the caller.
This behavior, after all, is consistent with what the traditional 
sequential iteration methods do.
</p></blockquote><p class="paragraph"></p><h3>Transparently parallel collections</h3><p class="paragraph">On top of adding new xxxParallel() methods, <strong class="bold">GPars</strong>
 can also let you change the semantics of the original iteration 
methods. For example, you may be passing a collection into a library 
method, which will process your collection
in a sequential way, let say using the  <em class="italic">collect()</em>  method. By changing the semantics of the  <em class="italic">collect()</em>  method on your collection you can effectively parallelize the library sequential code.</p><p class="paragraph"></p><div class="code"><pre>GParsPool.withPool {<p class="paragraph">    //The selectImportantNames() will process the name collections concurrently
    assert ['ALICE', 'JASON'] == selectImportantNames(['Joe', 'Alice', 'Dave', 'Jason'].makeConcurrent())
}</p><p class="paragraph">/**
 * A function implemented using standard sequential collect() and findAll() methods.
 */
def selectImportantNames(names) {
    names.collect {it.toUpperCase()}.findAll{it.size() &gt; 4}
}</p></pre></div><p class="paragraph">The  <em class="italic">makeSequential()</em>  method will reset the collection back to the original sequential semantics.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.GParsPool.withPool<p class="paragraph">def list = [1, 2, 3, 4, 5, 6, 7, 8, 9]</p><p class="paragraph">println 'Sequential: '
list.each { print it + ',' }
println()</p><p class="paragraph">withPool {</p><p class="paragraph">    println 'Sequential: '
    list.each { print it + ',' }
    println()</p><p class="paragraph">    list.makeConcurrent()</p><p class="paragraph">    println 'Concurrent: '
    list.each { print it + ',' }
    println()</p><p class="paragraph">    list.makeSequential()</p><p class="paragraph">    println 'Sequential: '
    list.each { print it + ',' }
    println()
}</p><p class="paragraph">println 'Sequential: '
list.each { print it + ',' }
println()</p></pre></div><p class="paragraph">The  <em class="italic">asConcurrent()</em>  convenience method will allow you to specify code blocks, in which the collection maintains concurrent semantics.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.GParsPool.withPool<p class="paragraph">def list = [1, 2, 3, 4, 5, 6, 7, 8, 9]</p><p class="paragraph">println 'Sequential: '
list.each { print it + ',' }
println()</p><p class="paragraph">withPool {</p><p class="paragraph">    println 'Sequential: '
    list.each { print it + ',' }
    println()</p><p class="paragraph">    list.asConcurrent {
        println 'Concurrent: '
        list.each { print it + ',' }
        println()
    }</p><p class="paragraph">    println 'Sequential: '
    list.each { print it + ',' }
    println()
}</p><p class="paragraph">println 'Sequential: '
list.each { print it + ',' }
println()</p></pre></div><p class="paragraph">Transparent parallelizm, including the  <em class="italic">makeConcurrent()</em>  ,  <em class="italic">makeSequential()</em>  and  <em class="italic">asConcurrent()</em>  methods, is also available in combination with  <em class="italic">ParallelEnhancer</em>  .
</p><div class="code"><pre>/**
 * A function implemented using standard sequential collect() and findAll() methods.
 */
def selectImportantNames(names) {
    names.collect {it.toUpperCase()}.findAll{it.size() &gt; 4}
}<p class="paragraph">def names = ['Joe', 'Alice', 'Dave', 'Jason']
ParallelEnhancer.enhanceInstance(names)
//The selectImportantNames() will process the name collections concurrently
assert ['ALICE', 'JASON'] == selectImportantNames(names.makeConcurrent())</p></pre></div><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.ParallelEnhancer<p class="paragraph">def list = [1, 2, 3, 4, 5, 6, 7, 8, 9]</p><p class="paragraph">println 'Sequential: '
list.each { print it + ',' }
println()</p><p class="paragraph">ParallelEnhancer.enhanceInstance(list)</p><p class="paragraph">println 'Sequential: '
list.each { print it + ',' }
println()</p><p class="paragraph">list.asConcurrent {
    println 'Concurrent: '
    list.each { print it + ',' }
    println()</p><p class="paragraph">}
list.makeSequential()</p><p class="paragraph">println 'Sequential: '
list.each { print it + ',' }
println()</p></pre></div>
<h2>Avoid side-effects in functions</h2><p class="paragraph">We have to warn you. Since the closures that are provided to the parallel methods like  <em class="italic">eachParallel()</em>  or  <em class="italic">collectParallel()</em>
  may be run in parallel, you have to make sure that each of the 
closures
is written in a thread-safe manner. The closures must hold no internal 
state, share data nor have side-effects beyond the boundaries the single
 element that they've been invoked on.
Violations of these rules will open the door for race conditions and 
deadlocks, the most severe enemies of a modern multi-core programmer.</p><p class="paragraph"><strong class="bold">Don't do this:</strong>
</p><div class="code"><pre>def thumbnails = []
images.eachParallel {thumbnails &lt;&lt; it.thumbnail}  //Concurrently accessing a not-thread-safe collection of thumbnails, don't <span class="java-keyword">do</span> <span class="java-keyword">this</span>!</pre></div>
At least, you've been warned.



<h2 id="dataParallelism_parallelCollections_GParsExecutorsPool">3.1.2 GParsExecutorsPool</h2>
Use of GParsExecutorsPool - the Java Executors' based concurrent collection processor<p class="paragraph"></p><h2>Usage of GParsExecutorsPool</h2><p class="paragraph">The  <em class="italic">GParsPool</em>  class enables a Java Executors-based concurrency DSL for collections and objects.</p><p class="paragraph">The  <em class="italic">GParsExecutorsPool</em>  class can be used as a pure-JDK-based collection parallel processor. Unlike the  <em class="italic">GParsPool</em>  class,  <em class="italic">GParsExecutorsPool</em>
  doesn't require jsr-166y jar file, but leverages the standard JDK 
executor services to parallelize closures processing a collections or an
 object iteratively.
It needs to be states, however, that  <em class="italic">GParsPool</em>  performs typically much better than  <em class="italic">GParsExecutorsPool</em>  does.</p><p class="paragraph">Examples of use:
</p><div class="code"><pre>//multiply numbers asynchronously
 GParsExecutorsPool.withPool {
     Collection&lt;Future&gt; result = [1, 2, 3, 4, 5].collectParallel{it * 10}
     assert <span class="java-keyword">new</span> HashSet([10, 20, 30, 40, 50]) == <span class="java-keyword">new</span> HashSet((Collection)result*.get())
 }<p class="paragraph"> //multiply numbers asynchronously using an asynchronous closure
 GParsExecutorsPool.withPool {
     def closure={it * 10}
     def asyncClosure=closure.async()
     Collection&lt;Future&gt; result = [1, 2, 3, 4, 5].collect(asyncClosure)
     assert <span class="java-keyword">new</span> HashSet([10, 20, 30, 40, 50]) == <span class="java-keyword">new</span> HashSet((Collection)result*.get())
 }</p></pre></div>
The passed-in closure takes an instance of a ExecutorService as a parameter, which can be then used freely inside the closure.
<div class="code"><pre>//find an element meeting specified criteria
 GParsExecutorsPool.withPool(5) {ExecutorService service -&gt;
     service.submit({performLongCalculation()} as <span class="java-object">Runnable</span>)
 }</pre></div>
The  <em class="italic">GParsExecutorsPool.withPool()</em>  method takes optional parameters for number of threads in the created pool and a thread factory.
<div class="code"><pre>withPool(10) {...}
withPool(20, threadFactory) {...}</pre></div><p class="paragraph">The  <em class="italic">GParsExecutorsPool.withExistingPool()</em>
  takes an already existing executor service instance to reuse. The DSL 
is valid only within the associated block of code and only for the 
thread that has called the  <em class="italic">withPool()</em>  or  <em class="italic">withExistingPool()</em>  method. The  <em class="italic">withPool()</em>
  method returns only after all the worker threads have finished their 
tasks and the executor service has been destroyed, returning back the 
return value of the associated block of code. The  <em class="italic">withExistingPool()</em>  method doesn't wait for the executor service threads to finish.</p><p class="paragraph">Alternatively, the  <em class="italic">GParsExecutorsPool</em>  class can be statically imported  <em class="italic">import static groovyx.gpars.GParsExecutorsPool.`*`</em> , which will allow omitting the  <em class="italic">GParsExecutorsPool</em>  class name.
</p><div class="code"><pre>withPool {
     def result = [1, 2, 3, 4, 5].findParallel{<span class="java-object">Number</span> number -&gt; number &gt; 2}
     assert result in [3, 4, 5]
 }</pre></div>
The following methods on all objects, which support iterations in Groovy, are currently supported:
<ul class="star">
<li>eachParallel()</li>
<li>eachWithIndexParallel()</li>
<li>collectParallel()</li>
<li>findAllParallel()</li>
<li>findParallel()</li>
<li>allParallel()</li>
<li>anyParallel()</li>
<li>grepParallel()</li>
<li>groupByParallel()</li>
</ul><p class="paragraph"></p><h3>Meta-class enhancer</h3><p class="paragraph">As an alternative you can use the  <em class="italic">GParsExecutorsPoolEnhancer</em>  class to enhance meta-classes for any classes or individual instances with asynchronous methods.
</p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.GParsExecutorsPoolEnhancer<p class="paragraph">def list = [1, 2, 3, 4, 5, 6, 7, 8, 9]
GParsExecutorsPoolEnhancer.enhanceInstance(list)
println list.collectParallel {it * 2 }</p><p class="paragraph">def animals = ['dog', 'ant', 'cat', 'whale']
GParsExecutorsPoolEnhancer.enhanceInstance animals
println (animals.anyParallel {it ==~ /ant/} ? 'Found an ant' : 'No ants found')
println (animals.allParallel {it.contains('a')} ? 'All animals contain a' : 'Some animals can live without an a')</p></pre></div><p class="paragraph">When using the  <em class="italic">GParsExecutorsPoolEnhancer</em>  class, you're not restricted to a  <em class="italic">withPool()</em>  block with the use of the GParsExecutorsPool DSLs. The enhanced classed or instances
remain enhanced till they get garbage collected.</p><p class="paragraph"></p><h3>Exception handling</h3><p class="paragraph">If exceptions are thrown while processing any of the passed-in closures, an instance of  <em class="italic">AsyncException</em>  wrapping all the original exceptions gets re-thrown from the xxxParallel methods.</p><p class="paragraph"></p><h2>Avoid side-effects in functions</h2><p class="paragraph">Once
 again we need to warn you about using closures with side-effects 
effecting objects beyond the scope of the single currently processed 
element or closures which keep state. Don't do that! It is dangerous to 
pass them to any of the  <em class="italic">xxxParallel()</em>  methods.



</p><h2 id="dataParallelism_parallelCollections_memoize">3.1.3 Memoize</h2>
The  <em class="italic">memoize</em>  function enables caching of 
function's return values. Repeated calls to the memoized function with 
the same argument values
will, instead of invoking the calculation encoded in the original 
function, retrieve the result value from an internal transparent cache.
Provided the calculation is considerably slower than retrieving a cached
 value from the cache, this allows users to trade-off memory for 
performance.
Checkout out the example, where we attempt to scan multiple websites for
 particular content:<p class="paragraph">The memoize functionality of 
GPars has been contributed to Groovy in version 1.8 and if you run on 
Groovy 1.8 or later, it is recommended to use the Groovy functionality.
Memoize in GPars is almost identical, except that it searches the 
memoize caches concurrently using the surrounding thread pool and so may
 give
performance benefits in some scenarios.</p><p class="paragraph"></p><blockquote class="note">
The GPars memoize functionality has been renamed to avoid future conflicts with the memoize functionality in Groovy.
GPars now calls the methods with a preceding letter  <em class="italic">g</em>  , such as gmemoize().
</blockquote><p class="paragraph"></p><h2>Examples of use</h2>
<div class="code"><pre>GParsPool.withPool {
    def urls = ['http://www.dzone.com', 'http://www.theserverside.com', 'http://www.infoq.com']
    Closure download = {url -&gt;
        println <span class="java-quote">"Downloading $url"</span>
        url.toURL().text.toUpperCase()
    }
    Closure cachingDownload = download.gmemoize()<p class="paragraph">    println 'Groovy sites today: ' + urls.findAllParallel {url -&gt; cachingDownload(url).contains('GROOVY')}
    println 'Grails sites today: ' + urls.findAllParallel {url -&gt; cachingDownload(url).contains('GRAILS')}
    println 'Griffon sites today: ' + urls.findAllParallel {url -&gt; cachingDownload(url).contains('GRIFFON')}
    println 'Gradle sites today: ' + urls.findAllParallel {url -&gt; cachingDownload(url).contains('GRADLE')}
    println 'Concurrency sites today: ' + urls.findAllParallel {url -&gt; cachingDownload(url).contains('CONCURRENCY')}
    println 'GPars sites today: ' + urls.findAllParallel {url -&gt; cachingDownload(url).contains('GPARS')}
}</p></pre></div><p class="paragraph">Notice closures are enhanced inside the  <em class="italic">GParsPool.withPool()</em>  blocks with a  <em class="italic">memoize()</em>  function, which returns a new closure
wrapping the original closure with a cache.
In the example we're calling the  <em class="italic">cachingDownload</em>
  function in several places in the code, however, each unique url gets 
downloaded only once - the first time
it is needed. The values are then cached and available for subsequent 
calls. And also to all threads, no matter which thread originally came 
first with
a download request for the particular url and had to handle the actual 
calculation/download.</p><p class="paragraph">So, to wrap up, memoize shields a function by a cache of past return values. However,  <em class="italic">memoize</em>
  can do even more. In some algorithms
adding a little memory may have dramatic impact on the computational 
complexity of the calculation. Let's look at a classical example of
Fibonacci numbers.</p><p class="paragraph"></p><h2>Fibonacci example</h2><p class="paragraph">A purely functional, recursive implementation, following closely the definition of Fibonacci numbers is exponentially complex:</p><p class="paragraph"></p><div class="code"><pre>Closure fib = {n -&gt; n &gt; 1 ? call(n - 1) + call(n - 2) : n}</pre></div><p class="paragraph">Try calling the  <em class="italic">fib</em>  function with numbers around 30 and you'll see how slow it is.</p><p class="paragraph">Now with a little twist and added memoize cache the algorithm magically turns into a linearly complex one:</p><p class="paragraph"></p><div class="code"><pre>Closure fib
fib = {n -&gt; n &gt; 1 ? fib(n - 1) + fib(n - 2) : n}.gmemoize()</pre></div><p class="paragraph">The extra memory we added cut off all but one recursive branches of the calculation. And all subsequent calls to the same  <em class="italic">fib</em> 
function will also benefit from the cached values.</p><p class="paragraph">Also, see below, how the  <em class="italic">memoizeAtMost</em>  variant can reduce memory consumption in our example, yet preserve the linear complexity
of the algorithm.</p><p class="paragraph"></p><h2>Available variants</h2><p class="paragraph"></p><h3>memoize</h3><p class="paragraph">The
 basic variant, which keeps values in the internal cache for the whole 
lifetime of the memoized function. Provides the best performance
characteristics of all the variants.</p><p class="paragraph"></p><h3>memoizeAtMost</h3><p class="paragraph">Allows the user to set a hard limit on number of items cached. Once the limit has been reached, all subsequently added values
will eliminate the oldest value from the cache using the LRU (Last Recently Used) strategy.</p><p class="paragraph">So for our Fibonacci number example, we could safely reduce the cache size to two items:</p><p class="paragraph"></p><div class="code"><pre>Closure fib
fib = {n -&gt; n &gt; 1 ? fib(n - 1) + fib(n - 2) : n}.memoizeAtMost(2)</pre></div><p class="paragraph">Setting an upper limit on the cache size may have two purposes:
</p><ol>
<li>Keep the memory footprint of the cache within defined boundaries</li>
<li>Preserve desired performance characteristics of the function. Too 
large caches may take longer to retrieve the cached value than it would 
have taken to calculate the result directly.</li>
</ol><p class="paragraph"></p><h3>memoizeAtLeast</h3><p class="paragraph">Allows unlimited growth of the internal cache until the JVM's garbage collector decides to step in and evict SoftReferences,
used by our implementation, from the memory. The single parameter value to the  <em class="italic">memoizeAtLeast()</em>  method specifies the minimum number
of cached items that should be protected from gc eviction. The cache will never shrink below the specified number of entries.
The cache ensures it only protects the most recently used items from eviction using the LRU (Last Recently Used) strategy.</p><p class="paragraph"></p><h3>memoizeBetween</h3><p class="paragraph">Combines
 memoizeAtLeast and memoizeAtMost and so allowing the cache to grow and 
shrink in the range between the two parameter values
depending on available memory and the gc activity, yet the cache size 
will never exceed the upper size limit
to preserve desired performance characteristics of the cache.</p><p class="paragraph">


</p><h2 id="dataParallelism_map-reduce">3.2 Map-Reduce</h2>
The Parallel Collection Map/Reduce DSL gives GPars a more functional 
flavor. In general, the Map/Reduce DSL may be used for the same purpose 
as the  <em class="italic">xxxParallel()</em>  family methods and has 
very similar semantics.
On the other hand, Map/Reduce can perform considerably faster, if you 
need to chain multiple methods to process a single collection in 
multiple steps:
<div class="code"><pre>println '<span class="java-object">Number</span> of occurrences of the word GROOVY today: ' + urls.parallel
            .map {it.toURL().text.toUpperCase()}
            .filter {it.contains('GROOVY')}
            .map{it.split()}
            .map{it.findAll{word -&gt; word.contains 'GROOVY'}.size()}
            .sum()</pre></div><p class="paragraph">The  <em class="italic">xxxParallel()</em>  methods have to follow the contract of their non-parallel peers. So a  <em class="italic">collectParallel()</em>
  method must return a legal collection of items, which you can again 
treat as a Groovy collection.
Internally the parallel collect method builds an efficient parallel 
structure, called parallel array, performs the required operation 
concurrently and before returning destroys the Parallel Array building 
the collection of results to return to you.
A potential call to let say  <em class="italic">findAllParallel()</em>  
on the resulting collection would repeat the whole process of 
construction and destruction of a Parallel Array instance under the 
covers.</p><p class="paragraph">With Map/Reduce you turn your collection
 into a Parallel Array and back only once. The Map/Reduce family of 
methods do not return Groovy collections, but are free to pass along the
 internal Parallel Arrays directly.
Invoking the  <em class="italic">parallel</em>  property on a collection
 will build a Parallel Array for the collection and return a thin 
wrapper around the Parallel Array instance.
Then you can chain all required methods like:
</p><ul class="star">
<li>map()</li>
<li>reduce()</li>
<li>filter()</li>
<li>size()</li>
<li>sum()</li>
<li>min()</li>
<li>max()</li>
<li>sort()</li>
<li>groupBy()</li>
<li>combine()</li>
</ul><p class="paragraph">Returning back to a plain Groovy collection instance is always just a matter of retrieving the  <em class="italic">collection</em>  property.</p><p class="paragraph"></p><div class="code"><pre>def myNumbers = (1..1000).parallel.filter{it % 2 == 0}.map{<span class="java-object">Math</span>.sqrt it}.collection</pre></div><p class="paragraph"></p><h2>Avoid side-effects in functions</h2><p class="paragraph">Once
 again we need to warn you. To avoid nasty surprises, please, keep your 
closures, which you pass to the Map/Reduce functions, stateless and 
clean from side-effects.</p><p class="paragraph"></p><h3>Availability</h3><p class="paragraph">This feature is only available when using in the Fork/Join-based  <em class="italic">GParsPool</em>  , not in  <em class="italic">GParsExecutorsPool</em>  .</p><p class="paragraph"></p><h3>Classical Example</h3><p class="paragraph">A classical example, inspired by http://github.com/thevery, counting occurrences of words in a string:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.GParsPool.withPool<p class="paragraph">def words = <span class="java-quote">"This is just a plain text to count words in"</span>
print count(words)</p><p class="paragraph">def count(arg) {
  withPool {
    <span class="java-keyword">return</span> arg.parallel
      .map{[it, 1]}
      .groupBy{it[0]}.getParallel()
      .map {it.value=it.value.size();it}
      .sort{-it.value}.collection
  }
}</p></pre></div><p class="paragraph">The same example, now implemented the more general  <em class="italic">combine</em>  operation:</p><p class="paragraph"></p><div class="code"><pre>def words = <span class="java-quote">"This is just a plain text to count words in"</span>
print count(words)<p class="paragraph">def count(arg) {
  withPool {
    <span class="java-keyword">return</span> arg.parallel
      .map{[it, 1]}
      .combine(0) {sum, value -&gt; sum + value}.getParallel()
      .sort{-it.value}.collection
  }
}</p></pre></div><p class="paragraph"></p><h3>Combine</h3><p class="paragraph">The  <em class="italic">combine</em>
  operation expects on its input a list of tuples (two-element lists) 
considered to be key-value pairs (such as [key1, value1, key2, value2, 
key1, value3, key3, value4 … ] )
with potentially repeating keys. When invoked,  <em class="italic">combine</em>
  merges the values for identical keys using the provided accumulator 
function and produces a map mapping the original (unique) keys to their 
accumulated values.
E.g. [a, b, c, d, a, e, c, f] will be combined into a : b+e, c : d+f, 
while the '+' operation on the values needs to be provided by the user 
as the accumulation closure.</p><p class="paragraph">The  <em class="italic">accumulation function</em>  argument needs to specify a function to use for combining (accumulating) the values belonging to the same key.
An  <em class="italic">initial accumulator value</em>  needs to be provided as well. Since the  <em class="italic">combine</em>  method processes items in parallel, the  <em class="italic">initial accumulator value</em>  will be reused multiple times.
Thus the provided value must allow for reuse. It should be either a <strong class="bold">cloneable</strong> or <strong class="bold">immutable</strong> value or a <strong class="bold">closure</strong> returning a fresh initial accumulator each time requested.
Good combinations of accumulator functions and reusable initial values include:
</p><div class="code"><pre>accumulator = {List acc, value -&gt; acc &lt;&lt; value} initialValue = []
accumulator = {List acc, value -&gt; acc &lt;&lt; value} initialValue = {-&gt; []}
accumulator = {<span class="java-object">int</span> sum, <span class="java-object">int</span> value -&gt; acc + value} initialValue = 0
accumulator = {<span class="java-object">int</span> sum, <span class="java-object">int</span> value -&gt; sum + value} initialValue = {-&gt; 0}
accumulator = {ShoppingCart cart, Item value -&gt; cart.addItem(value)} initialValue = {-&gt; <span class="java-keyword">new</span> ShoppingCart()}</pre></div><p class="paragraph">The return type is a map.
E.g. ['he', 1, 'she', 2, 'he', 2, 'me', 1, 'she, 5, 'he', 1 with the initial value provided a 0 will be combined into
'he' : 4, 'she' : 7, 'he', : 2, 'me' : 1</p><p class="paragraph"></p><blockquote class="note">
The keys will be mutually compared using their equals and hashCode methods. Consider using  <em class="italic">@Canonical</em>  or  <em class="italic">@EqualsAndHashCode</em>
 
to annotate classes that you use as keys. Just like with all hash maps 
in Groovy, be sure you're using a String not a GString as a key!
</blockquote><p class="paragraph">For more involved scenarios when you  <em class="italic">combine()</em>  complex objects, a good strategy here is to have a class that can be used as a key for the common use cases
and apply different keys for uncommon cases.</p><p class="paragraph">
</p><div class="code"><pre><span class="java-keyword">import</span> groovy.transform.ToString
<span class="java-keyword">import</span> groovy.transform.TupleConstructor<p class="paragraph"><span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.GParsPool.withPool</p><p class="paragraph"><code>TupleConstructor </code>ToString
class PricedCar <span class="java-keyword">implements</span> <span class="java-object">Cloneable</span> {
    <span class="java-object">String</span> model
    <span class="java-object">String</span> color
    <span class="java-object">Double</span> price</p><p class="paragraph">    <span class="java-object">boolean</span> equals(<span class="java-keyword">final</span> o) {
        <span class="java-keyword">if</span> (<span class="java-keyword">this</span>.is(o)) <span class="java-keyword">return</span> <span class="java-keyword">true</span>
        <span class="java-keyword">if</span> (getClass() != o.class) <span class="java-keyword">return</span> <span class="java-keyword">false</span></p><p class="paragraph">        <span class="java-keyword">final</span> PricedCar pricedCar = (PricedCar) o</p><p class="paragraph">        <span class="java-keyword">if</span> (color != pricedCar.color) <span class="java-keyword">return</span> <span class="java-keyword">false</span>
        <span class="java-keyword">if</span> (model != pricedCar.model) <span class="java-keyword">return</span> <span class="java-keyword">false</span></p><p class="paragraph">        <span class="java-keyword">return</span> <span class="java-keyword">true</span>
    }</p><p class="paragraph">    <span class="java-object">int</span> hashCode() {
        <span class="java-object">int</span> result
        result = (model != <span class="java-keyword">null</span> ? model.hashCode() : 0)
        result = 31 * result + (color != <span class="java-keyword">null</span> ? color.hashCode() : 0)
        <span class="java-keyword">return</span> result
    }</p><p class="paragraph">    @Override
    <span class="java-keyword">protected</span> <span class="java-object">Object</span> clone() {
        <span class="java-keyword">return</span> <span class="java-keyword">super</span>.clone()
    }
}</p><p class="paragraph">def cars = [<span class="java-keyword">new</span> PricedCar('F550', 'blue', 2342.223),
        <span class="java-keyword">new</span> PricedCar('F550', 'red', 234.234),
        <span class="java-keyword">new</span> PricedCar('Da', 'white', 2222.2),
        <span class="java-keyword">new</span> PricedCar('Da', 'white', 1111.1)]</p><p class="paragraph">withPool {
    //Combine by model
    def result =
        cars.parallel.map {
            [it.model, it]
        }.combine(<span class="java-keyword">new</span> PricedCar('', 'N/A', 0.0)) {sum, value -&gt;
            sum.model = value.model
            sum.price += value.price
            sum
        }.values()</p><p class="paragraph">    println result</p><p class="paragraph">
    //Combine by model and color (the PricedCar's equals and hashCode))
    result =
        cars.parallel.map {
            [it, it]
        }.combine(<span class="java-keyword">new</span> PricedCar('', 'N/A', 0.0)) {sum, value -&gt;
            sum.model = value.model
            sum.color = value.color
            sum.price += value.price
            sum
        }.values()</p><p class="paragraph">    println result
}</p></pre></div>


<h2 id="dataParallelism_parallelArrays">3.3 Parallel Arrays</h2>
As an alternative, the efficient tree-based data structures defines in JSR-166y can be used directly. The  <em class="italic">parallelArray</em> 
property on any collection or object will return a  <em class="italic">jsr166y.forkjoin.ParallelArray</em>  instance holding the elements of the original collection,
which then can be manipulated through the jsr166y API. Please refer to the jsr166y documentation for the API details.<p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.extra166y.Ops<p class="paragraph">groovyx.gpars.GParsPool.withPool {
    assert 15 == [1, 2, 3, 4, 5].parallelArray.reduce({a, b -&gt; a + b} as Ops.Reducer, 0)                                        //summarize
    assert 55 == [1, 2, 3, 4, 5].parallelArray.withMapping({it ** 2} as Ops.Op).reduce({a, b -&gt; a + b} as Ops.Reducer, 0)       //summarize squares
    assert 20 == [1, 2, 3, 4, 5].parallelArray.withFilter({it % 2 == 0} as Ops.Predicate)                                       //summarize squares of even numbers
            .withMapping({it ** 2} as Ops.Op)
            .reduce({a, b -&gt; a + b} as Ops.Reducer, 0)</p><p class="paragraph">    assert 'aa:bb:cc:dd:ee' == 'abcde'.parallelArray                                                                            //concatenate duplicated characters with separator
            .withMapping({it * 2} as Ops.Op)
            .reduce({a, b -&gt; <span class="java-quote">"$a:$b"</span>} as Ops.Reducer, <span class="java-quote">""</span>)</p></pre></div>



<h2 id="dataParallelism_asynchronousInvocation">3.4 Asynchronous Invocation</h2>
Running long-lasting tasks in the background belongs to the activities, the need for which arises quite frequently. Your main
thread of execution wants to initialize a few calculations, downloads, searches or such, however, the results may not be needed
immediately. <strong class="bold">GPars</strong> gives the developers the tools to schedule the asynchronous activities for processing in the background
and collect the results once they're needed.<p class="paragraph"></p><h2>Usage of GParsPool and GParsExecutorsPool asynchronous processing facilities</h2><p class="paragraph">Both  <em class="italic">GParsPool</em>  and  <em class="italic">GParsExecutorsPool</em>  provide almost identical services in this domain, although they leverage different
underlying machinery, based on which of the two classes the user chooses.</p><p class="paragraph"></p><h3>Closures enhancements</h3><p class="paragraph">The following methods are added to closures inside the  <em class="italic">GPars(Executors)Pool.withPool()</em>  blocks:
</p><ul class="star">
<li>async() - Creates an asynchronous variant of the supplied closure, 
which when invoked returns a future for the potential return value</li>
<li>callAsync() - Calls a closure in a separate thread supplying the 
given arguments, returning a future for the potential return value,</li>
</ul><p class="paragraph">Examples:
</p><div class="code"><pre>GParsPool.withPool() {
    Closure longLastingCalculation = {calculate()}
    Closure fastCalculation = longLastingCalculation.async()  //create a <span class="java-keyword">new</span> closure, which starts the original closure on a thread pool
    Future result=fastCalculation()                           //returns almost immediately
    //<span class="java-keyword">do</span> stuff <span class="java-keyword">while</span> calculation performs …
    println result.get()
}</pre></div><p class="paragraph"></p><div class="code"><pre>GParsPool.withPool() {
    /**
     * The callAsync() method is an asynchronous variant of the <span class="java-keyword">default</span> call() method to invoke a closure.
     * It will <span class="java-keyword">return</span> a Future <span class="java-keyword">for</span> the result value.
     */
    assert 6 == {it * 2}.call(3)
    assert 6 == {it * 2}.callAsync(3).get()
}</pre></div><p class="paragraph"></p><h4>Timeouts</h4><p class="paragraph">The  <em class="italic">callTimeoutAsync()</em>
  methods, taking either a long value or a Duration instance, allow the 
user to have the calculation cancelled after a given time interval.</p><p class="paragraph"></p><div class="code"><pre>{-&gt;
    <span class="java-keyword">while</span>(<span class="java-keyword">true</span>) {
        <span class="java-object">Thread</span>.sleep 1000  //Simulate a bit of interesting calculation
        <span class="java-keyword">if</span> (<span class="java-object">Thread</span>.currentThread().isInterrupted()) <span class="java-keyword">break</span>;  //We've been cancelled
    }
}.callTimeoutAsync(2000)</pre></div><p class="paragraph">In order to allow cancellation, the asynchronously running code must keep checking the  <em class="italic">interrupted</em>  flag of its own thread and cease the calculation once the flag is set to true.</p><p class="paragraph"></p><h3>Executor Service enhancements</h3><p class="paragraph">The
 ExecutorService and jsr166y.forkjoin.ForkJoinPool class is enhanced 
with the &lt;&lt; (leftShift) operator to submit tasks to the pool and 
return
a  <em class="italic">Future</em>  for the result.</p><p class="paragraph">Example:
</p><div class="code"><pre>GParsExecutorsPool.withPool {ExecutorService executorService -&gt;
    executorService &lt;&lt; {println 'Inside parallel task'}
}</pre></div><p class="paragraph"></p><h3>Running functions (closures) in parallel</h3><p class="paragraph">The  <em class="italic">GParsPool</em>  and  <em class="italic">GParsExecutorsPool</em>  classes also provide handy methods  <em class="italic">executeAsync()</em>  and  <em class="italic">executeAsyncAndWait()</em>  to easily run multiple closures asynchronously.</p><p class="paragraph">Example:
</p><div class="code"><pre>GParsPool.withPool {
    assert [10, 20] == GParsPool.executeAsyncAndWait({calculateA()}, {calculateB()}         //waits <span class="java-keyword">for</span> results
    assert [10, 20] == GParsPool.executeAsync({calculateA()}, {calculateB()})*.get()  //returns Futures instead and doesn't wait <span class="java-keyword">for</span> results to be calculated
}</pre></div>



<h2 id="dataParallelism_composableAsynchronousFunctions">3.5 Composable Asynchronous Functions</h2>
Functions are to be composed. In fact, composing side-effect-free 
functions is very easy. Much easier and reliable than composing objects,
 for example.
Given the same input, functions always return the same result, they 
never change their behavior unexpectedly nor they break when multiple 
threads call them at the same time.
<h3>Functions in Groovy</h3>
We can treat Groovy closures as functions. They take arguments, do their
 calculation and return a value. Provided you don't let your
closures touch anything outside their scope, your closures are 
well-behaved pure functions. Functions that you can combine for a better
 good.
<div class="code"><pre>def sum = (0..100000).inject(0, {a, b -&gt; a + b})</pre></div>
For example, by combining a function adding two numbers with the  <em class="italic">inject</em>  function, which iterates through the whole collection,
you can quickly summarize all items. Then, replacing the  <em class="italic">adding</em>  function with a  <em class="italic">comparison</em>  function will immediately give you a combined function calculating maximum.
<div class="code"><pre>def max = myNumbers.inject(0, {a, b -&gt; a&gt;b?a:b})</pre></div><p class="paragraph">You see, functional programming is popular for a reason.</p><p class="paragraph"></p><h3>Are we concurrent yet?</h3>
This all works just fine until you realize you're not utilizing the full
 power of your expensive hardware. The functions are plain sequential.
No parallelism in here. All but one processor core do nothing, they're 
idle, totally wasted.
<blockquote class="note">
Those paying attention would suggest to use the  <em class="italic">Parallel Collection</em>  techniques described earlier and they would certainly be correct.
For our scenario described here, where we process a collection, using those  <em class="italic">parallel</em>  methods would be the best choice.
However, we're now looking for a <strong class="bold">generic way to create and combine asynchronous functions</strong> , which would help us
not only for collection processing but mostly in other more generic cases, like the one right below.
</blockquote>
To make things more obvious, here's an example of combining four 
functions, which are supposed to check whether a particular web page 
matches the contents of a local file.
We need to download the page, load the file, calculate hashes of both 
and finally compare the resulting numbers.
<div class="code"><pre>Closure download = {<span class="java-object">String</span> url -&gt;
    url.toURL().text
}<p class="paragraph">Closure loadFile = {<span class="java-object">String</span> fileName -&gt;
    …  //load the file here
}</p><p class="paragraph">Closure hash = {s -&gt; s.hashCode()}</p><p class="paragraph">Closure compare = {<span class="java-object">int</span> first, <span class="java-object">int</span> second -&gt;
    first == second
}</p><p class="paragraph">def result = compare(hash(download('http://www.gpars.org')), hash(loadFile('/coolStuff/gpars/website/index.html')))
println <span class="java-quote">"The result of comparison: "</span> + result</p></pre></div>
We need to download the page, load up the file, calculate hashes of both
 and finally compare the resulting numbers.
Each of the functions is responsible for one particular job. One 
downloads the content, second loads the file, third calculates the 
hashes
and finally the fourth one will do the comparison. Combining the 
functions is as simple as nesting their calls.<p class="paragraph"></p><h3>Making it all asynchronous</h3><p class="paragraph">The downside of our code is that we don't leverage the independence of the  <em class="italic">download()</em>  and the  <em class="italic">loadFile()</em>
  functions.
Neither we allow the two hashes to be run concurrently. They could well 
run in parallel, but our way to combine functions restricts any 
parallelism.</p><p class="paragraph">Obviously not all of the functions 
can run concurrently. Some functions depend on results of others. They 
cannot start before the other function finishes.
We need to block them till their parameters are available. The  <em class="italic">hash()</em>  functions needs a string to work on. The  <em class="italic">compare()</em>  function needs two numbers to compare.</p><p class="paragraph">So we can only parallelize some functions, while blocking parallelism of others. Seems like a challenging task.</p><p class="paragraph"></p><h3>Things are bright in the functional world</h3><p class="paragraph">Luckily,
 the dependencies between functions are already expressed implicitly in 
the code. There's no need for us to duplicate the dependency 
information.
If one functions takes parameters and the parameters need first to be 
calculated by another function, we implicitly have a dependency here. 
The  <em class="italic">hash()</em>  function
depends on the  <em class="italic">loadFile()</em>  as well as on the  <em class="italic">download()</em>  functions in our example.
The  <em class="italic">inject</em>  function in our earlier example depends on the results of the  <em class="italic">addition</em>  functions invoked gradually on all the elements of the collection.</p><p class="paragraph"></p><blockquote class="note">
However difficult it may seem at first, our task is in fact very simple. We only need to teach our functions to return  <em class="italic">promises</em>  of their future results. And we need to teach the other functions
to accept those  <em class="italic">promises</em>  as parameters so that
 they wait for the real values before they start their work.
And if we convince the functions to release the threads they hold while 
waiting for the values, we get directly to where the magic can happen.
</blockquote><p class="paragraph">In the good tradition of  <em class="italic">GPars</em>  we've made it very straightforward for you to convince any function to believe in other functions' promises. Call the  <em class="italic">asyncFun()</em>  function on a closure
and you're asynchronous.
</p><div class="code"><pre>withPool {
    def maxPromise = numbers.inject(0, {a, b -&gt; a&gt;b?a:b}.asyncFun())
    println <span class="java-quote">"Look Ma, I can talk to the user <span class="java-keyword">while</span> the math is being done <span class="java-keyword">for</span> me!"</span>
    println maxPromise.get()
}</pre></div><p class="paragraph">The  <em class="italic">inject</em>  function doesn't really care what objects are being returned from the  <em class="italic">addition</em>  function, maybe it is just a little surprised that
each call to the  <em class="italic">addition</em>  function returns so fast, but doesn't moan much, keeps iterating and finally returns the overall result to you.</p><p class="paragraph">Now,
 this is the time you should stand behind what you say and do what you 
want others to do. Don't frown at the result and just accepts that you 
got back just a promise.
A <strong class="bold">promise</strong> to get the result delivered as 
soon as the calculation is done. The extra heat coming out of your 
laptop is an indication the calculation
exploits natural parallelism in your functions and makes its best effort
 to deliver the result to you quickly.</p><p class="paragraph"></p><blockquote class="note">
The  <em class="italic">promise</em>  is a good old  <em class="italic">DataflowVariable</em>  , so you may query its status, register notification hooks or make it an input to a Dataflow algorithm.
</blockquote><p class="paragraph"></p><div class="code"><pre>withPool {
    def sumPromise = (0..100000).inject(0, {a, b -&gt; a + b}.asyncFun())
    println <span class="java-quote">"Are we done yet? "</span> + sumPromise.bound
    sumPromise.whenBound {sum -&gt; println sum}
}</pre></div><p class="paragraph"></p><blockquote class="note">
The  <em class="italic">get()</em>  method has also a variant with a timeout parameter, if you want to avoid the risk of waiting indefinitely.
</blockquote><p class="paragraph"></p><h3>Can things go wrong?</h3><p class="paragraph">Sure. But you'll get an exception thrown from the result promise  <em class="italic">get()</em>  method.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">try</span> {
    sumPromise.get()
} <span class="java-keyword">catch</span> (MyCalculationException e) {
    println <span class="java-quote">"Guess, things are not ideal today."</span>
}</pre></div><p class="paragraph"></p><h3>This is all fine, but what functions can be really combined?</h3><p class="paragraph">There
 are no limits. Take any sequential functions you need to combine and 
you should be able to combine their asynchronous variants as well.</p><p class="paragraph">Back
 to our initial example comparing content of a file with a web page, we 
simply make all the functions asynchronous by calling
the  <em class="italic">asyncFun()</em>  method on them and we are ready to set off.</p><p class="paragraph"></p><div class="code"><pre>Closure download = {<span class="java-object">String</span> url -&gt;
        url.toURL().text
    }.asyncFun()<p class="paragraph">    Closure loadFile = {<span class="java-object">String</span> fileName -&gt;
        …  //load the file here
    }.asyncFun()</p><p class="paragraph">    Closure hash = {s -&gt; s.hashCode()}.asyncFun()</p><p class="paragraph">    Closure compare = {<span class="java-object">int</span> first, <span class="java-object">int</span> second -&gt;
        first == second
    }.asyncFun()</p><p class="paragraph">    def result = compare(hash(download('http://www.gpars.org')), hash(loadFile('/coolStuff/gpars/website/index.html')))
    println 'Allowed to <span class="java-keyword">do</span> something <span class="java-keyword">else</span> now'
    println <span class="java-quote">"The result of comparison: "</span> + result.get()</p></pre></div><p class="paragraph"></p><h3>Calling asynchronous functions from within asynchronous functions</h3><p class="paragraph">Another very valuable characteristics of asynchronous functions is that their result promises can also be composed.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.GParsPool.withPool<p class="paragraph">  withPool {
      Closure plus = {<span class="java-object">Integer</span> a, <span class="java-object">Integer</span> b -&gt;
          sleep 3000
          println 'Adding numbers'
          a + b
      }.asyncFun()</p><p class="paragraph">      Closure multiply = {<span class="java-object">Integer</span> a, <span class="java-object">Integer</span> b -&gt;
          sleep 2000
          a * b
      }.asyncFun()</p><p class="paragraph">      Closure measureTime = {-&gt;
          sleep 3000
          4
      }.asyncFun()</p><p class="paragraph">      Closure distance = {<span class="java-object">Integer</span> initialDistance, <span class="java-object">Integer</span> velocity, <span class="java-object">Integer</span> time -&gt;
          plus(initialDistance, multiply(velocity, time))
      }.asyncFun()</p><p class="paragraph">      Closure chattyDistance = {<span class="java-object">Integer</span> initialDistance, <span class="java-object">Integer</span> velocity, <span class="java-object">Integer</span> time -&gt;
          println 'All parameters are now ready - starting'
          println 'About to call another asynchronous function'
          def innerResultPromise = plus(initialDistance, multiply(velocity, time))
          println 'Returning the promise <span class="java-keyword">for</span> the <span class="java-keyword">inner</span> calculation as my own result'
          <span class="java-keyword">return</span> innerResultPromise
      }.asyncFun()</p><p class="paragraph">      println <span class="java-quote">"Distance = "</span> + distance(100, 20, measureTime()).get() + ' m'
      println <span class="java-quote">"ChattyDistance = "</span> + chattyDistance(100, 20, measureTime()).get() + ' m'
  }</p></pre></div><p class="paragraph">If an asynchronous function (e.f. the  <em class="italic">distance</em>  function in the example) in its body calls another asynchronous function
(e.g.  <em class="italic">plus</em>  ) and returns the the promise of the invoked function, the inner function's (  <em class="italic">plus</em>  ) result promise will compose with the outer function's (  <em class="italic">distance</em>  )
result promise. The inner function (  <em class="italic">plus</em>  ) will now bind its result to the outer function's (  <em class="italic">distance</em>
  ) promise, once the inner function (plus) finishes its calculation.
This ability of promises to compose allows functions to cease their 
calculation without blocking a thread not only when waiting for 
parameters,
but also whenever they call another asynchronous function anywhere in 
their body.</p><p class="paragraph"></p><h3>Methods as asynchronous functions</h3><p class="paragraph">Methods can be referred to as closures using the  <em class="italic">.&amp;</em>  operator. These closures can then be transformed using  <em class="italic">asyncFun</em>  into composable asynchronous functions just like ordinary closures.</p><p class="paragraph"></p><div class="code"><pre>class DownloadHelper {
    <span class="java-object">String</span> download(<span class="java-object">String</span> url) {
        url.toURL().text
    }<p class="paragraph">    <span class="java-object">int</span> scanFor(<span class="java-object">String</span> word, <span class="java-object">String</span> text) {
        text.findAll(word).size()
    }</p><p class="paragraph">    <span class="java-object">String</span> lower(s) {
        s.toLowerCase()
    }
}
//now we'll make the methods asynchronous
withPool {
    <span class="java-keyword">final</span> DownloadHelper d = <span class="java-keyword">new</span> DownloadHelper()
    Closure download = d.&amp;download.asyncFun()
    Closure scanFor = d.&amp;scanFor.asyncFun()
    Closure lower = d.&amp;lower.asyncFun()</p><p class="paragraph">    //asynchronous processing
    def result = scanFor('groovy', lower(download('http://www.infoq.com')))
    println 'Allowed to <span class="java-keyword">do</span> something <span class="java-keyword">else</span> now'
    println result.get()
}</p></pre></div><p class="paragraph"></p><h3>Using annotation to create asynchronous functions</h3><p class="paragraph">Instead of calling the  <em class="italic">asyncFun()</em>  function, the  <em class="italic">@AsyncFun</em>  annotation can be used to annotate Closure-typed fields.
The fields have to be initialized in-place and the containing class needs to be instantiated withing a  <em class="italic">withPool</em>  block.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.GParsPool.withPool
<span class="java-keyword">import</span> groovyx.gpars.AsyncFun<p class="paragraph">class DownloadingSearch {
    @AsyncFun Closure download = {<span class="java-object">String</span> url -&gt;
        url.toURL().text
    }</p><p class="paragraph">    @AsyncFun Closure scanFor = {<span class="java-object">String</span> word, <span class="java-object">String</span> text -&gt;
        text.findAll(word).size()
    }</p><p class="paragraph">    @AsyncFun Closure lower = {s -&gt; s.toLowerCase()}</p><p class="paragraph">    void scan() {
        def result = scanFor('groovy', lower(download('http://www.infoq.com')))  //synchronous processing
        println 'Allowed to <span class="java-keyword">do</span> something <span class="java-keyword">else</span> now'
        println result.get()
    }
}</p><p class="paragraph">withPool {
    <span class="java-keyword">new</span> DownloadingSearch().scan()
}</p></pre></div><p class="paragraph"></p><h4>Alternative pools</h4><p class="paragraph">The  <em class="italic">AsyncFun</em>  annotation by default uses an instance of  <em class="italic">GParsPool</em>  from the wrapping withPool block. You may, however, specify the type of pool explicitly:
</p><div class="code"><pre>@AsyncFun(GParsExecutorsPoolUtil) def sum6 = {a, b -&gt; a + b }</pre></div><p class="paragraph"></p><h4>Blocking functions through annotations</h4><p class="paragraph">The  <em class="italic">AsyncFun</em>
  also allows the user to specify, whether the resulting function should
 have blocking (true) or non-blocking (false - default) semantics.</p><p class="paragraph"></p><div class="code"><pre>@AsyncFun(blocking = <span class="java-keyword">true</span>)
def sum = {a, b -&gt; a + b }</pre></div><p class="paragraph"></p><h4>Explicit and delayed pool assignment</h4><p class="paragraph">When using the  <em class="italic">GPars(Executors)PoolUtil.asyncFun()</em>  function directly to create an asynchronous function you have two additional options
to assign a thread pool to the function.
</p><ol>
<li>The thread pool to use by the function can be specified explicitly as an additional argument at creation time</li>
<li>The implicit thread pool can be obtained from the surrounding scope at invocation rather at creation time</li>
</ol><p class="paragraph">When specifying the thread pool explicitly, the call doesn't need to be wrapped in an  <em class="italic">withPool()</em>  block:
</p><div class="code"><pre>Closure sPlus = {<span class="java-object">Integer</span> a, <span class="java-object">Integer</span> b -&gt;
    a + b
}<p class="paragraph">Closure sMultiply = {<span class="java-object">Integer</span> a, <span class="java-object">Integer</span> b -&gt;
    sleep 2000
    a * b
}</p><p class="paragraph">println <span class="java-quote">"Synchronous result: "</span> + sMultiply(sPlus(10, 30), 100)</p><p class="paragraph"><span class="java-keyword">final</span> pool = <span class="java-keyword">new</span> FJPool()</p><p class="paragraph">Closure aPlus = GParsPoolUtil.asyncFun(sPlus, pool)
Closure aMultiply = GParsPoolUtil.asyncFun(sMultiply, pool)</p><p class="paragraph">def result = aMultiply(aPlus(10, 30), 100)</p><p class="paragraph">println <span class="java-quote">"Time to <span class="java-keyword">do</span> something <span class="java-keyword">else</span> <span class="java-keyword">while</span> the calculation is running"</span>
println <span class="java-quote">"Asynchronous result: "</span> + result.get()</p></pre></div><p class="paragraph">With delayed pool assignment only the function invocation must be surrounded with a  <em class="italic">withPool()</em>  block:</p><p class="paragraph"></p><div class="code"><pre>Closure aPlus = GParsPoolUtil.asyncFun(sPlus)
Closure aMultiply = GParsPoolUtil.asyncFun(sMultiply)<p class="paragraph">withPool {
    def result = aMultiply(aPlus(10, 30), 100)</p><p class="paragraph">    println <span class="java-quote">"Time to <span class="java-keyword">do</span> something <span class="java-keyword">else</span> <span class="java-keyword">while</span> the calculation is running"</span>
    println <span class="java-quote">"Asynchronous result: "</span> + result.get()
}</p></pre></div><p class="paragraph">On our side this is a very 
interesting domain to explore, so any comments, questions or suggestions
 on combining asynchronous functions or hints about its limits are 
welcome.



</p><h2 id="dataParallelism_fork-join">3.6 Fork-Join</h2>
Fork/Join or Divide and Conquer is a very powerful abstraction to solve hierarchical problems.<p class="paragraph"></p><h2>The abstraction</h2><p class="paragraph">When talking about hierarchical problems, think about quick sort, merge sort, file system or general tree navigation and such.
</p><ul class="star">
<li>Fork / Join algorithms essentially split a problem at hands into 
several smaller sub-problems and recursively apply the same algorithm to
 each of the sub-problems.</li>
<li>Once the sub-problem is small enough, it is solved directly.</li>
<li>The solutions of all sub-problems are combined to solve their parent problem, which in turn helps solve its own parent problem.</li>
</ul><p class="paragraph"></p><blockquote class="note">
Check out the fancy <a href="http://blog.krecan.net/2011/03/27/visualizing-forkjoin/" target="blank">interactive Fork/Join visualization demo</a> ,
which will show you how threads cooperate to solve a common divide-and-conquer algorithm.
</blockquote><p class="paragraph">The mighty <strong class="bold">JSR-166y</strong>
 library solves Fork / Join orchestration pretty nicely for us, but 
leaves a couple of rough edges, which can hurt you, if you don't pay 
attention enough. You still deal
with threads, pools or synchronization barriers.</p><p class="paragraph"></p><h3>The GPars abstraction convenience layer</h3><p class="paragraph">GPars
 can hide the complexities of dealing with threads, pools and recursive 
tasks from you, yet let you leverage the powerful Fork/Join 
implementation in jsr166y.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.GParsPool.runForkJoin
<span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.GParsPool.withPool<p class="paragraph">withPool() {
    println <span class="java-quote">""</span><span class="java-quote">"<span class="java-object">Number</span> of files: ${
        runForkJoin(<span class="java-keyword">new</span> File("</span>./src<span class="java-quote">")) {file -&gt;
            <span class="java-object">long</span> count = 0
            file.eachFile {
                <span class="java-keyword">if</span> (it.isDirectory()) {
                    println "</span>Forking a child task <span class="java-keyword">for</span> $it<span class="java-quote">"
                    forkOffChild(it)           //fork a child task
                } <span class="java-keyword">else</span> {
                    count++
                }
            }
            <span class="java-keyword">return</span> count + (childrenResults.sum(0))
            //use results of children tasks to calculate and store own result
        }
    }"</span><span class="java-quote">""</span>
}</p></pre></div><p class="paragraph">The  <em class="italic">runForkJoin()</em>  factory method will use the supplied recursive code together with the provided values and build a hierarchical Fork/Join
calculation. The number of values passed to the  <em class="italic">runForkJoin()</em>  method must match the number of expected parameters of the closure as well as
the number of arguments passed into the  <em class="italic">forkOffChild()</em>  or  <em class="italic">runChildDirectly()</em>  methods.</p><p class="paragraph"></p><div class="code"><pre>def quicksort(numbers) {
    withPool {
        runForkJoin(0, numbers) {index, list -&gt;
            def groups = list.groupBy {it &lt;=&gt; list[list.size().intdiv(2)]}
            <span class="java-keyword">if</span> ((list.size() &lt; 2) || (groups.size() == 1)) {
                <span class="java-keyword">return</span> [index: index, list: list.clone()]
            }
            (-1..1).each {forkOffChild(it, groups[it] ?: [])}
            <span class="java-keyword">return</span> [index: index, list: childrenResults.sort {it.index}.sum {it.list}]
        }.list
    }
}</pre></div><p class="paragraph"></p><blockquote class="note">
The important piece of the puzzle that needs to be mentioned here is that  <em class="italic">forkOffChild()</em>  doesn't wait for the child to run.
It merely schedules it for execution some time in the future. If a child fails by throwing an exception, you should not expect
the exception to be fired from the forkOffChild() method itself. The exception ise likely to happen long after the parent
has returned from the call to the  <em class="italic">forkOffChild()</em>  method.<p class="paragraph">It is the  <em class="italic">getChildrenResults()</em>  method that will re-throw exceptions that happened in the child sub-tasks back to the parent task.
</p></blockquote><p class="paragraph"></p><h4>Alternative approach</h4><p class="paragraph">Alternatively, the underlying mechanism of nested Fork/Join worker tasks can be used directly. Custom-tailored workers can
eliminate the performance overhead associated with parameter spreading imposed when using the generic workers. Also, custom
workers can be implemented in Java and so further increase the performance of the algorithm.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">public</span> <span class="java-keyword">final</span> class FileCounter <span class="java-keyword">extends</span> AbstractForkJoinWorker&lt;<span class="java-object">Long</span>&gt; {
    <span class="java-keyword">private</span> <span class="java-keyword">final</span> File file;<p class="paragraph">    def FileCounter(<span class="java-keyword">final</span> File file) {
        <span class="java-keyword">this</span>.file = file
    }</p><p class="paragraph">    @Override
    <span class="java-keyword">protected</span> <span class="java-object">Long</span> computeTask() {
        <span class="java-object">long</span> count = 0;
        file.eachFile {
            <span class="java-keyword">if</span> (it.isDirectory()) {
                println <span class="java-quote">"Forking a thread <span class="java-keyword">for</span> $it"</span>
                forkOffChild(<span class="java-keyword">new</span> FileCounter(it))           //fork a child task
            } <span class="java-keyword">else</span> {
                count++
            }
        }
        <span class="java-keyword">return</span> count + ((childrenResults)?.sum() ?: 0)  //use results of children tasks to calculate and store own result
    }
}</p><p class="paragraph">withPool(1) {pool -&gt;  //feel free to experiment with the number of fork/join threads in the pool
    println <span class="java-quote">"<span class="java-object">Number</span> of files: ${runForkJoin(<span class="java-keyword">new</span> FileCounter(<span class="java-keyword">new</span> File("</span>..<span class="java-quote">")))}"</span>
}</p></pre></div><p class="paragraph">The AbstractForkJoinWorker subclasses may be written both in Java or Groovy, giving you the option to easily optimize
for execution speed, if row performance of the worker becomes a bottleneck.</p><p class="paragraph"></p><h3>Fork / Join saves your resources</h3><p class="paragraph">Fork/Join
 operations can be safely run with small number of threads thanks to 
internally using the TaskBarrier class to synchronize the threads. While
 a thread is blocked inside an algorithm waiting for its sub-problems to
 be calculated, the thread is silently returned to the pool to take on 
any of the available sub-problems from the task queue and process them.
Although the algorithm creates as many tasks as there are 
sub-directories and tasks wait for the sub-directory tasks to complete, 
as few as one thread is enough to keep the computation going and 
eventually calculate a valid result.</p><p class="paragraph"></p><h3>Mergesort example</h3><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.GParsPool.runForkJoin
<span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.GParsPool.withPool<p class="paragraph">/**
 * Splits a list of numbers in half
 */
def split(List&lt;<span class="java-object">Integer</span>&gt; list) {
    <span class="java-object">int</span> listSize = list.size()
    <span class="java-object">int</span> middleIndex = listSize / 2
    def list1 = list[0..&lt;middleIndex]
    def list2 = list[middleIndex..listSize - 1]
    <span class="java-keyword">return</span> [list1, list2]
}</p><p class="paragraph">/**
 * Merges two sorted lists into one
 */
List&lt;<span class="java-object">Integer</span>&gt; merge(List&lt;<span class="java-object">Integer</span>&gt; a, List&lt;<span class="java-object">Integer</span>&gt; b) {
    <span class="java-object">int</span> i = 0, j = 0
    <span class="java-keyword">final</span> <span class="java-object">int</span> newSize = a.size() + b.size()
    List&lt;<span class="java-object">Integer</span>&gt; result = <span class="java-keyword">new</span> ArrayList&lt;<span class="java-object">Integer</span>&gt;(newSize)</p><p class="paragraph">    <span class="java-keyword">while</span> ((i &lt; a.size()) &amp;&amp; (j &lt; b.size())) {
        <span class="java-keyword">if</span> (a[i] &lt;= b[j]) result &lt;&lt; a[i++]
        <span class="java-keyword">else</span> result &lt;&lt; b[j++]
    }</p><p class="paragraph">    <span class="java-keyword">if</span> (i &lt; a.size()) result.addAll(a[i..-1])
    <span class="java-keyword">else</span> result.addAll(b[j..-1])
    <span class="java-keyword">return</span> result
}</p><p class="paragraph"><span class="java-keyword">final</span> def numbers = [1, 5, 2, 4, 3, 8, 6, 7, 3, 4, 5, 2, 2, 9, 8, 7, 6, 7, 8, 1, 4, 1, 7, 5, 8, 2, 3, 9, 5, 7, 4, 3]</p><p class="paragraph">withPool(3) {  //feel free to experiment with the number of fork/join threads in the pool
    println <span class="java-quote">""</span><span class="java-quote">"Sorted numbers: ${
        runForkJoin(numbers) {nums -&gt;
            println "</span><span class="java-object">Thread</span> ${<span class="java-object">Thread</span>.currentThread().name[-1]}: Sorting $nums<span class="java-quote">"
            <span class="java-keyword">switch</span> (nums.size()) {
                <span class="java-keyword">case</span> 0..1:
                    <span class="java-keyword">return</span> nums                                   //store own result
                <span class="java-keyword">case</span> 2:
                    <span class="java-keyword">if</span> (nums[0] &lt;= nums[1]) <span class="java-keyword">return</span> nums     //store own result
                    <span class="java-keyword">else</span> <span class="java-keyword">return</span> nums[-1..0]                       //store own result
                <span class="java-keyword">default</span>:
                    def splitList = split(nums)
                    [splitList[0], splitList[1]].each {forkOffChild it}  //fork a child task
                    <span class="java-keyword">return</span> merge(* childrenResults)      //use results of children tasks to calculate and store own result
            }
        }
    }"</span><span class="java-quote">""</span>
}</p></pre></div>
<h3>Mergesort example using a custom-tailored worker class</h3><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">public</span> <span class="java-keyword">final</span> class SortWorker <span class="java-keyword">extends</span> AbstractForkJoinWorker&lt;List&lt;<span class="java-object">Integer</span>&gt;&gt; {
    <span class="java-keyword">private</span> <span class="java-keyword">final</span> List numbers<p class="paragraph">    def SortWorker(<span class="java-keyword">final</span> List&lt;<span class="java-object">Integer</span>&gt; numbers) {
        <span class="java-keyword">this</span>.numbers = numbers.asImmutable()
    }</p><p class="paragraph">    /**
     * Splits a list of numbers in half
     */
    def split(List&lt;<span class="java-object">Integer</span>&gt; list) {
        <span class="java-object">int</span> listSize = list.size()
        <span class="java-object">int</span> middleIndex = listSize / 2
        def list1 = list[0..&lt;middleIndex]
        def list2 = list[middleIndex..listSize - 1]
        <span class="java-keyword">return</span> [list1, list2]
    }</p><p class="paragraph">    /**
     * Merges two sorted lists into one
     */
    List&lt;<span class="java-object">Integer</span>&gt; merge(List&lt;<span class="java-object">Integer</span>&gt; a, List&lt;<span class="java-object">Integer</span>&gt; b) {
        <span class="java-object">int</span> i = 0, j = 0
        <span class="java-keyword">final</span> <span class="java-object">int</span> newSize = a.size() + b.size()
        List&lt;<span class="java-object">Integer</span>&gt; result = <span class="java-keyword">new</span> ArrayList&lt;<span class="java-object">Integer</span>&gt;(newSize)</p><p class="paragraph">        <span class="java-keyword">while</span> ((i &lt; a.size()) &amp;&amp; (j &lt; b.size())) {
            <span class="java-keyword">if</span> (a[i] &lt;= b[j]) result &lt;&lt; a[i++]
            <span class="java-keyword">else</span> result &lt;&lt; b[j++]
        }</p><p class="paragraph">        <span class="java-keyword">if</span> (i &lt; a.size()) result.addAll(a[i..-1])
        <span class="java-keyword">else</span> result.addAll(b[j..-1])
        <span class="java-keyword">return</span> result
    }</p><p class="paragraph">    /**
     * Sorts a small list or delegates to two children, <span class="java-keyword">if</span> the list contains more than two elements.
     */
    @Override
    <span class="java-keyword">protected</span> List&lt;<span class="java-object">Integer</span>&gt; computeTask() {
        println <span class="java-quote">"<span class="java-object">Thread</span> ${<span class="java-object">Thread</span>.currentThread().name[-1]}: Sorting $numbers"</span>
        <span class="java-keyword">switch</span> (numbers.size()) {
            <span class="java-keyword">case</span> 0..1:
                <span class="java-keyword">return</span> numbers                                   //store own result
            <span class="java-keyword">case</span> 2:
                <span class="java-keyword">if</span> (numbers[0] &lt;= numbers[1]) <span class="java-keyword">return</span> numbers     //store own result
                <span class="java-keyword">else</span> <span class="java-keyword">return</span> numbers[-1..0]                       //store own result
            <span class="java-keyword">default</span>:
                def splitList = split(numbers)
                [<span class="java-keyword">new</span> SortWorker(splitList[0]), <span class="java-keyword">new</span> SortWorker(splitList[1])].each{forkOffChild it}  //fork a child task
                <span class="java-keyword">return</span> merge(* childrenResults)      //use results of children tasks to calculate and store own result
        }
    }
}</p><p class="paragraph"><span class="java-keyword">final</span> def numbers = [1, 5, 2, 4, 3, 8, 6, 7, 3, 4, 5, 2, 2, 9, 8, 7, 6, 7, 8, 1, 4, 1, 7, 5, 8, 2, 3, 9, 5, 7, 4, 3]</p><p class="paragraph">withPool(1) {  //feel free to experiment with the number of fork/join threads in the pool
    println <span class="java-quote">"Sorted numbers: ${runForkJoin(<span class="java-keyword">new</span> SortWorker(numbers))}"</span>
}</p></pre></div><p class="paragraph"></p><h3>Running child tasks directly</h3><p class="paragraph">The  <em class="italic">forkOffChild()</em>  method has a sibling - the  <em class="italic">runChildDirectly()</em>  method, which will run the child task directly and immediately
within the current thread instead of scheduling the child task for asynchronous processing on the thread pool. Typically you'll
call _forkOffChild() on all sub-tasks but the last, which you invoke directly without the scheduling overhead.
</p><div class="code"><pre>Closure fib = {number -&gt;
            <span class="java-keyword">if</span> (number &lt;= 2) {
                <span class="java-keyword">return</span> 1
            }
            forkOffChild(number - 1)                            //  This task will run asynchronously, probably in a different thread
            <span class="java-keyword">final</span> def result = runChildDirectly(number - 2)     //  This task is run directly within the current thread
            <span class="java-keyword">return</span> (<span class="java-object">Integer</span>) getChildrenResults().sum() + result
        }<p class="paragraph">        withPool {
            assert 55 == runForkJoin(10, fib)
        }</p></pre></div><p class="paragraph"></p><h3>Availability</h3><p class="paragraph">This feature is only available when using in the Fork/Join-based  <em class="italic">GParsPool</em>  , not in  <em class="italic">GParsExecutorsPool</em>  .



</p><h2 id="dataParallelism_parallelSpeculations">3.7 Parallel Speculations</h2>
With processor cores having become plentiful, some algorithms might 
benefit from brutal-force parallel duplication.
Instead of deciding up-front about how to solve a problem, what 
algorithm to use or which location to connect to, you run all potential
solutions in parallel.<p class="paragraph"></p><h2>Parallel speculations</h2><p class="paragraph">Imagine
 you need to perform a task like e.g. calculate an expensive function or
 read data from a file, database or internet. Luckily, you know of 
several good ways (e.g. functions or urls)
to achieve your goal. However, they are not all equal. Although they 
return back the same (as far as your needs are concerned) result, they 
may all take different amount of time to complete
and some of them may even fail (e.g. network issues). What's worse, 
no-one is going to tell you which path gives you the solution first nor 
which paths lead to no solution at all. Shall I
run  <em class="italic">quick sort</em>  or  <em class="italic">merge sort</em>  on my list? Which url will work best? Is this service available at its primary location or should I use the backup one?</p><p class="paragraph">GPars
 speculations give you the option to try all the available alternatives 
in parallel and so get the result from the fastest functional path, 
silently ignoring the slow or broken ones.</p><p class="paragraph">This is what the  <em class="italic">speculate()</em>  methods on  <em class="italic">GParsPool</em>  and  <em class="italic">GParsExecutorsPool()</em>  can do.</p><p class="paragraph"></p><div class="code"><pre>def numbers = …
def quickSort = …
def mergeSort = …
def sortedNumbers = speculate(quickSort, mergeSort)</pre></div><p class="paragraph">Here we're performing both  <em class="italic">quick sort</em>  and  <em class="italic">merge sort</em>  <strong class="bold">concurrently</strong>,
 while getting the result of the faster one. Given the parallel 
resources available these days on mainstream hardware,
running the two functions in parallel will not have dramatic impact on 
speed of calculation of either one, and so we get the result in about 
the same time as if we ran solely the faster of the two
calculations. And we get the result sooner than when running the slower 
one. Yet we didn't have to know up-front, which of the two sorting 
algorithms would perform better on our data. Thus
we speculated.</p><p class="paragraph">Similarly, downloading a document from multiple sources of different speed and reliability would look like this:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.GParsPool.speculate
<span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.GParsPool.withPool<p class="paragraph">def alternative1 = {
    'http://www.dzone.com/links/index.html'.toURL().text
}</p><p class="paragraph">def alternative2 = {
    'http://www.dzone.com/'.toURL().text
}</p><p class="paragraph">def alternative3 = {
    'http://www.dzzzzzone.com/'.toURL().text  //wrong url
}</p><p class="paragraph">def alternative4 = {
    'http://dzone.com/'.toURL().text
}</p><p class="paragraph">withPool(4) {
    println speculate([alternative1, alternative2, alternative3, alternative4]).contains('groovy')
}</p></pre></div><p class="paragraph"></p><blockquote class="note">
Make sure the surrounding thread pool has enough threads to process all 
alternatives in parallel. The size of the pool should match
the number of closures supplied.
</blockquote><p class="paragraph"></p><h3>Alternatives using dataflow variables and streams</h3><p class="paragraph">In
 cases, when stopping unsuccessful alternatives is not needed, dataflow 
variables or streams may be used to obtain the result value
from the winning speculation.</p><p class="paragraph"></p><blockquote class="note">
Please refer to the Dataflow Concurrency section of the User Guide for details on Dataflow variables and streams.
</blockquote><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowQueue
<span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.Dataflow.task<p class="paragraph">def alternative1 = {
    'http://www.dzone.com/links/index.html'.toURL().text
}</p><p class="paragraph">def alternative2 = {
    'http://www.dzone.com/'.toURL().text
}</p><p class="paragraph">def alternative3 = {
    'http://www.dzzzzzone.com/'.toURL().text  //will fail due to wrong url
}</p><p class="paragraph">def alternative4 = {
    'http://dzone.com/'.toURL().text
}</p><p class="paragraph">//Pick either one of the following, both will work:
<span class="java-keyword">final</span> def result = <span class="java-keyword">new</span> DataflowQueue()
//  <span class="java-keyword">final</span> def result = <span class="java-keyword">new</span> DataflowVariable()</p><p class="paragraph">[alternative1, alternative2, alternative3, alternative4].each {code -&gt;
    task {
        <span class="java-keyword">try</span> {
            result &lt;&lt; code()
        } <span class="java-keyword">catch</span> (ignore) { }  //We deliberately ignore unsuccessful urls
    }
}</p><p class="paragraph">println result.val.contains('groovy')</p></pre></div>



<h1 id="GroovyCSP">4 Groovy CSP</h1>
The CSP (Communicating Sequential Processes) abstraction builds on 
independent composable processes, which exchange messages in a 
synchronous manner.
GPars leverages <a href="http://www.cs.kent.ac.uk/projects/ofa/jcsp/" target="blank">the JCSP library</a> developed at the University of Kent, UK.<p class="paragraph">Jon Kerridge, the author of the CSP implementation in GPars, provides exhaustive examples on of GroovyCSP use at
<a href="http://www.soc.napier.ac.uk/%7Ecs10/#_Toc271192596" target="blank">his website:</a></p><p class="paragraph"></p><blockquote class="note">
The GroovyCSP implementation leverages JCSP, a Java-based CSP library, which is licensed under LGPL. There are some differences
between the Apache 2 license, which GPars uses, and LGPL. Please make sure your application conforms to the LGPL
rules before enabling the use of JCSP in your code.
</blockquote><p class="paragraph">If the LGPL license is not adequate 
for your use, you might consider checking out the Dataflow Concurrency 
chapter of this User Guide
to learn about  <em class="italic">tasks</em>  ,  <em class="italic">selectors</em>  and  <em class="italic">operators</em>  , which may help you resolve concurrency issues in ways similar to the CSP approach.
In fact the dataflow and CSP concepts, as implemented in GPars, stand very close to each other.</p><p class="paragraph"></p><blockquote class="note">
By default, without actively adding an explicit dependency on JCSP in 
your build file or downloading and including the JCSP jar file in your 
project,
the standard commercial-software-friendly Apache 2 License terms apply 
to your project. GPars directly only depends on software licensed under 
licenses
compatible with the Apache 2 License.
</blockquote><p class="paragraph"></p><h2>The CSP model principles</h2><p class="paragraph">In
 essence, the CSP model builds on independent concurrent processes, 
which mutually communicate through channels using synchronous
(i.e. rendezvous) message passing. Unlike actors or dataflow operators, 
which revolve around the event-processing pattern,
CSP processes place focus the their activities (aka sequences of steps) 
and use communication to stay mutually in sync along the way.</p><p class="paragraph">Since
 the addressing is indirect through channels, the processes do not need 
to know about one another. They typically
consist of a set of input and output channels and a body. Once a CSP 
process is started, it obtains a thread from a thread pool
and starts processing its body, pausing only when reading from a channel
 or writing into a channel. Some implementations (e.g. GoLang)
can also detach the thread from the CSP process when blocked on a 
channel.</p><p class="paragraph">CSP programs are deterministic. The same data on the program's input will always generate the same output, irrespective of
the actual thread-scheduling scheme used. This helps a lot when debugging CSP programs as well as analyzing deadlocks.</p><p class="paragraph">Determinism combined with indirect addressing result in a great level of composability of CSP processes. You can combine
small CSP processes into bigger ones just by connecting their input and output channels and then wrapping them by another,
bigger containing process.</p><p class="paragraph">The CSP model introduces non-determinism using  <em class="italic">Alternatives</em> . A process can attempt to read a value from multiple channels
at the same time through a construct called  <em class="italic">Alternative</em>  or  <em class="italic">Select</em> . The first value that becomes available in any of the channels
involved in the  <em class="italic">Select</em>  will be read and consumed by the process. Since the order of messages received through a  <em class="italic">Select</em> 
depends on unpredictable conditions during program run-time, the value that will get read is non-deterministic.</p><p class="paragraph"></p><h2>CSP with GPars dataflow</h2><p class="paragraph">GPars provides all the necessary building blocks to create CSP processes.
</p><ul class="star">
<li><strong class="bold">CSP Processes</strong> can be modelled through GPars tasks using a  <em class="italic">Closure</em> , a  <em class="italic">Runnable</em>  or a  <em class="italic">Callable</em>  to hold the actual implementation of the process</li>
<li><strong class="bold">CSP Channels</strong> should be modelled with  <em class="italic">SyncDataflowQueue</em>  and  <em class="italic">SyncDataflowBroadcast</em>  classes</li>
<li><strong class="bold">CSP Alternative</strong> is provided through the  <em class="italic">Select</em>  class with its  <em class="italic">select</em>  and  <em class="italic"> prioritySelect</em>  methods</li>
</ul><p class="paragraph"></p><h3>Processes</h3><p class="paragraph">To start a process simply use the  <em class="italic">task</em>  factory method.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.group.DefaultPGroup
<span class="java-keyword">import</span> groovyx.gpars.scheduler.ResizeablePool<p class="paragraph">group = <span class="java-keyword">new</span> DefaultPGroup(<span class="java-keyword">new</span> ResizeablePool(<span class="java-keyword">true</span>))</p><p class="paragraph">def t = group.task {
    println <span class="java-quote">"I am a process"</span>
}</p><p class="paragraph">t.join()</p></pre></div><p class="paragraph"></p><blockquote class="note">
Since each process consumes a thread for its lifetime, it is advisable to use resizeable thread pools as in the example above.
</blockquote><p class="paragraph">A process can also be created from a Runnable or Callable object:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.group.DefaultPGroup
<span class="java-keyword">import</span> groovyx.gpars.scheduler.ResizeablePool<p class="paragraph">group = <span class="java-keyword">new</span> DefaultPGroup(<span class="java-keyword">new</span> ResizeablePool(<span class="java-keyword">true</span>))</p><p class="paragraph">class MyProcess <span class="java-keyword">implements</span> <span class="java-object">Runnable</span> {</p><p class="paragraph">    @Override
    void run() {
        println <span class="java-quote">"I am a process"</span>
    }
}
def t = group.task <span class="java-keyword">new</span> MyProcess()</p><p class="paragraph">t.join()</p></pre></div><p class="paragraph">Using Callable allows for values to be returned through the  <em class="italic">get()</em>  method:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.group.DefaultPGroup
<span class="java-keyword">import</span> groovyx.gpars.scheduler.ResizeablePool<p class="paragraph"><span class="java-keyword">import</span> java.util.concurrent.Callable</p><p class="paragraph">group = <span class="java-keyword">new</span> DefaultPGroup(<span class="java-keyword">new</span> ResizeablePool(<span class="java-keyword">true</span>))</p><p class="paragraph">class MyProcess <span class="java-keyword">implements</span> Callable&lt;<span class="java-object">String</span>&gt; {</p><p class="paragraph">    @Override
    <span class="java-object">String</span> call() {
        println <span class="java-quote">"I am a process"</span>
        <span class="java-keyword">return</span> <span class="java-quote">"CSP is great!"</span>
    }
}
def t = group.task <span class="java-keyword">new</span> MyProcess()</p><p class="paragraph">println t.get()</p></pre></div><p class="paragraph"></p><h3>Channels</h3><p class="paragraph">Processes typically need channels to communicate with the other processes as well as with the outside world:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovy.transform.TupleConstructor
<span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowReadChannel
<span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowWriteChannel
<span class="java-keyword">import</span> groovyx.gpars.group.DefaultPGroup
<span class="java-keyword">import</span> groovyx.gpars.scheduler.ResizeablePool<p class="paragraph"><span class="java-keyword">import</span> java.util.concurrent.Callable
<span class="java-keyword">import</span> groovyx.gpars.dataflow.SyncDataflowQueue</p><p class="paragraph">group = <span class="java-keyword">new</span> DefaultPGroup(<span class="java-keyword">new</span> ResizeablePool(<span class="java-keyword">true</span>))</p><p class="paragraph">@TupleConstructor
class Greeter <span class="java-keyword">implements</span> Callable&lt;<span class="java-object">String</span>&gt; {
    DataflowReadChannel names
    DataflowWriteChannel greetings</p><p class="paragraph">    @Override
    <span class="java-object">String</span> call() {
        <span class="java-keyword">while</span>(!<span class="java-object">Thread</span>.currentThread().isInterrupted()) {
            <span class="java-object">String</span> name = names.val
            greetings &lt;&lt; <span class="java-quote">"Hello "</span> + name
        }
        <span class="java-keyword">return</span> <span class="java-quote">"CSP is great!"</span>
    }
}</p><p class="paragraph">def a = <span class="java-keyword">new</span> SyncDataflowQueue()
def b = <span class="java-keyword">new</span> SyncDataflowQueue()</p><p class="paragraph">group.task <span class="java-keyword">new</span> Greeter(a, b)</p><p class="paragraph">a &lt;&lt; <span class="java-quote">"Joe"</span>
a &lt;&lt; <span class="java-quote">"Dave"</span>
println b.val
println b.val</p></pre></div><p class="paragraph"></p><blockquote class="note">
The CSP model uses synchronous messaging, however, in GPars you may 
consider using asynchronous channels as well as synchronous ones.
You can also combine these two types of channels within the same 
process.
</blockquote><p class="paragraph"></p><h3>Composition</h3><p class="paragraph">Grouping processes is then just a matter of connecting them with channels:</p><p class="paragraph"></p><div class="code"><pre>group = <span class="java-keyword">new</span> DefaultPGroup(<span class="java-keyword">new</span> ResizeablePool(<span class="java-keyword">true</span>))<p class="paragraph">@TupleConstructor
class Formatter <span class="java-keyword">implements</span> Callable&lt;<span class="java-object">String</span>&gt; {
    DataflowReadChannel rawNames
    DataflowWriteChannel formattedNames</p><p class="paragraph">    @Override
    <span class="java-object">String</span> call() {
        <span class="java-keyword">while</span>(!<span class="java-object">Thread</span>.currentThread().isInterrupted()) {
            <span class="java-object">String</span> name = rawNames.val
            formattedNames &lt;&lt; name.toUpperCase()
        }
    }
}</p><p class="paragraph">@TupleConstructor
class Greeter <span class="java-keyword">implements</span> Callable&lt;<span class="java-object">String</span>&gt; {
    DataflowReadChannel names
    DataflowWriteChannel greetings</p><p class="paragraph">    @Override
    <span class="java-object">String</span> call() {
        <span class="java-keyword">while</span>(!<span class="java-object">Thread</span>.currentThread().isInterrupted()) {
            <span class="java-object">String</span> name = names.val
            greetings &lt;&lt; <span class="java-quote">"Hello "</span> + name
        }
    }
}</p><p class="paragraph">def a = <span class="java-keyword">new</span> SyncDataflowQueue()
def b = <span class="java-keyword">new</span> SyncDataflowQueue()
def c = <span class="java-keyword">new</span> SyncDataflowQueue()</p><p class="paragraph">group.task <span class="java-keyword">new</span> Formatter(a, b)
group.task <span class="java-keyword">new</span> Greeter(b, c)</p><p class="paragraph">a &lt;&lt; <span class="java-quote">"Joe"</span>
a &lt;&lt; <span class="java-quote">"Dave"</span>
println c.val
println c.val</p></pre></div><p class="paragraph"></p><h3>Alternatives</h3><p class="paragraph">To introduce non-determinist GPars offers the  <em class="italic">Select</em>  class with its  <em class="italic">select</em>  and  <em class="italic">prioritySelect</em>  methods:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovy.transform.TupleConstructor
<span class="java-keyword">import</span> groovyx.gpars.dataflow.SyncDataflowQueue
<span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowReadChannel
<span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowWriteChannel
<span class="java-keyword">import</span> groovyx.gpars.dataflow.Select
<span class="java-keyword">import</span> groovyx.gpars.group.DefaultPGroup
<span class="java-keyword">import</span> groovyx.gpars.scheduler.ResizeablePool<p class="paragraph"><span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.Dataflow.select</p><p class="paragraph">group = <span class="java-keyword">new</span> DefaultPGroup(<span class="java-keyword">new</span> ResizeablePool(<span class="java-keyword">true</span>))</p><p class="paragraph">@TupleConstructor
class Receptionist <span class="java-keyword">implements</span> <span class="java-object">Runnable</span> {
    DataflowReadChannel emails
    DataflowReadChannel phoneCalls
    DataflowReadChannel tweets
    DataflowWriteChannel forwardedMessages</p><p class="paragraph">    <span class="java-keyword">private</span> <span class="java-keyword">final</span> Select incomingRequests = select([phoneCalls, emails, tweets])  //prioritySelect() would give highest precedence to phone calls</p><p class="paragraph">    @Override
    void run() {
        <span class="java-keyword">while</span>(!<span class="java-object">Thread</span>.currentThread().isInterrupted()) {
            <span class="java-object">String</span> msg = incomingRequests.select()
            forwardedMessages &lt;&lt; msg.toUpperCase()
        }
    }
}</p><p class="paragraph">def a = <span class="java-keyword">new</span> SyncDataflowQueue()
def b = <span class="java-keyword">new</span> SyncDataflowQueue()
def c = <span class="java-keyword">new</span> SyncDataflowQueue()
def d = <span class="java-keyword">new</span> SyncDataflowQueue()</p><p class="paragraph">group.task <span class="java-keyword">new</span> Receptionist(a, b, c, d)</p><p class="paragraph">a &lt;&lt; <span class="java-quote">"my email"</span>
b &lt;&lt; <span class="java-quote">"my phone call"</span>
c &lt;&lt; <span class="java-quote">"my tweet"</span></p><p class="paragraph">//The values come in random order since the process uses a Select to read its input
3.times{
    println d.val.value
}</p></pre></div><p class="paragraph">
</p><h3>Components</h3><p class="paragraph">CSP processes can be 
composed into larger entities. Suppose you already have a set of CSP 
processes (aka Runnable/Callable classes),
you can compose them into a larger process:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> class Prefix <span class="java-keyword">implements</span> Callable {
    <span class="java-keyword">private</span> <span class="java-keyword">final</span> DataflowChannel inChannel
    <span class="java-keyword">private</span> <span class="java-keyword">final</span> DataflowChannel outChannel
    <span class="java-keyword">private</span> <span class="java-keyword">final</span> def prefix<p class="paragraph">    def Prefix(<span class="java-keyword">final</span> inChannel, <span class="java-keyword">final</span> outChannel, <span class="java-keyword">final</span> prefix) {
        <span class="java-keyword">this</span>.inChannel = inChannel;
        <span class="java-keyword">this</span>.outChannel = outChannel;
        <span class="java-keyword">this</span>.prefix = prefix
    }</p><p class="paragraph">    <span class="java-keyword">public</span> def call() {
        outChannel &lt;&lt; prefix
        <span class="java-keyword">while</span> (<span class="java-keyword">true</span>) {
            sleep 200
            outChannel &lt;&lt; inChannel.val
        }
    }
}</p></pre></div><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> class Copy <span class="java-keyword">implements</span> Callable {
    <span class="java-keyword">private</span> <span class="java-keyword">final</span> DataflowChannel inChannel
    <span class="java-keyword">private</span> <span class="java-keyword">final</span> DataflowChannel outChannel1
    <span class="java-keyword">private</span> <span class="java-keyword">final</span> DataflowChannel outChannel2<p class="paragraph">    def Copy(<span class="java-keyword">final</span> inChannel, <span class="java-keyword">final</span> outChannel1, <span class="java-keyword">final</span> outChannel2) {
        <span class="java-keyword">this</span>.inChannel = inChannel;
        <span class="java-keyword">this</span>.outChannel1 = outChannel1;
        <span class="java-keyword">this</span>.outChannel2 = outChannel2;
    }</p><p class="paragraph">    <span class="java-keyword">public</span> def call() {
        <span class="java-keyword">final</span> PGroup group = Dataflow.retrieveCurrentDFPGroup()
        <span class="java-keyword">while</span> (<span class="java-keyword">true</span>) {
            def i = inChannel.val
            group.task {
                outChannel1 &lt;&lt; i
                outChannel2 &lt;&lt; i
            }.join()
        }
    }
}</p></pre></div><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowChannel
<span class="java-keyword">import</span> groovyx.gpars.dataflow.SyncDataflowQueue
<span class="java-keyword">import</span> groovyx.gpars.group.DefaultPGroup<p class="paragraph">group = <span class="java-keyword">new</span> DefaultPGroup(6)</p><p class="paragraph">def fib(DataflowChannel out) {
    group.task {
        def a = <span class="java-keyword">new</span> SyncDataflowQueue()
        def b = <span class="java-keyword">new</span> SyncDataflowQueue()
        def c = <span class="java-keyword">new</span> SyncDataflowQueue()
        def d = <span class="java-keyword">new</span> SyncDataflowQueue()
        [<span class="java-keyword">new</span> Prefix(d, a, 0L), <span class="java-keyword">new</span> Prefix(c, d, 1L), <span class="java-keyword">new</span> Copy(a, b, out), <span class="java-keyword">new</span> StatePairs(b, c)].each { group.task it}
    }
}</p><p class="paragraph"><span class="java-keyword">final</span> SyncDataflowQueue ch = <span class="java-keyword">new</span> SyncDataflowQueue()
group.task <span class="java-keyword">new</span> Print('Fibonacci numbers', ch)
fib(ch)</p><p class="paragraph">sleep 10000</p></pre></div>



<h1 id="actors">5 Actors</h1>
The actor support in GPars was originally inspired by the Actors library in Scala, but has since gone well
beyond what Scala offers as standard.<p class="paragraph">Actors allow for a message passing-based concurrency model: programs are collections of independent active
objects that exchange messages and have no mutable shared state.  Actors can help developers avoid issues
such as deadlock, live-lock and starvation, which are common problems for shared memory based approaches.
Actors are a way of leveraging the multi-core nature of today's hardware without all the problems
traditionally associated with shared-memory multi-threading, which is why programming languages such as
Erlang and Scala have taken up this model.</p><p class="paragraph">A nice article summarizing the key <a href="http://ruben.savanne.be/articles/concurrency-in-erlang-scala" target="blank">concepts behind
actors</a> was written recently by Ruben
Vermeersch.  Actors always guarantee that <strong class="bold">at most one thread processes the actor's body</strong> at any one time
and also, under the covers, that the memory gets synchronized
each time a thread gets assigned to an actor so the actor's state <strong class="bold">can be safely modified</strong> by code in the body <strong class="bold">without any other extra (synchronization or locking) effort</strong> .
Ideally actor's code should <strong class="bold">never be invoked</strong> directly from outside so all the code of the actor class can only be executed by the thread
handling the last received message and so all the actor's code is <strong class="bold">implicitly thread-safe</strong>
 .
If any of the actor's methods is allowed to be called by other objects 
directly, the thread-safety guarantee for the actor's code and state are
 <strong class="bold">no longer valid</strong> .</p><p class="paragraph"></p><h2>Types of actors</h2><p class="paragraph">In general, you can find two types of actors in the wild - ones that hold <strong class="bold">implicit state</strong> and those, who don't. GPars gives you both options.
<strong class="bold">Stateless</strong> actors, represented in <strong class="bold">GPars</strong> by the  <em class="italic">DynamicDispatchActor</em>  and the  <em class="italic">ReactiveActor</em>
  classes, keep no track of what messages have arrived previously.
You may thing of these as flat message handlers, which process messages 
as they come. Any state-based behavior has to be implemented by the 
user.</p><p class="paragraph">The <strong class="bold">stateful</strong> actors, represented in GPars by the  <em class="italic">DefaultActor</em>  class (and previously also by the  <em class="italic">AbstractPooledActor</em>  class), allow the user to handle implicit state directly.
After receiving a message the actor moves into a new state with different ways to handle future messages.
To give you an example, a freshly started actor may only accept some types of messages, e.g. encrypted messages for decryption,
only after it has received the encryption keys. The stateful actors allow to encode such dependencies directly in the structure
of the message-handling code.
Implicit state management, however, comes at a slight performance cost, mainly due to the lack of continuations support on JVM.</p><p class="paragraph"></p><h2>Actor threading model</h2><p class="paragraph">Since
 actors are detached from the system threads, a great number of actors 
can share a relatively small thread pool.
This can go as far as having many concurrent actors that share a single 
pooled thread. This architecture allows to avoid
some of the threading limitations of the JVM. In general, while the JVM 
can only give you a limited number of threads (typically around a couple
 of thousands),
the number of actors is only limited by the available memory. If an 
actor has no work to do, it doesn't consume threads.</p><p class="paragraph">Actor code is processed in chunks separated by quiet periods of waiting for new events (messages).
This can be naturally modeled through  <em class="italic">continuations</em>  . As JVM doesn't support continuations directly, they have to be simulated in the actors frameworks,
which has slight impact on organization of the actors' code. However, the benefits in most cases outweigh the difficulties.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.actor.Actor
<span class="java-keyword">import</span> groovyx.gpars.actor.DefaultActor<p class="paragraph">class GameMaster <span class="java-keyword">extends</span> DefaultActor {
    <span class="java-object">int</span> secretNum</p><p class="paragraph">    void afterStart() {
        secretNum = <span class="java-keyword">new</span> Random().nextInt(10)
    }</p><p class="paragraph">    void act() {
        loop {
            react { <span class="java-object">int</span> num -&gt;
                <span class="java-keyword">if</span> (num &gt; secretNum)
                reply 'too large'
                <span class="java-keyword">else</span> <span class="java-keyword">if</span> (num &lt; secretNum)
                reply 'too small'
                <span class="java-keyword">else</span> {
                    reply 'you win'
                    terminate()
                }
            }
        }
    }
}</p><p class="paragraph">class Player <span class="java-keyword">extends</span> DefaultActor {
    <span class="java-object">String</span> name
    Actor server
    <span class="java-object">int</span> myNum</p><p class="paragraph">    void act() {
        loop {
            myNum = <span class="java-keyword">new</span> Random().nextInt(10)
            server.send myNum
            react {
                <span class="java-keyword">switch</span> (it) {
                    <span class="java-keyword">case</span> 'too large': println <span class="java-quote">"$name: $myNum was too large"</span>; <span class="java-keyword">break</span>
                    <span class="java-keyword">case</span> 'too small': println <span class="java-quote">"$name: $myNum was too small"</span>; <span class="java-keyword">break</span>
                    <span class="java-keyword">case</span> 'you win': println <span class="java-quote">"$name: I won $myNum"</span>; terminate(); <span class="java-keyword">break</span>
                }
            }
        }
    }
}</p><p class="paragraph">def master = <span class="java-keyword">new</span> GameMaster().start()
def player = <span class="java-keyword">new</span> Player(name: 'Player', server: master).start()</p><p class="paragraph">//<span class="java-keyword">this</span> forces main thread to live until both actors stop
[master, player]*.join()</p></pre></div>
example by  <em class="italic">Jordi Campos i Miralles, Departament de 
MatemĂ&nbsp;tica Aplicada i AnĂ&nbsp;lisi, MAiA Facultat de 
MatemĂ&nbsp;tiques, Universitat de Barcelona</em> <p class="paragraph"></p><h1>Usage of Actors</h1><p class="paragraph">Gpars
 provides consistent Actor APIs and DSLs. Actors in principal perform 
three specific operations - send messages, receive messages and create 
new actors. Although not specifically enforced by <strong class="bold">GPars</strong>
messages should be immutable or at least follow the <strong class="bold">hands-off</strong> policy when the sender never touches the messages after the message has been sent off.</p><p class="paragraph"></p><h2>Sending messages</h2><p class="paragraph">Messages can be sent to actors using the  <em class="italic">send()</em>  method.</p><p class="paragraph"></p><div class="code"><pre>def passiveActor = Actors.actor{
    loop {
        react { msg -&gt; println <span class="java-quote">"Received: $msg"</span>; }
    }
}
passiveActor.send 'Message 1'
passiveActor &lt;&lt; 'Message 2'    //using the &lt;&lt; <span class="java-keyword">operator</span>
passiveActor 'Message 3'       //using the implicit call() method</pre></div><p class="paragraph">Alternatively, the  <em class="italic">&lt;&lt;</em>  operator or the implicit  <em class="italic">call()</em>  method can be used. A family of  <em class="italic">sendAndWait()</em>  methods is available to block the caller until a reply from the actor is available.
The  <em class="italic">reply</em>  is returned from the  <em class="italic">sendAndWait()</em>  method as a return value.
The  <em class="italic">sendAndWait()</em>  methods may also return after a timeout expires or in case of termination of the called actor.</p><p class="paragraph"></p><div class="code"><pre>def replyingActor = Actors.actor{
    loop {
        react { msg -&gt;
            println <span class="java-quote">"Received: $msg"</span>;
            reply <span class="java-quote">"I've got $msg"</span>
        }
    }
}
def reply1 = replyingActor.sendAndWait('Message 4')
def reply2 = replyingActor.sendAndWait('Message 5', 10, TimeUnit.SECONDS)
use (TimeCategory) {
    def reply3 = replyingActor.sendAndWait('Message 6', 10.seconds)
}</pre></div><p class="paragraph">The  <em class="italic">sendAndContinue()</em>  method allows the caller to continue its processing while the supplied closure is waiting for a reply from the actor.</p><p class="paragraph"></p><div class="code"><pre>friend.sendAndContinue 'I need money!', {money -&gt; pocket money}
println 'I can <span class="java-keyword">continue</span> <span class="java-keyword">while</span> my friend is collecting money <span class="java-keyword">for</span> me'</pre></div><p class="paragraph">The  <em class="italic">sendAndPromise()</em>  method returns a  <em class="italic">Promise</em>  (aka Future) to the final reply and so allows the caller to continue its processing
while the actor is handling the submitted message.</p><p class="paragraph"></p><div class="code"><pre>Promise loan = friend.sendAndPromise 'I need money!'
println 'I can <span class="java-keyword">continue</span> <span class="java-keyword">while</span> my friend is collecting money <span class="java-keyword">for</span> me'
loan.whenBound {money -&gt; pocket money}  //asynchronous waiting <span class="java-keyword">for</span> a reply
println <span class="java-quote">"Received ${loan.get()}"</span>  //synchronous waiting <span class="java-keyword">for</span> a reply</pre></div><p class="paragraph">All  <em class="italic">send()</em>  ,  <em class="italic">sendAndWait()</em>  or  <em class="italic">sendAndContinue()</em>  methods will throw an exception if invoked on a non-active actor.</p><p class="paragraph"></p><h2>Receiving messages</h2><p class="paragraph"></p><h3>Non-blocking message retrieval</h3><p class="paragraph">Calling the  <em class="italic">react()</em>
  method, optionally with a timeout parameter, from within the actor's 
code will consume the next message from the actor's inbox,
potentially waiting, if there is no message to be processed immediately.</p><p class="paragraph"></p><div class="code"><pre>println 'Waiting <span class="java-keyword">for</span> a gift'
react {gift -&gt;
    <span class="java-keyword">if</span> (myWife.likes gift) reply 'Thank you!'
}</pre></div><p class="paragraph">Under the covers the supplied closure 
is not invoked directly, but scheduled for processing by any thread in 
the thread pool once
a message is available. After scheduling the current thread will then be
 detached from the actor and freed to process any other actor,
which has received a message already.</p><p class="paragraph">To allow detaching actors from the threads the  <em class="italic">react()</em>  method demands the code to be written in a special <strong class="bold">Continuation-style</strong>.
</p><div class="code"><pre>Actors.actor {
    loop {
        println 'Waiting <span class="java-keyword">for</span> a gift'
        react {gift -&gt;
            <span class="java-keyword">if</span> (myWife.likes gift) reply 'Thank you!'
            <span class="java-keyword">else</span> {
                reply 'Try again, please'
                react {anotherGift -&gt;
                    <span class="java-keyword">if</span> (myChildren.like gift) reply 'Thank you!'
                }
                println 'Never reached'
            }
        }
        println 'Never reached'
    }
    println 'Never reached'
}</pre></div><p class="paragraph">The  <em class="italic">react()</em>  method has a special semantics to allow actors to be detached from threads when no messages are available in their mailbox.
Essentially,  <em class="italic">react()</em>  schedules the supplied code (closure) to be executed upon next message arrival and returns.
The closure supplied to the  <em class="italic">react()</em>  methods is the code where the computation should <strong class="bold">continue</strong> . Thus <strong class="bold">continuation style</strong> .</p><p class="paragraph">Since
 actor has to preserve the guarantee of at most one thread active within
 the actor's body, the next message cannot be handled
before the current message processing finishes. Typically, there 
shouldn't be a need to put code after calls to  <em class="italic">react()</em>  .
Some actor implementations even enforce this, however, GPars does not for performance reasons.
The  <em class="italic">loop()</em>  method allows iteration within the actor body. Unlike typical looping constructs, like  <em class="italic">for</em>  or  <em class="italic">while</em>  loops,
  <em class="italic">loop()</em>  cooperates with nested  <em class="italic">react()</em>  blocks and will ensure looping across subsequent message retrievals.</p><p class="paragraph"></p><h2>Sending replies</h2><p class="paragraph">The  <em class="italic">reply/replyIfExists</em>  methods are not only defined on the actors themselves, but for  <em class="italic">AbstractPooledActor</em>  (not available in  <em class="italic">DefaultActor</em>  ,  <em class="italic">DynamicDispatchActor</em>  nor  <em class="italic">ReactiveActor</em>  classes) also on the processed messages themselves
upon their reception, which is particularly handy when handling multiple messages in a single call. In such cases  <em class="italic">reply()</em>  invoked on the actor sends a reply to authors of all the currently processed message (the last one), whereas  <em class="italic">reply()</em>  called on messages sends a reply to the author of the particular message only.</p><p class="paragraph"><a href="http://git.codehaus.org/gitweb.cgi?p=gpars.git;a=blob_plain;f=src/test/groovy/groovyx/gpars/samples/actors/stateful/DemoMultiMessage.groovy;hb=HEAD" target="blank">See demo here</a></p><p class="paragraph"></p><h3>The sender property</h3><p class="paragraph">Messages
 upon retrieval offer the sender property to identify the originator of 
the message. The property is available inside the Actor's closure:
</p><div class="code"><pre>react {tweet -&gt;
    <span class="java-keyword">if</span> (isSpam(tweet)) ignoreTweetsFrom sender
    sender.send 'Never write me again!'
}</pre></div><p class="paragraph"></p><h3>Forwarding</h3><p class="paragraph">When
 sending a message, a different actor can be specified as the sender so 
that potential replies to the message will be forwarded to the specified
 actor and not to the actual originator.</p><p class="paragraph"></p><div class="code"><pre>def decryptor = Actors.actor {
    react {message -&gt;
        reply message.reverse()
//        sender.send message.reverse()    //An alternative way to send replies
    }
}<p class="paragraph">def console = Actors.actor {  //This actor will print out decrypted messages, since the replies are forwarded to it
    react {
        println 'Decrypted message: ' + it
    }
}</p><p class="paragraph">decryptor.send 'lellarap si yvoorG', console  //Specify an actor to send replies to
console.join()</p></pre></div><p class="paragraph"></p><h2>Creating Actors</h2><p class="paragraph">Actors share a <strong class="bold">pool</strong> of threads, which are dynamically assigned to actors when the actors need to <strong class="bold">react</strong>
 to messages sent to them. The threads are returned to back the pool 
once a message has been processed and the actor is idle waiting for some
 more messages to arrive.</p><p class="paragraph">For example, this is how you create an actor that prints out all messages that it receives.</p><p class="paragraph"></p><div class="code"><pre>def console = Actors.actor {
    loop {
        react {
            println it
        }
    }
}</pre></div><p class="paragraph">Notice the  <em class="italic">loop()</em>  method call, which ensures that the actor doesn't stop after having processed the first message.</p><p class="paragraph">Here's
 an example with a decryptor service, which can decrypt submitted 
messages and send the decrypted messages back to the originators.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> def decryptor = Actors.actor {
    loop {
        react {<span class="java-object">String</span> message -&gt;
            <span class="java-keyword">if</span> ('stopService' == message) {
                println 'Stopping decryptor'
                stop()
            }
            <span class="java-keyword">else</span> reply message.reverse()
        }
    }
}<p class="paragraph">Actors.actor {
    decryptor.send 'lellarap si yvoorG'
    react {
        println 'Decrypted message: ' + it
        decryptor.send 'stopService'
    }
}.join()</p></pre></div><p class="paragraph">Here's an example of an actor that waits for up to 30 seconds to receive a reply to its message.</p><p class="paragraph"></p><div class="code"><pre>def friend = Actors.actor {
    react {
        //<span class="java-keyword">this</span> doesn't reply -&gt; caller won't receive any answer in time
        println it
        //reply 'Hello' //uncomment <span class="java-keyword">this</span> to answer conversation
        react {
            println it
        }
    }
}<p class="paragraph">def me = Actors.actor {
    friend.send('Hi')
    //wait <span class="java-keyword">for</span> answer 1sec
    react(1000) {msg -&gt;
        <span class="java-keyword">if</span> (msg == Actor.TIMEOUT) {
            friend.send('I see, busy as usual. Never mind.')
            stop()
        } <span class="java-keyword">else</span> {
            //<span class="java-keyword">continue</span> conversation
            println <span class="java-quote">"Thank you <span class="java-keyword">for</span> $msg"</span>
        }
    }
}</p><p class="paragraph">me.join()</p></pre></div><p class="paragraph"></p><h2>Undelivered messages</h2><p class="paragraph">Sometimes
 messages cannot be delivered to the target actor. When special action 
needs to be taken for undelivered messages, at actor termination all 
unprocessed messages from its queue have their  <em class="italic">onDeliveryError()</em>  method called. The  <em class="italic">onDeliveryError()</em>  method or closure defined on the message can, for example, send a notification back to the original sender of the message.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> DefaultActor me
me = Actors.actor {
    def message = 1<p class="paragraph">    message.metaClass.onDeliveryError = {-&gt;
        //send message back to the caller
        me &lt;&lt; <span class="java-quote">"Could not deliver $delegate"</span>
    }</p><p class="paragraph">    def actor = Actors.actor {
        react {
            //wait 2sec in order next call in demo can be emitted
            <span class="java-object">Thread</span>.sleep(2000)
            //stop actor after first message
            stop()
        }
    }</p><p class="paragraph">    actor &lt;&lt; message
    actor &lt;&lt; message</p><p class="paragraph">    react {
        //print whatever comes back
        println it
    }</p><p class="paragraph">}</p><p class="paragraph">me.join()</p></pre></div><p class="paragraph">Alternatively the  <em class="italic">onDeliveryError()</em>  method can be specified on the sender itself. The method can be added both dynamically</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> DefaultActor me
me = Actors.actor {
    def message1 = 1
    def message2 = 2<p class="paragraph">    def actor = Actors.actor {
        react {
            //wait 2sec in order next call in demo can be emitted
            <span class="java-object">Thread</span>.sleep(2000)
            //stop actor after first message
            stop()
        }
    }</p><p class="paragraph">    me.metaClass.onDeliveryError = {msg -&gt;
        //callback on actor inaccessibility
        println <span class="java-quote">"Could not deliver message $msg"</span>
    }</p><p class="paragraph">    actor &lt;&lt; message1
    actor &lt;&lt; message2</p><p class="paragraph">    actor.join()</p><p class="paragraph">}</p><p class="paragraph">me.join()</p></pre></div><p class="paragraph">and statically in actor definition:
</p><div class="code"><pre>class MyActor <span class="java-keyword">extends</span> DefaultActor {
    <span class="java-keyword">public</span> void onDeliveryError(msg) {
        println <span class="java-quote">"Could not deliver message $msg"</span>
    }
    …
}</pre></div><p class="paragraph"></p><h2>Joining actors</h2><p class="paragraph">Actors provide a  <em class="italic">join()</em>  method to allow callers to wait for the actor to terminate. A variant accepting a timeout is also available. The Groovy  <em class="italic">spread-dot</em>  operator comes in handy when joining multiple actors at a time.</p><p class="paragraph"></p><div class="code"><pre>def master = <span class="java-keyword">new</span> GameMaster().start()
def player = <span class="java-keyword">new</span> Player(name: 'Player', server: master).start()<p class="paragraph">[master, player]*.join()</p></pre></div><p class="paragraph"></p><h2>Conditional and counting loops</h2><p class="paragraph">The  <em class="italic">loop()</em>  method allows for either a condition or a number of iterations to be specified, optionally accompanied with a closure
to invoke once the loop finishes -  <em class="italic">After Loop Termination Code Handler</em>  .</p><p class="paragraph">The following actor will loop three times to receive 3 messages and then prints out the maximum of the received messages.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> Actor actor = Actors.actor {
    def candidates = []
    def printResult = {-&gt; println <span class="java-quote">"The best offer is ${candidates.max()}"</span>}<p class="paragraph">    loop(3, printResult) {
        react {
            candidates &lt;&lt; it
        }
    }
}</p><p class="paragraph">actor 10
actor 30
actor 20
actor.join()</p></pre></div><p class="paragraph">The following actor will receive messages until a value greater then 30 arrives.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> Actor actor = Actors.actor {
    def candidates = []
    <span class="java-keyword">final</span> Closure printResult = {-&gt; println <span class="java-quote">"Reached best offer - ${candidates.max()}"</span>}<p class="paragraph">    loop({-&gt; candidates.max() &lt; 30}, printResult) {
        react {
            candidates &lt;&lt; it
        }
    }
}</p><p class="paragraph">actor 10
actor 20
actor 25
actor 31
actor 20
actor.join()</p></pre></div><p class="paragraph"></p><blockquote class="note">
The  <em class="italic">After Loop Termination Code Handler</em>  can use actor's  <em class="italic">react{}</em>  but not  <em class="italic">loop()</em>  .
</blockquote><p class="paragraph"></p><blockquote class="note">
 <em class="italic">DefaultActor</em>  can be set to behave in a fair on non-fair (default) manner. Depending on the strategy chosen, the actor
either makes the thread available to other actors sharing the same parallel group (fair), or keeps the thread fot itself
until the message queue gets empty (non-fair). Generally, non-fair actors perform 2 - 3 times better than fair ones.<p class="paragraph">Use either the  <em class="italic">fairActor()</em>  factory method or the actor's makeFair() method.</p><p class="paragraph"></p></blockquote><p class="paragraph"></p><h2>Custom schedulers</h2><p class="paragraph">Actors
 leverage the standard JDK concurrency library by default.  To provide a
 custom thread scheduler use the appropriate constructor parameter when 
creating a parallel group (PGroup class). The supplied scheduler will 
orchestrate threads in the group's thread pool.</p><p class="paragraph">Please also see the numerous <a href="http://git.codehaus.org/gitweb.cgi?p=gpars.git;a=tree;f=src/test/groovy/groovyx/gpars/samples;h=f9a751689a034a1d3de13c4874f4f4e839cb1026;hb=HEAD" target="blank">Actor Demos</a> .



</p><h2 id="actors_actorsPrinciples">5.1 Actors Principles</h2>
Actors share a <strong class="bold">pool</strong> of threads, which are dynamically assigned to actors when the actors need to <strong class="bold">react</strong>
 to messages sent to them.
The threads are returned back to the pool once a message has been 
processed and the actor is idle waiting for some more messages to 
arrive.
Actors become detached from the underlying threads and so a relatively 
small thread pool can serve potentially unlimited number of actors.
Virtually unlimited scalability in number of actors is the main 
advantage of  <em class="italic">event-based actors</em>  , which are detached from the underlying physical threads.<p class="paragraph">Here are some examples of how to use actors. This is how you create an actor that prints out all messages that it receives.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.actor.Actors.actor<p class="paragraph">def console = actor {
    loop {
        react {
            println it
        }
    }</p></pre></div><p class="paragraph">Notice the  <em class="italic">loop()</em>  method call, which ensures that the actor doesn't stop after having processed the first message.</p><p class="paragraph">As an alternative you can extend the  <em class="italic">DefaultActor</em>  class and override the  <em class="italic">act()</em>
  method. Once you instantiate the actor, you need to start it so that 
it attaches itself to the thread pool and can start accepting messages.
The  <em class="italic">actor()</em>  factory method will take care of starting the actor.</p><p class="paragraph"></p><div class="code"><pre>class CustomActor <span class="java-keyword">extends</span> DefaultActor {
    @Override
    <span class="java-keyword">protected</span> void act() {
        loop {
            react {
                println it
            }
        }
    }
}<p class="paragraph">def console=<span class="java-keyword">new</span> CustomActor()
console.start()</p></pre></div><p class="paragraph">Messages can be sent to the actor using multiple methods</p><p class="paragraph"></p><div class="code"><pre>console.send('Message')
console 'Message'
console.sendAndWait 'Message'                                                     //Wait <span class="java-keyword">for</span> a reply
console.sendAndContinue 'Message', {reply -&gt; println <span class="java-quote">"I received reply: $reply"</span>}  //Forward the reply to a function</pre></div><p class="paragraph"></p><h3>Creating an asynchronous service</h3><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.actor.Actors.actor<p class="paragraph"><span class="java-keyword">final</span> def decryptor = actor {
    loop {
        react {<span class="java-object">String</span> message-&gt;
            reply message.reverse()
        }
    }
}</p><p class="paragraph">def console = actor {
    decryptor.send 'lellarap si yvoorG'
    react {
        println 'Decrypted message: ' + it
    }
}</p><p class="paragraph">console.join()</p></pre></div><p class="paragraph">As you can see, you create new actors with the  <em class="italic">actor()</em>  method passing in the actor's body as a closure parameter. Inside
the actor's body you can use  <em class="italic">loop()</em>  to iterate,  <em class="italic">react()</em>  to receive messages and  <em class="italic">reply()</em>  to send a message to the actor,
which has sent the currently processed message. The sender of the current message is also available through the actor's  <em class="italic">sender</em>  property.
When the decryptor actor doesn't find a message in its message queue at the time when  <em class="italic">react()</em>  is called,
the  <em class="italic">react()</em>  method gives up the thread and returns it back to the thread pool for other actors to pick it up.
Only after a new message arrives to the actor's message queue, the closure of the  <em class="italic">react()</em>
  method gets scheduled for processing with the pool.
Event-based actors internally simulate continuations - actor's work is 
split into sequentially run chunks, which get invoked
once a message is available in the inbox. Each chunk for a single actor 
can be performed by a different thread from the thread pool.</p><p class="paragraph">Groovy flexible syntax with closures allows our library to offer multiple ways to define actors.
For instance, here's an example of an actor that waits for up to 30 seconds to receive a reply to its message.
Actors allow time DSL defined by org.codehaus.groovy.runtime.TimeCategory class to be used for timeout specification to the  <em class="italic">react()</em>  method,
provided the user wraps the call within a  <em class="italic">TimeCategory</em>  use block.</p><p class="paragraph"></p><div class="code"><pre>def friend = Actors.actor {
    react {
        //<span class="java-keyword">this</span> doesn't reply -&gt; caller won't receive any answer in time
        println it
        //reply 'Hello' //uncomment <span class="java-keyword">this</span> to answer conversation
        react {
            println it
        }
    }
}<p class="paragraph">def me = Actors.actor {
    friend.send('Hi')
    //wait <span class="java-keyword">for</span> answer 1sec
    react(1000) {msg -&gt;
        <span class="java-keyword">if</span> (msg == Actor.TIMEOUT) {
            friend.send('I see, busy as usual. Never mind.')
            stop()
        } <span class="java-keyword">else</span> {
            //<span class="java-keyword">continue</span> conversation
            println <span class="java-quote">"Thank you <span class="java-keyword">for</span> $msg"</span>
        }
    }
}</p><p class="paragraph">me.join()</p></pre></div><p class="paragraph">When a timeout expires when waiting for a message, the Actor.TIMEOUT message arrives instead. Also the  <em class="italic">onTimeout()</em>  handler
is invoked, if present on the actor:</p><p class="paragraph"></p><div class="code"><pre>def friend = Actors.actor {
    react {
        //<span class="java-keyword">this</span> doesn't reply -&gt; caller won't receive any answer in time
        println it
        //reply 'Hello' //uncomment <span class="java-keyword">this</span> to answer conversation
        react {
            println it
        }
    }
}<p class="paragraph">def me = Actors.actor {
    friend.send('Hi')</p><p class="paragraph">    delegate.metaClass.onTimeout = {-&gt;
        friend.send('I see, busy as usual. Never mind.')
        stop()
    }</p><p class="paragraph">    //wait <span class="java-keyword">for</span> answer 1sec
    react(1000) {msg -&gt;
        <span class="java-keyword">if</span> (msg != Actor.TIMEOUT) {
            //<span class="java-keyword">continue</span> conversation
            println <span class="java-quote">"Thank you <span class="java-keyword">for</span> $msg"</span>
        }
    }
}</p><p class="paragraph">me.join()</p></pre></div><p class="paragraph">Notice the possibility to use Groovy meta-programming to define actor's lifecycle notification methods (e.g.  <em class="italic">onTimeout()</em>  ) dynamically.
Obviously, the lifecycle methods can be defined the usual way when you decide to define a new class for your actor.
</p><div class="code"><pre>class MyActor <span class="java-keyword">extends</span> DefaultActor {
    <span class="java-keyword">public</span> void onTimeout() {
        …
    }<p class="paragraph">    <span class="java-keyword">protected</span> void act() {
       …
    }
}</p></pre></div><p class="paragraph"></p><h3>Actors guarantee thread-safety for non-thread-safe code</h3><p class="paragraph">Actors
 guarantee that always at most one thread processes the actor's body at a
 time and also under the covers the memory gets synchronized
each time a thread gets assigned to an actor so the actor's state <strong class="bold">can be safely modified</strong> by code in the body <strong class="bold">without any other extra (synchronization or locking) effort</strong> .</p><p class="paragraph"></p><div class="code"><pre>class MyCounterActor <span class="java-keyword">extends</span> DefaultActor {
    <span class="java-keyword">private</span> <span class="java-object">Integer</span> counter = 0<p class="paragraph">    <span class="java-keyword">protected</span> void act() {
        loop {
            react {
                counter++
            }
        }
    }
}</p></pre></div><p class="paragraph">Ideally actor's code should <strong class="bold">never be invoked</strong> directly from outside so all the code of the actor class can only be executed by the thread
handling the last received message and so all the actor's code is <strong class="bold">implicitly thread-safe</strong>
 .
If any of the actor's methods is allowed to be called by other objects 
directly, the thread-safety guarantee for the actor's code and state are
 <strong class="bold">no longer valid</strong> .</p><p class="paragraph"></p><h2>Simple calculator</h2><p class="paragraph">A
 little bit more realistic example of an event-driven actor that 
receives two numeric messages, sums them up and sends the result to the 
console actor.
</p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.group.DefaultPGroup<p class="paragraph">//not necessary, just showing that a single-threaded pool can still handle multiple actors
def group = <span class="java-keyword">new</span> DefaultPGroup(1);</p><p class="paragraph"><span class="java-keyword">final</span> def console = group.actor {
    loop {
        react {
            println 'Result: ' + it
        }
    }
}</p><p class="paragraph"><span class="java-keyword">final</span> def calculator = group.actor {
    react {a -&gt;
        react {b -&gt;
            console.send(a + b)
        }
    }
}</p><p class="paragraph">calculator.send 2
calculator.send 3</p><p class="paragraph">calculator.join()
group.shutdown()</p></pre></div><p class="paragraph">Notice that event-driven actors require special care regarding the  <em class="italic">react()</em>  method. Since  <em class="italic">event_driven actors</em>  need to split the code into independent chunks assignable to different threads sequentially
and <strong class="bold">continuations</strong> are not natively supported on JVM, the chunks are created artificially. The  <em class="italic">react()</em>  method creates the next message handler.
As soon as the current message handler finishes, the next message handler (continuation) gets scheduled.</p><p class="paragraph"></p><h3>Concurrent Merge Sort Example</h3><p class="paragraph">For
 comparison I'm also including a more involved example performing a 
concurrent merge sort of a list of integers using actors. You can see 
that thanks to flexibility of Groovy we came pretty close to the Scala 
model, although I still miss Scala pattern matching for message 
handling.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.group.DefaultPGroup
<span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.actor.Actors.actor<p class="paragraph">Closure createMessageHandler(def parentActor) {
    <span class="java-keyword">return</span> {
        react {List&lt;<span class="java-object">Integer</span>&gt; message -&gt;
            assert message != <span class="java-keyword">null</span>
            <span class="java-keyword">switch</span> (message.size()) {
                <span class="java-keyword">case</span> 0..1:
                    parentActor.send(message)
                    <span class="java-keyword">break</span>
                <span class="java-keyword">case</span> 2:
                    <span class="java-keyword">if</span> (message[0] &lt;= message[1]) parentActor.send(message)
                    <span class="java-keyword">else</span> parentActor.send(message[-1..0])
                    <span class="java-keyword">break</span>
                <span class="java-keyword">default</span>:
                    def splitList = split(message)</p><p class="paragraph">                    def child1 = actor(createMessageHandler(delegate))
                    def child2 = actor(createMessageHandler(delegate))
                    child1.send(splitList[0])
                    child2.send(splitList[1])</p><p class="paragraph">                    react {message1 -&gt;
                        react {message2 -&gt;
                            parentActor.send merge(message1, message2)
                        }
                    }
            }
        }
    }
}</p><p class="paragraph">def console = <span class="java-keyword">new</span> DefaultPGroup(1).actor {
    react {
        println <span class="java-quote">"Sorted array:t${it}"</span>
        <span class="java-object">System</span>.exit 0
    }
}</p><p class="paragraph">def sorter = actor(createMessageHandler(console))
sorter.send([1, 5, 2, 4, 3, 8, 6, 7, 3, 9, 5, 3])
console.join()</p><p class="paragraph">def split(List&lt;<span class="java-object">Integer</span>&gt; list) {
    <span class="java-object">int</span> listSize = list.size()
    <span class="java-object">int</span> middleIndex = listSize / 2
    def list1 = list[0..&lt;middleIndex]
    def list2 = list[middleIndex..listSize - 1]
    <span class="java-keyword">return</span> [list1, list2]
}</p><p class="paragraph">List&lt;<span class="java-object">Integer</span>&gt; merge(List&lt;<span class="java-object">Integer</span>&gt; a, List&lt;<span class="java-object">Integer</span>&gt; b) {
    <span class="java-object">int</span> i = 0, j = 0
    <span class="java-keyword">final</span> <span class="java-object">int</span> newSize = a.size() + b.size()
    List&lt;<span class="java-object">Integer</span>&gt; result = <span class="java-keyword">new</span> ArrayList&lt;<span class="java-object">Integer</span>&gt;(newSize)</p><p class="paragraph">    <span class="java-keyword">while</span> ((i &lt; a.size()) &amp;&amp; (j &lt; b.size())) {
        <span class="java-keyword">if</span> (a[i] &lt;= b[j]) result &lt;&lt; a[i++]
        <span class="java-keyword">else</span> result &lt;&lt; b[j++]
    }</p><p class="paragraph">    <span class="java-keyword">if</span> (i &lt; a.size()) result.addAll(a[i..-1])
    <span class="java-keyword">else</span> result.addAll(b[j..-1])
    <span class="java-keyword">return</span> result
}</p></pre></div><p class="paragraph">Since  <em class="italic">actors</em>  reuse threads from a pool, the script will work with virtually <strong class="bold">any size of a thread pool</strong>, no matter how many actors are created along the way.</p><p class="paragraph"></p><h3>Actor lifecycle methods</h3>
Each Actor can define lifecycle observing methods, which will be called whenever a certain lifecycle event occurs.
<ul class="star">
<li>afterStart() - called right after the actor has been started.</li>
<li>afterStop(List undeliveredMessages) - called right after the actor 
is stopped, passing in all the unprocessed messages from the queue.</li>
<li>onInterrupt(InterruptedException e) - called when the actor's thread
 gets interrupted. Thread interruption will result in the stopping the 
actor in any case.</li>
<li>onTimeout() - called when no messages are sent to the actor within 
the timeout specified for the currently blocking react method.</li>
<li>onException(Throwable e) - called when an exception occurs in the 
actor's event handler. Actor will stop after return from this method.</li>
</ul><p class="paragraph">You can either define the methods statically in your Actor class or add them dynamically to the actor's metaclass:
</p><div class="code"><pre>class MyActor <span class="java-keyword">extends</span> DefaultActor {
    <span class="java-keyword">public</span> void afterStart() {
        …
    }
    <span class="java-keyword">public</span> void onTimeout() {
        …
    }<p class="paragraph">    <span class="java-keyword">protected</span> void act() {
       …
    }
}</p></pre></div><p class="paragraph"></p><div class="code"><pre>def myActor = actor {
    delegate.metaClass.onException = {
        log.error('Exception occurred', it)
    }<p class="paragraph">…
}</p></pre></div><p class="paragraph"></p><blockquote class="note">
To help performance, you may consider using the  <em class="italic">silentStart()</em>  method instead of  <em class="italic">start()</em>  when starting a  <em class="italic">DynamicDispatchActor</em>  or a  <em class="italic">ReactiveActor</em>  .
Calling  <em class="italic">silentStart()</em>  will by-pass some of the start-up machinery and as a result will also avoid calling the  <em class="italic">afterStart()</em>  method.
Due to its stateful nature,  <em class="italic">DefaultActor</em>  cannot be started silently.
</blockquote><p class="paragraph"></p><h3>Pool management</h3><p class="paragraph"> <em class="italic">Actors</em>
  can be organized into groups and as a default there's always an 
application-wide pooled actor group available. And just like the  <em class="italic">Actors</em>
  abstract factory can be used to create actors in the default group, 
custom groups can be used as abstract factories to create new actors 
instances belonging to these groups.</p><p class="paragraph"></p><div class="code"><pre>def myGroup = <span class="java-keyword">new</span> DefaultPGroup()<p class="paragraph">def actor1 = myGroup.actor {
…
}</p><p class="paragraph">def actor2 = myGroup.actor {
…
}</p></pre></div><p class="paragraph">The  <em class="italic">parallelGroup</em>  property of an actor points to the group it belongs to. It by default points to the default actor group,
which is  <em class="italic">Actors.defaultActorPGroup</em>  , and can only be changed before the actor is started.</p><p class="paragraph"></p><div class="code"><pre>class MyActor <span class="java-keyword">extends</span> StaticDispatchActor&lt;<span class="java-object">Integer</span>&gt; {
    <span class="java-keyword">private</span> <span class="java-keyword">static</span> PGroup group = <span class="java-keyword">new</span> DefaultPGroup(100)<p class="paragraph">    MyActor(...) {
        <span class="java-keyword">this</span>.parallelGroup = group
        …
    }
}</p></pre></div><p class="paragraph">The actors belonging to the same group share the <strong class="bold">underlying thread pool</strong> of that group. The pool by default contains <strong class="bold">n + 1 threads</strong>, where <strong class="bold">n</strong> stands for the number of <strong class="bold">CPUs</strong> detected by the JVM. The <strong class="bold">pool size</strong> can be set <strong class="bold">explicitly</strong> either by setting the  <em class="italic">gpars.poolsize</em>  system property or individually for each actor group by specifying the appropriate constructor parameter.</p><p class="paragraph"></p><div class="code"><pre>def myGroup = <span class="java-keyword">new</span> DefaultPGroup(10)  //the pool will contain 10 threads</pre></div><p class="paragraph">The thread pool can be manipulated through the appropriate  <em class="italic">DefaultPGroup</em>  class, which <strong class="bold">delegates</strong> to the  <em class="italic">Pool</em>  interface of the thread pool. For example, the  <em class="italic">resize()</em>  method allows you to change the pool size any time and the  <em class="italic">resetDefaultSize()</em>  sets it back to the default value. The  <em class="italic">shutdown()</em>
  method can be called when you need to safely finish all tasks, destroy
 the pool and stop all the threads in order to exit JVM in an organized 
manner.</p><p class="paragraph"></p><div class="code"><pre>… (n+1 threads in the <span class="java-keyword">default</span> pool after startup)<p class="paragraph">Actors.defaultActorPGroup.resize 1  //use one-thread pool</p><p class="paragraph">… (1 thread in the pool)</p><p class="paragraph">Actors.defaultActorPGroup.resetDefaultSize()</p><p class="paragraph">… (n+1 threads in the pool)</p><p class="paragraph">Actors.defaultActorPGroup.shutdown()</p></pre></div><p class="paragraph">As an alternative to the  <em class="italic">DefaultPGroup</em> , which creates a pool of daemon threads, the  <em class="italic">NonDaemonPGroup</em>  class can be used when non-daemon threads are required.</p><p class="paragraph"></p><div class="code"><pre>def daemonGroup = <span class="java-keyword">new</span> DefaultPGroup()<p class="paragraph">def actor1 = daemonGroup.actor {
…
}</p><p class="paragraph">def nonDaemonGroup = <span class="java-keyword">new</span> NonDaemonPGroup()</p><p class="paragraph">def actor2 = nonDaemonGroup.actor {
…
}</p><p class="paragraph">class MyActor {
    def MyActor() {
        <span class="java-keyword">this</span>.parallelGroup = nonDaemonGroup
    }</p><p class="paragraph">    void act() {...}
}</p></pre></div><p class="paragraph">Actors belonging to the same group share the <strong class="bold">underlying thread pool</strong>.
 With pooled actor groups you can split your actors to leverage multiple
 thread pools of different sizes and so assign resources to different 
components of your system and tune their performance.</p><p class="paragraph"></p><div class="code"><pre>def coreActors = <span class="java-keyword">new</span> NonDaemonPGroup(5)  //5 non-daemon threads pool
def helperActors = <span class="java-keyword">new</span> DefaultPGroup(1)  //1 daemon thread pool<p class="paragraph">def priceCalculator = coreActors.actor {
…
}</p><p class="paragraph">def paymentProcessor = coreActors.actor {
…
}</p><p class="paragraph">def emailNotifier = helperActors.actor {
…
}</p><p class="paragraph">def cleanupActor = helperActors.actor {
…
}</p><p class="paragraph">//increase size of the core actor group
coreActors.resize 6</p><p class="paragraph">//shutdown the group's pool once you no longer need the group to release resources
helperActors.shutdown()</p></pre></div><p class="paragraph">Do not 
forget to shutdown custom pooled actor groups, once you no longer need 
them and their actors, to preserve system resources.</p><p class="paragraph"></p><h3>The default actor group</h3><p class="paragraph">Actors that didn't have their parallelGroup property changed or that were created through any of the factory methods on the  <em class="italic">Actors</em>  class
share a common group  <em class="italic">Actors.defaultActorPGroup</em>  . This group uses a <strong class="bold">resizeable thread pool</strong> with an upper limit of <strong class="bold">1000 threads</strong> .
This gives you the comfort of having the pool automatically adjust to the demand of the actors. On the other hand,
with a growing number of actors the pool may become too big an inefficient.
It is advisable to group your actors into your own PGroups with fixed size thread pools for all but trivial applications.</p><p class="paragraph"></p><h3>Common trap: App terminates while actors do not receive messages</h3><p class="paragraph">Most likely you're using daemon threads and pools, which is the default setting, and your main thread finishes. Calling  <em class="italic">actor.join()</em>
  on any, some or all of your actors would block the main thread until 
the actor terminates and thus keep all your actors running.
Alternatively use instances of  <em class="italic">NonDaemonPGroup</em>  and assign some of your actors to these groups.
</p><div class="code"><pre>def nonDaemonGroup = <span class="java-keyword">new</span> NonDaemonPGroup()
def myActor = nonDaemonGroup.actor {...}</pre></div><p class="paragraph">alternatively
</p><div class="code"><pre>def nonDaemonGroup = <span class="java-keyword">new</span> NonDaemonPGroup()<p class="paragraph">class MyActor <span class="java-keyword">extends</span> DefaultActor {
    def MyActor() {
        <span class="java-keyword">this</span>.parallelGroup = nonDaemonGroup
    }</p><p class="paragraph">    void act() {...}
}</p><p class="paragraph">def myActor = <span class="java-keyword">new</span> MyActor()</p></pre></div><p class="paragraph"></p><h3>Blocking Actors</h3><p class="paragraph">Instead
 of event-driven continuation-styled actors, you may in some scenarios 
prefer using blocking actors.
Blocking actors hold a single pooled thread for their whole life-time 
including the time when waiting for messages.
They avoid some of the thread management overhead, since they never 
fight for threads after start,
and also they let you write straight code without the necessity of 
continuation style, since they only do blocking message reads via the  <em class="italic">receive</em>  method.
Obviously the number of blocking actors running concurrently is limited by the number of threads available in the shared pool.
On the other hand, blocking actors typically provide better performance compared to continuation-style actors,
especially when the actor's message queue rarely gets empty.</p><p class="paragraph"></p><div class="code"><pre>def decryptor = blockingActor {
    <span class="java-keyword">while</span> (<span class="java-keyword">true</span>) {
        receive {message -&gt;
            <span class="java-keyword">if</span> (message <span class="java-keyword">instanceof</span> <span class="java-object">String</span>) reply message.reverse()
            <span class="java-keyword">else</span> stop()
        }
    }
}<p class="paragraph">def console = blockingActor {
    decryptor.send 'lellarap si yvoorG'
    println 'Decrypted message: ' + receive()
    decryptor.send <span class="java-keyword">false</span>
}</p><p class="paragraph">[decryptor, console]*.join()</p></pre></div><p class="paragraph">Blocking
 actors increase the number of options to tune performance of your 
applications. They may in particular be good candidates
for high-traffic positions in your actor network.



</p><h2 id="actors_statelessActors">5.2 Stateless Actors</h2>
<h3>Dynamic Dispatch Actor</h3><p class="paragraph">The  <em class="italic">DynamicDispatchActor</em>  class is an actor allowing for an alternative structure of the message handling code. In general  <em class="italic">DynamicDispatchActor</em>  repeatedly scans for messages and dispatches arrived messages to one
of the  <em class="italic">onMessage(message)</em>  methods defined on the actor. The  <em class="italic">DynamicDispatchActor</em>  leverages the Groovy dynamic method dispatch mechanism under the covers.
Since, unlike  <em class="italic">DefaultActor</em>  descendants, a  <em class="italic">DynamicDispatchActor</em>  not  <em class="italic">ReactiveActor</em>
  (discussed below) do not need to implicitly remember actor's state 
between subsequent
message receptions, they provide much better performance 
characteristics, generally comparable to other actor frameworks, like 
e.g. Scala Actors.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.actor.Actors
<span class="java-keyword">import</span> groovyx.gpars.actor.DynamicDispatchActor<p class="paragraph"><span class="java-keyword">final</span> class MyActor <span class="java-keyword">extends</span> DynamicDispatchActor {</p><p class="paragraph">    void onMessage(<span class="java-object">String</span> message) {
        println 'Received string'
    }</p><p class="paragraph">    void onMessage(<span class="java-object">Integer</span> message) {
        println 'Received integer'
        reply 'Thanks!'
    }</p><p class="paragraph">    void onMessage(<span class="java-object">Object</span> message) {
        println 'Received object'
        sender.send 'Thanks!'
    }</p><p class="paragraph">    void onMessage(List message) {
        println 'Received list'
        stop()
    }
}</p><p class="paragraph"><span class="java-keyword">final</span> def myActor = <span class="java-keyword">new</span> MyActor().start()</p><p class="paragraph">Actors.actor {
    myActor 1
    myActor ''
    myActor 1.0
    myActor(<span class="java-keyword">new</span> ArrayList())
    myActor.join()
}.join()</p></pre></div><p class="paragraph">In some scenarios, 
typically when no implicit conversation-history-dependent state needs to
 be preserved for the actor, the dynamic dispatch code structure may be 
more intuitive than the traditional one using nested  <em class="italic">loop</em>  and  <em class="italic">react</em>  statements.</p><p class="paragraph">The  <em class="italic">DynamicDispatchActor</em>  class also provides a handy facility to add message handlers dynamically at actor construction time or any time later
using the  <em class="italic">when</em>  handlers, optionally wrapped inside a  <em class="italic">become</em>  method:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> Actor myActor = <span class="java-keyword">new</span> DynamicDispatchActor().become {
    when {<span class="java-object">String</span> msg -&gt; println 'A <span class="java-object">String</span>'; reply 'Thanks'}
    when {<span class="java-object">Double</span> msg -&gt; println 'A <span class="java-object">Double</span>'; reply 'Thanks'}
    when {msg -&gt; println 'A something ...'; reply 'What was that?';stop()}
}
myActor.start()
Actors.actor {
    myActor 'Hello'
    myActor 1.0d
    myActor 10 as BigDecimal
    myActor.join()
}.join()</pre></div><p class="paragraph">Obviously the two approaches can be combined:
</p><div class="code"><pre><span class="java-keyword">final</span> class MyDDA <span class="java-keyword">extends</span> DynamicDispatchActor {<p class="paragraph">    void onMessage(<span class="java-object">String</span> message) {
        println 'Received string'
    }</p><p class="paragraph">    void onMessage(<span class="java-object">Integer</span> message) {
        println 'Received integer'
    }</p><p class="paragraph">    void onMessage(<span class="java-object">Object</span> message) {
        println 'Received object'
    }</p><p class="paragraph">    void onMessage(List message) {
        println 'Received list'
        stop()
    }
}</p><p class="paragraph"><span class="java-keyword">final</span> def myActor = <span class="java-keyword">new</span> MyDDA().become {
    when {BigDecimal num -&gt; println 'Received BigDecimal'}
    when {<span class="java-object">Float</span> num -&gt; println 'Got a <span class="java-object">float</span>'}
}.start()
Actors.actor {
    myActor 'Hello'
    myActor 1.0f
    myActor 10 as BigDecimal
    myActor.send([])
    myActor.join()
}.join()</p></pre></div><p class="paragraph">The dynamic message handlers registered via  <em class="italic">when</em>  take precedence over the static  <em class="italic">onMessage</em>  handlers.</p><p class="paragraph"></p><blockquote class="note">
 <em class="italic">DynamicDispatchActor</em>  can be set to behave in a fair on non-fair (default) manner. Depending on the strategy chosen, the actor
either makes the thread available to other actors sharing the same parallel group (fair), or keeps the thread fot itself
until the message queue gets empty (non-fair). Generally, non-fair actors perform 2 - 3 times better than fair ones.<p class="paragraph">Use either the  <em class="italic">fairMessageHandler()</em>  factory method or the actor's makeFair() method.</p><p class="paragraph"></p></blockquote><p class="paragraph"></p><div class="code"><pre>def fairActor = Actors.fairMessageHandler {...}</pre></div><p class="paragraph"></p><h3>Static Dispatch Actor</h3><p class="paragraph">While  <em class="italic">DynamicDispatchActor</em>  dispatches messages based on their run-time type and so pays extra performance penalty for each message,
 <em class="italic">StaticDispatchActor</em>  avoids run-time message checks and dispatches the message solely based on the compile-time information.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> class MyActor <span class="java-keyword">extends</span> StaticDispatchActor&lt;<span class="java-object">String</span>&gt; {
    void onMessage(<span class="java-object">String</span> message) {
        println 'Received string ' + message<p class="paragraph">        <span class="java-keyword">switch</span> (message) {
            <span class="java-keyword">case</span> 'hello':
                reply 'Hi!'
                <span class="java-keyword">break</span>
            <span class="java-keyword">case</span> 'stop':
                stop()
        }
    }
}</p></pre></div><p class="paragraph">Instances of  <em class="italic">StaticDispatchActor</em>  have to override the  <em class="italic">onMessage</em>  method appropriate for the actor's declared type parameter.
The  <em class="italic">onMessage(T message)</em>  method is then invoked with every received message.</p><p class="paragraph">A shorter route towards both fair and non-fair static dispatch actors is available through the helper factory methods:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> actor = staticMessageHandler {<span class="java-object">String</span> message -&gt;
    println 'Received string ' + message<p class="paragraph">    <span class="java-keyword">switch</span> (message) {
        <span class="java-keyword">case</span> 'hello':
            reply 'Hi!'
            <span class="java-keyword">break</span>
        <span class="java-keyword">case</span> 'stop':
            stop()
    }
}</p><p class="paragraph">println 'Reply: ' + actor.sendAndWait('hello')
actor 'bye'
actor 'stop'
actor.join()</p></pre></div><p class="paragraph">Although when compared to  <em class="italic">DynamicDispatchActor</em>  the   <em class="italic">StaticDispatchActor</em>  class is limited to a single handler method,
the simplified creation without any  <em class="italic">when</em>  handlers plus the considerable performance benefits should make  <em class="italic">StaticDispatchActor</em> 
your default choice for straightforward message handlers, when dispatching based on message run-time type is not necessary.
For example,  <em class="italic">StaticDispatchActors</em>  make dataflow operators four times faster compared to when using  <em class="italic">DynamicDispatchActor</em>  .</p><p class="paragraph"></p><h3>Reactive Actor</h3><p class="paragraph">The  <em class="italic">ReactiveActor</em>  class, constructed typically by calling  <em class="italic">Actors.reactor()</em>  or  <em class="italic">DefaultPGroup.reactor()</em>
 , allow for more event-driven like approach. When a reactive actor 
receives a message, the supplied block of code, which makes up the 
reactive actor's body, is run with the message as a parameter. The 
result returned from the code is sent in reply.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> def group = <span class="java-keyword">new</span> DefaultPGroup()<p class="paragraph"><span class="java-keyword">final</span> def doubler = group.reactor {
    2 * it
}</p><p class="paragraph">group.actor {
    println '<span class="java-object">Double</span> of 10 = ' + doubler.sendAndWait(10)
}</p><p class="paragraph">group.actor {
    println '<span class="java-object">Double</span> of 20 = ' + doubler.sendAndWait(20)
}</p><p class="paragraph">group.actor {
    println '<span class="java-object">Double</span> of 30 = ' + doubler.sendAndWait(30)
}</p><p class="paragraph"><span class="java-keyword">for</span>(i in (1..10)) {
    println <span class="java-quote">"<span class="java-object">Double</span> of $i = ${doubler.sendAndWait(i)}"</span>
}</p><p class="paragraph">doubler.stop()
doubler.join()</p></pre></div><p class="paragraph">Here's an example of an actor, which submits a batch of numbers to a  <em class="italic">ReactiveActor</em>  for processing and then prints the results gradually as they arrive.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.actor.Actor
<span class="java-keyword">import</span> groovyx.gpars.actor.Actors<p class="paragraph"><span class="java-keyword">final</span> def doubler = Actors.reactor {
    2 * it
}</p><p class="paragraph">Actor actor = Actors.actor {
    (1..10).each {doubler &lt;&lt; it}
    <span class="java-object">int</span> i = 0
    loop {
        i += 1
        <span class="java-keyword">if</span> (i &gt; 10) stop()
        <span class="java-keyword">else</span> {
            react {message -&gt;
                println <span class="java-quote">"<span class="java-object">Double</span> of $i = $message"</span>
            }
        }
    }
}</p><p class="paragraph">actor.join()
doubler.stop()
doubler.join()</p></pre></div><p class="paragraph">Essentially reactive 
actors provide a convenience shortcut for an actor that would wait for 
messages in a loop, process them and send back the result. This is 
schematically how the reactive actor looks inside:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">public</span> class ReactiveActor <span class="java-keyword">extends</span> DefaultActor {
    Closure body<p class="paragraph">    void act() {
        loop {
            react {message -&gt;
                reply body(message)
            }
        }
    }
}</p></pre></div><p class="paragraph"></p><blockquote class="note">
 <em class="italic">ReactiveActor</em>  can be set to behave in a fair on non-fair (default) manner. Depending on the strategy chosen, the actor
either makes the thread available to other actors sharing the same parallel group (fair), or keeps the thread fot itself
until the message queue gets empty (non-fair). Generally, non-fair actors perform 2 - 3 times better than fair ones.<p class="paragraph">Use either the  <em class="italic">fairReactor()</em>  factory method or the actor's makeFair() method.</p><p class="paragraph"></p></blockquote><p class="paragraph"></p><div class="code"><pre>def fairActor = Actors.fairReactor {...}</pre></div><p class="paragraph">


</p><h2 id="actors_tipsAndTricks">5.3 Tips and Tricks</h2>
<h3>Structuring actor's code</h3>
When extending the  <em class="italic">DefaultActor</em>  class, you can call any actor's methods from within the  <em class="italic">act()</em>  method and use the  <em class="italic">react()</em>  or  <em class="italic">loop()</em>  methods in them.
<div class="code"><pre>class MyDemoActor <span class="java-keyword">extends</span> DefaultActor {<p class="paragraph">    <span class="java-keyword">protected</span> void act() {
        handleA()
    }</p><p class="paragraph">    <span class="java-keyword">private</span> void handleA() {
        react {a -&gt;
            handleB(a)
        }
    }</p><p class="paragraph">    <span class="java-keyword">private</span> void handleB(<span class="java-object">int</span> a) {
        react {b -&gt;
            println a + b
            reply a + b
        }
    }
}</p><p class="paragraph"><span class="java-keyword">final</span> def demoActor = <span class="java-keyword">new</span> MyDemoActor()
demoActor.start()</p><p class="paragraph">Actors.actor {
    demoActor 10
    demoActor 20
    react {
        println <span class="java-quote">"Result: $it"</span>
    }
}.join()</p></pre></div><p class="paragraph">Bear in mind that the methods  <em class="italic">handleA()</em>  and  <em class="italic">handleB()</em>
  in all our examples will only schedule the supplied message handlers 
to run as continuations of the current calculation in reaction to the 
next message arriving.</p><p class="paragraph">Alternatively, when using the  <em class="italic">actor()</em>  factory method, you can add event-handling code through the meta class as closures.
</p><div class="code"><pre>Actor demoActor = Actors.actor {
    delegate.metaClass {
        handleA = {-&gt;
            react {a -&gt;
                 handleB(a)
            }
        }<p class="paragraph">        handleB = {a -&gt;
            react {b -&gt;
                println a + b
                reply a + b
            }
        }
    }</p><p class="paragraph">    handleA()
}</p><p class="paragraph">Actors.actor {
    demoActor 10
    demoActor 20
    react {
        println <span class="java-quote">"Result: $it"</span>
    }
}.join()</p></pre></div><p class="paragraph">Closures, which have the actor set as their delegate can also be used to structure event-handling code.</p><p class="paragraph"></p><div class="code"><pre>Closure handleB = {a -&gt;
    react {b -&gt;
        println a + b
        reply a + b
    }
}<p class="paragraph">Closure handleA = {-&gt;
    react {a -&gt;
        handleB(a)
    }
}</p><p class="paragraph">Actor demoActor = Actors.actor {
    handleA.delegate = delegate
    handleB.delegate = delegate</p><p class="paragraph">    handleA()
}</p><p class="paragraph">Actors.actor {
    demoActor 10
    demoActor 20
    react {
        println <span class="java-quote">"Result: $it"</span>
    }
}.join()</p></pre></div><p class="paragraph"></p><h3>Event-driven loops</h3>
When coding event-driven actors you have to have in mind that calls to  <em class="italic">react()</em>  and  <em class="italic">loop()</em>
  methods have slightly different semantics. This becomes a bit of a 
challenge once you try to implement any types of loops in your actors.
On the other hand, if you leverage the fact that  <em class="italic">react()</em>
  only schedules a continuation and returns, you may call methods 
recursively without fear to fill up the stack. Look at the examples 
below, which respectively use the three described techniques for 
structuring actor's code.<p class="paragraph">A subclass of  <em class="italic">DefaultActor</em> 
</p><div class="code"><pre>class MyLoopActor <span class="java-keyword">extends</span> DefaultActor {<p class="paragraph">    <span class="java-keyword">protected</span> void act() {
        outerLoop()
    }</p><p class="paragraph">    <span class="java-keyword">private</span> void outerLoop() {
        react {a -&gt;
            println 'Outer: ' + a
            <span class="java-keyword">if</span> (a != 0) innerLoop()
            <span class="java-keyword">else</span> println 'Done'
        }
    }</p><p class="paragraph">    <span class="java-keyword">private</span> void innerLoop() {
        react {b -&gt;
            println 'Inner ' + b
            <span class="java-keyword">if</span> (b == 0) outerLoop()
            <span class="java-keyword">else</span> innerLoop()
        }
    }
}</p><p class="paragraph"><span class="java-keyword">final</span> def actor = <span class="java-keyword">new</span> MyLoopActor().start()
actor 10
actor 20
actor 0
actor 0
actor.join()</p></pre></div><p class="paragraph">Enhancing the actor's metaClass</p><p class="paragraph"></p><div class="code"><pre>Actor actor = Actors.actor {<p class="paragraph">  delegate.metaClass {
      outerLoop = {-&gt;
          react {a -&gt;
              println 'Outer: ' + a
              <span class="java-keyword">if</span> (a!=0) innerLoop()
              <span class="java-keyword">else</span> println 'Done'
          }
      }</p><p class="paragraph">      innerLoop = {-&gt;
          react {b -&gt;
              println 'Inner ' + b
              <span class="java-keyword">if</span> (b==0) outerLoop()
              <span class="java-keyword">else</span> innerLoop()
          }
      }
  }</p><p class="paragraph">  outerLoop()
}</p><p class="paragraph">actor 10
actor 20
actor 0
actor 0
actor.join()</p></pre></div><p class="paragraph">Using Groovy closures</p><p class="paragraph"></p><div class="code"><pre>Closure innerLoop<p class="paragraph">Closure outerLoop = {-&gt;
    react {a -&gt;
        println 'Outer: ' + a
        <span class="java-keyword">if</span> (a!=0) innerLoop()
        <span class="java-keyword">else</span> println 'Done'
    }
}</p><p class="paragraph">innerLoop = {-&gt;
    react {b -&gt;
        println 'Inner ' + b
        <span class="java-keyword">if</span> (b==0) outerLoop()
        <span class="java-keyword">else</span> innerLoop()
    }
}</p><p class="paragraph">Actor actor = Actors.actor {
    outerLoop.delegate = delegate
    innerLoop.delegate = delegate</p><p class="paragraph">    outerLoop()
}</p><p class="paragraph">actor 10
actor 20
actor 0
actor 0
actor.join()</p></pre></div><p class="paragraph">Plus don't forget about the possibility to use the actor's  <em class="italic">loop()</em>  method to create a loop that runs until the actor terminates.</p><p class="paragraph"></p><div class="code"><pre>class MyLoopingActor <span class="java-keyword">extends</span> DefaultActor {<p class="paragraph">  <span class="java-keyword">protected</span> void act() {
      loop {
          outerLoop()
      }
  }</p><p class="paragraph">  <span class="java-keyword">private</span> void outerLoop() {
      react {a -&gt;
          println 'Outer: ' + a
          <span class="java-keyword">if</span> (a!=0) innerLoop()
          <span class="java-keyword">else</span> println 'Done <span class="java-keyword">for</span> now, but will loop again'
      }
  }</p><p class="paragraph">  <span class="java-keyword">private</span> void innerLoop() {
      react {b -&gt;
          println 'Inner ' + b
          <span class="java-keyword">if</span> (b == 0) outerLoop()
          <span class="java-keyword">else</span> innerLoop()
      }
  }
}</p><p class="paragraph"><span class="java-keyword">final</span> def actor = <span class="java-keyword">new</span> MyLoopingActor().start()
actor 10
actor 20
actor 0
actor 0
actor 10
actor.stop()
actor.join()</p></pre></div>



<h2 id="actors_activeObjects">5.4 Active Objects</h2>
Active objects provide an OO facade on top of actors, allowing you to avoid dealing directly with the actor machinery,
having to match messages, wait for results and send replies.<p class="paragraph"></p><h2>Actors with a friendly facade</h2>
<div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.activeobject.ActiveObject
<span class="java-keyword">import</span> groovyx.gpars.activeobject.ActiveMethod<p class="paragraph">@ActiveObject
class Decryptor {
    @ActiveMethod
    def decrypt(<span class="java-object">String</span> encryptedText) {
        <span class="java-keyword">return</span> encryptedText.reverse()
    }</p><p class="paragraph">    @ActiveMethod
    def decrypt(<span class="java-object">Integer</span> encryptedNumber) {
        <span class="java-keyword">return</span> -1*encryptedNumber + 142
    }
}</p><p class="paragraph"><span class="java-keyword">final</span> Decryptor decryptor = <span class="java-keyword">new</span> Decryptor()
def part1 = decryptor.decrypt(' noitcA ni yvoorG')
def part2 = decryptor.decrypt(140)
def part3 = decryptor.decrypt('noitide dn')</p><p class="paragraph">print part1.get()
print part2.get()
println part3.get()</p></pre></div><p class="paragraph">You mark active objects with the  <em class="italic">@ActiveObject</em>  annotation. This will ensure a hidden actor instance is created for each instance of your class.
Now you can mark methods with the  <em class="italic">@ActiveMethod</em>  annotation indicating that you want the method to be invoked asynchronously
by the target object's internal actor.
An optional boolean  <em class="italic">blocking</em>  parameter to the  <em class="italic">@ActiveMethod</em>  annotation specifies, whether the caller should block until a result is available
or whether instead the caller should only receive a  <em class="italic">promise</em>  for a future result in a form of a  <em class="italic">DataflowVariable</em>  and so the caller is not blocked waiting.</p><p class="paragraph"></p><blockquote class="note">
By default, all active methods are set to be <strong class="bold">non-blocking</strong> . However, methods, which declare their return type explicitly, must be configured
as blocking, otherwise the compiler will report an error. Only  <em class="italic">def</em>  ,  <em class="italic">void</em>  and  <em class="italic">DataflowVariable</em>  are allowed return types for non-blocking methods.
</blockquote><p class="paragraph">Under the covers, GPars will translate your method call to <strong class="bold">a message being sent to the internal actor</strong> . The actor will eventually handle that message by invoking the desired method
on behalf of the caller and once finished a reply will be sent back to the caller.
Non-blocking methods return promises for results, aka  <em class="italic">DataflowVariables</em>  .</p><p class="paragraph"></p><h3>But blocking means we're not really asynchronous, are we?</h3><p class="paragraph">Indeed, if you mark your active methods as  <em class="italic">blocking</em>  , the caller will be blocked waiting for the result, just like when doing normal plain method invocation.
All we've achieved is being thread-safe inside the Active object from concurrent access. Something the  <em class="italic">synchronized</em>  keyword could give you as well.
So it is the <strong class="bold">non-blocking</strong> methods that 
should drive your decision towards using active objects. Blocking 
methods will then provide the usual synchronous semantics yet give the 
consistency guarantees
across concurrent method invocations. The blocking methods are then 
still very useful when used in combination with non-blocking ones.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.activeobject.ActiveMethod
<span class="java-keyword">import</span> groovyx.gpars.activeobject.ActiveObject
<span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowVariable<p class="paragraph">@ActiveObject
class Decryptor {
    @ActiveMethod(blocking=<span class="java-keyword">true</span>)
    <span class="java-object">String</span> decrypt(<span class="java-object">String</span> encryptedText) {
        encryptedText.reverse()
    }</p><p class="paragraph">    @ActiveMethod(blocking=<span class="java-keyword">true</span>)
    <span class="java-object">Integer</span> decrypt(<span class="java-object">Integer</span> encryptedNumber) {
        -1*encryptedNumber + 142
    }
}</p><p class="paragraph"><span class="java-keyword">final</span> Decryptor decryptor = <span class="java-keyword">new</span> Decryptor()
print decryptor.decrypt(' noitcA ni yvoorG')
print decryptor.decrypt(140)
println decryptor.decrypt('noitide dn')</p></pre></div><p class="paragraph"></p><h3>Non-blocking semantics</h3><p class="paragraph">Now calling the non-blocking active method will return as soon as the actor has been sent a message.
The caller is now allowed to do whatever he likes, while the actor is taking care of the calculation.
The state of the calculation can be polled using the  <em class="italic">bound</em>  property on the promise.
Calling the  <em class="italic">get()</em>  method on the returned promise will block the caller until a value is available.
The call to  <em class="italic">get()</em>  will eventually return a value or throw an exception, depending on the outcome of the actual calculation.</p><p class="paragraph"></p><blockquote class="note">
The  <em class="italic">get()</em>  method has also a variant with a timeout parameter, if you want to avoid the risk of waiting indefinitely.
</blockquote><p class="paragraph"></p><h4>Annotation rules</h4><p class="paragraph">There are a few rules to follow when annotating your objects:
</p><ol>
<li>The  <em class="italic">ActiveMethod</em>  annotations are only accepted in classes annotated as  <em class="italic">ActiveObject</em> </li>
<li>Only instance (non-static) methods can be annotated as  <em class="italic">ActiveMethod</em> </li>
<li>You can override active methods with non-active ones and vice versa</li>
<li>Subclasses of active objects can declare additional active methods, provided they are themselves annotated as  <em class="italic">ActiveObject</em> </li>
<li>Combining concurrent use of active and non-active methods may result
 in race conditions. Ideally design your active objects as completely 
encapsulated classes with all non-private methods marked as active</li>
</ol><p class="paragraph"></p><h3>Inheritance</h3><p class="paragraph">The  <em class="italic">@ActiveObject</em>
  annotation can appear on any class in an inheritance hierarchy. The 
actor field will only be created in top-most annotated class in the 
hierarchy, the subclasses will reuse the field.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.activeobject.ActiveObject
<span class="java-keyword">import</span> groovyx.gpars.activeobject.ActiveMethod
<span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowVariable<p class="paragraph">@ActiveObject
class A {
    @ActiveMethod
    def fooA(value) {
        …
    }
}</p><p class="paragraph">class B <span class="java-keyword">extends</span> A {
}</p><p class="paragraph">@ActiveObject
class C <span class="java-keyword">extends</span> B {
    @ActiveMethod
    def fooC(value1, value2) {
        …
    }
}</p></pre></div><p class="paragraph">In our example the actor field will be generated into class  <em class="italic">A</em>  . Class  <em class="italic">C</em>  has to be annotated with  <em class="italic">@ActiveObject</em>  since it holds
the  <em class="italic">@ActiveMethod</em>  annotation on method  <em class="italic">fooC()</em>  , while class  <em class="italic">B</em>  does not need the annotation, since none of its methods is active.</p><p class="paragraph"></p><h3>Groups</h3><p class="paragraph">Just
 like actors can be grouped around thread pools, active objects can be 
configured to use threads from particular parallel groups.
</p><div class="code"><pre>@ActiveObject(<span class="java-quote">"group1"</span>)
class MyActiveObject {
    …
}</pre></div><p class="paragraph">The  <em class="italic">value</em>  parameter to the  <em class="italic">@ActiveObject</em>
  annotation specifies a name of parallel group to bind the internal 
actor to.
Only threads from the specified group will be used to run internal 
actors of instances of the class.
The groups, however, need to be created and registered prior to creation
 of any of the active object instances belonging to that group.
If not specified explicitly, an active object will use the default actor
 group -  <em class="italic">Actors.defaultActorPGroup</em>  .</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> DefaultPGroup group = <span class="java-keyword">new</span> DefaultPGroup(10)
ActiveObjectRegistry.instance.register(<span class="java-quote">"group1"</span>, group)</pre></div><p class="paragraph"></p><h3>Alternative names for the internal actor</h3><p class="paragraph">You will probably only rarely run into name collisions with the default name for the active object's internal actor field.
May you need to change the default name  <em class="italic">internalActiveObjectActor</em>  , use the  <em class="italic">actorName</em>  parameter to the  <em class="italic">@ActiveObject</em>  annotation.</p><p class="paragraph"></p><div class="code"><pre>@ActiveObject(actorName = <span class="java-quote">"alternativeActorName"</span>)
class MyActiveObject {
    …
}</pre></div><p class="paragraph"></p><blockquote class="note">
Alternative names for internal actors as well as their desired groups 
cannot be overriden in subclasses.
Make sure you only specify these values in the top-most active objects 
in your inheritance hierarchy. Obviously, the top most active object
is still allowed to subclass other classes, just none of the 
predecessors must be an active object.
</blockquote>



<h2 id="actors_classicExamples">5.5 Classic Examples</h2>
<h2>A few examples on Actors use</h2><p class="paragraph"></p><h3>Examples</h3>
<ul class="star">
<li>The Sieve of Eratosthenes</li>
<li>Sleeping Barber</li>
<li>Dining Philosophers</li>
<li>Word Sort</li>
<li>Load Balancer</li>
</ul><p class="paragraph"></p><h2>The Sieve of Eratosthenes</h2><p class="paragraph"><a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="blank">Problem description</a></p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.actor.DynamicDispatchActor<p class="paragraph">/**
 * Demonstrates concurrent implementation of the Sieve of Eratosthenes using actors
 *
 * In principle, the algorithm consists of concurrently run chained filters,
 * each of which detects whether the current number can be divided by a single prime number.
 * (generate nums 1, 2, 3, 4, 5, ...) -&gt; (filter by mod 2) -&gt; (filter by mod 3) -&gt; (filter by mod 5) -&gt; (filter by mod 7) -&gt; (filter by mod 11) -&gt; (caution! Primes falling out here)
 * The chain is built (grows) on the fly, whenever a <span class="java-keyword">new</span> prime is found.
 */</p><p class="paragraph"><span class="java-object">int</span> requestedPrimeNumberBoundary = 1000</p><p class="paragraph"><span class="java-keyword">final</span> def firstFilter = <span class="java-keyword">new</span> FilterActor(2).start()</p><p class="paragraph">/**
 * Generating candidate numbers and sending them to the actor chain
 */
(2..requestedPrimeNumberBoundary).each {
    firstFilter it
}
firstFilter.sendAndWait 'Poison'</p><p class="paragraph">/**
 * Filter out numbers that can be divided by a single prime number
 */
<span class="java-keyword">final</span> class FilterActor <span class="java-keyword">extends</span> DynamicDispatchActor {
    <span class="java-keyword">private</span> <span class="java-keyword">final</span> <span class="java-object">int</span> myPrime
    <span class="java-keyword">private</span> def follower</p><p class="paragraph">    def FilterActor(<span class="java-keyword">final</span> myPrime) { <span class="java-keyword">this</span>.myPrime = myPrime; }</p><p class="paragraph">    /**
     * Try to divide the received number with the prime. If the number cannot be divided, send it along the chain.
     * If there's no-one to send it to, I'm the last in the chain, the number is a prime and so I will create and chain
     * a <span class="java-keyword">new</span> actor responsible <span class="java-keyword">for</span> filtering by <span class="java-keyword">this</span> newly found prime number.
     */
    def onMessage(<span class="java-object">int</span> value) {
        <span class="java-keyword">if</span> (value % myPrime != 0) {
            <span class="java-keyword">if</span> (follower) follower value
            <span class="java-keyword">else</span> {
                println <span class="java-quote">"Found $value"</span>
                follower = <span class="java-keyword">new</span> FilterActor(value).start()
            }
        }
    }</p><p class="paragraph">    /**
     * Stop the actor on poisson reception
     */
    def onMessage(def poisson) {
        <span class="java-keyword">if</span> (follower) {
            def sender = sender
            follower.sendAndContinue(poisson, {<span class="java-keyword">this</span>.stop(); sender?.send('Done')})  //Pass the poisson along and stop after a reply
        } <span class="java-keyword">else</span> {  //I am the last in the chain
            stop()
            reply 'Done'
        }
    }
}</p></pre></div>
<h2>Sleeping Barber</h2><p class="paragraph"><a href="http://en.wikipedia.org/wiki/Sleeping_barber_problem" target="blank">Problem description</a></p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.group.DefaultPGroup
<span class="java-keyword">import</span> groovyx.gpars.actor.DefaultActor
<span class="java-keyword">import</span> groovyx.gpars.group.DefaultPGroup
<span class="java-keyword">import</span> groovyx.gpars.actor.Actor<p class="paragraph"><span class="java-keyword">final</span> def group = <span class="java-keyword">new</span> DefaultPGroup()</p><p class="paragraph"><span class="java-keyword">final</span> def barber = group.actor {
    <span class="java-keyword">final</span> def random = <span class="java-keyword">new</span> Random()
    loop {
        react {message -&gt;
            <span class="java-keyword">switch</span> (message) {
                <span class="java-keyword">case</span> Enter:
                    message.customer.send <span class="java-keyword">new</span> Start()
                    println <span class="java-quote">"Barber: Processing customer ${message.customer.name}"</span>
                    doTheWork(random)
                    message.customer.send <span class="java-keyword">new</span> Done()
                    reply <span class="java-keyword">new</span> Next()
                    <span class="java-keyword">break</span>
                <span class="java-keyword">case</span> Wait:
                    println <span class="java-quote">"Barber: No customers. Going to have a sleep"</span>
                    <span class="java-keyword">break</span>
            }
        }
    }
}</p><p class="paragraph"><span class="java-keyword">private</span> def doTheWork(Random random) {
    <span class="java-object">Thread</span>.sleep(random.nextInt(10) * 1000)
}</p><p class="paragraph"><span class="java-keyword">final</span> Actor waitingRoom</p><p class="paragraph">waitingRoom = group.actor {
    <span class="java-keyword">final</span> <span class="java-object">int</span> capacity = 5
    <span class="java-keyword">final</span> List&lt;Customer&gt; waitingCustomers = []
    <span class="java-object">boolean</span> barberAsleep = <span class="java-keyword">true</span></p><p class="paragraph">    loop {
        react {message -&gt;
            <span class="java-keyword">switch</span> (message) {
                <span class="java-keyword">case</span> Enter:
                    <span class="java-keyword">if</span> (waitingCustomers.size() == capacity) {
                        reply <span class="java-keyword">new</span> Full()
                    } <span class="java-keyword">else</span> {
                        waitingCustomers &lt;&lt; message.customer
                        <span class="java-keyword">if</span> (barberAsleep) {
                            assert waitingCustomers.size() == 1
                            barberAsleep = <span class="java-keyword">false</span>
                            waitingRoom.send <span class="java-keyword">new</span> Next()
                        }
                        <span class="java-keyword">else</span> reply <span class="java-keyword">new</span> Wait()
                    }
                    <span class="java-keyword">break</span>
                <span class="java-keyword">case</span> Next:
                    <span class="java-keyword">if</span> (waitingCustomers.size()&gt;0) {
                        def customer = waitingCustomers.remove(0)
                        barber.send <span class="java-keyword">new</span> Enter(customer:customer)
                    } <span class="java-keyword">else</span> {
                        barber.send <span class="java-keyword">new</span> Wait()
                        barberAsleep = <span class="java-keyword">true</span>
                    }
            }
        }
    }</p><p class="paragraph">}</p><p class="paragraph">class Customer <span class="java-keyword">extends</span> DefaultActor {
    <span class="java-object">String</span> name
    Actor localBarbers</p><p class="paragraph">    void act() {
        localBarbers &lt;&lt; <span class="java-keyword">new</span> Enter(customer:<span class="java-keyword">this</span>)
        loop {
            react {message -&gt;
                <span class="java-keyword">switch</span> (message) {
                    <span class="java-keyword">case</span> Full:
                        println <span class="java-quote">"Customer: $name: The waiting room is full. I am leaving."</span>
                        stop()
                        <span class="java-keyword">break</span>
                    <span class="java-keyword">case</span> Wait:
                        println <span class="java-quote">"Customer: $name: I will wait."</span>
                        <span class="java-keyword">break</span>
                    <span class="java-keyword">case</span> Start:
                        println <span class="java-quote">"Customer: $name: I am now being served."</span>
                        <span class="java-keyword">break</span>
                    <span class="java-keyword">case</span> Done:
                        println <span class="java-quote">"Customer: $name: I have been served."</span>
                        stop();
                        <span class="java-keyword">break</span></p><p class="paragraph">                }
            }
        }
    }
}</p><p class="paragraph">class Enter { Customer customer }
class Full {}
class Wait {}
class Next {}
class Start {}
class Done {}</p><p class="paragraph">def customers = []
customers &lt;&lt; <span class="java-keyword">new</span> Customer(name:'Joe', localBarbers:waitingRoom).start()
customers &lt;&lt; <span class="java-keyword">new</span> Customer(name:'Dave', localBarbers:waitingRoom).start()
customers &lt;&lt; <span class="java-keyword">new</span> Customer(name:'Alice', localBarbers:waitingRoom).start()</p><p class="paragraph">sleep 15000
customers &lt;&lt; <span class="java-keyword">new</span> Customer(name: 'James', localBarbers: waitingRoom).start()
sleep 5000
customers*.join()
barber.stop()
waitingRoom.stop()</p></pre></div>
<h2>Dining Philosophers</h2><p class="paragraph"><a href="http://en.wikipedia.org/wiki/Dining_philosophers_problem" target="blank">Problem description</a></p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.actor.DefaultActor
<span class="java-keyword">import</span> groovyx.gpars.actor.Actors<p class="paragraph">Actors.defaultActorPGroup.resize 5</p><p class="paragraph"><span class="java-keyword">final</span> class Philosopher <span class="java-keyword">extends</span> DefaultActor {
    <span class="java-keyword">private</span> Random random = <span class="java-keyword">new</span> Random()</p><p class="paragraph">    <span class="java-object">String</span> name
    def forks = []</p><p class="paragraph">    void act() {
        assert 2 == forks.size()
        loop {
            think()
            forks*.send <span class="java-keyword">new</span> Take()
            def messages = []
            react {a -&gt;
                messages &lt;&lt; [a, sender]
                react {b -&gt;
                    messages &lt;&lt; [b, sender]
                    <span class="java-keyword">if</span> ([a, b].any {Rejected.isCase it}) {
                        println <span class="java-quote">"$name: tOops, can't get my forks! Giving up."</span>
                        <span class="java-keyword">final</span> def accepted = messages.find {Accepted.isCase it[0]}
                        <span class="java-keyword">if</span> (accepted!=<span class="java-keyword">null</span>) accepted[1].send <span class="java-keyword">new</span> Finished()
                    } <span class="java-keyword">else</span> {
                        eat()
                        reply <span class="java-keyword">new</span> Finished()
                    }
                }
            }
        }
    }</p><p class="paragraph">    void think() {
        println <span class="java-quote">"$name: tI'm thinking"</span>
        <span class="java-object">Thread</span>.sleep random.nextInt(5000)
        println <span class="java-quote">"$name: tI'm done thinking"</span>
    }</p><p class="paragraph">    void eat() {
        println <span class="java-quote">"$name: tI'm EATING"</span>
        <span class="java-object">Thread</span>.sleep random.nextInt(2000)
        println <span class="java-quote">"$name: tI'm done EATING"</span>
    }
}</p><p class="paragraph"><span class="java-keyword">final</span> class Fork <span class="java-keyword">extends</span> DefaultActor {</p><p class="paragraph">    <span class="java-object">String</span> name
    <span class="java-object">boolean</span> available = <span class="java-keyword">true</span></p><p class="paragraph">    void act() {
        loop {
            react {message -&gt;
                <span class="java-keyword">switch</span> (message) {
                    <span class="java-keyword">case</span> Take:
                        <span class="java-keyword">if</span> (available) {
                            available = <span class="java-keyword">false</span>
                            reply <span class="java-keyword">new</span> Accepted()
                        } <span class="java-keyword">else</span> reply <span class="java-keyword">new</span> Rejected()
                        <span class="java-keyword">break</span>
                    <span class="java-keyword">case</span> Finished:
                        assert !available
                        available = <span class="java-keyword">true</span>
                        <span class="java-keyword">break</span>
                    <span class="java-keyword">default</span>: <span class="java-keyword">throw</span> <span class="java-keyword">new</span> IllegalStateException(<span class="java-quote">"Cannot process the message: $message"</span>)
                }
            }
        }
    }
}</p><p class="paragraph"><span class="java-keyword">final</span> class Take {}
<span class="java-keyword">final</span> class Accepted {}
<span class="java-keyword">final</span> class Rejected {}
<span class="java-keyword">final</span> class Finished {}</p><p class="paragraph">def forks = [
        <span class="java-keyword">new</span> Fork(name:'Fork 1'),
        <span class="java-keyword">new</span> Fork(name:'Fork 2'),
        <span class="java-keyword">new</span> Fork(name:'Fork 3'),
        <span class="java-keyword">new</span> Fork(name:'Fork 4'),
        <span class="java-keyword">new</span> Fork(name:'Fork 5')
]</p><p class="paragraph">def philosophers = [
        <span class="java-keyword">new</span> Philosopher(name:'Joe', forks:[forks[0], forks[1]]),
        <span class="java-keyword">new</span> Philosopher(name:'Dave', forks:[forks[1], forks[2]]),
        <span class="java-keyword">new</span> Philosopher(name:'Alice', forks:[forks[2], forks[3]]),
        <span class="java-keyword">new</span> Philosopher(name:'James', forks:[forks[3], forks[4]]),
        <span class="java-keyword">new</span> Philosopher(name:'Phil', forks:[forks[4], forks[0]]),
]</p><p class="paragraph">forks*.start()
philosophers*.start()</p><p class="paragraph">sleep 10000
forks*.stop()
philosophers*.stop()</p></pre></div>
<h2>Word sort</h2><p class="paragraph">Given a folder name, the script will sort words in all files in the folder. The  <em class="italic">SortMaster</em>  actor creates a given number of  <em class="italic">WordSortActors</em>  , splits among them the files to sort words in and collects the results.</p><p class="paragraph"><a href="http://fupeg.blogspot.com/2009/06/scala-concurrency.html" target="blank">Inspired by Scala Concurrency blog post by Michael Galpin</a></p><p class="paragraph"></p><div class="code"><pre>//Messages
<span class="java-keyword">private</span> <span class="java-keyword">final</span> class FileToSort { <span class="java-object">String</span> fileName }
<span class="java-keyword">private</span> <span class="java-keyword">final</span> class SortResult { <span class="java-object">String</span> fileName; List&lt;<span class="java-object">String</span>&gt; words }<p class="paragraph">//Worker actor
class WordSortActor <span class="java-keyword">extends</span> DefaultActor {</p><p class="paragraph">    <span class="java-keyword">private</span> List&lt;<span class="java-object">String</span>&gt; sortedWords(<span class="java-object">String</span> fileName) {
        parseFile(fileName).sort {it.toLowerCase()}
    }</p><p class="paragraph">    <span class="java-keyword">private</span> List&lt;<span class="java-object">String</span>&gt; parseFile(<span class="java-object">String</span> fileName) {
        List&lt;<span class="java-object">String</span>&gt; words = []
        <span class="java-keyword">new</span> File(fileName).splitEachLine(' ') {words.addAll(it)}
        <span class="java-keyword">return</span> words
    }</p><p class="paragraph">    void act() {
        loop {
            react {message -&gt;
                <span class="java-keyword">switch</span> (message) {
                    <span class="java-keyword">case</span> FileToSort:
                        println <span class="java-quote">"Sorting file=${message.fileName} on thread ${<span class="java-object">Thread</span>.currentThread().name}"</span>
                        reply <span class="java-keyword">new</span> SortResult(fileName: message.fileName, words: sortedWords(message.fileName))
                }
            }
        }
    }
}</p><p class="paragraph">//Master actor
<span class="java-keyword">final</span> class SortMaster <span class="java-keyword">extends</span> DefaultActor {</p><p class="paragraph">    <span class="java-object">String</span> docRoot = '/'
    <span class="java-object">int</span> numActors = 1</p><p class="paragraph">    List&lt;List&lt;<span class="java-object">String</span>&gt;&gt; sorted = []
    <span class="java-keyword">private</span> CountDownLatch startupLatch = <span class="java-keyword">new</span> CountDownLatch(1)
    <span class="java-keyword">private</span> CountDownLatch doneLatch</p><p class="paragraph">    <span class="java-keyword">private</span> void beginSorting() {
        <span class="java-object">int</span> cnt = sendTasksToWorkers()
        doneLatch = <span class="java-keyword">new</span> CountDownLatch(cnt)
    }</p><p class="paragraph">    <span class="java-keyword">private</span> List createWorkers() {
        <span class="java-keyword">return</span> (1..numActors).collect {<span class="java-keyword">new</span> WordSortActor().start()}
    }</p><p class="paragraph">    <span class="java-keyword">private</span> <span class="java-object">int</span> sendTasksToWorkers() {
        List&lt;Actor&gt; workers = createWorkers()
        <span class="java-object">int</span> cnt = 0
        <span class="java-keyword">new</span> File(docRoot).eachFile {
            workers[cnt % numActors] &lt;&lt; <span class="java-keyword">new</span> FileToSort(fileName: it)
            cnt += 1
        }
        <span class="java-keyword">return</span> cnt
    }</p><p class="paragraph">    <span class="java-keyword">public</span> void waitUntilDone() {
        startupLatch.await()
        doneLatch.await()
    }</p><p class="paragraph">    void act() {
        beginSorting()
        startupLatch.countDown()
        loop {
            react {
                <span class="java-keyword">switch</span> (it) {
                    <span class="java-keyword">case</span> SortResult:
                        sorted &lt;&lt; it.words
                        doneLatch.countDown()
                        println <span class="java-quote">"Received results <span class="java-keyword">for</span> file=${it.fileName}"</span>
                }
            }
        }
    }
}</p><p class="paragraph">//start the actors to sort words
def master = <span class="java-keyword">new</span> SortMaster(docRoot: 'c:/tmp/Logs/', numActors: 5).start()
master.waitUntilDone()
println 'Done'</p><p class="paragraph">File file = <span class="java-keyword">new</span> File(<span class="java-quote">"c:/tmp/Logs/sorted_words.txt"</span>)
file.withPrintWriter { printer -&gt;
    master.sorted.each { printer.println it }
}</p></pre></div>
<h2>Load Balancer</h2><p class="paragraph">Demonstrates work balancing 
among adaptable set of workers. The load balancer receives tasks and 
queues them in a temporary task queue. When a worker finishes his 
assignment, it asks the load balancer for a new task.</p><p class="paragraph">If the load balancer doesn't have any tasks available in the task queue, the worker is stopped.
If the number of tasks in the task queue exceeds certain limit, a new worker is created to increase size of the worker pool.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.actor.Actor
<span class="java-keyword">import</span> groovyx.gpars.actor.DefaultActor<p class="paragraph">/**
 * Demonstrates work balancing among adaptable set of workers.
 * The load balancer receives tasks and queues them in a temporary task queue.
 * When a worker finishes his assignment, it asks the load balancer <span class="java-keyword">for</span> a <span class="java-keyword">new</span> task.
 * If the load balancer doesn't have any tasks available in the task queue, the worker is stopped.
 * If the number of tasks in the task queue exceeds certain limit, a <span class="java-keyword">new</span> worker is created
 * to increase size of the worker pool.
 */</p><p class="paragraph"><span class="java-keyword">final</span> class LoadBalancer <span class="java-keyword">extends</span> DefaultActor {
    <span class="java-object">int</span> workers = 0
    List taskQueue = []
    <span class="java-keyword">private</span> <span class="java-keyword">static</span> <span class="java-keyword">final</span> QUEUE_SIZE_TRIGGER = 10</p><p class="paragraph">    void act() {
        loop {
            react { message -&gt;
                <span class="java-keyword">switch</span> (message) {
                    <span class="java-keyword">case</span> NeedMoreWork:
                        <span class="java-keyword">if</span> (taskQueue.size() == 0) {
                            println 'No more tasks in the task queue. Terminating the worker.'
                            reply DemoWorker.EXIT
                            workers -= 1
                        } <span class="java-keyword">else</span> reply taskQueue.remove(0)
                        <span class="java-keyword">break</span>
                    <span class="java-keyword">case</span> WorkToDo:
                        taskQueue &lt;&lt; message
                        <span class="java-keyword">if</span> ((workers == 0) || (taskQueue.size() &gt;= QUEUE_SIZE_TRIGGER)) {
                            println 'Need more workers. Starting one.'
                            workers += 1
                            <span class="java-keyword">new</span> DemoWorker(<span class="java-keyword">this</span>).start()
                        }
                }
                println <span class="java-quote">"Active workers=${workers}tTasks in queue=${taskQueue.size()}"</span>
            }
        }
    }
}</p><p class="paragraph"><span class="java-keyword">final</span> class DemoWorker <span class="java-keyword">extends</span> DefaultActor {
    <span class="java-keyword">final</span> <span class="java-keyword">static</span> <span class="java-object">Object</span> EXIT = <span class="java-keyword">new</span> <span class="java-object">Object</span>()
    <span class="java-keyword">private</span> <span class="java-keyword">static</span> <span class="java-keyword">final</span> Random random = <span class="java-keyword">new</span> Random()</p><p class="paragraph">    Actor balancer</p><p class="paragraph">    def DemoWorker(balancer) {
        <span class="java-keyword">this</span>.balancer = balancer
    }</p><p class="paragraph">    void act() {
        loop {
            <span class="java-keyword">this</span>.balancer &lt;&lt; <span class="java-keyword">new</span> NeedMoreWork()
            react {
                <span class="java-keyword">switch</span> (it) {
                    <span class="java-keyword">case</span> WorkToDo:
                        processMessage(it)
                        <span class="java-keyword">break</span>
                    <span class="java-keyword">case</span> EXIT: terminate()
                }
            }
        }</p><p class="paragraph">    }</p><p class="paragraph">    <span class="java-keyword">private</span> void processMessage(message) {
        <span class="java-keyword">synchronized</span> (random) {
            <span class="java-object">Thread</span>.sleep random.nextInt(5000)
        }
    }
}
<span class="java-keyword">final</span> class WorkToDo {}
<span class="java-keyword">final</span> class NeedMoreWork {}</p><p class="paragraph"><span class="java-keyword">final</span> Actor balancer = <span class="java-keyword">new</span> LoadBalancer().start()</p><p class="paragraph">//produce tasks
<span class="java-keyword">for</span> (i in 1..20) {
    <span class="java-object">Thread</span>.sleep 100
    balancer &lt;&lt; <span class="java-keyword">new</span> WorkToDo()
}</p><p class="paragraph">//produce tasks in a parallel thread
<span class="java-object">Thread</span>.start {
    <span class="java-keyword">for</span> (i in 1..10) {
        <span class="java-object">Thread</span>.sleep 1000
        balancer &lt;&lt; <span class="java-keyword">new</span> WorkToDo()
    }
}</p><p class="paragraph"><span class="java-object">Thread</span>.sleep 35000  //let the queues get empty
balancer &lt;&lt; <span class="java-keyword">new</span> WorkToDo()
balancer &lt;&lt; <span class="java-keyword">new</span> WorkToDo()
<span class="java-object">Thread</span>.sleep 10000</p><p class="paragraph">balancer.stop()
balancer.join()</p></pre></div>


<h1 id="agents">6 Agents</h1>
The Agent class, which is a thread-safe non-blocking shared mutable state wrapper implementation inspired by Agents in Clojure.<p class="paragraph"></p><blockquote class="note">
A lot of the concurrency problems disappear when you eliminate the need 
for Shared Mutable State with your architecture.
Indeed, concepts like actors, CSP or dataflow concurrency avoid or 
isolate mutable state completely.
In some cases, however, sharing mutable data is either inevitable or 
makes the design more natural and understandable. Think, for example,
of a shopping cart in a typical e-commerce application, when multiple 
AJAX requests may hit the cart with read or write requests concurrently.
</blockquote><p class="paragraph"></p><h2>Introduction</h2><p class="paragraph">In
 the Clojure programing language you can find a concept of Agents, the 
purpose of which is to protect mutable data that need to be shared 
across threads.
Agents hide the data and protect it from direct access. Clients can only
 send commands (functions) to the agent. The commands will be serialized
 and processed against the data one-by-one in turn.
With the commands being executed serially the commands do not need to 
care about concurrency and can assume the data is all theirs when run.
Although implemented differently, GPars Agents, called  <em class="italic">Agent</em>
  , fundamentally behave like actors. They accept messages and process 
them asynchronously.
The messages, however, must be commands (functions or Groovy closures) 
and will be executed inside the agent.
After reception the received function is run against the internal state 
of the Agent and the return value of the function is considered to be 
the new internal state of the Agent.</p><p class="paragraph">Essentially, agents safe-guard mutable values by allowing only a single <strong class="bold">agent-managed thread</strong> to make modifications to them. The mutable values are <strong class="bold">not directly accessible</strong> from outside, but instead <strong class="bold">requests have to be sent to the agent</strong> and the agent guarantees to process the requests sequentially on behalf of the callers.
Agents guarantee sequential execution of all requests and so consistency of the values.</p><p class="paragraph">Schematically:
</p><div class="code"><pre>agent = <span class="java-keyword">new</span> Agent(0)  //created a <span class="java-keyword">new</span> Agent wrapping an integer with initial value 0
agent.send {increment()}  //asynchronous send operation, sending the increment() function
…
//after some delay to process the message the internal Agent's state has been updated
…
assert agent.val== 1</pre></div>
To wrap integers, we can certainly use AtomicXXX types on the Java 
platform, but when the state is a more complex object we need more 
support.<p class="paragraph">
</p><h2>Concepts</h2><p class="paragraph">GPars provides an Agent class, which is a special-purpose thread-safe non-blocking implementation inspired by Agents in Clojure.</p><p class="paragraph">An
 Agent wraps a reference to mutable state, held inside a single field, 
and accepts code (closures / commands) as messages, which can be sent to
 the Agent just like to any other actor using the '&lt;&lt;' operator, 
the send() methods or the implicit  <em class="italic">call()</em>  
method.
At some point after reception of a closure / command, the closure is 
invoked against the internal mutable field and can make changes to it. 
The closure is guaranteed to be run without intervention from other 
threads and so may freely alter the internal state of the Agent held in 
the internal &lt;i&gt;data&lt;/i&gt; field.</p><p class="paragraph">The 
whole update process is of the fire-and-forget type, since once the 
message (closure) is sent to the Agent, the caller thread can go off to 
do other things and come back later to check the current value with 
Agent.val or Agent.valAsync(closure).</p><p class="paragraph"></p><h3>Basic rules</h3>
<ul class="star">
<li>When executed, the submitted commands obtain the agent's state as a parameter.</li>
<li>The submitted commands /closures can call any methods on the agent's state.</li>
<li>Replacing the state object with a new one is also possible and is done using the <strong class="bold">updateValue() method</strong>.</li>
<li>The <strong class="bold">return value</strong> of the submitted closure doesn't have a special meaning and is ignored.</li>
<li>If the message sent to an  <em class="italic">Agent</em>  is <strong class="bold">not a closure</strong>, it is considered to be a <strong class="bold">new value</strong> for the internal reference field.</li>
<li>The  <em class="italic">val</em>  property of an  <em class="italic">Agent</em>  will wait until all preceding commands in the agent's queue are consumed and then safely return the value of the Agent.</li>
<li>The  <em class="italic">valAsync()</em>  method will do the same <strong class="bold">without blocking</strong> the caller.</li>
<li>The  <em class="italic">instantVal</em>  property will return an immediate snapshot of the internal agent's state.</li>
<li>All Agent instances share a default daemon thread pool. Setting the  <em class="italic">threadPool</em>  property of an Agent instance will allow it to use a different thread pool.</li>
<li>Exceptions thrown by the commands can be collected using the  <em class="italic">errors</em>  property.</li>
</ul><p class="paragraph"></p><h2>Examples</h2><p class="paragraph"></p><h3>Shared list of members</h3><p class="paragraph">The
 Agent wraps a list of members, who have been added to the jug. To add a
 new member a message (command to add a member) has to be sent to the  <em class="italic">jugMembers</em>  Agent.
</p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.agent.Agent
<span class="java-keyword">import</span> java.util.concurrent.ExecutorService
<span class="java-keyword">import</span> java.util.concurrent.Executors<p class="paragraph">/**
 * Create a <span class="java-keyword">new</span> Agent wrapping a list of strings
 */
def jugMembers = <span class="java-keyword">new</span> Agent&lt;List&lt;<span class="java-object">String</span>&gt;&gt;(['Me'])  //add Me</p><p class="paragraph">jugMembers.send {it.add 'James'}  //add James</p><p class="paragraph"><span class="java-keyword">final</span> <span class="java-object">Thread</span> t1 = <span class="java-object">Thread</span>.start {
    jugMembers.send {it.add 'Joe'}  //add Joe
}</p><p class="paragraph"><span class="java-keyword">final</span> <span class="java-object">Thread</span> t2 = <span class="java-object">Thread</span>.start {
    jugMembers &lt;&lt; {it.add 'Dave'}  //add Dave
    jugMembers {it.add 'Alice'}    //add Alice (using the implicit call() method)
}</p><p class="paragraph">[t1, t2]*.join()
println jugMembers.val
jugMembers.valAsync {println <span class="java-quote">"Current members: $it"</span>}</p><p class="paragraph">jugMembers.await()</p></pre></div><p class="paragraph"></p><h3>Shared conference counting number of registrations</h3><p class="paragraph">The
 Conference class allows registration and un-registration, however these
 methods can only be called from the commands sent to the  <em class="italic">conference</em>  Agent.
</p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.agent.Agent<p class="paragraph">/**
 * Conference stores number of registrations and allows parties to register and unregister.
 * It inherits from the Agent class and adds the register() and unregister() <span class="java-keyword">private</span> methods,
 * which callers may use it the commands they submit to the Conference.
 */
class Conference <span class="java-keyword">extends</span> Agent&lt;<span class="java-object">Long</span>&gt; {
    def Conference() { <span class="java-keyword">super</span>(0) }
    <span class="java-keyword">private</span> def register(<span class="java-object">long</span> num) { data += num }
    <span class="java-keyword">private</span> def unregister(<span class="java-object">long</span> num) { data -= num }
}</p><p class="paragraph"><span class="java-keyword">final</span> Agent conference = <span class="java-keyword">new</span> Conference()  //<span class="java-keyword">new</span> Conference created</p><p class="paragraph">/**
 * Three external parties will <span class="java-keyword">try</span> to register/unregister concurrently
 */</p><p class="paragraph"><span class="java-keyword">final</span> <span class="java-object">Thread</span> t1 = <span class="java-object">Thread</span>.start {
    conference &lt;&lt; {register(10L)}               //send a command to register 10 attendees
}</p><p class="paragraph"><span class="java-keyword">final</span> <span class="java-object">Thread</span> t2 = <span class="java-object">Thread</span>.start {
    conference &lt;&lt; {register(5L)}                //send a command to register 5 attendees
}</p><p class="paragraph"><span class="java-keyword">final</span> <span class="java-object">Thread</span> t3 = <span class="java-object">Thread</span>.start {
    conference &lt;&lt; {unregister(3L)}              //send a command to unregister 3 attendees
}</p><p class="paragraph">[t1, t2, t3]*.join()</p><p class="paragraph">assert 12L == conference.val</p></pre></div><p class="paragraph"></p><h2>Factory methods</h2><p class="paragraph">Agent instances can also be created using the  <em class="italic">Agent.agent()</em>  factory method.</p><p class="paragraph"></p><div class="code"><pre>def jugMembers = Agent.agent ['Me']  //add Me</pre></div><p class="paragraph"></p><h2>Listeners and validators</h2><p class="paragraph">Agents allow the user to add listeners and validators. While listeners will get notified each time the internal state changes,
validators get a chance to reject a coming change by throwing an exception.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> Agent counter = <span class="java-keyword">new</span> Agent()<p class="paragraph">counter.addListener {oldValue, newValue -&gt; println <span class="java-quote">"Changing value from $oldValue to $newValue"</span>}
counter.addListener {agent, oldValue, newValue -&gt; println <span class="java-quote">"Agent $agent changing value from $oldValue to $newValue"</span>}</p><p class="paragraph">counter.addValidator {oldValue, newValue -&gt; <span class="java-keyword">if</span> (oldValue &gt; newValue) <span class="java-keyword">throw</span> <span class="java-keyword">new</span> IllegalArgumentException('Things can only go up in Groovy')}
counter.addValidator {agent, oldValue, newValue -&gt; <span class="java-keyword">if</span> (oldValue == newValue) <span class="java-keyword">throw</span> <span class="java-keyword">new</span> IllegalArgumentException('Things never stay the same <span class="java-keyword">for</span> $agent')}</p><p class="paragraph">counter 10
counter 11
counter {updateValue 12}
counter 10  //Will be rejected
counter {updateValue it - 1}  //Will be rejected
counter {updateValue it}  //Will be rejected
counter {updateValue 11}  //Will be rejected
counter 12  //Will be rejected
counter 20
counter.await()</p></pre></div><p class="paragraph">Both listeners and validators are essentially closures taking two or three arguments. Exceptions thrown from the validators
will be logged inside the agent and can be tested using the  <em class="italic">hasErrors()</em>  method or retrieved through the  <em class="italic">errors</em>  property.</p><p class="paragraph"></p><div class="code"><pre>assert counter.hasErrors()
assert counter.errors.size() == 5</pre></div><p class="paragraph"></p><h3>Validator gotchas</h3><p class="paragraph">With
 Groovy being not very strict on data types and immutability, agent 
users should be aware of potential bumps on the road.
If the submitted code modifies the state directly, validators will not 
be able to un-do the change in case of a validation rule violation.
There are two possible solutions available:
</p><ol>
<li>Make sure you never change the supplied object representing current agent state</li>
<li>Use custom copy strategy on the agent to allow the agent to create copies of the internal state</li>
</ol><p class="paragraph">In both cases you need to call  <em class="italic">updateValue()</em>  to set and validate the new state properly.</p><p class="paragraph">The problem as well as both of the solutions are shown below:</p><p class="paragraph"></p><div class="code"><pre>//Create an agent storing names, rejecting 'Joe'
<span class="java-keyword">final</span> Closure rejectJoeValidator = {oldValue, newValue -&gt; <span class="java-keyword">if</span> ('Joe' in newValue) <span class="java-keyword">throw</span> <span class="java-keyword">new</span> IllegalArgumentException('Joe is not allowed to enter our list.')}<p class="paragraph">Agent agent = <span class="java-keyword">new</span> Agent([])
agent.addValidator rejectJoeValidator</p><p class="paragraph">agent {it &lt;&lt; 'Dave'}                    //Accepted
agent {it &lt;&lt; 'Joe'}                     //Erroneously accepted, since by-passes the validation mechanism
println agent.val</p><p class="paragraph">//Solution 1 - never alter the supplied state object
agent = <span class="java-keyword">new</span> Agent([])
agent.addValidator rejectJoeValidator</p><p class="paragraph">agent {updateValue(['Dave', * it])}      //Accepted
agent {updateValue(['Joe', * it])}       //Rejected
println agent.val</p><p class="paragraph">//Solution 2 - use custom copy strategy on the agent
agent = <span class="java-keyword">new</span> Agent([], {it.clone()})
agent.addValidator rejectJoeValidator</p><p class="paragraph">agent {updateValue it &lt;&lt; 'Dave'}        //Accepted
agent {updateValue it &lt;&lt; 'Joe'}         //Rejected, since 'it' is now just a copy of the internal agent's state
println agent.val</p></pre></div><p class="paragraph"></p><h2>Grouping</h2><p class="paragraph">By default all Agent instances belong to the same group sharing its daemon thread pool.</p><p class="paragraph">Custom
 groups can also create instances of Agent. These instances will belong 
to the group, which created them, and will share a thread pool.
To create an Agent instance belonging to a group, call the  <em class="italic">agent()</em>  factory method on the group. This way you can organize
and tune performance of agents.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> def group = <span class="java-keyword">new</span> NonDaemonPGroup(5)  //create a group around a thread pool
def jugMembers = group.agent(['Me'])  //add Me</pre></div><p class="paragraph"></p><blockquote class="note">
The default thread pool for agents contains daemon threads. Make sure 
that your custom thread pools either use daemon threads, too, which can 
be achieved
either by using DefaultPGroup or by providing your own thread factory to
 a thread pool constructor,
or in case your thread pools use non-daemon threads, such as when using 
the NonDaemonPGroup group class, make sure you shutdown the group or the
 thread pool explicitly by calling its shutdown() method,
otherwise your applications will not exit.
</blockquote><p class="paragraph"></p><h4>Direct pool replacement</h4><p class="paragraph">Alternatively, by calling the  <em class="italic">attachToThreadPool()</em>  method on an Agent instance a custom thread pool can be specified for it.
</p><div class="code"><pre>def jugMembers = <span class="java-keyword">new</span> Agent&lt;List&lt;<span class="java-object">String</span>&gt;&gt;(['Me'])  //add Me<p class="paragraph"><span class="java-keyword">final</span> ExecutorService pool = Executors.newFixedThreadPool(10)
jugMembers.attachToThreadPool(<span class="java-keyword">new</span> DefaultPool(pool))</p></pre></div><p class="paragraph"></p><blockquote class="note">
Remember, like actors, a single Agent instance (aka agent) can never use more than one thread at a time
</blockquote><p class="paragraph"></p><h3>The shopping cart example</h3><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.agent.Agent<p class="paragraph">class ShoppingCart {
    <span class="java-keyword">private</span> def cartState = <span class="java-keyword">new</span> Agent([:])
//----------------- <span class="java-keyword">public</span> methods below here ----------------------------------
    <span class="java-keyword">public</span> void addItem(<span class="java-object">String</span> product, <span class="java-object">int</span> quantity) {
        cartState &lt;&lt; {it[product] = quantity}  //the &lt;&lt; <span class="java-keyword">operator</span> sends
                                               //a message to the Agent
    }    <span class="java-keyword">public</span> void removeItem(<span class="java-object">String</span> product) {
        cartState &lt;&lt; {it.remove(product)}
    }    <span class="java-keyword">public</span> <span class="java-object">Object</span> listContent() {
        <span class="java-keyword">return</span> cartState.val
    }    <span class="java-keyword">public</span> void clearItems() {
        cartState &lt;&lt; performClear
    }</p><p class="paragraph">    <span class="java-keyword">public</span> void increaseQuantity(<span class="java-object">String</span> product, <span class="java-object">int</span> quantityChange) {
        cartState &lt;&lt; <span class="java-keyword">this</span>.&amp;changeQuantity.curry(product, quantityChange)
    }
//----------------- <span class="java-keyword">private</span> methods below here ---------------------------------
    <span class="java-keyword">private</span> void changeQuantity(<span class="java-object">String</span> product, <span class="java-object">int</span> quantityChange, Map items) {
        items[product] = (items[product] ?: 0) + quantityChange
    }    <span class="java-keyword">private</span> Closure performClear = { it.clear() }
}
//----------------- script code below here -------------------------------------
<span class="java-keyword">final</span> ShoppingCart cart = <span class="java-keyword">new</span> ShoppingCart()
cart.addItem 'Pilsner', 10
cart.addItem 'Budweisser', 5
cart.addItem 'Staropramen', 20</p><p class="paragraph">cart.removeItem 'Budweisser'
cart.addItem 'Budweisser', 15</p><p class="paragraph">println <span class="java-quote">"Contents ${cart.listContent()}"</span></p><p class="paragraph">cart.increaseQuantity 'Budweisser', 3
println <span class="java-quote">"Contents ${cart.listContent()}"</span></p><p class="paragraph">cart.clearItems()
println <span class="java-quote">"Contents ${cart.listContent()}"</span></p></pre></div>
You might have noticed two implementation strategies in the code.
<ol>
<li>Public methods may internally just send the required code off to the Agent, instead of executing the same functionality directly</li>
</ol><p class="paragraph">And so sequential code like
</p><div class="code"><pre><span class="java-keyword">public</span> void addItem(<span class="java-object">String</span> product, <span class="java-object">int</span> quantity) {
    cartState[product]=quantity<p class="paragraph">}</p></pre></div>
becomes<p class="paragraph"></p><div class="code"><pre><span class="java-keyword">public</span> void addItem(<span class="java-object">String</span> product, <span class="java-object">int</span> quantity) {
    cartState &lt;&lt; {it[product] = quantity}
}</pre></div>
2. Public methods may send references to internal private methods or closures, which hold the desired functionality to perform
<div class="code"><pre><span class="java-keyword">public</span> void clearItems() {
    cartState &lt;&lt; performClear
}<p class="paragraph"><span class="java-keyword">private</span> Closure performClear = { it.clear() }</p></pre></div>
<strong class="bold">Currying might be necessary</strong>, if the closure takes other arguments besides the current internal state instance. See the  <em class="italic">increaseQuantity</em>  method.<p class="paragraph"></p><h3>The printer service example</h3><p class="paragraph">Another
 example - a not thread-safe printer service shared by multiple threads.
 The printer needs to have the document and quality properties set 
before printing, so obviously a potential for race conditions if not 
guarded properly. Callers don't want to block until the printer is 
available, which the fire-and-forget nature of actors solves very 
elegantly.
</p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.agent.Agent<p class="paragraph">/**
 * A non-thread-safe service that slowly prints documents on at a time
 */
class PrinterService {
    <span class="java-object">String</span> document
    <span class="java-object">String</span> quality</p><p class="paragraph">    <span class="java-keyword">public</span> void printDocument() {
        println <span class="java-quote">"Printing $document in $quality quality"</span>
        <span class="java-object">Thread</span>.sleep 5000
        println <span class="java-quote">"Done printing $document"</span>
    }
}</p><p class="paragraph">def printer = <span class="java-keyword">new</span> Agent&lt;PrinterService&gt;(<span class="java-keyword">new</span> PrinterService())</p><p class="paragraph"><span class="java-keyword">final</span> <span class="java-object">Thread</span> thread1 = <span class="java-object">Thread</span>.start {
    <span class="java-keyword">for</span> (num in (1..3)) {
        <span class="java-keyword">final</span> <span class="java-object">String</span> text = <span class="java-quote">"document $num"</span>
        printer &lt;&lt; {printerService -&gt;
            printerService.document = text
            printerService.quality = 'High'
            printerService.printDocument()
        }
        <span class="java-object">Thread</span>.sleep 200
    }
    println '<span class="java-object">Thread</span> 1 is ready to <span class="java-keyword">do</span> something <span class="java-keyword">else</span>. All print tasks have been submitted'
}</p><p class="paragraph"><span class="java-keyword">final</span> <span class="java-object">Thread</span> thread2 = <span class="java-object">Thread</span>.start {
    <span class="java-keyword">for</span> (num in (1..4)) {
        <span class="java-keyword">final</span> <span class="java-object">String</span> text = <span class="java-quote">"picture $num"</span>
        printer &lt;&lt; {printerService -&gt;
            printerService.document = text
            printerService.quality = 'Medium'
            printerService.printDocument()
        }
        <span class="java-object">Thread</span>.sleep 500
    }
    println '<span class="java-object">Thread</span> 2 is ready to <span class="java-keyword">do</span> something <span class="java-keyword">else</span>. All print tasks have been submitted'
}</p><p class="paragraph">[thread1, thread2]*.join()
printer.await()</p></pre></div>
For latest update, see the respective Demos.<p class="paragraph"></p><h2>Reading the value</h2><p class="paragraph">To follow the clojure philosophy closely the Agent class gives reads higher priority than to writes.
By using the  <em class="italic">instantVal</em>  property your read request will bypass the incoming message queue of the Agent
and return the current snapshot of the internal state.
The  <em class="italic">val</em>  property will wait in the message queue for processing, just like the non-blocking variant
 <em class="italic">valAsync(Clojure cl)</em>  , which will invoke the provided closure with the internal state as a parameter.</p><p class="paragraph">You have to bear in mind that the  <em class="italic">instantVal</em>  property might return although correct, but randomly looking results, since the internal state
of the Agent at the time of  <em class="italic">instantVal</em>  execution is non-deterministic and depends on the messages that have been processed
before the thread scheduler executes the body of  <em class="italic">instantVal</em>  .</p><p class="paragraph">The  <em class="italic">await()</em>  method allows you to wait for processing all the messages submitted to the Agent before and so blocks
the calling thread.</p><p class="paragraph"></p><h2>State copy strategy</h2><p class="paragraph">To avoid leaking the internal state the Agent class allows to specify a copy strategy as the second constructor argument.
With the copy strategy specified, the internal state is processed by the copy strategy closure and the output value
of the copy strategy value is returned to the caller instead of the actual internal state. This applies to  <em class="italic">instantVal</em> ,
 <em class="italic">val</em>  as well as to  <em class="italic">valAsync()</em>  .</p><p class="paragraph"></p><h2>Error handling</h2><p class="paragraph">Exceptions thrown from within the submitted commands are stored inside the agent and can be obtained from the  <em class="italic">errors</em>  property.
The property gets cleared once read.
</p><div class="code"><pre>def jugMembers = <span class="java-keyword">new</span> Agent&lt;List&gt;()
    assert jugMembers.errors.empty<p class="paragraph">    jugMembers.send {<span class="java-keyword">throw</span> <span class="java-keyword">new</span> IllegalStateException('test1')}
    jugMembers.send {<span class="java-keyword">throw</span> <span class="java-keyword">new</span> IllegalArgumentException('test2')}
    jugMembers.await()</p><p class="paragraph">    List errors = jugMembers.errors
    assert 2 == errors.size()
    assert errors[0] <span class="java-keyword">instanceof</span> IllegalStateException
    assert 'test1' == errors[0].message
    assert errors[1] <span class="java-keyword">instanceof</span> IllegalArgumentException
    assert 'test2' == errors[1].message</p><p class="paragraph">    assert jugMembers.errors.empty</p></pre></div><p class="paragraph"></p><h2>Fair and Non-fair agents</h2><p class="paragraph">Agents
 can be either fair or non-fair. Fair agents give up the thread after 
processing each message, non-fair agents keep a thread until their 
message queue is empty.
As a result, non-fair agents tend to perform better than fair ones.
The default setting for all Agent instances is to be <strong class="bold">non-fair</strong>, however by calling its  <em class="italic">makeFair()</em>  method the instance can be made fair.
</p><div class="code"><pre>def jugMembers = <span class="java-keyword">new</span> Agent&lt;List&gt;(['Me'])  //add Me
    jugMembers.makeFair()</pre></div>



<h1 id="dataflow">7 Dataflow</h1>
Dataflow concurrency offers an alternative concurrency model, which is inherently safe and robust.<p class="paragraph"></p><h2>Introduction</h2><p class="paragraph">Check
 out the small example written in Groovy using GPars, which sums results
 of calculations performed by three concurrently run tasks:
</p><div class="code"><pre><span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.Dataflow.task<p class="paragraph"><span class="java-keyword">final</span> def x = <span class="java-keyword">new</span> DataflowVariable()
<span class="java-keyword">final</span> def y = <span class="java-keyword">new</span> DataflowVariable()
<span class="java-keyword">final</span> def z = <span class="java-keyword">new</span> DataflowVariable()</p><p class="paragraph">task {
    z &lt;&lt; x.val + y.val
}</p><p class="paragraph">task {
    x &lt;&lt; 10
}</p><p class="paragraph">task {
    y &lt;&lt; 5
}</p><p class="paragraph">println <span class="java-quote">"Result: ${z.val}"</span></p></pre></div><p class="paragraph">Or the same algorithm rewritten using the  <em class="italic">Dataflows</em>  class.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.Dataflow.task<p class="paragraph"><span class="java-keyword">final</span> def df = <span class="java-keyword">new</span> Dataflows()</p><p class="paragraph">task {
    df.z = df.x + df.y
}</p><p class="paragraph">task {
    df.x = 10
}</p><p class="paragraph">task {
    df.y = 5
}</p><p class="paragraph">println <span class="java-quote">"Result: ${df.z}"</span></p></pre></div><p class="paragraph">We
 start three logical tasks, which can run in parallel and perform their 
particular activities. The tasks need to exchange data and they do so 
using <strong class="bold">Dataflow Variables</strong>.
Think of Dataflow Variables as one-shot channels safely and reliably transferring data from producers to their consumers.</p><p class="paragraph">The Dataflow Variables have a pretty straightforward semantics. When a task needs to read a value from  <em class="italic">DataflowVariable</em>
  (through the val property), it will block until the value has been set
 by another task or thread (using the '&lt;&lt;' operator). Each  <em class="italic">DataflowVariable</em>  can be set <strong class="bold">only once</strong>
 in its lifetime. Notice that you don't have to bother with ordering and
 synchronizing the tasks or threads and their access to shared 
variables. The values are magically transferred among tasks at the right
 time without your intervention.
The data flow seamlessly among tasks / threads without your intervention
 or care.</p><p class="paragraph"><strong class="bold">Implementation detail:</strong> The three tasks in the example <strong class="bold">do not necessarily need to be mapped to three physical threads</strong>.
 Tasks represent so-called "green" or "logical" threads and can be 
mapped under the covers to any number of physical threads. The actual 
mapping depends on the scheduler, but the outcome of dataflow algorithms
 doesn't depend on the actual scheduling.</p><p class="paragraph"></p><blockquote class="note">
The  <em class="italic">bind</em>  operation of dataflow variables silently accepts re-binding to a value, which is equal to an already bound value. Call  <em class="italic">bindUnique</em>  to reject equal values on already-bound variables.
</blockquote><p class="paragraph"></p><h2>Benefits</h2><p class="paragraph">Here's what you gain by using Dataflow Concurrency (by <a href="http://www.jonasboner.com/" target="blank">Jonas Bonér</a> ):
</p><ul class="star">
<li>No race-conditions</li>
<li>No live-locks</li>
<li>Deterministic deadlocks</li>
<li>Completely deterministic programs</li>
<li>BEAUTIFUL code.</li>
</ul><p class="paragraph">This doesn't sound bad, does it?</p><p class="paragraph"></p><h1>Concepts</h1><p class="paragraph"></p><h2>Dataflow programming</h2><p class="paragraph"></p><h4>Quoting Wikipedia</h4><p class="paragraph">Operations
 (in Dataflow programs) consist of "black boxes" with inputs and 
outputs, all of which are always explicitly defined. They run as soon as
 all of their inputs become valid, as opposed to when the program 
encounters them. Whereas a traditional program essentially consists of a
 series of statements saying "do this, now do this", a dataflow program 
is more like a series of workers on an assembly line, who will do their 
assigned task as soon as the materials arrive. This is why dataflow 
languages are inherently parallel; the operations have no hidden state 
to keep track of, and the operations are all "ready" at the same time.</p><p class="paragraph"></p><h2>Principles</h2><p class="paragraph">With Dataflow Concurrency you can safely share variables across tasks. These variables (in Groovy instances of the  <em class="italic">DataflowVariable</em>
  class) can only be assigned (using the '&lt;&lt;' operator) a value 
once in their lifetime. The values of the variables, on the other hand, 
can be read multiple times (in Groovy through the val property), even 
before the value has been assigned. In such cases the reading task is 
suspended until the value is set by another task.
So you can simply write your code for each task sequentially using 
Dataflow Variables and the underlying mechanics will make sure you get 
all the values you need in a thread-safe manner.</p><p class="paragraph">In brief, you generally perform three operations with Dataflow variables:
</p><ul class="star">
<li>Create a dataflow variable</li>
<li>Wait for the variable to be bound (read it)</li>
<li>Bind the variable (write to it)</li>
</ul><p class="paragraph">And these are the three essential rules your programs have to follow:
</p><ul class="star">
<li>When the program encounters an unbound variable it waits for a value.</li>
<li>It is not possible to change the value of a dataflow variable once it is bound.</li>
<li>Dataflow variables makes it easy to create concurrent stream agents.</li>
</ul><p class="paragraph"></p><h2>Dataflow Queues and Broadcasts</h2><p class="paragraph">Before you go to check the samples of using <strong class="bold">Dataflow Variables</strong>, <strong class="bold">Tasks</strong> and <strong class="bold">Operators</strong>, you should know a bit about streams and queues to have a full picture of Dataflow Concurrency.
Except for dataflow variables there are also the concepts of  <em class="italic">DataflowQueues</em>  and  <em class="italic">DataflowBroadcast</em>
  that you can leverage in your code.
You may think of them as thread-safe buffers or queues for message 
transfer among concurrent tasks or threads. Check out a typical 
producer-consumer demo:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.Dataflow.task<p class="paragraph">def words = ['Groovy', 'fantastic', 'concurrency', 'fun', 'enjoy', 'safe', 'GPars', 'data', 'flow']
<span class="java-keyword">final</span> def buffer = <span class="java-keyword">new</span> DataflowQueue()</p><p class="paragraph">task {
    <span class="java-keyword">for</span> (word in words) {
        buffer &lt;&lt; word.toUpperCase()  //add to the buffer
    }
}</p><p class="paragraph">task {
    <span class="java-keyword">while</span>(<span class="java-keyword">true</span>) println buffer.val  //read from the buffer in a loop
}</p></pre></div><p class="paragraph">Both  <em class="italic">DataflowBroadcasts</em>  and  <em class="italic">DataflowQueues</em>  , just like  <em class="italic">DataflowVariables</em>  , implement the  <em class="italic">DataflowChannel</em>  interface with common methods allowing users
to write to them and read values from them. The ability to treat both types identically through the  <em class="italic">DataflowChannel</em>  interface comes in handy
once you start using them to wire  <em class="italic">tasks</em>  ,  <em class="italic">operators</em>  or  <em class="italic">selectors</em>  together.</p><p class="paragraph"></p><blockquote class="note">
The  <em class="italic">DataflowChannel</em>  interface combines two interfaces, each serving its purpose:
<ul class="star">
<li>DataflowReadChannel holding all the methods necessary for reading 
values from a channel - getVal(), getValAsync(), whenBound(), etc.</li>
<li>DataflowWriteChannel holding all the methods necessary for writing values into a channel - bind(), &lt;&lt;</li>
</ul><p class="paragraph">You may prefer using these dedicated interfaces instead of the general  <em class="italic">DataflowChannel</em>  interface, to better express the intended usage.
</p></blockquote><p class="paragraph">Please refer to the <a href="http://gpars.codehaus.org/API+doc" target="blank">API doc</a> for more details on the channel interfaces.</p><p class="paragraph"></p><h3>Point-to-point communication</h3><p class="paragraph">The  <em class="italic">DataflowQueue</em>
  class can be viewed as a point-to-point (1 to 1, many to 1) 
communication channel. It allows one or more producers send messages to 
one reader.
If multiple readers read from the same  <em class="italic">DataflowQueue</em>  , they will each consume different messages. Or to put it a different way, each message is consumed by exactly one reader.
You can easily imagine a simple load-balancing scheme built around a shared  <em class="italic">DataflowQueue</em>  with readers being added dynamically when the consumer part of your algorithm needs to scale up.
This is also a useful default choice when connecting tasks or operators.</p><p class="paragraph"></p><h3>Publish-subscribe communication</h3><p class="paragraph">The  <em class="italic">DataflowBroadcast</em>
  class offers a publish-subscribe (1 to many, many to many) 
communication model. One or more producers write messages,
while all registered readers will receive all the messages. Each message
 is thus consumed by all readers with a valid subscription at the moment
 when the message is being written to the channel.
The readers subscribe by calling the  <em class="italic">createReadChannel()</em>  method.</p><p class="paragraph"></p><div class="code"><pre>DataflowWriteChannel broadcastStream = <span class="java-keyword">new</span> DataflowBroadcast()
DataflowReadChannel stream1 = broadcastStream.createReadChannel()
DataflowReadChannel stream2 = broadcastStream.createReadChannel()
broadcastStream &lt;&lt; 'Message1'
broadcastStream &lt;&lt; 'Message2'
broadcastStream &lt;&lt; 'Message3'
assert stream1.val == stream2.val
assert stream1.val == stream2.val
assert stream1.val == stream2.val</pre></div><p class="paragraph">Under the hood  <em class="italic">DataflowBroadcast</em>  uses the  <em class="italic">DataflowStream</em>  class to implement the message delivery.</p><p class="paragraph"></p><h2>DataflowStream</h2><p class="paragraph">The  <em class="italic">DataflowStream</em>
  class represents a deterministic dataflow channel. It is build around 
the concept of a functional queue and so provides a lock-free 
thread-safe implementation for message passing.
Essentially, you may think of  <em class="italic">DataflowStream</em>  as a 1 to many communication channel, since when a reader consumes a messages,
other readers will still be able to read the message. Also, all messages arrive to all readers in the same order.
Since  <em class="italic">DataflowStream</em>  is implemented as a functional queue, its API requires that users traverse the values in the stream themselves.
On the other hand  <em class="italic">DataflowStream</em>  offers handy methods for value filtering or transformation together with interesting performance characteristics.</p><p class="paragraph"></p><blockquote class="note">
The  <em class="italic">DataflowStream</em>  class, unlike the other communication elements, does not implement the  <em class="italic">DataflowChannel</em>  interface, since the semantics of its use is different.
Use  <em class="italic">DataflowStreamReadAdapter</em>  and  <em class="italic">DataflowStreamWriteAdapter</em>  classes to wrap instances of the  <em class="italic">DataflowChannel</em>  class
in  <em class="italic">DataflowReadChannel</em>  or  <em class="italic">DataflowWriteChannel</em>  implementations.
</blockquote><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.stream.DataflowStream
<span class="java-keyword">import</span> groovyx.gpars.group.DefaultPGroup
<span class="java-keyword">import</span> groovyx.gpars.scheduler.ResizeablePool<p class="paragraph">/**
 * Demonstrates concurrent implementation of the Sieve of Eratosthenes using dataflow tasks
 *
 * In principle, the algorithm consists of a concurrently run chained filters,
 * each of which detects whether the current number can be divided by a single prime number.
 * (generate nums 1, 2, 3, 4, 5, ...) -&gt; (filter by mod 2) -&gt; (filter by mod 3) -&gt; (filter by mod 5) -&gt; (filter by mod 7) -&gt; (filter by mod 11) -&gt; (caution! Primes falling out here)
 * The chain is built (grows) on the fly, whenever a <span class="java-keyword">new</span> prime is found
 */</p><p class="paragraph">/**
 * We need a resizeable thread pool, since tasks consume threads <span class="java-keyword">while</span> waiting blocked <span class="java-keyword">for</span> values at DataflowQueue.val
 */
group = <span class="java-keyword">new</span> DefaultPGroup(<span class="java-keyword">new</span> ResizeablePool(<span class="java-keyword">true</span>))</p><p class="paragraph"><span class="java-keyword">final</span> <span class="java-object">int</span> requestedPrimeNumberCount = 100</p><p class="paragraph">/**
 * Generating candidate numbers
 */
<span class="java-keyword">final</span> DataflowStream candidates = <span class="java-keyword">new</span> DataflowStream()
group.task {
    candidates.generate(2, {it + 1}, {it &lt; 1000})
}</p><p class="paragraph">/**
 * Chain a <span class="java-keyword">new</span> filter <span class="java-keyword">for</span> a particular prime number to the end of the Sieve
 * @param inChannel The current end channel to consume
 * @param prime The prime number to divide <span class="java-keyword">future</span> prime candidates with
 * @<span class="java-keyword">return</span> A <span class="java-keyword">new</span> channel ending the whole chain
 */
def filter(DataflowStream inChannel, <span class="java-object">int</span> prime) {
    inChannel.filter { number -&gt;
        group.task {
            number % prime != 0
        }
    }
}</p><p class="paragraph">/**
 * Consume Sieve output and add additional filters <span class="java-keyword">for</span> all found primes
 */
def currentOutput = candidates
requestedPrimeNumberCount.times {
    <span class="java-object">int</span> prime = currentOutput.first
    println <span class="java-quote">"Found: $prime"</span>
    currentOutput = filter(currentOutput, prime)
}</p></pre></div><p class="paragraph">For convenience and for the ability to use  <em class="italic">DataflowStream</em>  with other dataflow constructs, like e.g. operators,
you can wrap it with  <em class="italic">DataflowReadAdapter</em>  for read access or  <em class="italic">DataflowWriteAdapter</em>  for write access.
The  <em class="italic">DataflowStream</em>  class is designed for single-threaded producers and consumers. If multiple threads are supposed to read or write values
to the stream, their access to the stream must be serialized externally or the adapters should be used.</p><p class="paragraph"></p><h3>DataflowStream Adapters</h3><p class="paragraph">Since the  <em class="italic">DataflowStream</em>  API as well as the semantics of its use are very different from the one defined by  <em class="italic">Dataflow(Read/Write)Channel</em>  , adapters have to be used in order to allow  <em class="italic">DataflowStreams</em> 
to be used with other dataflow elements.
The  <em class="italic">DataflowStreamReadAdapter</em>  class will wrap a  <em class="italic">DataflowStream</em>  with necessary methods to read values, while the  <em class="italic">DataflowStreamWriteAdapter</em>  class
will provide write methods around the wrapped  <em class="italic">DataflowStream</em>  .</p><p class="paragraph"></p><blockquote class="note">
It is important to mention that the  <em class="italic">DataflowStreamWriteAdapter</em>  is thread safe allowing multiple threads to add values to the wrapped  <em class="italic">DataflowStream</em>  through the adapter.
On the other hand,  <em class="italic">DataflowStreamReadAdapter</em>  is designed to be used by a single thread.<p class="paragraph">To minimize the overhead and stay in-line with the  <em class="italic">DataflowStream</em>  semantics, the  <em class="italic">DataflowStreamReadAdapter</em>  class is not thread-safe
and should only be used from within a single thread.
If multiple threads need to read from a DataflowStream, they should each create their own wrapping  <em class="italic">DataflowStreamReadAdapter</em>  .
</p></blockquote><p class="paragraph">Thanks to the adapters  <em class="italic">DataflowStream</em>  can be used for communication between operators or selectors, which expect  <em class="italic">Dataflow(Read/Write)Channels</em>  .</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowQueue
<span class="java-keyword">import</span> groovyx.gpars.dataflow.stream.DataflowStream
<span class="java-keyword">import</span> groovyx.gpars.dataflow.stream.DataflowStreamReadAdapter
<span class="java-keyword">import</span> groovyx.gpars.dataflow.stream.DataflowStreamWriteAdapter
<span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.Dataflow.selector
<span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.Dataflow.<span class="java-keyword">operator</span><p class="paragraph">/**
 * Demonstrates the use of DataflowStreamAdapters to allow dataflow operators to use DataflowStreams
 */</p><p class="paragraph"><span class="java-keyword">final</span> DataflowStream a = <span class="java-keyword">new</span> DataflowStream()
<span class="java-keyword">final</span> DataflowStream b = <span class="java-keyword">new</span> DataflowStream()
def aw = <span class="java-keyword">new</span> DataflowStreamWriteAdapter(a)
def bw = <span class="java-keyword">new</span> DataflowStreamWriteAdapter(b)
def ar = <span class="java-keyword">new</span> DataflowStreamReadAdapter(a)
def br = <span class="java-keyword">new</span> DataflowStreamReadAdapter(b)</p><p class="paragraph">def result = <span class="java-keyword">new</span> DataflowQueue()</p><p class="paragraph">def op1 = <span class="java-keyword">operator</span>(ar, bw) {
    bindOutput it
}
def op2 = selector([br], [result]) {
    result &lt;&lt; it
}</p><p class="paragraph">aw &lt;&lt; 1
aw &lt;&lt; 2
aw &lt;&lt; 3
assert([1, 2, 3] == [result.val, result.val, result.val])
op1.stop()
op2.stop()
op1.join()
op2.join()</p></pre></div><p class="paragraph">Also the ability to select a value from multiple  <em class="italic">DataflowChannels</em>  can only be used through an adapter around a  <em class="italic">DataflowStream</em>  :</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.Select
<span class="java-keyword">import</span> groovyx.gpars.dataflow.stream.DataflowStream
<span class="java-keyword">import</span> groovyx.gpars.dataflow.stream.DataflowStreamReadAdapter
<span class="java-keyword">import</span> groovyx.gpars.dataflow.stream.DataflowStreamWriteAdapter
<span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.Dataflow.select
<span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.Dataflow.task<p class="paragraph">/**
 * Demonstrates the use of DataflowStreamAdapters to allow dataflow select to select on DataflowStreams
 */</p><p class="paragraph"><span class="java-keyword">final</span> DataflowStream a = <span class="java-keyword">new</span> DataflowStream()
<span class="java-keyword">final</span> DataflowStream b = <span class="java-keyword">new</span> DataflowStream()
def aw = <span class="java-keyword">new</span> DataflowStreamWriteAdapter(a)
def bw = <span class="java-keyword">new</span> DataflowStreamWriteAdapter(b)
def ar = <span class="java-keyword">new</span> DataflowStreamReadAdapter(a)
def br = <span class="java-keyword">new</span> DataflowStreamReadAdapter(b)</p><p class="paragraph"><span class="java-keyword">final</span> Select&lt;?&gt; select = select(ar, br)
task {
    aw &lt;&lt; 1
    aw &lt;&lt; 2
    aw &lt;&lt; 3
}
assert 1 == select().value
assert 2 == select().value
assert 3 == select().value
task {
    bw &lt;&lt; 4
    aw &lt;&lt; 5
    bw &lt;&lt; 6
}
def result = (1..3).collect{select()}.sort{it.value}
assert result*.value == [4, 5, 6]
assert result*.index == [1, 0, 1]</p></pre></div><p class="paragraph"></p><blockquote class="note">
If you don't need any of the functional queue  <em class="italic">DataflowStream-special</em>  functionality, like generation, filtering or mapping,
you may consider using the  <em class="italic">DataflowBroadcast</em>  class instead, which offers the  <em class="italic">publish-subscribe</em>  communication model through the  <em class="italic">DataflowChannel</em>  interface.
</blockquote><p class="paragraph"></p><h2>Bind handlers</h2><p class="paragraph"></p><div class="code"><pre>def a = <span class="java-keyword">new</span> DataflowVariable()
a &gt;&gt; {println <span class="java-quote">"The variable has just been bound to $it"</span>}
a.whenBound {println <span class="java-quote">"Just to confirm that the variable has been really set to $it"</span>}
...</pre></div><p class="paragraph">Bind handlers can be registered on 
all dataflow channels (variables, queues or broadcasts) either using the
 &gt;&gt; operator and the  <em class="italic">then()</em>  or the  <em class="italic">whenBound()</em>  methods. They will be run once a value is bound to the variable.</p><p class="paragraph">Dataflow queues and broadcasts also support a  <em class="italic">wheneverBound</em>  method to register a closure or a message handler to run each time a value is bound to them.</p><p class="paragraph"></p><div class="code"><pre>def queue = <span class="java-keyword">new</span> DataflowQueue()
queue.wheneverBound {println <span class="java-quote">"A value $it arrived to the queue"</span>}</pre></div><p class="paragraph">Obviously
 nothing prevents you from having more of such handlers for a single 
promise: They will all trigger in parallel once the promise has a 
concrete value:</p><p class="paragraph"></p><div class="code"><pre>Promise bookingPromise = task {
    <span class="java-keyword">final</span> data = collectData()
    <span class="java-keyword">return</span> broker.makeBooking(data)
}
…
bookingPromise.whenBound {booking -&gt; printAgenda booking}
bookingPromise.whenBound {booking -&gt; sendMeAnEmailTo booking}
bookingPromise.whenBound {booking -&gt; updateTheCalendar booking}</pre></div><p class="paragraph"></p><blockquote class="note">
Dataflow variables and broadcasts are one of several possible ways to implement  <em class="italic">Parallel Speculations</em>  . For details, please check out  <em class="italic">Parallel Speculations</em>  in the  <em class="italic">Parallel Collections</em>  section
of the User Guide.
</blockquote><p class="paragraph"></p><h2>Bind handlers grouping</h2><p class="paragraph">When you need to wait for multiple DataflowVariables/Promises to be bound, you can benefit from calling the  <em class="italic">whenAllBound()</em>  function,
which is available on the  <em class="italic">Dataflow</em>  class as well as on  <em class="italic">PGroup</em>  instances.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> group = <span class="java-keyword">new</span> NonDaemonPGroup()<p class="paragraph">    //Calling asynchronous services and receiving back promises <span class="java-keyword">for</span> the reservations
    Promise flightReservation = flightBookingService('PRG &lt;-&gt; BRU')
    Promise hotelReservation = hotelBookingService('BRU:Feb 24 2009 - Feb 29 2009')
    Promise taxiReservation = taxiBookingService('BRU:Feb 24 2009 10:31')</p><p class="paragraph">    //when all reservations have been made we need to build an agenda <span class="java-keyword">for</span> our trip
    Promise agenda = group.whenAllBound(flightReservation, hotelReservation, taxiReservation) {flight, hotel, taxi -&gt;
        <span class="java-quote">"Agenda: $flight | $hotel | $taxi"</span>
    }</p><p class="paragraph">    //since <span class="java-keyword">this</span> is a demo, we will only print the agenda and block till it is ready
    println agenda.val</p></pre></div><p class="paragraph">If you cannot specify up-front the number of parameters the  <em class="italic">whenAllBound()</em>  handler takes, use a closure with one argument of type  <em class="italic">List</em> :
</p><div class="code"><pre>Promise module1 = task {
    compile(module1Sources)
}
Promise module2 = task {
    compile(module2Sources)
}
//We don't know the number of modules that will be jarred together, so use a List
<span class="java-keyword">final</span> jarCompiledModules = {List modules -&gt; ...}<p class="paragraph">whenAllBound([module1, module2], jarCompiledModules)</p></pre></div><p class="paragraph"></p><h2>Bind handlers chaining</h2><p class="paragraph">All dataflow channels also support the  <em class="italic">then()</em>  method to register a handler (a callback) that should be invoked when a value becomes available. Unlike  <em class="italic">whenBound()</em>  the  <em class="italic">then()</em>  method allows for chaining,
giving you the option to pass result values between functions asynchronously.
</p><blockquote class="note">
Notice that Groovy allows us to leave out some of the  <em class="italic">dots</em>  in the  <em class="italic">then()</em>  method chains.
</blockquote><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> DataflowVariable variable = <span class="java-keyword">new</span> DataflowVariable()
<span class="java-keyword">final</span> DataflowVariable result = <span class="java-keyword">new</span> DataflowVariable()<p class="paragraph">variable.then {it * 2} then {it + 1} then {result &lt;&lt; it}
variable &lt;&lt; 4
assert 9 == result.val</p></pre></div><p class="paragraph">This could be nicely combined with  <em class="italic">Asynchronous functions</em> </p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> DataflowVariable variable = <span class="java-keyword">new</span> DataflowVariable()
<span class="java-keyword">final</span> DataflowVariable result = <span class="java-keyword">new</span> DataflowVariable()<p class="paragraph"><span class="java-keyword">final</span> doubler = {it * 2}
<span class="java-keyword">final</span> adder = {it + 1}</p><p class="paragraph">variable.then doubler then adder then {result &lt;&lt; it}</p><p class="paragraph"><span class="java-object">Thread</span>.start {variable &lt;&lt; 4}
assert 9 == result.val</p></pre></div><p class="paragraph">or  <em class="italic">ActiveObjects</em> </p><p class="paragraph"></p><div class="code"><pre>@ActiveObject
class ActiveDemoCalculator {
    @ActiveMethod
    def doubler(<span class="java-object">int</span> value) {
        value * 2
    }<p class="paragraph">    @ActiveMethod
    def adder(<span class="java-object">int</span> value) {
        value + 1
    }
}</p><p class="paragraph"><span class="java-keyword">final</span> DataflowVariable result = <span class="java-keyword">new</span> DataflowVariable()
<span class="java-keyword">final</span> calculator = <span class="java-keyword">new</span> ActiveDemoCalculator();
calculator.doubler(4).then {calculator.adder it}.then {result &lt;&lt; it}
assert 9 == result.val</p></pre></div><p class="paragraph"></p><blockquote class="note">
Chaining can save quite some code when calling other asynchronous services from within  <em class="italic">whenBound()</em>  handlers. Asynchronous services,
such as  <em class="italic">Asynchronous Functions</em>  or  <em class="italic">Active Methods</em> , return  <em class="italic">Promises</em>
  for their results. To obtain the actual results
your handlers would either have to block to wait for the value to be 
bound, which would lock the current thread in an unproductive state,
<div class="code"><pre>variable.whenBound {value -&gt;
    Promise promise = asyncFunction(value)
    println promise.get()
}</pre></div>
or, alternatively, it would register another (nested)  <em class="italic">whenBound()</em>  handler, which would result in unnecessarily complex code.
<div class="code"><pre>variable.whenBound {value -&gt;
    asyncFunction(value).whenBound {
        println it
    }
}</pre></div>
For illustration compare the two following code snippets, one using  <em class="italic">whenBound()</em>  and one using  <em class="italic">then()</em>  chaining. They ate both equivalent in terms of functionality and behavior.<p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> DataflowVariable variable = <span class="java-keyword">new</span> DataflowVariable()<p class="paragraph"><span class="java-keyword">final</span> doubler = {it * 2}
<span class="java-keyword">final</span> inc = {it + 1}</p><p class="paragraph">//Using whenBound()
variable.whenBound {value -&gt;
    task {
        doubler(value)
    }.whenBound {doubledValue -&gt;
        task {
            inc(doubledValue)
        }.whenBound {incrementedValue -&gt;
            println incrementedValue
        }
    }
}</p><p class="paragraph">//Using then() chaining
variable.then doubler then inc then <span class="java-keyword">this</span>.&amp;println</p><p class="paragraph"><span class="java-object">Thread</span>.start {variable &lt;&lt; 4}</p></pre></div>
Chaining Promises solves both of these issues elegantly:
<div class="code"><pre>variable &gt;&gt; asyncFunction &gt;&gt; {println it}</pre></div>
</blockquote><p class="paragraph">The  <em class="italic">RightShift</em>  ( <em class="italic">&gt;&gt;</em> ) operator has been overloaded to call  <em class="italic">then()</em>  and so can be chained the same way:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> DataflowVariable variable = <span class="java-keyword">new</span> DataflowVariable()
<span class="java-keyword">final</span> DataflowVariable result = <span class="java-keyword">new</span> DataflowVariable()<p class="paragraph"><span class="java-keyword">final</span> doubler = {it * 2}
<span class="java-keyword">final</span> adder = {it + 1}</p><p class="paragraph">variable &gt;&gt; doubler &gt;&gt; adder &gt;&gt; {result &lt;&lt; it}</p><p class="paragraph"><span class="java-object">Thread</span>.start {variable &lt;&lt; 4}</p><p class="paragraph">assert 9 == result.val</p></pre></div><p class="paragraph"></p><h3>Error handling for Promise chaining</h3><p class="paragraph">Asynchronous operations may obviously throw exceptions. It is important to be able to handle them easily and with little effort.
GPars promises can implicitly propagate exceptions from asynchronous calculations across promise chains.
</p><ol>
<li>Promises propagate result values as well as exceptions. The blocking  <em class="italic">get()</em>  method re-throws the exception that was bound to the Promise and so the caller can handle it.</li>
<li>For asynchronous notifications, the  <em class="italic">whenBound()</em>  handler closure gets the exception passed in as an argument.</li>
<li>The  <em class="italic">then()</em>  method accepts two arguments - a <strong class="bold">value handler</strong> and an optional <strong class="bold">error handler</strong>.
 These will be invoked depending on whether the result is a regular 
value or an exception. If no errorHandler is specified, the exception is
 re-thrown to the Promise returned by  <em class="italic">then()</em>  .</li>
<li>Exactly the same behavior as for  <em class="italic">then()</em>  holds true for the  <em class="italic">whenAllBound()</em>  method, which listens on multiple Promises to get bound</li>
</ol><p class="paragraph"></p><div class="code"><pre>Promise&lt;<span class="java-object">Integer</span>&gt; initial = <span class="java-keyword">new</span> DataflowVariable&lt;<span class="java-object">Integer</span>&gt;()
    Promise&lt;<span class="java-object">String</span>&gt; result = initial.then {it * 2} then {100 / it}                  //Will <span class="java-keyword">throw</span> exception <span class="java-keyword">for</span> 0
            .then {println <span class="java-quote">"Logging the value $it as it passes by"</span>; <span class="java-keyword">return</span> it}      //Since no error handler is defined, exceptions will be ignored
                                                                                    //and silently re-thrown to the next handler in the chain
            .then({<span class="java-quote">"The result <span class="java-keyword">for</span> $num is $it"</span>}, {<span class="java-quote">"Error detected <span class="java-keyword">for</span> $num: $it"</span>}) //Here the exception is caught
    initial &lt;&lt; 0
    println result.get()</pre></div><p class="paragraph">ErrorHandler is a closure that accepts instances of  <em class="italic">Throwable</em>  as its only (optional) argument and returns a value that should be bound to
the result of the  <em class="italic">then()</em>  method call (the returned Promise). If an exception is thrown from within an error handler, it is bound
as an error to the resulting Promise.</p><p class="paragraph"></p><div class="code"><pre>promise.then({it+1})                                                         //Implicitly re-<span class="java-keyword">throws</span> potential exceptions bound to promise
promise.then({it+1}, {e -&gt; <span class="java-keyword">throw</span> e})                                         //Explicitly re-<span class="java-keyword">throws</span> potential exceptions bound to promise
promise.then({it+1}, {e -&gt; <span class="java-keyword">throw</span> <span class="java-keyword">new</span> RuntimeException('Error occurred', e})  //Explicitly re-<span class="java-keyword">throws</span> a <span class="java-keyword">new</span> exception wrapping a potential exception bound to promise</pre></div><p class="paragraph">Just
 like with regular exception handling in Java with try-catch statements,
 this behavior of GPars promises gives asynchronous invocations the 
freedom to handle exceptions
at the place where it is most convenient. You may freely ignore 
exceptions in your code and assume things just work, yet exceptions
will not get accidentally swallowed.</p><p class="paragraph"> </p><div class="code"><pre>task {
    'gpars.codehaus.org'.toURL().text  //should <span class="java-keyword">throw</span> MalformedURLException
}
.then {page -&gt; page.toUpperCase()}
.then {page -&gt; page.contains('GROOVY')}
.then({mentionsGroovy -&gt; println <span class="java-quote">"Groovy found: $mentionsGroovy"</span>}, {error -&gt; println <span class="java-quote">"Error: $error"</span>}).join()</pre></div><p class="paragraph"></p><h4>Handling concrete exception type</h4><p class="paragraph">You may be also more specific about the handled exception type:</p><p class="paragraph"></p><div class="code"><pre>url.then(download)
    .then(calculateHash, {MalformedURLException e -&gt; <span class="java-keyword">return</span> 0})
    .then(formatResult)
    .then(printResult, printError)
    .then(sendNotificationEmail);</pre></div>`<p class="paragraph"></p><h4>Customer-site exception handling</h4><p class="paragraph">You may also leave the exception completely un-handled and let the clients (consumers) handle it:</p><p class="paragraph"></p><div class="code"><pre>`
Promise&lt;<span class="java-object">Object</span>&gt; result = url.then(download).then(calculateHash).then(formatResult).then(printResult);
<span class="java-keyword">try</span> {
    result.get()
} <span class="java-keyword">catch</span> (Exception e) {
    //handle exceptions here
}</pre></div>`<p class="paragraph">
</p><h3>Putting it together</h3><p class="paragraph">By combining  <em class="italic">whenAllBound()</em>  and  <em class="italic">then</em>  (or &gt;&gt;) you can easily create large asynchronous scenarios in a convenient way:</p><p class="paragraph"></p><div class="code"><pre>withPool {
    Closure download = {<span class="java-object">String</span> url -&gt;
        sleep 3000  //Simulate a web read
        'web content'
    }.asyncFun()<p class="paragraph">    Closure loadFile = {<span class="java-object">String</span> fileName -&gt;
        'file content'  //simulate a local file read
    }.asyncFun()</p><p class="paragraph">    Closure hash = {s -&gt; s.hashCode()}</p><p class="paragraph">    Closure compare = {<span class="java-object">int</span> first, <span class="java-object">int</span> second -&gt;
        first == second
    }</p><p class="paragraph">    Closure errorHandler = {println <span class="java-quote">"Error detected: $it"</span>}</p><p class="paragraph">    def all = whenAllBound([
                  download('http://www.gpars.org') &gt;&gt; hash,
                  loadFile('/coolStuff/gpars/website/index.html') &gt;&gt; hash
              ], compare).then({println it}, errorHandler)
    all.join()  //optionally block until the calculation is all done</p></pre></div><p class="paragraph"></p><blockquote class="note">
Notice that only the initial action (function) needs to be asynchronous. The functions further down the pipe will be invoked
asynchronously by the promise even if the are synchronous.
</blockquote><p class="paragraph"></p><h2>Lazy dataflow variables</h2><p class="paragraph">Sometimes you may like to combine the qualities of dataflow variables with their lazy initialization.
</p><div class="code"><pre>Closure&lt;<span class="java-object">String</span>&gt; download = {url -&gt;
    println <span class="java-quote">"Downloading"</span>
    url.toURL().text
}<p class="paragraph">def pageContent = <span class="java-keyword">new</span> LazyDataflowVariable(download.curry(<span class="java-quote">"http://gpars.codehaus.org"</span>))</p></pre></div><p class="paragraph">Instances of  <em class="italic">LazyDataflowVariable</em>  have an initializer specified at construction time, which only gets triggered
when someone asks for its value, either through the blocking  <em class="italic">get()</em>  method or using any of the non-blocking callback
methods, such as  <em class="italic">then()</em>  .
Since  <em class="italic">LazyDataflowVariables</em>  preserve all the goodies of ordinary  <em class="italic">DataflowVariables</em>  , you can again chain them easily
 with other  <em class="italic">lazy</em>  or  <em class="italic">ordinary</em>  dataflow variables.</p><p class="paragraph"></p><h4>Example</h4><p class="paragraph">This
 deserves a more practical example. Taking inspiration from 
http://blog.jcoglan.com/2013/03/30/callbacks-are-imperative-promises-are-functional-nodes-biggest-missed-opportunity/
the
 following piece of code demonstrates use of  <em class="italic">LazyDataflowVariables</em>  to lazily and asynchronously load mutually dependent components into memory.
The components (modules) will be loaded in the order of their dependencies and concurrently, if possible.
Each module will only be loaded once, irrespective of the number of modules that depend on it.
Thanks to laziness only the modules that are transitively needed will be loaded.
Our example uses a simple "diamond" dependency scheme:
</p><ul class="star">
<li>D depends on B and C</li>
<li>C depends on A</li>
<li>B depends on A</li>
</ul><p class="paragraph">When loading D, A will get loaded first. B and C will be loaded concurrently once A has been loaded. D will start loading
once both B and C have been loaded.</p><p class="paragraph"></p><div class="code"><pre>def moduleA = <span class="java-keyword">new</span> LazyDataflowVariable({-&gt;
    println <span class="java-quote">"Loading moduleA into memory"</span>
    sleep 3000
    println <span class="java-quote">"Loaded moduleA into memory"</span>
    <span class="java-keyword">return</span> <span class="java-quote">"moduleA"</span>
})<p class="paragraph">def moduleB = <span class="java-keyword">new</span> LazyDataflowVariable({-&gt;
    moduleA.then {
        println <span class="java-quote">"-&gt;Loading moduleB into memory, since moduleA is ready"</span>
        sleep 3000
        println <span class="java-quote">"  Loaded moduleB into memory"</span>
        <span class="java-keyword">return</span> <span class="java-quote">"moduleB"</span>
    }
})</p><p class="paragraph">def moduleC = <span class="java-keyword">new</span> LazyDataflowVariable({-&gt;
    moduleA.then {
        println <span class="java-quote">"-&gt;Loading moduleC into memory, since moduleA is ready"</span>
        sleep 3000
        println <span class="java-quote">"  Loaded moduleC into memory"</span>
        <span class="java-keyword">return</span> <span class="java-quote">"moduleC"</span>
    }
})</p><p class="paragraph">def moduleD = <span class="java-keyword">new</span> LazyDataflowVariable({-&gt;
    whenAllBound(moduleB, moduleC) { b, c -&gt;
        println <span class="java-quote">"--&gt;Loading moduleD into memory, since moduleB and moduleC are ready"</span>
        sleep 3000
        println <span class="java-quote">"   Loaded moduleD into memory"</span>
        <span class="java-keyword">return</span> <span class="java-quote">"moduleD"</span>
    }
})</p><p class="paragraph">println <span class="java-quote">"Nothing loaded so far"</span>
println <span class="java-quote">"==================================================================="</span>
println <span class="java-quote">"Load module: "</span> + moduleD.get()
println <span class="java-quote">"==================================================================="</span>
println <span class="java-quote">"All requested modules loaded"</span></p></pre></div><p class="paragraph"></p><h2>Dataflow Expressions</h2><p class="paragraph">Look at the magic below:</p><p class="paragraph"></p><div class="code"><pre>def initialDistance = <span class="java-keyword">new</span> DataflowVariable()
def acceleration = <span class="java-keyword">new</span> DataflowVariable()
def time = <span class="java-keyword">new</span> DataflowVariable()<p class="paragraph">task {
    initialDistance &lt;&lt; 100
    acceleration &lt;&lt; 2
    time &lt;&lt; 10
}</p><p class="paragraph">def result = initialDistance + acceleration*0.5*time**2
println 'Total distance ' + result.val</p></pre></div><p class="paragraph">We
 use DataflowVariables that represent several parameters to a 
mathematical equation calculating total distance of an accelerating 
object.
In the equation itself, however, we use the DataflowVariables directly. 
We do not refer to the values they represent
and yet we are able to do the math correctly. This shows that 
DataflowVariables can be very flexible.</p><p class="paragraph">For example, you can call methods on them and these methods will get dispatched to the bound values:</p><p class="paragraph"></p><div class="code"><pre>def name = <span class="java-keyword">new</span> DataflowVariable()
task {
    name &lt;&lt; '  adam   '
}
println name.toUpperCase().trim().val</pre></div><p class="paragraph">You can pass other DataflowVariables as arguments to such methods and the real values will be passed automatically instead:</p><p class="paragraph"></p><div class="code"><pre>def title = <span class="java-keyword">new</span> DataflowVariable()
def searchPhrase = <span class="java-keyword">new</span> DataflowVariable()
task {
    title &lt;&lt; ' Groovy in Action 2nd edition   '
}<p class="paragraph">task {
    searchPhrase &lt;&lt; '2nd'
}</p><p class="paragraph">println title.trim().contains(searchPhrase).val</p></pre></div><p class="paragraph">And you can also query properties of the bound value using directly the DataflowVariable:</p><p class="paragraph"></p><div class="code"><pre>def book = <span class="java-keyword">new</span> DataflowVariable()
def searchPhrase = <span class="java-keyword">new</span> DataflowVariable()
task {
    book &lt;&lt; [
             title:'Groovy in Action 2nd edition   ',
             author:'Dierk Koenig',
             publisher:'Manning']
}<p class="paragraph">task {
    searchPhrase &lt;&lt; '2nd'
}</p><p class="paragraph">book.title.trim().contains(searchPhrase).whenBound {println it}  //Asynchronous waiting</p><p class="paragraph">println book.title.trim().contains(searchPhrase).val  //Synchronous waiting</p></pre></div><p class="paragraph">Please
 note that the result is still a DataflowVariable (DataflowExpression to
 be precise), which you can get the real value from both synchronously 
and asynchronously.</p><p class="paragraph"></p><h2>Bind error notification</h2><p class="paragraph"> <em class="italic">DataflowVariables</em>  offer the ability to send notifications to the registered listeners whenever a bind operation fails. The  <em class="italic">getBindErrorManager()</em>
  method allows for listener to be added and removed.
The listeners get notified in case of a failed attempt to bind a value 
(through bind(), bindSafely(), bindUnique() or leftShift()) or an error 
(through bindError()).</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> DataflowVariable variable = <span class="java-keyword">new</span> DataflowVariable()<p class="paragraph">        variable.getBindErrorManager().addBindErrorListener(<span class="java-keyword">new</span> BindErrorListener() {
            @Override
            void onBindError(<span class="java-keyword">final</span> <span class="java-object">Object</span> oldValue, <span class="java-keyword">final</span> <span class="java-object">Object</span> failedValue, <span class="java-keyword">final</span> <span class="java-object">boolean</span> uniqueBind) {
                println <span class="java-quote">"Bind failed!"</span>
            }</p><p class="paragraph">            @Override
            void onBindError(<span class="java-keyword">final</span> <span class="java-object">Object</span> oldValue, <span class="java-keyword">final</span> Throwable failedError) {
                println <span class="java-quote">"Binding an error failed!"</span>
            }</p><p class="paragraph">            @Override
            <span class="java-keyword">public</span> void onBindError(<span class="java-keyword">final</span> Throwable oldError, <span class="java-keyword">final</span> <span class="java-object">Object</span> failedValue, <span class="java-keyword">final</span> <span class="java-object">boolean</span> uniqueBind) {
                println <span class="java-quote">"Bind failed!"</span>
            }</p><p class="paragraph">            @Override
            <span class="java-keyword">public</span> void onBindError(<span class="java-keyword">final</span> Throwable oldError, <span class="java-keyword">final</span> Throwable failedError) {
                println <span class="java-quote">"Binding an error failed!"</span>
            }</p><p class="paragraph">        })</p></pre></div><p class="paragraph">This allows you to customize reactions to attempts to binding of already bound dataflow variables. For example, using  <em class="italic">bindSafely()</em>  you do not get bind exceptions fired to the caller,
but instead a registered  <em class="italic">BindErrorListener</em>  gets notified.</p><p class="paragraph"></p><h2>Further reading</h2><p class="paragraph"><a href="http://github.com/jboner/scala-dataflow/tree/f9a38992f5abed4df0b12f6a5293f703aa04dc33/src" target="blank">Scala Dataflow library</a> by Jonas Bonér</p><p class="paragraph"><a href="http://jonasboner.com/talks/state_youre_doing_it_wrong/html/all.html" target="blank">JVM concurrency presentation slides</a> by Jonas Bonér</p><p class="paragraph"><a href="http://github.com/larrytheliquid/dataflow/tree/master" target="blank">Dataflow Concurrency library for Ruby</a>



</p><h2 id="dataflow_tasks">7.1 Tasks</h2>
The <strong class="bold">Dataflow tasks</strong> give you an 
easy-to-grasp abstraction of mutually-independent logical tasks or 
threads, which can run
concurrently and exchange data solely through Dataflow Variables, 
Queues, Broadcasts and Streams.
Dataflow tasks with their easy-to-express mutual dependencies and 
inherently sequential body could also be used as a practical 
implementation of UML  <em class="italic">Activity Diagrams</em>  .<p class="paragraph">Check out the examples.</p><p class="paragraph"></p><h3>A simple mashup example</h3><p class="paragraph">In
 the example we're downloading the front pages of three popular web 
sites, each in their own task, while in a separate task we're filtering 
out sites talking about Groovy today and forming the output. The output 
task synchronizes automatically with the three download tasks on the 
three Dataflow variables through which the content of each website is 
passed to the output task.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.GParsPool.withPool
<span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowVariable
<span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.Dataflow.task<p class="paragraph">
/**
 * A simple mashup sample, downloads content of three websites
 * and checks how many of them refer to Groovy.
 */</p><p class="paragraph">def dzone = <span class="java-keyword">new</span> DataflowVariable()
def jroller = <span class="java-keyword">new</span> DataflowVariable()
def theserverside = <span class="java-keyword">new</span> DataflowVariable()</p><p class="paragraph">task {
    println 'Started downloading from DZone'
    dzone &lt;&lt; 'http://www.dzone.com'.toURL().text
    println 'Done downloading from DZone'
}</p><p class="paragraph">task {
    println 'Started downloading from JRoller'
    jroller &lt;&lt; 'http://www.jroller.com'.toURL().text
    println 'Done downloading from JRoller'
}</p><p class="paragraph">task {
    println 'Started downloading from TheServerSide'
    theserverside &lt;&lt; 'http://www.theserverside.com'.toURL().text
    println 'Done downloading from TheServerSide'
}</p><p class="paragraph">task {
    withPool {
        println <span class="java-quote">"<span class="java-object">Number</span> of Groovy sites today: "</span> +
                ([dzone, jroller, theserverside].findAllParallel {
                    it.val.toUpperCase().contains 'GROOVY'
                }).size()
    }
}.join()</p></pre></div><p class="paragraph"></p><h3>Grouping tasks</h3><p class="paragraph">Dataflow tasks can be organized into groups to allow for performance fine-tuning. Groups provide a handy  <em class="italic">task()</em>
  factory method
to create tasks attached to the groups.
Using groups allows you to organize tasks or operators around different 
thread pools (wrapped inside the group).
While the Dataflow.task() command schedules the task on a default thread
 pool (java.util.concurrent.Executor, fixed size=#cpu+1, daemon 
threads),
you may prefer being able to define your own thread pool(s) to run your 
tasks.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.group.DefaultPGroup<p class="paragraph">def group = <span class="java-keyword">new</span> DefaultPGroup()</p><p class="paragraph">group.with {
    task {
        …
    }</p><p class="paragraph">    task {
        …
    }
}</p></pre></div><p class="paragraph"></p><blockquote class="note">
The default thread pool for dataflow tasks contains daemon threads, 
which means your application will exit as soon as the main thread 
finishes and won't wait for all tasks to complete.
When grouping tasks, make sure that your custom thread pools either use 
daemon threads, too, which can be achieved by
using DefaultPGroup or by providing your own thread factory to a thread 
pool constructor,
or in case your thread pools use non-daemon threads, such as when using 
the NonDaemonPGroup group class, make sure you shutdown the group or the
 thread pool explicitly by calling its shutdown() method,
otherwise your applications will not exit.
</blockquote><p class="paragraph">You may selectively override the default group used for tasks, operators, callbacks and other dataflow elements inside
a code block using the _Dataflow.usingGroup() method:
</p><div class="code"><pre>Dataflow.usingGroup(group) {
    task {
        'http://gpars.codehaus.org'.toURL().text  //should <span class="java-keyword">throw</span> MalformedURLException
    }
    .then {page -&gt; page.toUpperCase()}
    .then {page -&gt; page.contains('GROOVY')}
    .then({mentionsGroovy -&gt; println <span class="java-quote">"Groovy found: $mentionsGroovy"</span>}, {error -&gt; println <span class="java-quote">"Error: $error"</span>}).join()
}</pre></div><p class="paragraph">You can always override the default group by being specific:</p><p class="paragraph"></p><div class="code"><pre>Dataflow.usingGroup(group) {
    anotherGroup.task {
        'http://gpars.codehaus.org'.toURL().text  //should <span class="java-keyword">throw</span> MalformedURLException
    }
    .then(anotherGroup) {page -&gt; page.toUpperCase()}
    .then(anotherGroup) {page -&gt; page.contains('GROOVY')}.then(anotherGroup) {println Dataflow.retrieveCurrentDFPGroup();it}
    .then(anotherGroup, {mentionsGroovy -&gt; println <span class="java-quote">"Groovy found: $mentionsGroovy"</span>}, {error -&gt; println <span class="java-quote">"Error: $error"</span>}).join()
}</pre></div><p class="paragraph"></p><h3>A mashup variant with methods</h3><p class="paragraph">To avoid giving you wrong impression about structuring the Dataflow code, here's a rewrite of the mashup example, with a  <em class="italic">downloadPage()</em>
  method performing the actual download in a separate task and returning
 a DataflowVariable instance, so that the main application thread could 
eventually get hold of the downloaded content.
Dataflow variables can obviously be passed around as parameters or 
return values.
</p><div class="code"><pre><span class="java-keyword">package</span> groovyx.gpars.samples.dataflow<p class="paragraph"><span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.GParsExecutorsPool.withPool
<span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowVariable
<span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.Dataflow.task</p><p class="paragraph">
/**
 * A simple mashup sample, downloads content of three websites and checks how many of them refer to Groovy.
 */
<span class="java-keyword">final</span> List urls = ['http://www.dzone.com', 'http://www.jroller.com', 'http://www.theserverside.com']</p><p class="paragraph">task {
    def pages = urls.collect { downloadPage(it) }
    withPool {
        println <span class="java-quote">"<span class="java-object">Number</span> of Groovy sites today: "</span> +
                (pages.findAllParallel {
                    it.val.toUpperCase().contains 'GROOVY'
                }).size()
    }
}.join()</p><p class="paragraph">def downloadPage(def url) {
    def page = <span class="java-keyword">new</span> DataflowVariable()
    task {
        println <span class="java-quote">"Started downloading from $url"</span>
        page &lt;&lt; url.toURL().text
        println <span class="java-quote">"Done downloading from $url"</span>
    }
    <span class="java-keyword">return</span> page
}</p></pre></div><p class="paragraph"></p><h3>A physical calculation example</h3><p class="paragraph">Dataflow
 programs naturally scale with the number of processors. Up to a certain
 level, the more processors you have the faster the program runs.
Check out, for example, the following script, which calculates 
parameters of a simple physical experiment and prints out the results. 
Each task performs its part of the calculation and may depend on values 
calculated by some other tasks as well as its result might be needed by 
some of the other tasks. With Dataflow Concurrency you can split the 
work between tasks or reorder the tasks themselves as you like and the 
dataflow mechanics will ensure the calculation will be accomplished 
correctly.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowVariable
<span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.Dataflow.task<p class="paragraph"><span class="java-keyword">final</span> def mass = <span class="java-keyword">new</span> DataflowVariable()
<span class="java-keyword">final</span> def radius = <span class="java-keyword">new</span> DataflowVariable()
<span class="java-keyword">final</span> def volume = <span class="java-keyword">new</span> DataflowVariable()
<span class="java-keyword">final</span> def density = <span class="java-keyword">new</span> DataflowVariable()
<span class="java-keyword">final</span> def acceleration = <span class="java-keyword">new</span> DataflowVariable()
<span class="java-keyword">final</span> def time = <span class="java-keyword">new</span> DataflowVariable()
<span class="java-keyword">final</span> def velocity = <span class="java-keyword">new</span> DataflowVariable()
<span class="java-keyword">final</span> def decelerationForce = <span class="java-keyword">new</span> DataflowVariable()
<span class="java-keyword">final</span> def deceleration = <span class="java-keyword">new</span> DataflowVariable()
<span class="java-keyword">final</span> def distance = <span class="java-keyword">new</span> DataflowVariable()</p><p class="paragraph">def t = task {
    println <span class="java-quote">""</span><span class="java-quote">"
Calculating distance required to stop a moving ball.
====================================================
The ball has a radius of ${radius.val} meters and is made of a material with ${density.val} kg/m3 density,
which means that the ball has a volume of ${volume.val} m3 and a mass of ${mass.val} kg.
The ball has been accelerating with ${acceleration.val} m/s2 from 0 <span class="java-keyword">for</span> ${time.val} seconds and so reached a velocity of ${velocity.val} m/s.</span></p><p class="paragraph">Given our ability to push the ball backwards with a force of ${decelerationForce.val} N (Newton), we can cause a deceleration
of ${deceleration.val} m/s2 and so stop the ball at a distance of ${distance.val} m.</p><p class="paragraph">=======================================================================================================================
This example has been calculated asynchronously in multiple tasks using GPars Dataflow concurrency in Groovy.
Author: ${author.val}
"<span class="java-quote">""</span></p><p class="paragraph">    <span class="java-object">System</span>.exit 0
}</p><p class="paragraph">task {
    mass &lt;&lt; volume.val * density.val
}</p><p class="paragraph">task {
    volume &lt;&lt; <span class="java-object">Math</span>.PI * (radius.val ** 3)
}</p><p class="paragraph">task {
    radius &lt;&lt; 2.5
    density &lt;&lt; 	998.2071  //water
    acceleration &lt;&lt; 9.80665 //free fall
    decelerationForce &lt;&lt; 900
}</p><p class="paragraph">task {
    println 'Enter your name:'
    def name = <span class="java-keyword">new</span> InputStreamReader(<span class="java-object">System</span>.in).readLine()
    author &lt;&lt; (name?.trim()?.size()&gt;0 ? name : 'anonymous')
}</p><p class="paragraph">task {
    time &lt;&lt; 10
    velocity &lt;&lt; acceleration.val * time.val
}</p><p class="paragraph">task {
    deceleration &lt;&lt; decelerationForce.val / mass.val
}</p><p class="paragraph">task {
    distance &lt;&lt; deceleration.val * ((velocity.val/deceleration.val) ** 2) * 0.5
}</p><p class="paragraph">t.join()</p></pre></div>Note: I did my best to
 make all the physical calculations right. Feel free to change the 
values and see how long distance you need to stop the rolling ball.<p class="paragraph"></p><h2>Deterministic deadlocks</h2><p class="paragraph">If
 you happen to introduce a deadlock in your dependencies, the deadlock 
will occur each time you run the code. No randomness allowed. That's one
 of the benefits of Dataflow concurrency. Irrespective of the actual 
thread scheduling scheme, if you don't get a deadlock in tests, you 
won't get them in production.
</p><div class="code"><pre>task {
    println a.val
    b &lt;&lt; 'Hi there'
}<p class="paragraph">task {
    println b.val
    a &lt;&lt; 'Hello man'
}</p></pre></div><p class="paragraph"></p><h2>Dataflows map</h2><p class="paragraph">As a handy shortcut the  <em class="italic">Dataflows</em>  class can help you reduce the amount of code you have to write to leverage Dataflow variables.</p><p class="paragraph"></p><div class="code"><pre>def df = <span class="java-keyword">new</span> Dataflows()
df.x = 'value1'
assert df.x == 'value1'<p class="paragraph">Dataflow.task {df.y = 'value2}</p><p class="paragraph">assert df.y == 'value2'</p></pre></div>
Think of Dataflows as a map with Dataflow Variables as keys storing 
their bound values as appropriate map values. The semantics of reading a
 value (e.g. df.x) and binding a value (e.g. df.x = 'value') remain 
identical to the semantics of plain Dataflow Variables (x.val and x 
&lt;&lt; 'value' respectively).<p class="paragraph"></p><h3>Mixing  <em class="italic">Dataflows</em>  and Groovy  <em class="italic">with</em>  blocks</h3><p class="paragraph">When inside a  <em class="italic">with</em>  block of a Dataflows instance, the dataflow variables stored inside the Dataflows instance can be accessed directly
without the need to prefix them with the Dataflows instance identifier.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">new</span> Dataflows().with {
    x = 'value1'
    assert x == 'value1'<p class="paragraph">    Dataflow.task {y = 'value2}</p><p class="paragraph">    assert y == 'value2'
}</p></pre></div><p class="paragraph"></p><h2>Returning a value from a task</h2><p class="paragraph">Typically
 dataflow tasks communicate through dataflow variables. On top of that, 
tasks can also return values, again through a dataflow variable.
 When you invoke the  <em class="italic">task()</em>  factory method, 
you get back an instance of Promise (implemented as DataflowVariable), 
through which you can listen for the task's return value,
 just like when using any other Promise or DataflowVariable.</p><p class="paragraph"> </p><div class="code"><pre><span class="java-keyword">final</span> Promise t1 = task {
        <span class="java-keyword">return</span> 10
    }
    <span class="java-keyword">final</span> Promise t2 = task {
        <span class="java-keyword">return</span> 20
    }
    def results = [t1, t2]*.val
    println 'Both sub-tasks finished and returned values: ' + results</pre></div><p class="paragraph"> Obviously the value can also be obtained without blocking the caller using the  <em class="italic">whenBound()</em>  method.</p><p class="paragraph"> </p><div class="code"><pre>def task = task {
    println 'The task is running and calculating the <span class="java-keyword">return</span> value'
    30
}
task &gt;&gt; {value -&gt; println <span class="java-quote">"The task finished and returned $value"</span>}</pre></div><p class="paragraph"> h2. Joining tasks</p><p class="paragraph"> Using the  <em class="italic">join()</em>  operation on the result dataflow variable of a task you can block until the task finishes.</p><p class="paragraph"> </p><div class="code"><pre>task {
     <span class="java-keyword">final</span> Promise t1 = task {
         println 'First sub-task running.'
     }
     <span class="java-keyword">final</span> Promise t2 = task {
         println 'Second sub-task running'
     }
     [t1, t2]*.join()
     println 'Both sub-tasks finished'
 }.join()</pre></div>


<h2 id="dataflow_selects">7.2 Selects</h2>
Frequently a value needs to be obtained from one of several dataflow channels (variables, queues, broadcasts or streams). The  <em class="italic">Select</em>  class
is suitable for such scenarios.
 <em class="italic">Select</em>  can scan multiple dataflow channels and
 pick one channel from all the input channels, which currently have a 
value available for read.
The value from that channels is read and returned to the caller together
 with the index of the originating channel.
Picking the channel is either random, or based on channel priority, in 
which case channels with lower position index in the  <em class="italic">Select</em>  constructor
have higher priority.<p class="paragraph"></p><h2>Selecting a value from multiple channels</h2><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowQueue
<span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowVariable
<span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.Dataflow.select
<span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.Dataflow.task<p class="paragraph">/**
 * Shows a basic use of Select, which monitors a set of input channels <span class="java-keyword">for</span> values and makes these values
 * available on its output irrespective of their original input channel.
 * Note that dataflow variables and queues can be combined <span class="java-keyword">for</span> Select.
 *
 * You might also consider checking out the prioritySelect method, which prioritizes values by the index of their input channel
 */
def a = <span class="java-keyword">new</span> DataflowVariable()
def b = <span class="java-keyword">new</span> DataflowVariable()
def c = <span class="java-keyword">new</span> DataflowQueue()</p><p class="paragraph">task {
    sleep 3000
    a &lt;&lt; 10
}</p><p class="paragraph">task {
    sleep 1000
    b &lt;&lt; 20
}</p><p class="paragraph">task {
    sleep 5000
    c &lt;&lt; 30
}</p><p class="paragraph">def select = select([a, b, c])
println <span class="java-quote">"The fastest result is ${select().value}"</span></p></pre></div><p class="paragraph"></p><blockquote class="note">
Note that the return type from  <em class="italic">select()</em>  is  <em class="italic">SelectResult</em>  , holding the value as well as the originating channel index.
</blockquote><p class="paragraph">There are multiple ways to read values from a Select:</p><p class="paragraph"></p><div class="code"><pre>def sel = select(a, b, c, d)
def result = sel.select()                                       //Random selection
def result = sel()                                              //Random selection (a <span class="java-object">short</span>-hand variant)
def result = sel.select([<span class="java-keyword">true</span>, <span class="java-keyword">true</span>, <span class="java-keyword">false</span>, <span class="java-keyword">true</span>])              //Random selection with guards specified
def result = sel([<span class="java-keyword">true</span>, <span class="java-keyword">true</span>, <span class="java-keyword">false</span>, <span class="java-keyword">true</span>])                     //Random selection with guards specified (a <span class="java-object">short</span>-hand variant)
def result = sel.prioritySelect()                               //Priority selection
def result = sel.prioritySelect([<span class="java-keyword">true</span>, <span class="java-keyword">true</span>, <span class="java-keyword">false</span>, <span class="java-keyword">true</span>])      //Priority selection with guards specifies</pre></div><p class="paragraph">By default the  <em class="italic">Select</em>  blocks the caller until a value to read is available. The alternative  <em class="italic">selectToPromise()</em>  and  <em class="italic">prioritySelectToPromise()</em>
 
methods give you a way to obtain a promise for the value that will be 
selected some time in the future. Through the returned Promise
you may register a callback to get invoked asynchronously whenever the 
next value is selected.</p><p class="paragraph"></p><div class="code"><pre>def sel = select(a, b, c, d)
Promise result = sel.selectToPromise()                                       //Random selection
Promise result = sel.selectToPromise([<span class="java-keyword">true</span>, <span class="java-keyword">true</span>, <span class="java-keyword">false</span>, <span class="java-keyword">true</span>])              //Random selection with guards specified
Promise result = sel.prioritySelectToPromise()                               //Priority selection
Promise result = sel.prioritySelectToPromise([<span class="java-keyword">true</span>, <span class="java-keyword">true</span>, <span class="java-keyword">false</span>, <span class="java-keyword">true</span>])      //Priority selection with guards specifies</pre></div><p class="paragraph">Alternatively,  <em class="italic">Select</em>  allows to have the value sent to a provided  <em class="italic">MessageStream</em>  (e.g. an actor) without blocking the caller.</p><p class="paragraph"></p><div class="code"><pre>def handler = actor {...}
def sel = select(a, b, c, d)<p class="paragraph">sel.select(handler)                                         //Random selection
sel(handler)                                                //Random selection (a <span class="java-object">short</span>-hand variant)
sel.select(handler, [<span class="java-keyword">true</span>, <span class="java-keyword">true</span>, <span class="java-keyword">false</span>, <span class="java-keyword">true</span>])              //Random selection with guards specified
sel(handler, [<span class="java-keyword">true</span>, <span class="java-keyword">true</span>, <span class="java-keyword">false</span>, <span class="java-keyword">true</span>])                     //Random selection with guards specified (a <span class="java-object">short</span>-hand variant)
sel.prioritySelect(handler)                                 //Priority selection
sel.prioritySelect(handler, [<span class="java-keyword">true</span>, <span class="java-keyword">true</span>, <span class="java-keyword">false</span>, <span class="java-keyword">true</span>])      //Priority selection with guards specifies</p></pre></div><p class="paragraph"></p><h3>Guards</h3><p class="paragraph">Guards allow the caller to omit some input channels from the selection. Guards are specified as a List of boolean flags
passed to the  <em class="italic">select()</em>  or  <em class="italic">prioritySelect()</em>  methods.</p><p class="paragraph"></p><div class="code"><pre>def sel = select(leaders, seniors, experts, juniors)
def teamLead = sel([<span class="java-keyword">true</span>, <span class="java-keyword">true</span>, <span class="java-keyword">false</span>, <span class="java-keyword">false</span>]).value        //Only 'leaders' and 'seniors' qualify <span class="java-keyword">for</span> becoming a teamLead here</pre></div><p class="paragraph">A typical use for guards is to make Selects flexible to adopt to the changes in the user state.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowQueue
<span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.Dataflow.select
<span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.Dataflow.task<p class="paragraph">/**
 * Demonstrates the ability to enable/disable channels during a value selection on a select by providing <span class="java-object">boolean</span> guards.
 */
<span class="java-keyword">final</span> DataflowQueue operations = <span class="java-keyword">new</span> DataflowQueue()
<span class="java-keyword">final</span> DataflowQueue numbers = <span class="java-keyword">new</span> DataflowQueue()</p><p class="paragraph">def t = task {
    <span class="java-keyword">final</span> def select = select(operations, numbers)
    3.times {
        def instruction = select([<span class="java-keyword">true</span>, <span class="java-keyword">false</span>]).value
        def num1 = select([<span class="java-keyword">false</span>, <span class="java-keyword">true</span>]).value
        def num2 = select([<span class="java-keyword">false</span>, <span class="java-keyword">true</span>]).value
        <span class="java-keyword">final</span> def formula = <span class="java-quote">"$num1 $instruction $num2"</span>
        println <span class="java-quote">"$formula = ${<span class="java-keyword">new</span> GroovyShell().evaluate(formula)}"</span>
    }
}</p><p class="paragraph">task {
    operations &lt;&lt; '+'
    operations &lt;&lt; '+'
    operations &lt;&lt; '*'
}</p><p class="paragraph">task {
    numbers &lt;&lt; 10
    numbers &lt;&lt; 20
    numbers &lt;&lt; 30
    numbers &lt;&lt; 40
    numbers &lt;&lt; 50
    numbers &lt;&lt; 60
}</p><p class="paragraph">t.join()</p></pre></div><p class="paragraph"></p><h3>Priority Select</h3><p class="paragraph">When certain channels should have precedence over others when selecting, the prioritySelect methods should be used instead.</p><p class="paragraph"></p><div class="code"><pre>/**
 * Shows a basic use of Priority Select, which monitors a set of input channels <span class="java-keyword">for</span> values and makes these values
 * available on its output irrespective of their original input channel.
 * Note that dataflow variables, queues and broadcasts can be combined <span class="java-keyword">for</span> Select.
 * Unlike plain select method call, the prioritySelect call gives precedence to input channels with lower index.
 * Available messages from high priority channels will be served before messages from lower-priority channels.
 * Messages received through a single input channel will have their mutual order preserved.
 *
 */
def critical = <span class="java-keyword">new</span> DataflowVariable()
def ordinary = <span class="java-keyword">new</span> DataflowQueue()
def whoCares = <span class="java-keyword">new</span> DataflowQueue()<p class="paragraph">task {
    ordinary &lt;&lt; 'All working fine'
    whoCares &lt;&lt; 'I feel a bit tired'
    ordinary &lt;&lt; 'We are on target'
}</p><p class="paragraph">task {
    ordinary &lt;&lt; 'I have just started my work. Busy. Will come back later...'
    sleep 5000
    ordinary &lt;&lt; 'I am done <span class="java-keyword">for</span> now'
}</p><p class="paragraph">task {
    whoCares &lt;&lt; 'Huh, what is that noise'
    ordinary &lt;&lt; 'Here I am to <span class="java-keyword">do</span> some clean-up work'
    whoCares &lt;&lt; 'I wonder whether unplugging <span class="java-keyword">this</span> cable will eliminate that nasty sound.'
    critical &lt;&lt; 'The server room goes on UPS!'
    whoCares &lt;&lt; 'The sound has disappeared'
}</p><p class="paragraph">def select = select([critical, ordinary, whoCares])
println 'Starting to monitor our IT department'
sleep 3000
10.times {println <span class="java-quote">"Received: ${select.prioritySelect().value}"</span>}</p></pre></div><p class="paragraph"></p><h3>Collecting results of asynchronous computations</h3><p class="paragraph">Asynchronous activities, no matter whether they are <strong class="bold">dataflow tasks</strong> , <strong class="bold">active objects' methods</strong> or <strong class="bold">asynchronous functions</strong> , return  <em class="italic">Promises</em>  .
 <em class="italic">Promises</em>  implement the  <em class="italic">SelectableChannel</em>  interface and so can be passed in  <em class="italic">selects</em>  for selection together with other  <em class="italic">Promises</em> 
as well as  <em class="italic">read channels</em>  .
Similarly to Java's  <em class="italic">CompletionService</em>  , GPars  <em class="italic">Select</em>  enables you to obtain results of asynchronous activities as soon as each of them becomes available.
Also, you may employ  <em class="italic">Select</em>  to give you the first/fastest result of several computations running in parallel.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.Promise
<span class="java-keyword">import</span> groovyx.gpars.dataflow.Select
<span class="java-keyword">import</span> groovyx.gpars.group.DefaultPGroup
/**
 * Demonstrates the use of dataflow tasks and selects to pick the fastest result of concurrently run calculations.
 */<p class="paragraph"><span class="java-keyword">final</span> group = <span class="java-keyword">new</span> DefaultPGroup()
group.with {
    Promise p1 = task {
        sleep(1000)
        10 * 10 + 1
    }
    Promise p2 = task {
        sleep(1000)
        5 * 20 + 2
    }
    Promise p3 = task {
        sleep(1000)
        1 * 100 + 3
    }</p><p class="paragraph">    <span class="java-keyword">final</span> alt = <span class="java-keyword">new</span> Select(group, p1, p2, p3)
    def result = alt.select()
    println <span class="java-quote">"Result: "</span> + result
}</p></pre></div><p class="paragraph"></p><h3>Timeouts</h3><p class="paragraph">The  <em class="italic">Select.createTimeout()</em>  method will create a DataflowVariable that gets bound to a value after a given time period.
This can be leveraged in  <em class="italic">Selects</em>  so that they unblock after a desired delay, if none of the other channels delivers
a value before that moment. Just pass the <strong class="bold">timeout channel</strong> as another input channel to the  <em class="italic">Select</em>  .</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.Promise
<span class="java-keyword">import</span> groovyx.gpars.dataflow.Select
<span class="java-keyword">import</span> groovyx.gpars.group.DefaultPGroup
/**
 * Demonstrates the use of dataflow tasks and selects to pick the fastest result of concurrently run calculations.
 */<p class="paragraph"><span class="java-keyword">final</span> group = <span class="java-keyword">new</span> DefaultPGroup()
group.with {
    Promise p1 = task {
        sleep(1000)
        10 * 10 + 1
    }
    Promise p2 = task {
        sleep(1000)
        5 * 20 + 2
    }
    Promise p3 = task {
        sleep(1000)
        1 * 100 + 3
    }</p><p class="paragraph">    <span class="java-keyword">final</span> timeoutChannel = Select.createTimeout(500)</p><p class="paragraph">    <span class="java-keyword">final</span> alt = <span class="java-keyword">new</span> Select(group, p1, p2, p3, timeoutChannel)
    def result = alt.select()
    println <span class="java-quote">"Result: "</span> + result
}</p></pre></div><p class="paragraph"></p><h3>Cancellation</h3><p class="paragraph">In case you need to cancel the other tasks once a value has been calculated or a timeout expired, the best way is to
set a flag that the tasks periodically monitor. There's intentionally no cancellation machinery built into
 <em class="italic">DataflowVariables</em>  or  <em class="italic">Tasks</em>  .</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.Promise
<span class="java-keyword">import</span> groovyx.gpars.dataflow.Select
<span class="java-keyword">import</span> groovyx.gpars.group.DefaultPGroup<p class="paragraph"><span class="java-keyword">import</span> java.util.concurrent.atomic.AtomicBoolean</p><p class="paragraph">/**
 * Demonstrates the use of dataflow tasks and selects to pick the fastest result of concurrently run calculations.
 * It shows a waz to cancel the slower tasks once a result is known
 */</p><p class="paragraph"><span class="java-keyword">final</span> group = <span class="java-keyword">new</span> DefaultPGroup()
<span class="java-keyword">final</span> done = <span class="java-keyword">new</span> AtomicBoolean()</p><p class="paragraph">group.with {
    Promise p1 = task {
        sleep(1000)
        <span class="java-keyword">if</span> (done.get()) <span class="java-keyword">return</span>
        10 * 10 + 1
    }
    Promise p2 = task {
        sleep(1000)
        <span class="java-keyword">if</span> (done.get()) <span class="java-keyword">return</span>
        5 * 20 + 2
    }
    Promise p3 = task {
        sleep(1000)
        <span class="java-keyword">if</span> (done.get()) <span class="java-keyword">return</span>
        1 * 100 + 3
    }</p><p class="paragraph">    <span class="java-keyword">final</span> alt = <span class="java-keyword">new</span> Select(group, p1, p2, p3, Select.createTimeout(500))
    def result = alt.select()
    done.set(<span class="java-keyword">true</span>)
    println <span class="java-quote">"Result: "</span> + result
}</p></pre></div><p class="paragraph">


</p><h2 id="dataflow_operators">7.3 Operators</h2>
Dataflow Operators and Selectors provide a full Dataflow implementation with all the usual ceremony.<p class="paragraph"></p><h3>Concepts</h3><p class="paragraph">Full dataflow concurrency builds on the concept of channels connecting operators and selectors, which consume
values coming through input channels, transform them into new values and output the new values into their output channels.
While  <em class="italic">Operators</em>  wait for <strong class="bold">all</strong> input channels to have a value available for read before they start process them,
 <em class="italic">Selectors</em>  are triggered by a value available on <strong class="bold">any</strong> of the input channels.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">operator</span>(inputs: [a, b, c], outputs: [d]) {x, y, z -&gt;
    …
    bindOutput 0, x + y + z
}</pre></div><p class="paragraph"></p><div class="code"><pre>/**
 * CACHE
 *
 * Caches sites' contents. Accepts requests <span class="java-keyword">for</span> url content, outputs the content. Outputs requests <span class="java-keyword">for</span> download
 * <span class="java-keyword">if</span> the site is not in cache yet.
 */
<span class="java-keyword">operator</span>(inputs: [urlRequests], outputs: [downloadRequests, sites]) {request -&gt;<p class="paragraph">    <span class="java-keyword">if</span> (!request.content) {
        println <span class="java-quote">"[Cache] Retrieving ${request.site}"</span>
        def content = cache[request.site]
        <span class="java-keyword">if</span> (content) {
            println <span class="java-quote">"[Cache] Found in cache"</span>
            bindOutput 1, [site: request.site, word:request.word, content: content]
        } <span class="java-keyword">else</span> {
            def downloads = pendingDownloads[request.site]
            <span class="java-keyword">if</span> (downloads != <span class="java-keyword">null</span>) {
                println <span class="java-quote">"[Cache] Awaiting download"</span>
                downloads &lt;&lt; request
            } <span class="java-keyword">else</span> {
                pendingDownloads[request.site] = []
                println <span class="java-quote">"[Cache] Asking <span class="java-keyword">for</span> download"</span>
                bindOutput 0, request
            }
        }
    } <span class="java-keyword">else</span> {
        println <span class="java-quote">"[Cache] Caching ${request.site}"</span>
        cache[request.site] = request.content
        bindOutput 1, request
        def downloads = pendingDownloads[request.site]
        <span class="java-keyword">if</span> (downloads != <span class="java-keyword">null</span>) {
            <span class="java-keyword">for</span> (downloadRequest in downloads) {
                println <span class="java-quote">"[Cache] Waking up"</span>
                bindOutput 1, [site: downloadRequest.site, word:downloadRequest.word, content: request.content]
            }
            pendingDownloads.remove(request.site)
        }
    }
}</p></pre></div><p class="paragraph"></p><blockquote class="note">
The standard error handling will print out an error message to the 
standard error output and terminate the operator in case an uncaught
exception is thrown from withing the operator's body. To alter the 
behavior, you can register your own event listener:<p class="paragraph"></p><div class="code"><pre>def listener = <span class="java-keyword">new</span> DataflowEventAdapter() {
    @Override
    <span class="java-object">boolean</span> onException(<span class="java-keyword">final</span> DataflowProcessor processor, <span class="java-keyword">final</span> Throwable e) {
        logChannel &lt;&lt; e
        <span class="java-keyword">return</span> <span class="java-keyword">false</span>   //Indicate whether to terminate the <span class="java-keyword">operator</span> or not
    }
}<p class="paragraph">op = group.<span class="java-keyword">operator</span>(inputs: [a, b], outputs: [c], listeners: [listener]) {x, y -&gt;
    …
}
See the  <em class="italic">Operator lifecycle</em>  section <span class="java-keyword">for</span> more details.</p></pre></div><p class="paragraph"></p></blockquote><p class="paragraph"></p><h4>Types of operators</h4><p class="paragraph">There are specialized versions of operators serving specific purposes:
</p><ul class="star">
<li>operator - the basic general-purpose operator</li>
<li>selector - operator that is triggered by a value being available in any of its input channels</li>
<li>prioritySelector - a selector that prefers delivering messages from lower-indexed input channels over higher-indexed ones</li>
<li>splitter - a single-input operator copying its input values to all of its output channels</li>
</ul><p class="paragraph"></p><h4>Wiring operators together</h4><p class="paragraph">Operators are typically combined into networks, when some operators consume output by other operators.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">operator</span>(inputs:[a, b], outputs:[c, d]) {...}
splitter(c, [e, f])
selector(inputs:[e, d]: outputs:[]) {...}</pre></div><p class="paragraph">You may alternatively refer to output channels through operators themselves:</p><p class="paragraph"></p><div class="code"><pre>def op1 = <span class="java-keyword">operator</span>(inputs:[a, b], outputs:[c, d]) {...}
def sp1 = splitter(op1.outputs[0], [e, f])                            //takes the first output of op1
selector(inputs:[sp1.outputs[0], op1.outputs[1]]: outputs:[]) {...}   //takes the first output of sp1 and the second output of op1</pre></div><p class="paragraph"></p><h3>Grouping operators</h3><p class="paragraph">Dataflow operators can be organized into groups to allow for performance fine-tuning. Groups provide a handy  <em class="italic">operator()</em>  factory method
to create tasks attached to the groups.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.group.DefaultPGroup<p class="paragraph">def group = <span class="java-keyword">new</span> DefaultPGroup()</p><p class="paragraph">group.with {
    <span class="java-keyword">operator</span>(inputs: [a, b, c], outputs: [d]) {x, y, z -&gt;
        …
        bindOutput 0, x + y + z
    }
}</p></pre></div><p class="paragraph"></p><blockquote class="note">
The default thread pool for dataflow operators contains daemon threads, 
which means your application will exit as soon as the main thread 
finishes and won't wait for all tasks to complete.
When grouping operators, make sure that your custom thread pools either 
use daemon threads, too, which can be achieved by
using DefaultPGroup or by providing your own thread factory to a thread 
pool constructor,
or in case your thread pools use non-daemon threads, such as when using 
the NonDaemonPGroup group class, make sure you shutdown the group or the
 thread pool explicitly by calling its shutdown() method,
otherwise your applications will not exit.
</blockquote><p class="paragraph">You may selectively override the default group used for tasks, operators, callbacks and other dataflow elements inside
a code block using the _Dataflow.usingGroup() method:
</p><div class="code"><pre>Dataflow.usingGroup(group) {
    <span class="java-keyword">operator</span>(inputs: [a, b, c], outputs: [d]) {x, y, z -&gt;
        …
        bindOutput 0, x + y + z
    }
}</pre></div><p class="paragraph">You can always override the default group by being specific:</p><p class="paragraph"></p><div class="code"><pre>Dataflow.usingGroup(group) {
    anotherGroup.<span class="java-keyword">operator</span>(inputs: [a, b, c], outputs: [d]) {x, y, z -&gt;
        …
        bindOutput 0, x + y + z
    }
}</pre></div><p class="paragraph"></p><h3>Constructing operators</h3><p class="paragraph">The construction properties of an operator, such as  <em class="italic">inputs</em> ,  <em class="italic">outputs</em> ,  <em class="italic">stateObject</em>  or  <em class="italic">maxForks</em>  cannot be modified once the operator has been build.
You may find the  <em class="italic">groovyx.gpars.dataflow.ProcessingNode</em>  class helpful when gradually collecting channels and values into lists
before you finally build an operator.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.Dataflow
<span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowQueue
<span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.ProcessingNode.node<p class="paragraph">/**
 * Shows how to build operators using the ProcessingNode class
 */</p><p class="paragraph"><span class="java-keyword">final</span> DataflowQueue aValues = <span class="java-keyword">new</span> DataflowQueue()
<span class="java-keyword">final</span> DataflowQueue bValues = <span class="java-keyword">new</span> DataflowQueue()
<span class="java-keyword">final</span> DataflowQueue results = <span class="java-keyword">new</span> DataflowQueue()</p><p class="paragraph">//Create a config and gradually set the required properties - channels, code, etc.
def adderConfig = node {valueA, valueB -&gt;
    bindOutput valueA + valueB
}
adderConfig.inputs &lt;&lt; aValues
adderConfig.inputs &lt;&lt; bValues
adderConfig.outputs &lt;&lt; results</p><p class="paragraph">//Build the <span class="java-keyword">operator</span>
<span class="java-keyword">final</span> adder = adderConfig.<span class="java-keyword">operator</span>(Dataflow.DATA_FLOW_GROUP)</p><p class="paragraph">//Now the <span class="java-keyword">operator</span> is running and processing the data
aValues &lt;&lt; 10
aValues &lt;&lt; 20
bValues &lt;&lt; 1
bValues &lt;&lt; 2</p><p class="paragraph">assert [11, 22] == (1..2).collect {
    results.val
}</p></pre></div><p class="paragraph"></p><h3>State in operators</h3><p class="paragraph">Although
 operators can frequently do without keeping state between subsequent 
invocations, GPars allows operators to maintain state,
if desired by the developer. One obvious way is to leverage the Groovy 
closure capabilities to close-over their context:</p><p class="paragraph"></p><div class="code"><pre><span class="java-object">int</span> counter = 0
<span class="java-keyword">operator</span>(inputs: [a], outputs: [b]) {value -&gt;
    counter += 1
}</pre></div><p class="paragraph">Another way, which allows you to avoid
 declaring the state object outside of the operator definition, is to 
pass the state object
into the operator as a  <em class="italic">stateObject</em>  parameter at construction time:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">operator</span>(inputs: [a], outputs: [b], stateObject: [counter: 0]) {value -&gt;
    stateObject.counter += 1
}</pre></div><p class="paragraph"></p><h3>Parallelize operators</h3><p class="paragraph">By
 default an operator's body is processed by a single thread at a time. 
While this is a safe setting allowing the operator's
body to be written in a non-thread-safe manner, once an operator becomes
 "hot" and data start to accumulate in the operator's
input queues, you might consider allowing multiple threads to run the 
operator's body concurrently. Bear in mind that in such a case
you need to avoid or protect shared resources from multi-threaded 
access.
To enable multiple threads to run the operator's body concurrently, pass
 an extra  <em class="italic">maxForks</em>  parameter when creating an operator:</p><p class="paragraph"></p><div class="code"><pre>def op = <span class="java-keyword">operator</span>(inputs: [a, b, c], outputs: [d, e], maxForks: 2) {x, y, z -&gt;
    bindOutput 0, x + y + z
    bindOutput 1, x * y * z
}</pre></div><p class="paragraph">The value of the  <em class="italic">maxForks</em>  parameter indicates the maximum of threads running the operator concurrently. Only positive
numbers are allowed with value 1 being the default.</p><p class="paragraph"></p><blockquote class="note">
Please always make sure the <strong class="bold">group</strong> serving 
the operator holds enough threads to support all requested forks.
Using groups allows you to organize tasks or operators around different 
thread pools (wrapped inside the group).
While the Dataflow.task() command schedules the task on a default thread
 pool (java.util.concurrent.Executor, fixed size=#cpu+1, daemon 
threads),
you may prefer being able to define your own thread pool(s) to run your 
tasks.<p class="paragraph"></p><div class="code"><pre>def group = <span class="java-keyword">new</span> DefaultPGroup(10)
group.<span class="java-keyword">operator</span>((inputs: [a, b, c], outputs: [d, e], maxForks: 5) {x, y, z -&gt; ...}</pre></div><p class="paragraph">The default group uses a resizeable thread pool as so will never run out of threads.
</p></blockquote><p class="paragraph"></p><h4>Synchronizing the output</h4><p class="paragraph">When enabling internal parallelization of an operator by setting the value for  <em class="italic">maxForks</em>
  to a value greater than 1
it is important to remember that without explicit or implicit 
synchronization in the operators' body race-conditions may occur.
Especially bear in mind that values written to multiple output channels 
are not guarantied to be written atomically in the same order to all the
 channels
</p><div class="code"><pre><span class="java-keyword">operator</span>(inputs:[inputChannel], outputs:[a, b], maxForks:5) {msg -&gt;
    bindOutput 0, msg
    bindOutput 1, msg
}
inputChannel &lt;&lt; 1
inputChannel &lt;&lt; 2
inputChannel &lt;&lt; 3
inputChannel &lt;&lt; 4
inputChannel &lt;&lt; 5</pre></div>
 May result in output channels having the values mixed-up something like:
<div class="code"><pre>a -&gt; 1, 3, 2, 4, 5
b -&gt; 2, 1, 3, 5, 4</pre></div><p class="paragraph"> Explicit synchronization is one way to get correctly bound all output channels and protect operator not-thread local state:
</p><div class="code"><pre>def lock = <span class="java-keyword">new</span> <span class="java-object">Object</span>()
<span class="java-keyword">operator</span>(inputs:[inputChannel], outputs:[a, b], maxForks:5) {msg -&gt;
    doStuffThatIsThreadSafe()<p class="paragraph">    <span class="java-keyword">synchronized</span>(lock) {
        doSomethingThatMustNotBeAccessedByMultipleThreadsAtTheSameTime()
        bindOutput 0, msg
        bindOutput 1, 2*msg
    }
}</p></pre></div><p class="paragraph">Obviously you need to weight the pros and cons here, since synchronization may defeat the purpose of setting  <em class="italic">maxForks</em>  to a value greater than 1.</p><p class="paragraph">To set values of all the operator's output channels in one atomic step, you may also consider calling either the  <em class="italic">bindAllOutputsAtomically</em>  method, passing in
a single value to write to all output channels or the  <em class="italic">bindAllOutputsAtomically</em>  method, which takes a multiple values, each of which will be written
to the output channel with the same position index.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">operator</span>(inputs:[inputChannel], outputs:[a, b], maxForks:5) {msg -&gt;
    doStuffThatIsThreadSafe()
        bindAllOutputValuesAtomically msg, 2*msg
    }
}</pre></div><p class="paragraph"></p><blockquote class="note">
 Using the  <em class="italic">bindAllOutputs</em>  or the  <em class="italic">bindAllOutputValues</em>  methods will not guarantee atomicity of writes across al the output channels when using internal parallelism.
 If preserving the order of messages in multiple output channels is not an issue,  <em class="italic">bindAllOutputs</em>  as well as  <em class="italic">bindAllOutputValues</em>  will provide better performance over the atomic variants.
</blockquote><p class="paragraph"></p><h4>Operator lifecycle</h4><p class="paragraph">Dataflow operators and selectors fire several events during their lifecycle, which allows the interested parties to obtain
notifications and potential alter operator's behavior. The  <em class="italic">DataflowEventListener</em>  interface offers a couple of callback methods:
</p><div class="code"><pre><span class="java-keyword">public</span> <span class="java-keyword">interface</span> DataflowEventListener {
    /**
     * Invoked immediately after the <span class="java-keyword">operator</span> starts by a pooled thread before the first message is obtained
     *
     * @param processor The reporting dataflow <span class="java-keyword">operator</span>/selector
     */
    void afterStart(DataflowProcessor processor);<p class="paragraph">    /**
     * Invoked immediately after the <span class="java-keyword">operator</span> terminates
     *
     * @param processor The reporting dataflow <span class="java-keyword">operator</span>/selector
     */
    void afterStop(DataflowProcessor processor);</p><p class="paragraph">    /**
     * Invoked <span class="java-keyword">if</span> an exception occurs.
     * If any of the listeners returns <span class="java-keyword">true</span>, the <span class="java-keyword">operator</span> will terminate.
     * Exceptions outside of the <span class="java-keyword">operator</span>'s body or listeners' messageSentOut() handlers will terminate the <span class="java-keyword">operator</span> irrespective of the listeners' votes.
     *
     * @param processor The reporting dataflow <span class="java-keyword">operator</span>/selector
     * @param e         The thrown exception
     * @<span class="java-keyword">return</span> True, <span class="java-keyword">if</span> the <span class="java-keyword">operator</span> should terminate in response to the exception, <span class="java-keyword">false</span> otherwise.
     */
    <span class="java-object">boolean</span> onException(DataflowProcessor processor, Throwable e);</p><p class="paragraph">    /**
     * Invoked when a message becomes available in an input channel.
     *
     * @param processor The reporting dataflow <span class="java-keyword">operator</span>/selector
     * @param channel   The input channel holding the message
     * @param index     The index of the input channel within the <span class="java-keyword">operator</span>
     * @param message   The incoming message
     * @<span class="java-keyword">return</span> The original message or a message that should be used instead
     */
    <span class="java-object">Object</span> messageArrived(DataflowProcessor processor, DataflowReadChannel&lt;<span class="java-object">Object</span>&gt; channel, <span class="java-object">int</span> index, <span class="java-object">Object</span> message);</p><p class="paragraph">    /**
     * Invoked when a control message (instances of ControlMessage) becomes available in an input channel.
     *
     * @param processor The reporting dataflow <span class="java-keyword">operator</span>/selector
     * @param channel   The input channel holding the message
     * @param index     The index of the input channel within the <span class="java-keyword">operator</span>
     * @param message   The incoming message
     * @<span class="java-keyword">return</span> The original message or a message that should be used instead
     */
    <span class="java-object">Object</span> controlMessageArrived(DataflowProcessor processor, DataflowReadChannel&lt;<span class="java-object">Object</span>&gt; channel, <span class="java-object">int</span> index, <span class="java-object">Object</span> message);</p><p class="paragraph">    /**
     * Invoked when a message is being bound to an output channel.
     *
     * @param processor The reporting dataflow <span class="java-keyword">operator</span>/selector
     * @param channel   The output channel to send the message to
     * @param index     The index of the output channel within the <span class="java-keyword">operator</span>
     * @param message   The message to send
     * @<span class="java-keyword">return</span> The original message or a message that should be used instead
     */
    <span class="java-object">Object</span> messageSentOut(DataflowProcessor processor, DataflowWriteChannel&lt;<span class="java-object">Object</span>&gt; channel, <span class="java-object">int</span> index, <span class="java-object">Object</span> message);</p><p class="paragraph">    /**
     * Invoked when all messages required to trigger the <span class="java-keyword">operator</span> become available in the input channels.
     *
     * @param processor The reporting dataflow <span class="java-keyword">operator</span>/selector
     * @param messages  The incoming messages
     * @<span class="java-keyword">return</span> The original list of messages or a modified/<span class="java-keyword">new</span> list of messages that should be used instead
     */
    List&lt;<span class="java-object">Object</span>&gt; beforeRun(DataflowProcessor processor, List&lt;<span class="java-object">Object</span>&gt; messages);</p><p class="paragraph">    /**
     * Invoked when the <span class="java-keyword">operator</span> completes a single run
     *
     * @param processor The reporting dataflow <span class="java-keyword">operator</span>/selector
     * @param messages  The incoming messages that have been processed
     */
    void afterRun(DataflowProcessor processor, List&lt;<span class="java-object">Object</span>&gt; messages);</p><p class="paragraph">    /**
     * Invoked when the fireCustomEvent() method is triggered manually on a dataflow <span class="java-keyword">operator</span>/selector
     *
     * @param processor The reporting dataflow <span class="java-keyword">operator</span>/selector
     * @param data      The custom piece of data provided as part of the event
     * @<span class="java-keyword">return</span> A value to <span class="java-keyword">return</span> from the fireCustomEvent() method to the caller (event initiator)
     */
    <span class="java-object">Object</span> customEvent(DataflowProcessor processor, <span class="java-object">Object</span> data);
}</p></pre></div><p class="paragraph">A default implementation is provided through the  <em class="italic">DataflowEventAdapter</em>  class.</p><p class="paragraph">Listeners provide a way to handle exceptions, when they occur inside operators. A listener may typically log such exceptions,
notify a supervising entity, generate an alternative output or perform any steps required to recover from the situation.
If there's no listener registered or if any of the listeners returns  <em class="italic">true</em>  the operator will terminate, preserving the contract of  <em class="italic">afterStop()</em>  .
Exceptions that occur outside the actual operator's body, i.e. at the parameter preparation phase before the body is triggered
or at the clean-up and channel subscription phase, after the body finishes, always lead to operator termination.</p><p class="paragraph">The  <em class="italic">fireCustomEvent()</em>  method available on operators and selectors may be used to communicate back and forth between operator's body
and the interested listeners:
</p><div class="code"><pre><span class="java-keyword">final</span> listener = <span class="java-keyword">new</span> DataflowEventAdapter() {
    @Override
    <span class="java-object">Object</span> customEvent(DataflowProcessor processor, <span class="java-object">Object</span> data) {
        println <span class="java-quote">"Log: Getting quite high on the scale $data"</span>
        <span class="java-keyword">return</span> 100  //The value to use instead
    }
}<p class="paragraph">op = group.<span class="java-keyword">operator</span>(inputs: [a, b], outputs: [c], listeners: [listener]) {x, y -&gt;
    <span class="java-keyword">final</span> sum = x + y
    <span class="java-keyword">if</span> (sum &gt; 100) bindOutput(fireCustomEvent(sum))  //Reporting that the sum is too high, binding the lowered value that comes back
    <span class="java-keyword">else</span> bindOutput sum
}</p></pre></div><p class="paragraph"></p><h2>Selectors</h2><p class="paragraph">Selector's body should be a closure consuming either one or two arguments.
</p><div class="code"><pre>selector (inputs : [a, b, c], outputs : [d, e]) {value -&gt;
    ....
}</pre></div><p class="paragraph">The two-argument closure will get a value plus an index of the input channel, the value of which is currently being processed.
This allows the selector to distinguish between values coming through different input channels.</p><p class="paragraph"></p><div class="code"><pre>selector (inputs : [a, b, c], outputs : [d, e]) {value, index -&gt;
    ....
}</pre></div><p class="paragraph"></p><h3>Priority Selector</h3><p class="paragraph">When priorities need to be preserved among input channels, a  <em class="italic">DataflowPrioritySelector</em>  should be used.</p><p class="paragraph"></p><div class="code"><pre>prioritySelector(inputs : [a, b, c], outputs : [d, e]) {value, index -&gt;
    …
}</pre></div><p class="paragraph">The priority selector will always 
prefer values from channels with lower position index over values coming
 through the channels with higher position index.</p><p class="paragraph"></p><h3>Join selector</h3><p class="paragraph">A selector without a body closure specified will copy all incoming values to all of its output channels.</p><p class="paragraph"></p><div class="code"><pre>def join = selector (inputs : [programmers, analysis, managers], outputs : [employees, colleagues])</pre></div><p class="paragraph"></p><h3>Internal parallelism</h3><p class="paragraph">The  <em class="italic">maxForks</em>  attribute allowing for internal selectors parallelism is also available.</p><p class="paragraph"></p><div class="code"><pre>selector (inputs : [a, b, c], outputs : [d, e], maxForks : 5) {value -&gt;
    ....
}</pre></div><p class="paragraph"></p><h3>Guards</h3><p class="paragraph">Just like  <em class="italic">Selects</em>  ,  <em class="italic">Selectors</em>  also allow the users to temporarily include/exclude individual input channels from selection.
The  <em class="italic">guards</em>  input property can be used to set the initial mask on all input channels and the  <em class="italic">setGuards</em>  and  <em class="italic">setGuard</em>  methods
are then available in the selector's body.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowQueue
<span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.Dataflow.selector
<span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.Dataflow.task<p class="paragraph">/**
 * Demonstrates the ability to enable/disable channels during a value selection on a select by providing <span class="java-object">boolean</span> guards.
 */
<span class="java-keyword">final</span> DataflowQueue operations = <span class="java-keyword">new</span> DataflowQueue()
<span class="java-keyword">final</span> DataflowQueue numbers = <span class="java-keyword">new</span> DataflowQueue()</p><p class="paragraph">def instruction
def nums = []</p><p class="paragraph">selector(inputs: [operations, numbers], outputs: [], guards: [<span class="java-keyword">true</span>, <span class="java-keyword">false</span>]) {value, index -&gt;   //initial guards is set here
    <span class="java-keyword">if</span> (index == 0) {
        instruction = value
        setGuard(0, <span class="java-keyword">false</span>)  //setGuard() used here
        setGuard(1, <span class="java-keyword">true</span>)
    }
    <span class="java-keyword">else</span> nums &lt;&lt; value
    <span class="java-keyword">if</span> (nums.size() == 2) {
        setGuards([<span class="java-keyword">true</span>, <span class="java-keyword">false</span>])                                    //setGuards() used here
        <span class="java-keyword">final</span> def formula = <span class="java-quote">"${nums[0]} $instruction ${nums[1]}"</span>
        println <span class="java-quote">"$formula = ${<span class="java-keyword">new</span> GroovyShell().evaluate(formula)}"</span>
        nums.clear()
    }
}</p><p class="paragraph">task {
    operations &lt;&lt; '+'
    operations &lt;&lt; '+'
    operations &lt;&lt; '*'
}</p><p class="paragraph">task {
    numbers &lt;&lt; 10
    numbers &lt;&lt; 20
    numbers &lt;&lt; 30
    numbers &lt;&lt; 40
    numbers &lt;&lt; 50
    numbers &lt;&lt; 60
}</p></pre></div><p class="paragraph"></p><blockquote class="note">
Avoid combining  <em class="italic">guards</em>  and  <em class="italic">maxForks</em>  greater than 1. Although the  <em class="italic">Selector</em>
  is thread-safe and won't be damaged in any way, the guards are likely 
not to be set
the way you expect. The multiple threads running selector's body 
concurrently will tend to over-write each-other's settings to the  <em class="italic">guards</em>  property.
</blockquote>


<h2 id="dataflow_operators_shutdown">7.4 Shutting Down Dataflow Networks</h2>
Shutting down a network of dataflow processors (operators and selectors) may sometimes be a non-trivial task, especially
if you need a generic mechanism that will not leave any messages unprocessed.<p class="paragraph">Dataflow operators and selectors can be terminated in three ways:
</p><ol>
<li>by calling the terminate() method on all operators that need to be terminated</li>
<li>by sending a poisson message</li>
<li>by setting up a network of activity monitors that will shutdown the network after all messages have been processed</li>
</ol><p class="paragraph">Check out the details on the ways that GPars provides.</p><p class="paragraph"></p><blockquote class="note">
<strong class="bold">Shutting down the thread pool</strong><p class="paragraph">If you use a custom  <em class="italic">PGroup</em>
  to maintain a thread pool for your dataflow network, you should not 
forget to shutdown the pool once the network is terminated.
Otherwise the thread pool will consume system resources and, in case of 
using non-daemon threads, it will prevent JVM from exit.
</p></blockquote><p class="paragraph"></p><h3>Emergency shutdown</h3><p class="paragraph">You can call  <em class="italic">terminate()</em>  on any operator/selector to immediately shut it down. Provided you keep track of all your processors,
perhaps by adding them to a list, the fastest way to stop the network would be:
</p><div class="code"><pre>allMyProcessors*.terminate()</pre></div><p class="paragraph">This
 should, however, be treated as an emergency exit, since no guarantees 
can be given regarding messages processed nor finished work.
Operators will simply terminate instantly leaving work unfinished and 
abandoning messages in the input channels.
Certainly, the lifecycle event listeners hooked to the 
operators/selectors will have their  <em class="italic">afterStop()</em>  event handlers invoked
in order to, for example, release resources or output a note into the log.</p><p class="paragraph"></p><div class="code"><pre>def op1 = <span class="java-keyword">operator</span>(inputs: [a, b, c], outputs: [d, e]) {x, y, z -&gt; }<p class="paragraph">def op2 = selector(inputs: [d], outputs: [f, out]) { }</p><p class="paragraph">def op3 = prioritySelector(inputs: [e, f], outputs: [b]) {value, index -&gt; }</p><p class="paragraph">[op1, op2, op3]*.terminate()  //Terminate all operators by calling the terminate() method on them
op1.join()
op2.join()
op3.join()</p></pre></div><p class="paragraph"></p><blockquote class="note">
Shutting down the whole JVM through  <em class="italic">System.exit()</em>  will also obvisouly shutdown the dataflow network, however, no lifecycle listeners will be invoked in such cases.
</blockquote><p class="paragraph"></p><h4>Stopping operators gently</h4><p class="paragraph">Operators
 handle incoming messages repeatedly. The only safe moment for stopping 
an operator without the risk of loosing
any messages is right after the operator has finished processing 
messages and is just about to look for more messages in its incoming 
pipes.
This is exactly what the  <em class="italic">terminateAfterNextRun()</em>  method does. It will schedule the operator for shutdown after the next set
of messages gets handled.</p><p class="paragraph">The unprocessed messages will stay in the input channels, which allows you to handle them later,
perhaps with a different operator/selector or in some other way. Using  <em class="italic">terminateAfterNextRun()</em>
  you will not loose any input messages.
This may be particularly handy when you use a group of 
operators/selectors to load-balance messages coming from a channel.
Once the work-load decreases, the terminateAfterNextRun() method may be 
used to safely reduce the pool of load-balancing operators.</p><p class="paragraph"></p><blockquote class="note">
<strong class="bold">Detecting shutdown</strong><p class="paragraph">Operators and electors offer a handy  <em class="italic">join()</em>  method for those who need to block until the operator terminates.
</p><div class="code"><pre>allMyProcessors*.join()</pre></div>
This is the easies way to wait until the whole dataflow network shuts down, irrespective of the shutdown method used.
</blockquote><p class="paragraph"></p><h3>PoisonPill</h3><p class="paragraph"> <em class="italic">PoisonPill</em>  is a common term for a strategy that uses special-purpose messages to stop entities that receive it.
GPars offers the  <em class="italic">PoisonPill</em>  class, which has exactly such effect or operators and selectors. Since  <em class="italic">PoisonPill</em> 
is a  <em class="italic">ControlMessage</em> , it is invisible to operator's body and custom code does not need to handle it in any way.
 <em class="italic">DataflowEventListeners</em>  may react to  <em class="italic">ControlMessages</em>  through the  <em class="italic">controlMessageArrived()</em>  handler method.</p><p class="paragraph"></p><div class="code"><pre>def op1 = <span class="java-keyword">operator</span>(inputs: [a, b, c], outputs: [d, e]) {x, y, z -&gt; }<p class="paragraph">def op2 = selector(inputs: [d], outputs: [f, out]) { }</p><p class="paragraph">def op3 = prioritySelector(inputs: [e, f], outputs: [b]) {value, index -&gt; }</p><p class="paragraph">a &lt;&lt; PoisonPill.instance  //Send the poisson</p><p class="paragraph">op1.join()
op2.join()
op3.join()</p></pre></div><p class="paragraph">After receiving a poisson an operator terminates, right after it finishes the current calculation and makes sure the poisson
is sent to all its output channels, so that the poisson can spread to the connected operators.
Also, although operators typically wait for all inputs to have a value, in case of  <em class="italic">PoisonPills</em> , the operator will terminate
immediately as soon as a  <em class="italic">PoisonPill</em>  appears on any of its inputs. The values already obtained from the other channels
will be lost. It can be considered an error in the design of the network, if these messages were supposed to be processed.
They would need a proper value as their peer and not a PoisonPill in order to be processes normally.</p><p class="paragraph">Selectors, on the other hand, will patiently wait for  <em class="italic">PoisonPill</em>  to be received from all their input channels before
sending it on the the output channels.
This behavior prevents networks containing <strong class="bold">feed-back loops involving selectors</strong> from being shutdown using  <em class="italic">PoisonPill</em>  .
A selector would never receive a  <em class="italic">PoisonPill</em>  from the channel that comes back from behind the selector. A different shutdown
strategy should be used for such networks.</p><p class="paragraph"></p><blockquote class="note">
Given the potential variety of operator networks and their asynchronous nature, a good termination strategy is that
operators and selectors should only ever terminate themselves.
All ways of terminating them from outside (either by calling the terminate() method or by sending poisson down the stream)
may result in messages being lost somewhere in the pipes, when the reading operators terminate before they fully handle
the messages waiting in their input channels.
</blockquote><p class="paragraph"></p><h4>Immediate poison pill</h4><p class="paragraph">Especially for selectors to shutdown immediately after receiving a poison pill, a notion of <strong class="bold">immediate poison pill</strong>
 has been introduced.
Since normal, non-immediate poison pills merely close the input channel 
leaving the selector alive until at least one input channel remains 
open,
the immediate poison pill closes the selector instantly. Obviously, 
unprocessed messages from the other selector's input channels
will not be handled by the selector, once it reads an immediate poison 
pill.</p><p class="paragraph">With immediate poison pill you can safely shutdown networks with selectors involved in feedback loops.</p><p class="paragraph"></p><div class="code"><pre>def op1 = selector(inputs: [a, b, c], outputs: [d, e]) {value, index -&gt; }
def op2 = selector(inputs: [d], outputs: [f, out]) { }
def op3 = prioritySelector(inputs: [e, f], outputs: [b]) {value, index -&gt; }<p class="paragraph">a &lt;&lt; PoisonPill.immediateInstance</p><p class="paragraph">[op1, op2, op3]*.join()</p></pre></div><p class="paragraph"></p><h4>Poison with counting</h4><p class="paragraph">When
 sending a poison pill down the operator network you may need to be 
notified when all the operators or a specified number of them
have been stopped. The  <em class="italic">CountingPoisonPill</em>  class serves exactly this purpose:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">operator</span>(inputs: [a, b, c], outputs: [d, e]) {x, y, z -&gt; }
selector(inputs: [d], outputs: [f, out]) { }
prioritySelector(inputs: [e, f], outputs: [b]) {value, index -&gt; }<p class="paragraph">//Send the poisson indicating the number of operators than need to be terminated before we can <span class="java-keyword">continue</span>
<span class="java-keyword">final</span> pill = <span class="java-keyword">new</span> CountingPoisonPill(3)
a &lt;&lt; pill</p><p class="paragraph">//Wait <span class="java-keyword">for</span> all operators to terminate
pill.join()
//At least 3 operators should be terminated by now</p></pre></div><p class="paragraph">The  <em class="italic">termination</em>  property of the  <em class="italic">CountingPoisonPill</em>  class is a regular  <em class="italic">Promise&lt;Boolean&gt;</em>  and so has a lot of handy properties.
</p><div class="code"><pre>//Send the poisson indicating the number of operators than need to be terminated before we can <span class="java-keyword">continue</span>
<span class="java-keyword">final</span> pill = <span class="java-keyword">new</span> CountingPoisonPill(3)
pill.termination.whenBound {println <span class="java-quote">"Reporting asynchronously that the network has been stopped"</span>}
a &lt;&lt; pill<p class="paragraph"><span class="java-keyword">if</span> (pill.termination.bound) println <span class="java-quote">"Wow, that was quick. We are done already!"</span>
<span class="java-keyword">else</span> println <span class="java-quote">"Things are being slow today. The network is still running."</span></p><p class="paragraph">//Wait <span class="java-keyword">for</span> all operators to terminate
assert pill.termination.get()
//At least 3 operators should be terminated by now</p></pre></div><p class="paragraph"></p><blockquote class="note">
An immediate variant of  <em class="italic">CountingPoisonPill</em>  is also available -  <em class="italic">ImmediateCountingPoisonPill</em>  .
<div class="code"><pre>def op1 = selector(inputs: [a, b, c], outputs: [d, e]) {value, index -&gt; }
def op2 = selector(inputs: [d], outputs: [f, out]) { }
def op3 = prioritySelector(inputs: [e, f], outputs: [b]) {value, index -&gt; }<p class="paragraph"><span class="java-keyword">final</span> pill = <span class="java-keyword">new</span> ImmediateCountingPoisonPill(3)
a &lt;&lt; pill
pill.join()</p></pre></div><p class="paragraph"> <em class="italic">ImmediateCountingPoisonPill</em>  will safely and instantly shutdown dataflow networks even with selectors involved in feedback loops,
which normal non-immediate poison pill would not be able to.
</p></blockquote><p class="paragraph"></p><h4>Poison strategies</h4><p class="paragraph">To correctly shutdown a network using  <em class="italic">PoisonPill</em>  you must identify the appropriate set of channels to send  <em class="italic">PoisonPill</em>  to.
 <em class="italic">PoisonPill</em>  will spread in the network the usual way through the channels and processors down the stream. Typically the right
channels to send  <em class="italic">PoisonPill</em>  to will be those that serve as <strong class="bold">data sources</strong> for the network.
This may be difficult to achieve for general cases or for complex networks. On the other hand, for networks with a prevalent
direction of message flow  <em class="italic">PoisonPill</em>  provides a very straightforward way to shutdown the whole network gracefully.</p><p class="paragraph"></p><blockquote class="note">
Load-balancing architectures, which use multiple operators reading messages off a shared channel (queue), will also prevent
poison shutdown to work properly, since only one of the reading operators will get to read the poison message.
You may consider using <strong class="bold">forked operators</strong> instead, by setting the  <em class="italic">maxForks</em>
  property to a value greater than 1.
Another alternative is to manually split the message stream into 
multiple channels, each of which would be consumed by one of the 
original operators.
</blockquote><p class="paragraph"></p><h4>Termination tips and tricks</h4><p class="paragraph">Notice that GPars  <em class="italic">tasks</em>  return a  <em class="italic">DataflowVariable</em> , which gets bound to a value as soon as the task finishes.
The 'terminator' operator below leverages the fact that  <em class="italic">DataflowVariables</em>  are implementations of the  <em class="italic">DataflowReadChannel</em> 
interface and thus can be consumed by operators. As soon as both tasks finish, the operator will send a  <em class="italic">PoisonPill</em> 
down the  <em class="italic">q</em>  channel to stop the consumer as soon as it processes all data.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowQueue
<span class="java-keyword">import</span> groovyx.gpars.group.NonDaemonPGroup<p class="paragraph">
def group = <span class="java-keyword">new</span> NonDaemonPGroup()</p><p class="paragraph"><span class="java-keyword">final</span> DataflowQueue q = <span class="java-keyword">new</span> DataflowQueue()</p><p class="paragraph">// <span class="java-keyword">final</span> destination
def customs = group.<span class="java-keyword">operator</span>(inputs: [q], outputs: []) { value -&gt;
    println <span class="java-quote">"Customs received $value"</span>
}</p><p class="paragraph">// big producer
def green = group.task {
    (1..100).each {
        q &lt;&lt; 'green channel ' + it
        sleep 10
    }
}</p><p class="paragraph">// little producer
def red = group.task {
    (1..10).each {
        q &lt;&lt; 'red channel ' + it
        sleep 15
    }
}</p><p class="paragraph">def terminator = group.<span class="java-keyword">operator</span>(inputs: [green, red], outputs: []) { t1, t2 -&gt;
    q &lt;&lt; PoisonPill.instance
}</p><p class="paragraph">customs.join()
group.shutdown()</p></pre></div><p class="paragraph"></p><h4>Keeping PoisonPill inside a given network</h4><p class="paragraph">If your network passed values through channels to entities outside of it, you may need to stop the  <em class="italic">PoisonPill</em>
  messages
on the network boundaries. This can be easily achieved by putting a 
single-input single-output filtering operator on each such channel.
</p><div class="code"><pre><span class="java-keyword">operator</span>(networkLeavingChannel, otherNetworkEnteringChannel) {value -&gt;
    <span class="java-keyword">if</span> (!(value instanceOf PoisonPill)) bindOutput it
}</pre></div><p class="paragraph">The  <em class="italic">Pipeline</em>  DSL may be also helpful here:</p><p class="paragraph"></p><div class="code"><pre>networkLeavingChannel.filter { !(it instanceOf PoisonPill) } into otherNetworkEnteringChannel</pre></div><p class="paragraph"></p><blockquote class="note">
Check out the  <em class="italic">Pipeline DSL</em>  section to find out more on pipelines.
</blockquote><p class="paragraph"></p><h3>Graceful shutdown</h3><p class="paragraph">GPars
 provides a generic way to shutdown a dataflow network. Unlike the 
previously mentioned mechanisms this approach
will keep the network running until all the messages get handled and 
than gracefully shuts all operators down letting you know when this 
happens.
You have to pay a modest performance penalty, though. This is 
unavoidable since we need to keep track of what's happening inside the 
network.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowBroadcast
<span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowQueue
<span class="java-keyword">import</span> groovyx.gpars.dataflow.<span class="java-keyword">operator</span>.component.GracefulShutdownListener
<span class="java-keyword">import</span> groovyx.gpars.dataflow.<span class="java-keyword">operator</span>.component.GracefulShutdownMonitor
<span class="java-keyword">import</span> groovyx.gpars.group.DefaultPGroup
<span class="java-keyword">import</span> groovyx.gpars.group.PGroup<p class="paragraph">PGroup group = <span class="java-keyword">new</span> DefaultPGroup(10)
<span class="java-keyword">final</span> a = <span class="java-keyword">new</span> DataflowQueue()
<span class="java-keyword">final</span> b = <span class="java-keyword">new</span> DataflowQueue()
<span class="java-keyword">final</span> c = <span class="java-keyword">new</span> DataflowQueue()
<span class="java-keyword">final</span> d = <span class="java-keyword">new</span> DataflowQueue&lt;<span class="java-object">Object</span>&gt;()
<span class="java-keyword">final</span> e = <span class="java-keyword">new</span> DataflowBroadcast&lt;<span class="java-object">Object</span>&gt;()
<span class="java-keyword">final</span> f = <span class="java-keyword">new</span> DataflowQueue&lt;<span class="java-object">Object</span>&gt;()
<span class="java-keyword">final</span> result = <span class="java-keyword">new</span> DataflowQueue&lt;<span class="java-object">Object</span>&gt;()</p><p class="paragraph"><span class="java-keyword">final</span> monitor = <span class="java-keyword">new</span> GracefulShutdownMonitor(100);</p><p class="paragraph">def op1 = group.<span class="java-keyword">operator</span>(inputs: [a, b], outputs: [c], listeners: [<span class="java-keyword">new</span> GracefulShutdownListener(monitor)]) {x, y -&gt;
    sleep 5
    bindOutput x + y
}
def op2 = group.<span class="java-keyword">operator</span>(inputs: [c], outputs: [d, e], listeners: [<span class="java-keyword">new</span> GracefulShutdownListener(monitor)]) {x -&gt;
    sleep 10
    bindAllOutputs 2*x
}
def op3 = group.<span class="java-keyword">operator</span>(inputs: [d], outputs: [f], listeners: [<span class="java-keyword">new</span> GracefulShutdownListener(monitor)]) {x -&gt;
    sleep 5
    bindOutput x + 40
}
def op4 = group.<span class="java-keyword">operator</span>(inputs: [e.createReadChannel(), f], outputs: [result], listeners: [<span class="java-keyword">new</span> GracefulShutdownListener(monitor)]) {x, y -&gt;
    sleep 5
    bindOutput x + y
}</p><p class="paragraph">100.times{a &lt;&lt; 10}
100.times{b &lt;&lt; 20}</p><p class="paragraph"><span class="java-keyword">final</span> shutdownPromise = monitor.shutdownNetwork()</p><p class="paragraph">100.times{assert 160 == result.val}</p><p class="paragraph">shutdownPromise.get()
[op1, op2, op3, op4]*.join()</p><p class="paragraph">group.shutdown()</p></pre></div><p class="paragraph">First, we need an instance of  <em class="italic">GracefulShutdownMonitor</em>  , which will orchestrate the shutdown process. It relies on
instances of  <em class="italic">GracefulShutdownListener</em>  attached to all operators/selectors. These listeners observe their respective
processors together with their input channels and report to the shared  <em class="italic">GracefulShutdownMonitor</em> .
Once  <em class="italic">shutdownNetwork()</em>  is called on  <em class="italic">GracefulShutdownMonitor</em>  , it will periodically check for reported activities,
query the state of operators as well as the number of messages in their input channels.
</p><blockquote class="note">
Please make sure that no new messages enter the dataflow network after 
the shutdown has been initiated, since this may cause the network to 
never terminate.
The shutdown process should only be started after all data producers 
have ceased sending additional messages to the monitored network.
</blockquote><p class="paragraph">The  <em class="italic">shutdownNetwork()</em>  method returns a  <em class="italic">Promise</em>  so that you can do the usual set of tricks with it - block waiting for the network
to terminate using the  <em class="italic">get()</em>  method, register a callback using the  <em class="italic">whenBound()</em>  method or make it trigger a whole set of activities
through the  <em class="italic">then()</em>  method.</p><p class="paragraph"></p><blockquote class="note">
<strong class="bold">Limitations of graceful shutdown</strong>
<ol>
<li>For  <em class="italic">GracefulShutdownListener</em>  to work correctly, its  <em class="italic">messageArrived()</em>
  event handler must see the original value that has arrived through the
 input channel. Since some event listeners may alter the messages as 
they pass through the listeners it is advisable to add the  <em class="italic">GracefulShutdownListener</em>  first to the list of listeners on each dataflow processor.</li>
<li>Also, graceful shutdown will not work for those rare operators that 
have listeners, which turn control messages into plain value messages in
 the  <em class="italic">controlMessageArrived()</em>  event handler.</li>
<li>Third and last, load-balancing architectures, which use multiple 
operators reading messages off a shared channel (queue), will also 
prevent graceful shutdown to work properly. You may consider using <strong class="bold">forked operators</strong> instead, by setting the  <em class="italic">maxForks</em>
  property to a value greater than 1. Another alternative is to manually
 split the message stream into multiple channels, each of which would be
 consumed by one of the original operators.</li>
</ol><p class="paragraph"></p></blockquote>



<h2 id="dataflow_applications">7.5 Application Frameworks</h2>
Dataflow Operators and Selectors can be successfully used to build 
high-level domain-specific frameworks for problems that naturally fit 
the flow model.<p class="paragraph"></p><h3>Building flow frameworks on top of GPars dataflow</h3><p class="paragraph">GPars dataflow can be viewed as bottom-line language-level infrastructure. Operators, selectors, channels and event listeners
can be very useful at language level to combine, for example, with actors or parallel collections.
Whenever a need comes for asynchronous handling of events that come through one of more channels, a dataflow operator
or a small dataflow network could be a very good fit. Unlike tasks, operators are lightweight and release threads
when there's no message to process. Unlike actors, operators are addressed indirectly through channels and may easily combine
messages from multiple channels into one action.</p><p class="paragraph">Alternatively,
 operators can be looked at as continuous functions, which instantly and
 repeatedly transform their input values into output.
We believe that a concurrency-friendly general-purpose programming 
language should provide this type of abstraction.</p><p class="paragraph">At
 the same time, dataflow elements can be easily used as building blocks 
for constructing domain-specific workflow-like frameworks.
These frameworks can offer higher-level abstractions specialized to a 
single problem domain, which would be inappropriate for a 
general-purpose
language-level library. Each of the higher-level concepts is then mapped
 to (potentially several) GPars concepts.</p><p class="paragraph">For 
example, a network solving data-mining problems may consist of several 
data sources, data cleaning nodes, categorization nodes,
reporting nodes and others. Image processing network, on the other hand,
 may need nodes specialized in image compression
and format transformation. Similarly, networks for data encryption, mp3 
encoding, work-flow management as well as many other domains
that would benefit from dataflow-based solutions, will differ in many 
aspects - the type of nodes in the network, the type and frequency of 
events,
the load-balancing scheme, potential constraints on branching, the need 
for visualization, debugging and logging, the way users define the 
networks
and interact with them as well as many others.</p><p class="paragraph">The
 higher-level application-specific frameworks should put effort into 
providing abstractions best suited for the given domain
and hide GPars complexities. For example, the visual graph of the 
network that the user manipulates on the screen should
typically not show all the channels that participate in the network. 
Debugging or logging channels, which rarely contribute
to the core of the solution, are among the first good candidates to 
consider for exclusion. Also channels and lifecycle-event listeners,
which orchestrate aspects such as load balancing or graceful shutdown, 
will probably be not exposed to the user, although they will be part
of the generated and executed network. Similarly, a single channel in 
the domain-specific model will in reality translate into multiple 
channels
perhaps with one or more logging/transforming/filtering operators 
connecting them together. The function associated with a node
will most likely be wrapped with some additional infrastructural code to
 form the operator's body.</p><p class="paragraph">GPars gives you the 
underlying components that the end user may be abstracted away 
completely by the application-specific framework.
This keeps GPars domain-agnostic and universal, yet useful at the 
implementation level.</p><p class="paragraph">


</p><h2 id="dataflow_pipelineDSL">7.6 Pipeline DSL</h2>
<h3>A DSL for building operators pipelines</h3><p class="paragraph">Building
 dataflow networks can be further simplified. GPars offers handy 
shortcuts for the common scenario of building (mostly linear) pipelines 
of operators.</p><p class="paragraph"></p><div class="code"><pre>def toUpperCase = {s -&gt; s.toUpperCase()}<p class="paragraph"><span class="java-keyword">final</span> encrypt = <span class="java-keyword">new</span> DataflowQueue()
<span class="java-keyword">final</span> DataflowReadChannel encrypted = encrypt | toUpperCase | {it.reverse()} | {'###encrypted###' + it + '###'}</p><p class="paragraph">encrypt &lt;&lt; <span class="java-quote">"I need to keep <span class="java-keyword">this</span> message secret!"</span>
encrypt &lt;&lt; <span class="java-quote">"GPars can build linear <span class="java-keyword">operator</span> pipelines really easily"</span></p><p class="paragraph">println encrypted.val
println encrypted.val</p></pre></div><p class="paragraph">This saves you from directly creating, wiring and manipulating all the channels and operators that are to form the pipeline.
The  <em class="italic">pipe</em>  operator lets you hook an output of one function/operator/process to the input of another one. Just like chaining
system processes on the command line.</p><p class="paragraph">The  <em class="italic">pipe</em>  operator is a handy shorthand for a more generic  <em class="italic">chainWith()</em>  method:</p><p class="paragraph"></p><div class="code"><pre>def toUpperCase = {s -&gt; s.toUpperCase()}<p class="paragraph"><span class="java-keyword">final</span> encrypt = <span class="java-keyword">new</span> DataflowQueue()
<span class="java-keyword">final</span> DataflowReadChannel encrypted = encrypt.chainWith toUpperCase chainWith {it.reverse()} chainWith {'###encrypted###' + it + '###'}</p><p class="paragraph">encrypt &lt;&lt; <span class="java-quote">"I need to keep <span class="java-keyword">this</span> message secret!"</span>
encrypt &lt;&lt; <span class="java-quote">"GPars can build linear <span class="java-keyword">operator</span> pipelines really easily"</span></p><p class="paragraph">println encrypted.val
println encrypted.val</p></pre></div><p class="paragraph"></p><h4>Combining pipelines with straight operators</h4><p class="paragraph">Since each operator pipeline has an entry and an exit channel, pipelines can be wired into more complex operator networks.
Only your imagination can limit your ability to mix pipelines with channels and operators in the same network definitions.</p><p class="paragraph"></p><div class="code"><pre>def toUpperCase = {s -&gt; s.toUpperCase()}
def save = {text -&gt;
    //Just pretending to be saving the text to disk, database or whatever
    println 'Saving ' + text
}<p class="paragraph"><span class="java-keyword">final</span> toEncrypt = <span class="java-keyword">new</span> DataflowQueue()
<span class="java-keyword">final</span> DataflowReadChannel encrypted = toEncrypt.chainWith toUpperCase chainWith {it.reverse()} chainWith {'###encrypted###' + it + '###'}</p><p class="paragraph"><span class="java-keyword">final</span> DataflowQueue fork1 = <span class="java-keyword">new</span> DataflowQueue()
<span class="java-keyword">final</span> DataflowQueue fork2 = <span class="java-keyword">new</span> DataflowQueue()
splitter(encrypted, [fork1, fork2])  //Split the data flow</p><p class="paragraph">fork1.chainWith save  //Hook in the save operation</p><p class="paragraph">//Hook in a sneaky decryption pipeline
<span class="java-keyword">final</span> DataflowReadChannel decrypted = fork2.chainWith {it[15..-4]} chainWith {it.reverse()} chainWith {it.toLowerCase()}
      .chainWith {'Groovy leaks! Check out a decrypted secret message: ' + it}</p><p class="paragraph">toEncrypt &lt;&lt; <span class="java-quote">"I need to keep <span class="java-keyword">this</span> message secret!"</span>
toEncrypt &lt;&lt; <span class="java-quote">"GPars can build <span class="java-keyword">operator</span> pipelines really easy"</span></p><p class="paragraph">println decrypted.val
println decrypted.val</p></pre></div><p class="paragraph"></p><blockquote class="note">
The type of the channel is preserved across the whole pipeline. E.g. if 
you start chaining off a synchronous channel,
 all the channels in the pipeline will be synchronous. In that case, 
obviously, the whole chain blocks, including the writer who writes into 
the channel at head,
 until someone reads data off the tail of the pipeline.
 <div class="code"><pre><span class="java-keyword">final</span> SyncDataflowQueue queue = <span class="java-keyword">new</span> SyncDataflowQueue()
<span class="java-keyword">final</span> result = queue.chainWith {it * 2}.chainWith {it + 1} chainWith {it * 100}<p class="paragraph"><span class="java-object">Thread</span>.start {
    5.times {
        println result.val
    }
}</p><p class="paragraph">queue &lt;&lt; 1
queue &lt;&lt; 2
queue &lt;&lt; 3
queue &lt;&lt; 4
queue &lt;&lt; 5</p></pre></div>
</blockquote><p class="paragraph"></p><h4>Joining pipelines</h4><p class="paragraph">Two pipelines (or channels) can be connected using the  <em class="italic">into()</em>  method:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> encrypt = <span class="java-keyword">new</span> DataflowQueue()
<span class="java-keyword">final</span> DataflowWriteChannel messagesToSave = <span class="java-keyword">new</span> DataflowQueue()
encrypt.chainWith toUpperCase chainWith {it.reverse()} into messagesToSave<p class="paragraph">task {
    encrypt &lt;&lt; <span class="java-quote">"I need to keep <span class="java-keyword">this</span> message secret!"</span>
    encrypt &lt;&lt; <span class="java-quote">"GPars can build <span class="java-keyword">operator</span> pipelines really easy"</span>
}</p><p class="paragraph">task {
    2.times {
        println <span class="java-quote">"Saving "</span> + messagesToSave.val
    }
}</p></pre></div><p class="paragraph">The output of the  <em class="italic">encryption</em>  pipeline is directly connected to the input of the  <em class="italic">saving</em>  pipeline (a single channel in out case).</p><p class="paragraph"></p><h4>Forking the data flow</h4><p class="paragraph">When a need comes to copy the output of a pipeline/channel into more than one following pipeline/channel, the  <em class="italic">split()</em>  method will help you:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> encrypt = <span class="java-keyword">new</span> DataflowQueue()
<span class="java-keyword">final</span> DataflowWriteChannel messagesToSave = <span class="java-keyword">new</span> DataflowQueue()
<span class="java-keyword">final</span> DataflowWriteChannel messagesToLog = <span class="java-keyword">new</span> DataflowQueue()<p class="paragraph">encrypt.chainWith toUpperCase chainWith {it.reverse()}.split(messagesToSave, messagesToLog)</p></pre></div><p class="paragraph"></p><h4>Tapping into the pipeline</h4>
Like  <em class="italic">split()</em>  the  <em class="italic">tap()</em>  method allows you to fork the data flow into multiple channels. Tapping, however, is slightly more convenient
in some scenarios, since it treats one of the two new forks as the successor of the pipeline.<p class="paragraph"></p><div class="code"><pre>queue.chainWith {it * 2}.tap(logChannel).chainWith{it + 1}.tap(logChannel).into(PrintChannel)</pre></div><p class="paragraph"></p><h4>Merging channels</h4><p class="paragraph">Merging
 allows you to join multiple read channels as inputs for a single 
dataflow operator. The function passed as the second argument needs to 
accept
as many arguments as there are channels being merged - each will hold a 
value of the corresponding channel.</p><p class="paragraph"></p><div class="code"><pre>maleChannel.merge(femaleChannel) {m, f -&gt; m.marry(f)}.into(mortgageCandidatesChannel)</pre></div><p class="paragraph"></p><h4>Separation</h4><p class="paragraph"> <em class="italic">Separation</em>  is the opposite operation to  <em class="italic">merge</em> . The supplied closure returns a list of values, each of which will be output into an output channel
with the corresponding position index.</p><p class="paragraph"></p><div class="code"><pre>queue1.separate([queue2, queue3, queue4]) {a -&gt; [a-1, a, a+1]}</pre></div><p class="paragraph"></p><h4>Choices</h4><p class="paragraph">The  <em class="italic">binaryChoice()</em>  and  <em class="italic">choice()</em>
  methods allow you to send a value to one out of two (or many) output 
channels, as indicated by the return value from a closure.</p><p class="paragraph"></p><div class="code"><pre>queue1.binaryChoice(queue2, queue3) {a -&gt; a &gt; 0}
queue1.choice([queue2, queue3, queue4]) {a -&gt; a % 3}</pre></div><p class="paragraph">
</p><h4>Filtering</h4><p class="paragraph">The  <em class="italic">filter()</em>  method allows to filter data in the pipeline using boolean predicates.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> DataflowQueue queue1 = <span class="java-keyword">new</span> DataflowQueue()
        <span class="java-keyword">final</span> DataflowQueue queue2 = <span class="java-keyword">new</span> DataflowQueue()<p class="paragraph">        <span class="java-keyword">final</span> odd = {num -&gt; num % 2 != 0 }</p><p class="paragraph">        queue1.filter(odd) into queue2
        (1..5).each {queue1 &lt;&lt; it}
        assert 1 == queue2.val
        assert 3 == queue2.val
        assert 5 == queue2.val</p></pre></div><p class="paragraph"></p><h4>Null values</h4><p class="paragraph">If a chained function returns a  <em class="italic">null</em>  value, it is normally passed along the pipeline as a valid value. To indicate to the operator
that no value should be passed further down the pipeline, a  <em class="italic">NullObject.nullObject</em>  instance must be returned.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> DataflowQueue queue1 = <span class="java-keyword">new</span> DataflowQueue()
        <span class="java-keyword">final</span> DataflowQueue queue2 = <span class="java-keyword">new</span> DataflowQueue()<p class="paragraph">        <span class="java-keyword">final</span> odd = {num -&gt;
            <span class="java-keyword">if</span> (num == 5) <span class="java-keyword">return</span> <span class="java-keyword">null</span>  //<span class="java-keyword">null</span> values are normally passed on
            <span class="java-keyword">if</span> (num % 2 != 0) <span class="java-keyword">return</span> num
            <span class="java-keyword">else</span> <span class="java-keyword">return</span> NullObject.nullObject  //<span class="java-keyword">this</span> value gets blocked
        }</p><p class="paragraph">        queue1.chainWith odd into queue2
        (1..5).each {queue1 &lt;&lt; it}
        assert 1 == queue2.val
        assert 3 == queue2.val
        assert <span class="java-keyword">null</span> == queue2.val</p></pre></div><p class="paragraph"></p><h4>Customizing the thread pools</h4><p class="paragraph">All of the Pipeline DSL methods allow for custom thread pools or  <em class="italic">PGroups</em>  to be specified:
</p><div class="code"><pre>channel | {it * 2}<p class="paragraph">channel.chainWith(closure)
channel.chainWith(pool) {it * 2}
channel.chainWith(group) {it * 2}</p><p class="paragraph">channel.into(otherChannel)
channel.into(pool, otherChannel)
channel.into(group, otherChannel)</p><p class="paragraph">channel.split(otherChannel1, otherChannel2)
channel.split(otherChannels)
channel.split(pool, otherChannel1, otherChannel2)
channel.split(pool, otherChannels)
channel.split(group, otherChannel1, otherChannel2)
channel.split(group, otherChannels)</p><p class="paragraph">channel.tap(otherChannel)
channel.tap(pool, otherChannel)
channel.tap(group, otherChannel)</p><p class="paragraph">channel.merge(otherChannel)
channel.merge(otherChannels)
channel.merge(pool, otherChannel)
channel.merge(pool, otherChannels)
channel.merge(group, otherChannel)
channel.merge(group, otherChannels)</p><p class="paragraph">channel.filter( otherChannel)
channel.filter(pool, otherChannel)
channel.filter(group, otherChannel)</p><p class="paragraph">channel.binaryChoice( trueBranch, falseBranch)
channel.binaryChoice(pool, trueBranch, falseBranch)
channel.binaryChoice(group, trueBranch, falseBranch)</p><p class="paragraph">channel.choice( branches)
channel.choice(pool, branches)
channel.choice(group, branches)</p><p class="paragraph">channel.separate( outputs)
channel.separate(pool, outputs)
channel.separate(group, outputs)</p></pre></div><p class="paragraph"></p><h3>Overriding the default PGroup</h3><p class="paragraph">To
 avoid the necessity to specify PGroup for each Pipeline DSL method 
separately you may override the value of the default Dataflow PGroup.
</p><div class="code"><pre>Dataflow.usingGroup(group) {
    channel.choice(branches)
}
//Is identical to
channel.choice(group, branches)</pre></div><p class="paragraph">The  <em class="italic">Dataflow.usingGroup()</em>  method resets the value of the default dataflow PGroup for the given code block to the value specified.</p><p class="paragraph"></p><h3>The pipeline builder</h3><p class="paragraph">The  <em class="italic">Pipeline</em>  class offers an intuitive builder for operator pipelines. The greatest benefit of using the  <em class="italic">Pipeline</em>  class compared to chaining the channels directly is
the ease with which a custom thread pool/group can be applied to all the operators along the constructed chain.
The available methods and overloaded operators are identical to the ones available on channels directly.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowQueue
<span class="java-keyword">import</span> groovyx.gpars.dataflow.<span class="java-keyword">operator</span>.Pipeline
<span class="java-keyword">import</span> groovyx.gpars.scheduler.DefaultPool
<span class="java-keyword">import</span> groovyx.gpars.scheduler.Pool<p class="paragraph"><span class="java-keyword">final</span> DataflowQueue queue = <span class="java-keyword">new</span> DataflowQueue()
<span class="java-keyword">final</span> DataflowQueue result1 = <span class="java-keyword">new</span> DataflowQueue()
<span class="java-keyword">final</span> DataflowQueue result2 = <span class="java-keyword">new</span> DataflowQueue()
<span class="java-keyword">final</span> Pool pool = <span class="java-keyword">new</span> DefaultPool(<span class="java-keyword">false</span>, 2)</p><p class="paragraph"><span class="java-keyword">final</span> negate = {-it}</p><p class="paragraph"><span class="java-keyword">final</span> Pipeline pipeline = <span class="java-keyword">new</span> Pipeline(pool, queue)</p><p class="paragraph">pipeline | {it * 2} | {it + 1} | negate
pipeline.split(result1, result2)</p><p class="paragraph">queue &lt;&lt; 1
queue &lt;&lt; 2
queue &lt;&lt; 3</p><p class="paragraph">assert -3 == result1.val
assert -5 == result1.val
assert -7 == result1.val</p><p class="paragraph">assert -3 == result2.val
assert -5 == result2.val
assert -7 == result2.val</p><p class="paragraph">pool.shutdown()</p></pre></div><p class="paragraph"></p><h3>Passing construction parameters through the Pipeline DSL</h3><p class="paragraph">You
 are likely to frequently need the ability to pass additional 
initialization parameters to the operators, such as the listeners
to attach or the value for  <em class="italic">maxForks</em> . Just like when building operators directly, the Pipeline DSL methods accept an optional
map of parameters to pass in.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">new</span> Pipeline(group, queue1).merge([maxForks: 4, listeners: [listener]], queue2) {a, b -&gt; a + b}.into queue3</pre></div>



<h2 id="dataflow_implementation">7.7 Implementation</h2>
The Dataflow Concurrency in GPars builds on the same principles as the 
actor support. All of the dataflow tasks share a thread pool and so the 
number threads created through  <em class="italic">Dataflow.task()</em>  factory method don't need to correspond to the number of physical threads required from the system.
The  <em class="italic">PGroup.task()</em>  factory method can be used 
to attach the created task to a group. Since each group defines its own 
thread pool, you can easily organize tasks around different thread pools
 just like you do with actors.<p class="paragraph"></p><h3>Combining actors and Dataflow Concurrency</h3><p class="paragraph">The
 good news is that you can combine actors and Dataflow Concurrency in 
any way you feel fit for your particular problem at hands. You can 
freely you use Dataflow Variables from actors.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">final</span> DataflowVariable a = <span class="java-keyword">new</span> DataflowVariable()<p class="paragraph"><span class="java-keyword">final</span> Actor doubler = Actors.actor {
    react {message-&gt;
        a &lt;&lt; 2 * message
    }
}</p><p class="paragraph"><span class="java-keyword">final</span> Actor fakingDoubler = actor {
    react {
        doubler.send it  //send a number to the doubler
        println <span class="java-quote">"Result ${a.val}"</span>  //wait <span class="java-keyword">for</span> the result to be bound to 'a'
    }
}</p><p class="paragraph">fakingDoubler &lt;&lt; 10</p></pre></div><p class="paragraph">In the example you see the "fakingDoubler" using both messages and a  <em class="italic">DataflowVariable</em>  to communicate with the  <em class="italic">doubler</em>  actor.</p><p class="paragraph"></p><h3>Using plain java threads</h3><p class="paragraph">The  <em class="italic">DataflowVariable</em>  as well as the  <em class="italic">DataflowQueue</em>  classes can obviously be used from any thread of your application, not only from the tasks created by  <em class="italic">Dataflow.task()</em>  . Consider the following example:
</p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowVariable<p class="paragraph"><span class="java-keyword">final</span> DataflowVariable a = <span class="java-keyword">new</span> DataflowVariable&lt;<span class="java-object">String</span>&gt;()
<span class="java-keyword">final</span> DataflowVariable b = <span class="java-keyword">new</span> DataflowVariable&lt;<span class="java-object">String</span>&gt;()</p><p class="paragraph"><span class="java-object">Thread</span>.start {
    println <span class="java-quote">"Received: $a.val"</span>
    <span class="java-object">Thread</span>.sleep 2000
    b &lt;&lt; 'Thank you'
}</p><p class="paragraph"><span class="java-object">Thread</span>.start {
    <span class="java-object">Thread</span>.sleep 2000
    a &lt;&lt; 'An important message from the second thread'
    println <span class="java-quote">"Reply: $b.val"</span>
}</p></pre></div>We're creating two plain  <em class="italic">java.lang.Thread</em>
  instances, which exchange data using the two data flow variables. 
Obviously, neither the actor lifecycle methods, nor the send/react 
functionality or thread pooling take effect in such scenarios.



<h2 id="dataflow_synchronousVariablesAndChannels">7.8 Synchronous Variables and Channels</h2>
When using asynchronous dataflow channels, apart from the fact that 
readers have to wait for a value to be available for consumption,
the communicating parties remain completely independent. Writers don't 
wait for their messages to get consumed. Readers
obtain values immediately as they come and ask.
Synchronous channels, on the other hand, can synchronize writers with 
the readers as well as multiple readers among themselves.
This is particularly useful when you need to increase the level of 
determinism. The writer-to-reader partial ordering imposed
by asynchronous communication is complemented with reader-to-writer 
partial ordering, when using synchronous communication.
In other words, you are guaranteed that whatever the reader did before 
reading a value from a synchronous channel preceded
whatever the writer did after writing the value.
Also, with synchronous communication writers can never get too far ahead
 of readers, which simplifies reasoning about the system
and reduces the need to manage data production speed in order to avoid 
system overload.<p class="paragraph"></p><h3>Synchronous dataflow queue</h3><p class="paragraph">The  <em class="italic">SyncDataflowQueue</em>  class should be used for point-to-point (1:1 or n:1) communication. Each message written to the queue
will be consumed by exactly one reader. Writers are blocked until their message is consumed, readers are blocked until there's
a value available for them to read.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.SyncDataflowQueue
<span class="java-keyword">import</span> groovyx.gpars.group.NonDaemonPGroup<p class="paragraph">/**
 * Shows how synchronous dataflow queues can be used to throttle fast producer when serving data to a slow consumer.
 * Unlike when using asynchronous channels, synchronous channels block both the writer and the readers until all parties are ready to exchange messages.
 */</p><p class="paragraph">def group = <span class="java-keyword">new</span> NonDaemonPGroup()</p><p class="paragraph"><span class="java-keyword">final</span> SyncDataflowQueue channel = <span class="java-keyword">new</span> SyncDataflowQueue()</p><p class="paragraph">def producer = group.task {
    (1..30).each {
        channel &lt;&lt; it
        println <span class="java-quote">"Just sent $it"</span>
    }
    channel &lt;&lt; -1
}</p><p class="paragraph">def consumer = group.task {
    <span class="java-keyword">while</span> (<span class="java-keyword">true</span>) {
        sleep 500  //simulating a slow consumer
        <span class="java-keyword">final</span> <span class="java-object">Object</span> msg = channel.val
        <span class="java-keyword">if</span> (msg == -1) <span class="java-keyword">return</span>
        println <span class="java-quote">"Received $msg"</span>
    }
}</p><p class="paragraph">consumer.join()</p><p class="paragraph">group.shutdown()</p></pre></div><p class="paragraph"></p><h3>Synchronous dataflow broadcast</h3><p class="paragraph">The  <em class="italic">SyncDataflowBroadcast</em>
  class should be used for publish-subscribe (1:n or n:m) communication.
 Each message written to the broadcast
will be consumed by all subscribed readers. Writers are blocked until 
their message is consumed by all readers, readers are blocked until 
there's
a value available for them to read and all the other subscribed readers 
ask for the message as well.
With  <em class="italic">SyncDataflowBroadcast</em>  you get all readers processing the same message at the same time and waiting for one-another
before getting the next one.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.SyncDataflowBroadcast
<span class="java-keyword">import</span> groovyx.gpars.group.NonDaemonPGroup<p class="paragraph">/**
 * Shows how synchronous dataflow broadcasts can be used to throttle fast producer when serving data to slow consumers.
 * Unlike when using asynchronous channels, synchronous channels block both the writer and the readers until all parties are ready to exchange messages.
 */</p><p class="paragraph">def group = <span class="java-keyword">new</span> NonDaemonPGroup()</p><p class="paragraph"><span class="java-keyword">final</span> SyncDataflowBroadcast channel = <span class="java-keyword">new</span> SyncDataflowBroadcast()</p><p class="paragraph">def subscription1 = channel.createReadChannel()
def fastConsumer = group.task {
    <span class="java-keyword">while</span> (<span class="java-keyword">true</span>) {
        sleep 10  //simulating a fast consumer
        <span class="java-keyword">final</span> <span class="java-object">Object</span> msg = subscription1.val
        <span class="java-keyword">if</span> (msg == -1) <span class="java-keyword">return</span>
        println <span class="java-quote">"Fast consumer received $msg"</span>
    }
}</p><p class="paragraph">def subscription2 = channel.createReadChannel()
def slowConsumer = group.task {
    <span class="java-keyword">while</span> (<span class="java-keyword">true</span>) {
        sleep 500  //simulating a slow consumer
        <span class="java-keyword">final</span> <span class="java-object">Object</span> msg = subscription2.val
        <span class="java-keyword">if</span> (msg == -1) <span class="java-keyword">return</span>
        println <span class="java-quote">"Slow consumer received $msg"</span>
    }
}</p><p class="paragraph">def producer = group.task {
    (1..30).each {
        println <span class="java-quote">"Sending $it"</span>
        channel &lt;&lt; it
        println <span class="java-quote">"Sent $it"</span>
    }
    channel &lt;&lt; -1
}</p><p class="paragraph">[fastConsumer, slowConsumer]*.join()</p><p class="paragraph">group.shutdown()</p></pre></div><p class="paragraph"></p><h3>Synchronous dataflow variable</h3><p class="paragraph">Unlike  <em class="italic">DataflowVariable</em> , which is asynchronous and only blocks the readers until a value is bound to the variable,
the  <em class="italic">SyncDataflowVariable</em>  class provides a one-shot data exchange mechanism that blocks the writer and all readers until a specified
number of waiting parties is reached.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.SyncDataflowVariable
<span class="java-keyword">import</span> groovyx.gpars.group.NonDaemonPGroup<p class="paragraph"><span class="java-keyword">final</span> NonDaemonPGroup group = <span class="java-keyword">new</span> NonDaemonPGroup()</p><p class="paragraph"><span class="java-keyword">final</span> SyncDataflowVariable value = <span class="java-keyword">new</span> SyncDataflowVariable(2)  //two readers required to exchange the message</p><p class="paragraph">def writer = group.task {
    println <span class="java-quote">"Writer about to write a value"</span>
    value &lt;&lt; 'Hello'
    println <span class="java-quote">"Writer has written the value"</span>
}</p><p class="paragraph">def reader = group.task {
    println <span class="java-quote">"Reader about to read a value"</span>
    println <span class="java-quote">"Reader has read the value: ${value.val}"</span>
}</p><p class="paragraph">def slowReader = group.task {
    sleep 5000
    println <span class="java-quote">"Slow reader about to read a value"</span>
    println <span class="java-quote">"Slow reader has read the value: ${value.val}"</span>
}</p><p class="paragraph">[reader, slowReader]*.join()</p><p class="paragraph">group.shutdown()</p></pre></div>



<h2 id="dataflow_kanbanFlow">7.9 Kanban Flow</h2>
APIs:
<a href="http://gpars.org/1.1.0/docs/groovydoc/groovyx/gpars/dataflow/KanbanFlow.html" class="api">KanbanFlow</a> |
<a href="http://gpars.org/1.1.0/docs/groovydoc/groovyx/gpars/dataflow/KanbanLink.html" class="api">KanbanLink</a> |
<a href="http://gpars.org/1.1.0/docs/groovydoc/groovyx/gpars/dataflow/KanbanTray.html" class="api">KanbanTray</a> |
<a href="http://gpars.org/1.1.0/docs/groovydoc/groovyx/gpars/dataflow/ProcessingNode.html" class="api">ProcessingNode</a><p class="paragraph"></p><h3>KanbanFlow</h3><p class="paragraph">A  <em class="italic">KanbanFlow</em>  is a composed object that uses dataflow abstractions to define dependencies
between multiple concurrent producer and consumer operators.</p><p class="paragraph">Each link between a producer and a consumer is defined by a  <em class="italic">KanbanLink</em> .</p><p class="paragraph">Inside each KanbanLink, the communication between producer and consumer follows the
KanbanFlow pattern as described in
<a href="http://people.canoo.com/mittie/kanbanflow.html" target="blank">The KanbanFlow Pattern</a> (recommended read).
They use objects of type  <em class="italic">KanbanTray</em>  to send products downstream and signal requests
for further products back to the producer.</p><p class="paragraph">The figure below shows a  <em class="italic">KanbanLink</em>  with one producer, one consumer and five trays
numbered 0 to 4. Tray number 0 has been used to take a product from producer to
consumer, has been emptied by the consumer and is now sent back to the producer's
input queue. Trays 1 and 2 wait carry products waiting for consumption, trays 3 and 4 wait to be used
by producers.</p><p class="paragraph"><img class="center" src="The%20GPars%20Framework%201.1.0_files/dataflow_kanban.png" border="0"></p><p class="paragraph">A  <em class="italic">KanbanFlow</em>  object links producers to consumers thus creating  <em class="italic">KanbanLink</em>  objects.
In the course of this activity, a second link may be constructed where the producer
is the same object that acted as the consumer in a formerly created link such
that the two links become connected to build a chain.</p><p class="paragraph">Here is an example of a  <em class="italic">KanbanFlow</em>  with only one link, e.g. one producer and one consumer.
The producer always sends the number 1 downstream and the consumer prints this number.
</p><div class="code"><pre><span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.ProcessingNode.node
<span class="java-keyword">import</span> groovyx.gpars.dataflow.KanbanFlow<p class="paragraph">def producer = node { down -&gt; down 1 }
def consumer = node { up   -&gt; println up.take() }</p><p class="paragraph"><span class="java-keyword">new</span> KanbanFlow().with {
    link producer to consumer
    start()
    // run <span class="java-keyword">for</span> a <span class="java-keyword">while</span>
    stop()
}</p></pre></div><p class="paragraph">For putting a product into a tray and sending the tray downstream, one can either
use the <code>send()</code> method, the <code>&lt;&lt;</code> operator, or use the tray as a method object.
The following lines are equivalent:
</p><div class="code"><pre>node { down -&gt; down.send 1 }
node { down -&gt; down &lt;&lt; 1 }
node { down -&gt; down 1 }</pre></div><p class="paragraph">When a product is taken from the input tray with the <code>take()</code> method, the empty
tray is automatically released.</p><p class="paragraph"></p><blockquote class="note">
You should call <code>take()</code> only once!
</blockquote><p class="paragraph">If you prefer to not using an empty tray for sending products downstream (as typically
the case when a  <em class="italic">ProcessingNode</em>  acts as a filter), you must
release the tray in order to keep it in play. Otherwise, the number of trays in the
system decreases. You can release a tray either by calling the <code>release()</code> method
or by using the <code>~</code> operator (think "shake it off").
The following lines are equivalent:
</p><div class="code"><pre>node { down -&gt; down.release() }
node { down -&gt; ~down }</pre></div><p class="paragraph"></p><blockquote class="note">
Trays are automatically released, if you call any of the <code>take()</code> or <code>send()</code> methods.
</blockquote><p class="paragraph"></p><h4>Various linking structures</h4><p class="paragraph">In addition to a linear chains, a  <em class="italic">KanbanFlow</em>  can also link a single producer to multiple
consumers (tree) or multiple producers to a single consumer (collector) or any combination
of the above that results in a directed acyclic graph (DAG).</p><p class="paragraph">The  <em class="italic">KanbanFlowTest</em>  class has many examples for such structures, including scenarios where
a single producer delegates work to multiple consumers with
</p><ul class="star">
<li>a <strong class="bold">work-stealing</strong> strategy where all consumers get their pick from the downstream,</li>
<li>a <strong class="bold">master-slave</strong> strategy where a producer chooses from the available consumers, and</li>
<li>a <strong class="bold">broadcast</strong> strategy where a producer sends all products to all consumers.</li>
</ul><p class="paragraph">Cycles are forbidden by default but when enabled, they can be used as so-called
generators. A producer can even be his own consumer that increases a product value
in every cycle. The generator itself remains state-free since the value is only stored as
a product riding on a tray.
Such a generator can be used for e.g. lazy sequences or as a the "heartbeat" of a
subsequent flow.</p><p class="paragraph">The approach of generator "loops" can equally be applied to collectors, where a collector
does not maintain any internal state but sends a collection onto itself, adding products
at each call.</p><p class="paragraph">Generally speaking, a  <em class="italic">ProcessingNode</em>  can link to itself for exporting state to
the tray/product that it sends to itself. Access to the product is then <strong class="bold">thread-safe by design</strong>.</p><p class="paragraph"></p><h4>Composing KanbanFlows</h4><p class="paragraph">Just as  <em class="italic">KanbanLink</em>  objects can be chained together to form a  <em class="italic">KanbanFlow</em> , flows themselves
can be composed again to form new greater flows from existing smaller ones.</p><p class="paragraph"></p><div class="code"><pre>def firstFlow = <span class="java-keyword">new</span> KanbanFlow()
def producer  = node(counter)
def consumer  = node(repeater)
firstFlow.link(producer).to(consumer)<p class="paragraph">def secondFlow = <span class="java-keyword">new</span> KanbanFlow()
def producer2  = node(repeater)
def consumer2  = node(reporter)
secondFlow.link(producer2).to(consumer2)</p><p class="paragraph">flow = firstFlow + secondFlow</p><p class="paragraph">flow.start()</p></pre></div><p class="paragraph"></p><h4>Customizing concurrency characteristics</h4><p class="paragraph">The amount of concurrency in a kanban system is determined by the number
of trays (sometimes called <strong class="bold">WIP</strong> = work in progress). With no trays in the
streams, the system does nothing.
</p><ul class="star">
<li>With one tray only, the system is confined to sequential execution.</li>
<li>With more trays, concurrency begins.</li>
<li>With more trays than available processing units, the system begins to waste resources.</li>
</ul><p class="paragraph">The number of trays can be controlled in various ways. They are typically
set when starting the flow.
</p><div class="code"><pre>flow.start(0) // start without trays
flow.start(1) // start with one tray per link in the flow
flow.start()  // start with the optimal number of trays</pre></div><p class="paragraph">In addition to the trays, the  <em class="italic">KanbanFlow</em>  may also be constrained by its
underlying  <em class="italic">ThreadPool</em> . A pool of size 1 for example will not allow much
concurrency.</p><p class="paragraph"> <em class="italic">KanbanFlows</em>  use a default pool that is dimensioned by the number of available
cores. This can be customized by setting the <code>pooledGroup</code> property.</p><p class="paragraph"><strong class="bold">Test:</strong> <br>
<a href="https://github.com/GPars/GPars/blob/master/src/test/groovy/groovyx/gpars/dataflow/KanbanFlowTest.groovy" target="blank">KanbanFlowTest</a> <br>
<strong class="bold">Demos:</strong> <br>
<a href="https://github.com/GPars/GPars/blob/master/src/test/groovy/groovyx/gpars/samples/dataflow/kanban/DemoKanbanFlow.groovy" target="blank">DemoKanbanFlow</a> <br>
<a href="https://github.com/GPars/GPars/blob/master/src/test/groovy/groovyx/gpars/samples/dataflow/kanban/DemoKanbanFlowBroadcast.groovy" target="blank">DemoKanbanFlowBroadcast</a> <br>
<a href="https://github.com/GPars/GPars/blob/master/src/test/groovy/groovyx/gpars/samples/dataflow/kanban/DemoKanbanFlowCycle.groovy" target="blank">DemoKanbanFlowCycle</a> <br>
<a href="https://github.com/GPars/GPars/blob/master/src/test/groovy/groovyx/gpars/samples/dataflow/kanban/DemoKanbanLazyPrimeSequenceLoops.groovy" target="blank">DemoKanbanLazyPrimeSequenceLoops</a>



</p><h2 id="dataflow_classicExamples">7.10 Classic Examples</h2>
<h3>The Sieve of Eratosthenes implementation using dataflow tasks</h3><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowQueue
<span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.Dataflow.task<p class="paragraph">/**
 * Demonstrates concurrent implementation of the Sieve of Eratosthenes using dataflow tasks
 */</p><p class="paragraph"><span class="java-keyword">final</span> <span class="java-object">int</span> requestedPrimeNumberCount = 1000</p><p class="paragraph"><span class="java-keyword">final</span> DataflowQueue initialChannel = <span class="java-keyword">new</span> DataflowQueue()</p><p class="paragraph">/**
 * Generating candidate numbers
 */
task {
    (2..10000).each {
        initialChannel &lt;&lt; it
    }
}</p><p class="paragraph">/**
 * Chain a <span class="java-keyword">new</span> filter <span class="java-keyword">for</span> a particular prime number to the end of the Sieve
 * @param inChannel The current end channel to consume
 * @param prime The prime number to divide <span class="java-keyword">future</span> prime candidates with
 * @<span class="java-keyword">return</span> A <span class="java-keyword">new</span> channel ending the whole chain
 */
def filter(inChannel, <span class="java-object">int</span> prime) {
    def outChannel = <span class="java-keyword">new</span> DataflowQueue()</p><p class="paragraph">    task {
        <span class="java-keyword">while</span> (<span class="java-keyword">true</span>) {
            def number = inChannel.val
            <span class="java-keyword">if</span> (number % prime != 0) {
                outChannel &lt;&lt; number
            }
        }
    }
    <span class="java-keyword">return</span> outChannel
}</p><p class="paragraph">/**
 * Consume Sieve output and add additional filters <span class="java-keyword">for</span> all found primes
 */
def currentOutput = initialChannel
requestedPrimeNumberCount.times {
    <span class="java-object">int</span> prime = currentOutput.val
    println <span class="java-quote">"Found: $prime"</span>
    currentOutput = filter(currentOutput, prime)
}</p></pre></div><p class="paragraph"></p><h3>The Sieve of Eratosthenes implementation using a combination of dataflow tasks and operators</h3><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.dataflow.DataflowQueue
       <span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.Dataflow.<span class="java-keyword">operator</span>
       <span class="java-keyword">import</span> <span class="java-keyword">static</span> groovyx.gpars.dataflow.Dataflow.task<p class="paragraph">       /**
        * Demonstrates concurrent implementation of the Sieve of Eratosthenes using dataflow tasks and operators
        */</p><p class="paragraph">       <span class="java-keyword">final</span> <span class="java-object">int</span> requestedPrimeNumberCount = 100</p><p class="paragraph">       <span class="java-keyword">final</span> DataflowQueue initialChannel = <span class="java-keyword">new</span> DataflowQueue()</p><p class="paragraph">       /**
        * Generating candidate numbers
        */
       task {
           (2..1000).each {
               initialChannel &lt;&lt; it
           }
       }</p><p class="paragraph">       /**
        * Chain a <span class="java-keyword">new</span> filter <span class="java-keyword">for</span> a particular prime number to the end of the Sieve
        * @param inChannel The current end channel to consume
        * @param prime The prime number to divide <span class="java-keyword">future</span> prime candidates with
        * @<span class="java-keyword">return</span> A <span class="java-keyword">new</span> channel ending the whole chain
        */
       def filter(inChannel, <span class="java-object">int</span> prime) {
           def outChannel = <span class="java-keyword">new</span> DataflowQueue()</p><p class="paragraph">           <span class="java-keyword">operator</span>([inputs: [inChannel], outputs: [outChannel]]) {
               <span class="java-keyword">if</span> (it % prime != 0) {
                   bindOutput it
               }
           }
           <span class="java-keyword">return</span> outChannel
       }</p><p class="paragraph">       /**
        * Consume Sieve output and add additional filters <span class="java-keyword">for</span> all found primes
        */
       def currentOutput = initialChannel
       requestedPrimeNumberCount.times {
           <span class="java-object">int</span> prime = currentOutput.val
           println <span class="java-quote">"Found: $prime"</span>
           currentOutput = filter(currentOutput, prime)
       }</p></pre></div>


<h1 id="STM">8 STM</h1>
Software Transactional Memory (STM) gives developers transactional semantics for accessing in-memory data. When multiple threads
share data in memory, by marking blocks of code as transactional (atomic) the developer delegates the responsibility
for data consistency to the Stm engine.
GPars leverages the Multiverse Stm engine. Check out more details on the transactional engine at the <a href="http://multiverse.codehaus.org/overview.html" target="blank">Multiverse site</a><p class="paragraph"></p><h3>Running a piece of code atomically</h3><p class="paragraph">When using Stm, developers organize their code into transactions. A transaction is a piece of code, which is executed <strong class="bold">atomically</strong> - either all the code is run or none at all.
The data used by the transactional code remains <strong class="bold">consistent</strong> irrespective of whether the transaction finishes normally or abruptly.
While running inside a transaction the code is given an illusion of being <strong class="bold">isolated</strong> from the other concurrently run transactions so that changes to data in one transaction
are not visible in the other ones until the transactions commit. This gives us the <strong class="bold">ACI</strong> part of the <strong class="bold">ACID</strong> characteristics of database transactions. The <strong class="bold">durability</strong> transactional aspect
so typical for databases, is not typically mandated for Stm.</p><p class="paragraph">GPars allows developers to specify transaction boundaries by using the  <em class="italic">atomic</em>  closures.</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.stm.GParsStm
<span class="java-keyword">import</span> org.multiverse.api.references.TxnInteger
<span class="java-keyword">import</span> <span class="java-keyword">static</span> org.multiverse.api.StmUtils.newTxnInteger<p class="paragraph"><span class="java-keyword">public</span> class Account {
    <span class="java-keyword">private</span> <span class="java-keyword">final</span> TxnInteger amount = newTxnInteger(0);</p><p class="paragraph">    <span class="java-keyword">public</span> void transfer(<span class="java-keyword">final</span> <span class="java-object">int</span> a) {
        GParsStm.atomic {
            amount.increment(a);
        }
    }</p><p class="paragraph">    <span class="java-keyword">public</span> <span class="java-object">int</span> getCurrentAmount() {
        GParsStm.atomicWithInt {
            amount.get();
        }
    }
}</p></pre></div><p class="paragraph">There are several types of  <em class="italic">atomic</em>  closures, each for different type of return value:
</p><ul class="star">
<li> <em class="italic">atomic</em>  - returning  <em class="italic">Object</em> </li>
<li> <em class="italic">atomicWithInt</em>  - returning  <em class="italic">int</em> </li>
<li> <em class="italic">atomicWithLong</em>  - returning  <em class="italic">long</em> </li>
<li> <em class="italic">atomicWithBoolean</em>  - returning  <em class="italic">boolean</em> </li>
<li> <em class="italic">atomicWithDouble</em>  - returning  <em class="italic">double</em> </li>
<li> <em class="italic">atomicWithVoid</em>  - no return value</li>
</ul><p class="paragraph">Multiverse by default uses optimistic locking 
strategy and automatically rolls back and retries colliding 
transactions.
Developers should thus restrain from irreversible actions (e.g. writing 
to the console, sending and e-mail, launching a missile, etc.) in their 
transactional code.
To increase flexibility, the default Multiverse settings can be 
customized through custom  <em class="italic">atomic blocks</em>  .</p><p class="paragraph"></p><h3>Customizing the transactional properties</h3><p class="paragraph">Frequently
 it may be desired to specify different values for some of the 
transaction properties (e.g. read-only transactions, locking strategy, 
isolation level, etc.).
The  <em class="italic">createAtomicBlock</em>  method will create a new  <em class="italic">AtomicBlock</em>  configured with the supplied values:</p><p class="paragraph"></p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.stm.GParsStm
<span class="java-keyword">import</span> org.multiverse.api.AtomicBlock
<span class="java-keyword">import</span> org.multiverse.api.PropagationLevel<p class="paragraph"><span class="java-keyword">final</span> TxnExecutor block = GParsStm.createTxnExecutor(maxRetries: 3000, familyName: 'Custom', PropagationLevel: PropagationLevel.Requires, interruptible: <span class="java-keyword">false</span>)
assert GParsStm.atomicWithBoolean(block) {
    <span class="java-keyword">true</span>
}</p></pre></div><p class="paragraph">The customized  <em class="italic">AtomicBlock</em>  can then be used to create transactions following the specified settings.  <em class="italic">AtomicBlock</em>  instances are thread-safe and can be freely reused among threads and transactions.</p><p class="paragraph"></p><h3>Using the  <em class="italic">Transaction</em>  object</h3><p class="paragraph">The atomic closures are provided the current  <em class="italic">Transaction</em>  as a parameter. The  <em class="italic">Txn</em>  objects representing a transaction can then be used
to manually control the transaction.
This is illustrated in the example below, where we use the  <em class="italic">retry()</em>  method to block the current transaction until the counter reaches the desired value:
 </p><div class="code"><pre><span class="java-keyword">import</span> groovyx.gpars.stm.GParsStm
<span class="java-keyword">import</span> org.multiverse.api.PropagationLevel
<span class="java-keyword">import</span> org.multiverse.api.TxnExecutor<p class="paragraph"><span class="java-keyword">import</span> <span class="java-keyword">static</span> org.multiverse.api.StmUtils.newTxnInteger</p><p class="paragraph"><span class="java-keyword">final</span> TxnExecutor block = GParsStm.createTxnExecutor(maxRetries: 3000, familyName: 'Custom', PropagationLevel: PropagationLevel.Requires, interruptible: <span class="java-keyword">false</span>)</p><p class="paragraph">def counter = newTxnInteger(0)
<span class="java-keyword">final</span> <span class="java-object">int</span> max = 100
<span class="java-object">Thread</span>.start {
    <span class="java-keyword">while</span> (counter.atomicGet() &lt; max) {
        counter.atomicIncrementAndGet(1)
        sleep 10
    }
}
assert max + 1 == GParsStm.atomicWithInt(block) { tx -&gt;
    <span class="java-keyword">if</span> (counter.get() == max) <span class="java-keyword">return</span> counter.get() + 1
    tx.retry()
}</p></pre></div><p class="paragraph"></p><h3>Data structures</h3><p class="paragraph">You
 might have noticed in the code examples above that we use dedicated 
data structures to hold values. The fact is that normal Java classes
do not support transactions and thus cannot be used directly, since 
Multiverse would not be able to share them safely among concurrent 
transactions, commit them nor roll them back.
We need to use data that know about transactions:
</p><ul class="star">
<li>TxnIntRef</li>
<li>TxnLongRef</li>
<li>TxnBooleanRef</li>
<li>TxnDoubleRef</li>
<li>TxnRef</li>
</ul><p class="paragraph">You typically create these through the factory methods of the  <em class="italic">org.multiverse.api.StmUtils</em>  class.</p><p class="paragraph"></p><h3>More information</h3><p class="paragraph">We decided not to duplicate the information that is already available on the Multiverse website. Please visit
the <a href="http://multiverse.codehaus.org/overview.html" target="blank">Multiverse site</a> and use it as a reference for your further Stm adventures with GPars.



</p><h1 id="GAE">9 Google App Engine Integration</h1>
GPars can be run on the <a href="https://developers.google.com/appengine/" target="blank">Google App Engine (GAE)</a> .
It can be made part of Groovy and Java GAE applications as well as a plugged into Gaelyk.
The small <a href="https://github.com/musketyr/gpars-appengine" target="blank">GPars App Engine integration library</a>
provides all the necessary infrastructure to hook GAE services into GPars.
Although you'll be running on GAE threads and leveraging GAE timer services, the high-level abstractions remain the same.
With a few restrictions you can still use GPars actors, dataflow, agents, parallel collections and other handy concepts.<p class="paragraph">Please refer to the <a href="https://github.com/musketyr/gpars-appengine" target="blank">GPars App Engine library</a> documentation for details
on how to proceed with GPars on GAE.



</p><h1 id="tips">10 Tips</h1>
<h2>General GPars Tips</h2><p class="paragraph"></p><h3>Grouping</h3><p class="paragraph">High-level concurrency concepts, like Agents, Actors or Dataflow tasks and operators can be grouped around shared thread pools.
The  <em class="italic">PGroup</em>  class and its sub-classes represent convenient GPars wrappers around thread pools.
Objects created using the group's factory methods will share the group's thread pool.
</p><div class="code"><pre>def group1 = <span class="java-keyword">new</span> DefaultPGroup()
def group2 = <span class="java-keyword">new</span> NonDaemonPGroup()<p class="paragraph">group1.with {
    task {...}
    task {...}
    def op = <span class="java-keyword">operator</span>(...) {...}
    def actor = actor{...}
    def anotherActor = group2.actor{...}  //will belong to group2
    def agent = safe(0)
}</p></pre></div><p class="paragraph"></p><blockquote class="note">
When customizing the thread pools for groups, consider using the existing GPars implementations - the  <em class="italic">DefaultPool</em>  or  <em class="italic">ResizeablePool</em>  classes.
Or you may create your own implementation of the  <em class="italic">groovyx.gpars.scheduler.Pool</em>  interface to pass to the  <em class="italic">DefaultPGroup</em>  or  <em class="italic">NonDaemonPGroup</em>  constructors.
</blockquote><p class="paragraph"></p><h3>Java API</h3><p class="paragraph">Most of GPars functionality can be used from Java just as well as from Groovy. Checkout the  <em class="italic">2.6 Java API - Using GPars from Java</em>  section of the User Guide
and experiment with the maven-based stand-alone Java <a href="http://gpars.codehaus.org/Demos" target="blank">demo application</a> .
Take GPars with you wherever you go!



</p><h2 id="tips_performance">10.1 Performance</h2>
Your code in Groovy can be just as fast as code written in Java, Scala or any other programing language.
This should not be surprising, since GPars is technically a solid tasty Java-made cake with a Groovy DSL cream on it.<p class="paragraph">Unlike
 in Java, however, with GPars, as well as with other DSL-friendly 
languages, you are very likely to experience a useful kind of code 
speed-up for free,
a speed-up coming from a better and cleaner design of your application. 
Coding with a concurrency DSL will give you smaller code-base with code
using the concurrency primitives as language constructs. So it is much 
easier to build robust concurrent applications, identify potential
bottle-necks or errors and eliminate them.</p><p class="paragraph">While
 this whole User Guide is describing how to use Groovy and GPars to 
create beautiful and robust concurrent code, let's use this chapter
to highlight a few places, where some code tuning or minor design 
compromises could give you interesting performance gains.</p><p class="paragraph"></p><h3>Parallel Collections</h3>
Methods for parallel collection processing, like  <em class="italic">eachParallel()</em>  ,  <em class="italic">collectParallel()</em>  and such use  <em class="italic">Parallel Array</em>  , an efficient tree-like data structure behind the scenes.
This data structure has to be built from the original collection each time you call any of the parallel collection methods.
Thus when chaining parallel method calls you might consider using the  <em class="italic">map/reduce</em>  API instead or resort to using the  <em class="italic">ParallelArray</em>  API directly, to avoid the  <em class="italic">Parallel Array</em>  creation overhead.<p class="paragraph"></p><div class="code"><pre>GParsPool.withPool {
    people.findAllParallel{it.isMale()}.collectParallel{it.name}.any{it == 'Joe'}
    people.parallel.filter{it.isMale()}.map{it.name}.filter{it == 'Joe'}.size() &gt; 0
    people.parallelArray.withFilter({it.isMale()} as Predicate).withMapping({it.name} as Mapper).any{it == 'Joe'} != <span class="java-keyword">null</span>
}</pre></div><p class="paragraph">In many scenarios changing the pool 
size from the default value may give you performance benefits. 
Especially if your tasks
perform IO operations, like file or database access, networking and 
such, increasing the number of threads in the pool is likely to help 
performance.</p><p class="paragraph"></p><div class="code"><pre>GParsPool.withPool(50) {
    …
}</pre></div><p class="paragraph">Since the closures you provide to the parallel collection processing methods will get executed frequently and concurrently,
you may further slightly benefit from turning them into Java.</p><p class="paragraph"></p><h3>Actors</h3><p class="paragraph">GPars actors are fast.  <em class="italic">DynamicDispatchActors</em>  and  <em class="italic">ReactiveActors</em>  are about twice as fast as the  <em class="italic">DefaultActors</em>  , since they don't have to maintain
an implicit state between subsequent message arrivals. The  <em class="italic">DefaultActors</em>  are in fact on par in performance with actors in  <em class="italic">Scala</em>  , which you can hardly hear of as being slow.</p><p class="paragraph">If top performance is what you're looking for, a good start is to identify the following patterns in your actor code:
</p><div class="code"><pre>actor {
    loop {
        react {msg -&gt;
            <span class="java-keyword">switch</span>(msg) {
                <span class="java-keyword">case</span> <span class="java-object">String</span>:…
                <span class="java-keyword">case</span> <span class="java-object">Integer</span>:…
            }
        }
    }
}</pre></div>
and replace them with  <em class="italic">DynamicDispatchActor</em>  :
<div class="code"><pre>messageHandler {
    when{<span class="java-object">String</span> msg -&gt; ...}
    when{<span class="java-object">Integer</span> msg -&gt; ...}
}</pre></div><p class="paragraph">The  <em class="italic">loop</em>  and  <em class="italic">react</em>  methods are rather costly to call.</p><p class="paragraph">Defining a  <em class="italic">DynamicDispatchActor</em>  or  <em class="italic">ReactiveActor</em>  as classes instead of using the  <em class="italic">messageHandler</em>  and  <em class="italic">reactor</em>  factory methods will also give you some more speed:</p><p class="paragraph"></p><div class="code"><pre>class MyHandler <span class="java-keyword">extends</span> DynamicDispatchActor {
    <span class="java-keyword">public</span> void handleMessage(<span class="java-object">String</span> msg) {
        …
    }<p class="paragraph">    <span class="java-keyword">public</span> void handleMessage(<span class="java-object">Integer</span> msg) {
        …
    }
}</p></pre></div><p class="paragraph">Now, moving the  <em class="italic">MyHandler</em>  class into Java will squeeze the last bit of performance from GPars.</p><p class="paragraph"></p><h4>Pool adjustment</h4><p class="paragraph">GPars allows you to group actors around thread pools, giving you the freedom to organize actors any way you like.
It is always worthwhile to experiment with the actor pool size and type.  <em class="italic">FJPool</em>  usually gives better characteristics that
 <em class="italic">DefaultPool</em>  , but seems to be more sensitive to the number of threads in the pool.
Sometimes using a  <em class="italic">ResizeablePool</em>  or  <em class="italic">ResizeableFJPool</em>  could help performance by automatic eliminating unneeded threads.</p><p class="paragraph"></p><div class="code"><pre>def attackerGroup = <span class="java-keyword">new</span> DefaultPGroup(<span class="java-keyword">new</span> ResizeableFJPool(10))
def defenderGroup = <span class="java-keyword">new</span> DefaultPGroup(<span class="java-keyword">new</span> DefaultPool(5))<p class="paragraph">def attacker = attackerGroup.actor {...}
def defender = defenderGroup.messageHandler {...}
...</p></pre></div><p class="paragraph"></p><h3>Agents</h3><p class="paragraph">GPars  <em class="italic">Agents</em>  are even a bit faster in processing messages than actors. The advice to group agents wisely around thread pools
and tune the pool sizes and types applies to agents as well as to actors.
With agents, you may also benefit from submitting Java-written closures as messages.</p><p class="paragraph"></p><h3>Share your experience</h3><p class="paragraph">The
 more we hear about GPars uses in the wild the better we can adapt it 
for the future. Let us know how you use GPars and how it performs.
Send us your benchmarks, performance comparisons or profiling reports to
 help us tune GPars for you.</p><p class="paragraph">


</p><h2 id="tips_hostedEnvironment">10.2 Integration into hosted environment</h2>
Hosted environments, such as Google App Engine, impose additional restrictions on threading. For GPars to integrate with
these environments better, the default thread factory and timer factory can be customized.
The  <em class="italic">GPars_Config</em>  class provides static initialization methods allowing third parties to register their own implementations of
the  <em class="italic">PoolFactory</em>  and  <em class="italic">TimerFactory</em>  interfaces, which will then be used to create default pools and timers for Actors, Dataflow
and PGroups.<p class="paragraph"></p><div class="code"><pre><span class="java-keyword">public</span> <span class="java-keyword">final</span> class GParsConfig {
    <span class="java-keyword">private</span> <span class="java-keyword">static</span> <span class="java-keyword">volatile</span> PoolFactory poolFactory;
    <span class="java-keyword">private</span> <span class="java-keyword">static</span> <span class="java-keyword">volatile</span> TimerFactory timerFactory;<p class="paragraph">    <span class="java-keyword">public</span> <span class="java-keyword">static</span> void setPoolFactory(<span class="java-keyword">final</span> PoolFactory pool)</p><p class="paragraph">    <span class="java-keyword">public</span> <span class="java-keyword">static</span> PoolFactory getPoolFactory()</p><p class="paragraph">    <span class="java-keyword">public</span> <span class="java-keyword">static</span> Pool retrieveDefaultPool()</p><p class="paragraph">    <span class="java-keyword">public</span> <span class="java-keyword">static</span> void setTimerFactory(<span class="java-keyword">final</span> TimerFactory timerFactory)</p><p class="paragraph">    <span class="java-keyword">public</span> <span class="java-keyword">static</span> TimerFactory getTimerFactory()</p><p class="paragraph">    <span class="java-keyword">public</span> <span class="java-keyword">static</span> GeneralTimer retrieveDefaultTimer(<span class="java-keyword">final</span> <span class="java-object">String</span> name, <span class="java-keyword">final</span> <span class="java-object">boolean</span> daemon)
}</p></pre></div><p class="paragraph">The custom factories should be registered immediately after the application startup in order for Actors and Dataflow
to be able to use them for their default groups.</p><p class="paragraph"></p><h3>Compatibility</h3><p class="paragraph">Some
 further compatibility problems may occur when running GPars in a hosted
 environment. The most noticeable one is probably
 the lack of ForkJoinThreadPool (aka jsr-166y) support in GAE. 
Functionality such as Fork/Join and GParsPool may thus not be available 
on some
 services as a result. However, GParsExecutorsPool, Dataflow, Actors, 
Agents and Stm should work normally
 even when using managed non-Java SE thread pools.



</p><h1 id="conclusion">11 Conclusion</h1>
This was quite a wild ride, wasn't it? Now, after going through the User
 Guide, you're certainly ready to build fast, robust and reliable 
concurrent applications.
You've seen that there are many concepts you can choose from and each 
has its own areas of applicability. The ability
to pick the right concept to apply to a given problem and combine it 
with the rest of the system is key to being a successful developer.
If you feel you can do this with GPars, the mission of the User Guide 
has been accomplished.<p class="paragraph">Now, go ahead, use GPars and have fun!


                    </p></div>
                </td>
                <td id="col2">
            <div class="local clearfix">
                <div class="local-title">
                    <a href="http://gpars.org/1.1.0/guide/guide/index.html" target="mainFrame">Quick Reference</a>
                    <span class="toggle">(<a href="#" onclick="localToggle(); return false;">hide</a>)</span>
                </div>
                <div class="menu">
                    
                    <div class="menu-block"><h1 class="menu-title" onclick="toggleRef(this.parentNode.childNodes[1])">Actors</h1><div class="menu-sub">
                        
                        
                        <div class="menu-item"><a href="http://gpars.org/1.1.0/guide/ref/Actors/Concepts.html">Concepts</a>
                        </div>
                        
                        <div class="menu-item"><a href="http://gpars.org/1.1.0/guide/ref/Actors/Lifecycle.html">Lifecycle</a>
                        </div>
                        
                        <div class="menu-item"><a href="http://gpars.org/1.1.0/guide/ref/Actors/Usage.html">Usage</a>
                        </div>
                        
                        </div>
                    </div>
                    
                    <div class="menu-block"><h1 class="menu-title" onclick="toggleRef(this.parentNode.childNodes[1])">Agent</h1><div class="menu-sub">
                        
                        
                        <div class="menu-item"><a href="http://gpars.org/1.1.0/guide/ref/Agent/Concepts.html">Concepts</a>
                        </div>
                        
                        <div class="menu-item"><a href="http://gpars.org/1.1.0/guide/ref/Agent/Usage.html">Usage</a>
                        </div>
                        
                        </div>
                    </div>
                    
                    <div class="menu-block"><h1 class="menu-title" onclick="toggleRef(this.parentNode.childNodes[1])">CSP</h1><div class="menu-sub">
                        
                        
                        <div class="menu-item"><a href="http://gpars.org/1.1.0/guide/ref/CSP/Concepts.html">Concepts</a>
                        </div>
                        
                        <div class="menu-item"><a href="http://gpars.org/1.1.0/guide/ref/CSP/Usage.html">Usage</a>
                        </div>
                        
                        </div>
                    </div>
                    
                    <div class="menu-block"><h1 class="menu-title" onclick="toggleRef(this.parentNode.childNodes[1])">Data Flow</h1><div class="menu-sub">
                        
                        
                        <div class="menu-item"><a href="http://gpars.org/1.1.0/guide/ref/Data%20Flow/Concepts.html">Concepts</a>
                        </div>
                        
                        <div class="menu-item"><a href="http://gpars.org/1.1.0/guide/ref/Data%20Flow/Usage.html">Usage</a>
                        </div>
                        
                        </div>
                    </div>
                    
                    <div class="menu-block"><h1 class="menu-title" onclick="toggleRef(this.parentNode.childNodes[1])">ForkJoin</h1><div class="menu-sub">
                        
                        
                        <div class="menu-item"><a href="http://gpars.org/1.1.0/guide/ref/ForkJoin/Concepts.html">Concepts</a>
                        </div>
                        
                        <div class="menu-item"><a href="http://gpars.org/1.1.0/guide/ref/ForkJoin/Usage.html">Usage</a>
                        </div>
                        
                        </div>
                    </div>
                    
                    <div class="menu-block"><h1 class="menu-title" onclick="toggleRef(this.parentNode.childNodes[1])">ForkJoinPool</h1><div class="menu-sub">
                        
                        
                        <div class="menu-item"><a href="http://gpars.org/1.1.0/guide/ref/ForkJoinPool/Concepts.html">Concepts</a>
                        </div>
                        
                        <div class="menu-item"><a href="http://gpars.org/1.1.0/guide/ref/ForkJoinPool/Usage.html">Usage</a>
                        </div>
                        
                        </div>
                    </div>
                    
                    <div class="menu-block"><h1 class="menu-title" onclick="toggleRef(this.parentNode.childNodes[1])">Stm</h1><div class="menu-sub">
                        
                        
                        <div class="menu-item"><a href="http://gpars.org/1.1.0/guide/ref/Stm/Concepts.html">Concepts</a>
                        </div>
                        
                        <div class="menu-item"><a href="http://gpars.org/1.1.0/guide/ref/Stm/Usage.html">Usage</a>
                        </div>
                        
                        </div>
                    </div>
                    
                    <div class="menu-block"><h1 class="menu-title" onclick="toggleRef(this.parentNode.childNodes[1])">ThreadPool</h1><div class="menu-sub">
                        
                        
                        <div class="menu-item"><a href="http://gpars.org/1.1.0/guide/ref/ThreadPool/Concepts.html">Concepts</a>
                        </div>
                        
                        <div class="menu-item"><a href="http://gpars.org/1.1.0/guide/ref/ThreadPool/Usage.html">Usage</a>
                        </div>
                        
                        </div>
                    </div>
                    
                </div>
            </div>
        </td>
            </tr>
        </tbody></table>

        <div id="footer">
            Copies of this document may be made for your own use and for
 distribution to others, provided that you do not charge any fee for 
such copies and further provided that each copy contains this Copyright 
Notice, whether distributed in print or electronically.
            Tackling the complexity of concurrent programming with 
Groovy.
        </div>



<script type="text/javascript" src="The%20GPars%20Framework%201.1.0_files/docs.js"></script>

    

</body></html>